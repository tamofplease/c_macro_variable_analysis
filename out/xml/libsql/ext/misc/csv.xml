<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/misc/csv.c"><comment type="block">/*
** 2016-05-28
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains the implementation of an SQLite virtual table for
** reading CSV files.
**
** Usage:
**
**    .load ./csv
**    CREATE VIRTUAL TABLE temp.csv USING csv(filename=FILENAME);
**    SELECT * FROM csv;
**
** The columns are named "c1", "c2", "c3", ... by default.  Or the
** application can define its own CREATE TABLE statement using the
** schema= parameter, like this:
**
**    CREATE VIRTUAL TABLE temp.csv2 USING csv(
**       filename = "../http.log",
**       schema = "CREATE TABLE x(date,ipaddr,url,referrer,userAgent)"
**    );
**
** Instead of specifying a file, the text of the CSV can be loaded using
** the data= parameter.
**
** If the columns=N parameter is supplied, then the CSV file is assumed to have
** N columns.  If both the columns= and schema= parameters are omitted, then
** the number and names of the columns is determined by the first line of
** the CSV input.
**
** Some extra debugging features (used for testing virtual tables) are available
** if this module is compiled with -DSQLITE_TEST.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sqlite3ext.h&gt;</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** A macro to hint to the compiler that a function should not be
** inlined.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_NOINLINE</name></cpp:macro>  <cpp:value>__attribute__((noinline))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1310</literal></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_NOINLINE</name></cpp:macro>  <cpp:value>__declspec(noinline)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_NOINLINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Max size of the error message in a CsvReader */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_MXERR</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>

<comment type="block">/* Size of the CsvReader input buffer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_INBUFSZ</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/* A context object used when read a CSV file. */</comment>
<typedef>typedef <type><name><name>struct</name> <name>CsvReader</name></name></type> <name>CsvReader</name>;</typedef>
<struct>struct <name>CsvReader</name> <block>{
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>              <comment type="block">/* Read the CSV text from this input stream */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>               <comment type="block">/* Accumulated text for a field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                 <comment type="block">/* Number of bytes in z */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>            <comment type="block">/* Space allocated for z[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLine</name></decl>;</decl_stmt>             <comment type="block">/* Current line number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bNotFirst</name></decl>;</decl_stmt>         <comment type="block">/* True if prior text has been seen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cTerm</name></decl>;</decl_stmt>             <comment type="block">/* Character that terminated the most recent field */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>iIn</name></decl>;</decl_stmt>            <comment type="block">/* Next unread character in the input buffer */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nIn</name></decl>;</decl_stmt>            <comment type="block">/* Number of characters in the input buffer */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>             <comment type="block">/* The input buffer */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zErr</name><index>[<expr><name>CSV_MXERR</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Error message */</comment>
}</block>;</struct>

<comment type="block">/* Initialize a CsvReader object */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>csv_reader_init</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bNotFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Close and reset a CsvReader object */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>csv_reader_reset</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>csv_reader_init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Report an error on a CsvReader */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>csv_errmsg</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vsnprintf</name><argument_list>(<argument><expr><name>CSV_MXERR</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErr</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Open the file associated with a CsvReader
** Return the number of errors.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csv_reader_open</name><parameter_list>(
  <parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* The reader to open */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,      <comment type="block">/* Read from this filename */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zData</name></decl></parameter>           <comment type="block">/*  ... or use this data */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>CSV_INBUFSZ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>csv_reader_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot open '%s' for reading"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nIn</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The input buffer has overflowed.  Refill the input buffer, then
** return the next character
*/</comment>
<function><type><specifier>static</specifier> <name>CSV_NOINLINE</name> <name>int</name></type> <name>csv_getc_refill</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>got</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iIn</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nIn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Only called on an empty input buffer */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* Only called if reading froma file */</comment>

  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>CSV_INBUFSZ</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>got</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nIn</name></name> <operator>=</operator> <name>got</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iIn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the next character of input.  Return EOF at end of input. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csv_getc</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iIn</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nIn</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>csv_getc_refill</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>EOF</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>zIn</name></name><operator>)</operator><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iIn</name></name><operator>++</operator></expr>]</index></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Increase the size of p-&gt;z and append character c to the end. 
** Return 0 on success and non-zero if there is an OOM error */</comment>
<function><type><specifier>static</specifier> <name>CSV_NOINLINE</name> <name>int</name></type> <name>csv_resize_and_append</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Append a single character to the CsvReader.z[] array.
** Return 0 on success and non-zero if there is an OOM error */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csv_append</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>csv_resize_and_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read a single field of CSV text.  Compatible with rfc4180 and extended
** with the option of having a separator other than ",".
**
**   +  Input comes from p-&gt;in.
**   +  Store results in p-&gt;z of length p-&gt;n.  Space to hold p-&gt;z comes
**      from sqlite3_malloc64().
**   +  Keep track of the line number in p-&gt;nLine.
**   +  Store the character that terminates the field in p-&gt;cTerm.  Store
**      EOF on end-of-file.
**
** Return 0 at EOF or on OOM.  On EOF, the p-&gt;cTerm character will have
** been set to EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>csv_read_one_field</name><parameter_list>(<parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>csv_getc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>EOF</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>, <decl><type ref="prev"/><name>ppc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>startLine</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>ppc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>csv_getc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="char">'"'</literal> <operator>||</operator> <name>pc</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pc</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><literal type="char">'"'</literal><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><literal type="char">'"'</literal><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name>ppc</name><operator>==</operator><literal type="char">'"'</literal><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><name>EOF</name> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><literal type="char">'"'</literal><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <do>do<block>{<block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name><operator>!=</operator><literal type="char">'"'</literal></expr> )</condition>;</do>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pc</name><operator>==</operator><literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"line %d: unescaped %c character"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>EOF</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"line %d: unterminated %c-quoted field\n"</literal></expr></argument>,
                     <argument><expr><name>startLine</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>csv_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>ppc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If this is the first field being parsed and it begins with the
    ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">0xef</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bNotFirst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>csv_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>csv_getc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">0xbb</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>csv_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>csv_getc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">0xbf</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bNotFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <return>return <expr><call><name>csv_read_one_field</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="char">','</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>!=</operator><name>EOF</name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\n'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>csv_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>csv_getc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bNotFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Forward references to the various virtual table methods implemented
** in this file. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabCreate</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type></decl></parameter>, 
                           <parameter><decl><type><name>sqlite3_vtab</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabConnect</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type></decl></parameter>, 
                           <parameter><decl><type><name>sqlite3_vtab</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3_index_info</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabFilter</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>csvtabRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3_int64</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* An instance of the CSV virtual table */</comment>
<typedef>typedef <type><struct>struct <name>CsvTable</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>                <comment type="block">/* Name of the CSV file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>                    <comment type="block">/* Raw CSV data in lieu of zFilename */</comment>
  <decl_stmt><decl><type><name>long</name></type> <name>iStart</name></decl>;</decl_stmt>                    <comment type="block">/* Offset to start of data in zFilename */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in the CSV file */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tstFlags</name></decl>;</decl_stmt>          <comment type="block">/* Bit values used for testing */</comment>
}</block></struct></type> <name>CsvTable</name>;</typedef>

<comment type="block">/* Allowed values for tstFlags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSVTEST_FIDX</name></cpp:macro>  <cpp:value>0x0001</cpp:value></cpp:define>      <comment type="block">/* Pretend that constrained searchs cost less*/</comment>

<comment type="block">/* A cursor for the CSV virtual table */</comment>
<typedef>typedef <type><struct>struct <name>CsvCursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>       <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>CsvReader</name></type> <name>rdr</name></decl>;</decl_stmt>                  <comment type="block">/* The CsvReader object */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azVal</name></decl>;</decl_stmt>                   <comment type="block">/* Value of the current row */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aLen</name></decl>;</decl_stmt>                      <comment type="block">/* Length of each entry */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>           <comment type="block">/* The current rowid.  Negative for EOF */</comment>
}</block></struct></type> <name>CsvCursor</name>;</typedef>

<comment type="block">/* Transfer error message text from a reader into a CsvTable */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>csv_xfer_error</name><parameter_list>(<parameter><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>pRdr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pRdr</name><operator>-&gt;</operator><name>zErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor fo a CsvTable object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>CsvTable</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Skip leading whitespace.  Return a pointer to the first non-whitespace
** character, or to the zero terminator if the string has only whitespace */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>csv_skip_whitespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove trailing whitespace from the end of string z[] */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>csv_trim_whitespace</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Dequote the string */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>csv_dequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>cQuote</name> <init>= <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>cQuote</name><operator>!=</operator><literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name>cQuote</name><operator>!=</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">2</literal> <operator>||</operator> <name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>cQuote</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>cQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check to see if the string is of the form:  "TAG = VALUE" with optional
** whitespace before and around tokens.  If it is, return a pointer to the
** first character of VALUE.  If it is not, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>csv_parameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>csv_skip_whitespace</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zTag</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nTag</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>csv_skip_whitespace</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>nTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'='</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>csv_skip_whitespace</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decode a parameter that requires a dequoted string.
**
** Return 1 if the parameter is seen, or 0 if not.  1 is returned
** even if there is an error.  If an error occurs, then an error message
** is left in p-&gt;zErr.  If there are no errors, p-&gt;zErr[0]==0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csv_string_parameter</name><parameter_list>(
  <parameter><decl><type><name>CsvReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* Leave the error message here, if there is one */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>,      <comment type="block">/* Parameter we are checking for */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>,        <comment type="block">/* Raw text of the virtual table argment */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzVal</name></decl></parameter>             <comment type="block">/* Write the dequoted string value here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zValue</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>zValue</name> <operator>=</operator> <call><name>csv_parameter</name><argument_list>(<argument><expr><name>zParam</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zValue</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pzVal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"more than one '%s' parameter"</literal></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzVal</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pzVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>csv_trim_whitespace</name><argument_list>(<argument><expr><operator>*</operator><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>csv_dequote</name><argument_list>(<argument><expr><operator>*</operator><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Return 0 if the argument is false and 1 if it is true.  Return -1 if
** we cannot really tell.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csv_boolean</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check to see if the string is of the form:  "TAG = BOOLEAN" or just "TAG".
** If it is, set *pValue to be the value of the boolean ("true" if there is
** not "= BOOLEAN" component) and return non-zero.  If the input string
** does not begin with TAG, return zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csv_boolean_parameter</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTag</name></decl></parameter>,       <comment type="block">/* Tag we are looking for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTag</name></decl></parameter>,               <comment type="block">/* Size of the tag in bytes */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,          <comment type="block">/* Input parameter */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>             <comment type="block">/* Write boolean value here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>csv_skip_whitespace</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zTag</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nTag</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>csv_skip_whitespace</name><argument_list>(<argument><expr><name>z</name> <operator>+</operator> <name>nTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'='</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>csv_skip_whitespace</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>csv_boolean</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>b</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parameters:
**    filename=FILENAME          Name of file containing CSV content
**    data=TEXT                  Direct CSV content.
**    schema=SCHEMA              Alternative CSV schema.
**    header=YES|NO              First row of CSV defines the names of
**                               columns if "yes".  Default "no".
**    columns=N                  Assume the CSV file contains N columns.
**
** Only available if compiled with SQLITE_TEST:
**    
**    testflags=N                Bitmask of test flags.  Optional
**
** If schema= is omitted, then the columns are named "c0", "c1", "c2",
** and so forth.  If columns=N is omitted, then the file is opened and
** the number of columns in the first row is counted to determine the
** column count.  If header=YES, then the first row is skipped.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* The CsvTable object to construct */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHeader</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* header= flags.  -1 means not seen yet */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Result code from this routine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                  <comment type="block">/* Loop counters */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>tstFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Value for testflags=N parameter */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>                     <comment type="block">/* Value of a boolean parameter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><operator>-</operator><literal type="number">99</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Value of the columns= parameter */</comment>
  <decl_stmt><decl><type><name>CsvReader</name></type> <name>sRdr</name></decl>;</decl_stmt>            <comment type="block">/* A CSV file reader used to store an error
                             ** message and/or to count the number of columns */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azParam</name><index>[]</index></name> <init>= <expr><block>{
     <expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"data"</literal></expr>, <expr><literal type="string">"schema"</literal></expr>, 
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>azPValue</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>         <comment type="block">/* Parameter values */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_FILENAME</name></cpp:macro> <cpp:value>(azPValue[0])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_DATA</name></cpp:macro>     <cpp:value>(azPValue[1])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_SCHEMA</name></cpp:macro>   <cpp:value>(azPValue[2])</cpp:value></cpp:define>


  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>azPValue</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azParam</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sRdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>azPValue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>azPValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zValue</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azParam</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azParam</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>csv_string_parameter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><name><name>azParam</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azPValue</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azParam</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azParam</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sRdr</name><operator>.</operator><name>zErr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>csvtab_connect_error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><call><name>csv_boolean_parameter</name><argument_list>(<argument><expr><literal type="string">"header"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bHeader</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="string">"more than one 'header' parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>csvtab_connect_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>bHeader</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    if<condition>( <expr><operator>(</operator><name>zValue</name> <operator>=</operator> <call><name>csv_parameter</name><argument_list>(<argument><expr><literal type="string">"testflags"</literal></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tstFlags</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>atoi</name><argument_list>(<argument><expr><name>zValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if<condition>( <expr><operator>(</operator><name>zValue</name> <operator>=</operator> <call><name>csv_parameter</name><argument_list>(<argument><expr><literal type="string">"columns"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="string">"more than one 'columns' parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>csvtab_connect_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nCol</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>zValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="string">"column= value must be positive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>csvtab_connect_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else
    <block>{<block_content>
      <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="string">"bad parameter: '%s'"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>csvtab_connect_error</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>CSV_FILENAME</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>CSV_DATA</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="string">"must specify either filename= or data= but not both"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>csvtab_connect_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nCol</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>bHeader</name><operator>==</operator><literal type="number">1</literal><operator>)</operator>
   <operator>&amp;&amp;</operator> <call><name>csv_reader_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><name>CSV_FILENAME</name></expr></argument>, <argument><expr><name>CSV_DATA</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <goto>goto <name>csvtab_connect_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>csvtab_connect_oom</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>CSV_SCHEMA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bHeader</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><call><name>csv_read_one_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name><name>sRdr</name><operator>.</operator><name>cTerm</name></name><operator>==</operator><literal type="char">','</literal></expr> )</condition>;</do>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bHeader</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%sc%d TEXT"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <do>do<block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>csv_read_one_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nCol</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name>nCol</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>nCol</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bHeader</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>,<argument><expr><literal type="string">"%s\"%w\" TEXT"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>iCol</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name><name>sRdr</name><operator>.</operator><name>cTerm</name></name><operator>==</operator><literal type="char">','</literal></expr> )</condition>;</do>
      <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <while>while<condition>( <expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>,<argument><expr><literal type="string">"%sc%d TEXT"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><operator>++</operator><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>CSV_SCHEMA</name> <operator>=</operator> <call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>CSV_SCHEMA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>csvtab_connect_oom</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <do>do<block>{<block_content>
      <expr_stmt><expr><call><name>csv_read_one_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>sRdr</name><operator>.</operator><name>cTerm</name></name><operator>==</operator><literal type="char">','</literal></expr> )</condition>;</do>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFilename</name></name> <operator>=</operator> <name>CSV_FILENAME</name></expr>;</expr_stmt>  <expr_stmt><expr><name>CSV_FILENAME</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name> <operator>=</operator> <name>CSV_DATA</name></expr>;</expr_stmt>          <expr_stmt><expr><name>CSV_DATA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>tstFlags</name></name> <operator>=</operator> <name>tstFlags</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>bHeader</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>sRdr</name><operator>.</operator><name>iIn</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>ftell</name><argument_list>(<argument><expr><name><name>sRdr</name><operator>.</operator><name>in</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>sRdr</name><operator>.</operator><name>nIn</name></name> <operator>+</operator> <name><name>sRdr</name><operator>.</operator><name>iIn</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>csv_reader_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>CSV_SCHEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="string">"bad schema: '%s' - %s"</literal></expr></argument>, <argument><expr><name>CSV_SCHEMA</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>csvtab_connect_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azPValue</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azPValue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azPValue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <comment type="block">/* Rationale for DIRECTONLY:
  ** An attacker who controls a database schema could use this vtab
  ** to exfiltrate sensitive data from other files in the filesystem.
  ** And, recommended practice is to put all CSV virtual tables in the
  ** TEMP namespace, so they should still be usable from within TEMP
  ** views, so there shouldn't be a serious loss of functionality by
  ** prohibiting the use of this vtab from persistent triggers and views.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_DIRECTONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>csvtab_connect_oom</name>:</label>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>csvtab_connect_error</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>csvtabDisconnect</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azPValue</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azPValue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azPValue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>sRdr</name><operator>.</operator><name>zErr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sRdr</name><operator>.</operator><name>zErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>csv_reader_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset the current row content held by a CsvCursor.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>csvtabCursorRowReset</name><parameter_list>(<parameter><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>CsvTable</name><operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** The xConnect and xCreate methods do the same thing, but they must be
** different so that the virtual table is not an eponymous virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabCreate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
 <return>return <expr><call><name>csvtabConnect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for a CsvCursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>CsvCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>csvtabCursorRowReset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>csv_reader_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new CsvTable cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>CsvTable</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>csv_reader_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>csv_xfer_error</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Advance a CsvCursor to its next row of input.
** Set the EOF marker if we reach the end of input.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>CsvCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>CsvTable</name><operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>csv_read_one_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>csv_errmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name></name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>csv_xfer_error</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>cTerm</name></name><operator>==</operator><literal type="char">','</literal></expr> )</condition>;</do>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the CsvCursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>CsvCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>CsvTable</name><operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>azVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the rowid for the current row.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>CsvCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>CsvCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>&lt;</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Only a full table scan is supported.  So xFilter simply rewinds to
** the beginning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CsvCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>CsvCursor</name><operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CsvTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>CsvTable</name><operator>*</operator><operator>)</operator><name><name>pVtabCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Ensure the field buffer is always allocated. Otherwise, if the
  ** first field is zero bytes in size, this may be mistaken for an OOM
  ** error in csvtabNext(). */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>csv_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>in</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>zIn</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>zData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iStart</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>iStart</name></name><operator>&lt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>nIn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>iIn</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iStart</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>in</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iStart</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>iIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rdr</name><operator>.</operator><name>nIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>csvtabNext</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Only a forward full table scan is supported.  xBestIndex is mostly
** a no-op.  If CSVTEST_FIDX is set, then the presence of equality
** constraints lowers the estimated cost, which is fiction, but is useful
** for testing certain kinds of virtual table behavior.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>CsvTable</name><operator>*</operator><operator>)</operator><name>tab</name><operator>)</operator><operator>-&gt;</operator><name>tstFlags</name> <operator>&amp;</operator> <name>CSVTEST_FIDX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The usual (and sensible) case is to always do a full table scan.
    ** The code in this branch only runs when testflags=1.  This code
    ** generates an artifical and unrealistic plan which is useful
    ** for testing virtual table logic but is not helpful to real applications.
    **
    ** Any ==, LIKE, or GLOB constraint is marked as usable by the virtual
    ** table (even though it is not) and the cost of running the virtual table
    ** is reduced from 1 million to just 10.  The constraints are *not* marked
    ** as omittable, however, so the query planner should still generate a
    ** plan that gives a correct answer, even if they plan is not optimal.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nConst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>op</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>usable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name> 
       <operator>||</operator> <name>op</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LIKE</name>
       <operator>||</operator> <name>op</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GLOB</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>nConst</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>nConst</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nConst</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>CsvModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* iVersion */</comment>
  <expr><name>csvtabCreate</name></expr>,            <comment type="block">/* xCreate */</comment>
  <expr><name>csvtabConnect</name></expr>,           <comment type="block">/* xConnect */</comment>
  <expr><name>csvtabBestIndex</name></expr>,         <comment type="block">/* xBestIndex */</comment>
  <expr><name>csvtabDisconnect</name></expr>,        <comment type="block">/* xDisconnect */</comment>
  <expr><name>csvtabDisconnect</name></expr>,        <comment type="block">/* xDestroy */</comment>
  <expr><name>csvtabOpen</name></expr>,              <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>csvtabClose</name></expr>,             <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>csvtabFilter</name></expr>,            <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>csvtabNext</name></expr>,              <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>csvtabEof</name></expr>,               <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>csvtabColumn</name></expr>,            <comment type="block">/* xColumn - read data */</comment>
  <expr><name>csvtabRowid</name></expr>,             <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xRename */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** For virtual table testing, make a version of the CSV virtual table
** available that has an xUpdate function.  But the xUpdate always returns
** SQLITE_READONLY since the CSV file is not really writable.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>csvtabUpdate</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type><name>v</name></decl></parameter>,<parameter><decl><type><name>sqlite3_int64</name><modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>CsvModuleFauxWrite</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* iVersion */</comment>
  <expr><name>csvtabCreate</name></expr>,            <comment type="block">/* xCreate */</comment>
  <expr><name>csvtabConnect</name></expr>,           <comment type="block">/* xConnect */</comment>
  <expr><name>csvtabBestIndex</name></expr>,         <comment type="block">/* xBestIndex */</comment>
  <expr><name>csvtabDisconnect</name></expr>,        <comment type="block">/* xDisconnect */</comment>
  <expr><name>csvtabDisconnect</name></expr>,        <comment type="block">/* xDestroy */</comment>
  <expr><name>csvtabOpen</name></expr>,              <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>csvtabClose</name></expr>,             <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>csvtabFilter</name></expr>,            <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>csvtabNext</name></expr>,              <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>csvtabEof</name></expr>,               <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>csvtabColumn</name></expr>,            <comment type="block">/* xColumn - read data */</comment>
  <expr><name>csvtabRowid</name></expr>,             <comment type="block">/* xRowid - read data */</comment>
  <expr><name>csvtabUpdate</name></expr>,            <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xRename */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIRTUALTABLE) */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* 
** This routine is called when the extension is loaded.  The new
** CSV virtual table module is registered with the calling database
** connection.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_csv_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"csv"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>CsvModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"csv_wr"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>CsvModuleFauxWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
