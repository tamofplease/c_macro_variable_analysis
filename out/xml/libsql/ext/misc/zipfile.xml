<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/misc/zipfile.c"><comment type="block">/*
** 2017-12-26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file implements a virtual table for reading and writing ZIP archive
** files.
**
** Usage example:
**
**     SELECT name, sz, datetime(mtime,'unixepoch') FROM zipfile($filename);
**
** Current limitations:
**
**    *  No support for encryption
**    *  No support for ZIP archives spanning multiple files
**    *  No support for zip64 extensions
**    *  Only the "inflate/deflate" (zlib) compression method is supported
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UINT32_TYPE</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_UINT32_T</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT32_TYPE</name></cpp:macro> <cpp:value>uint32_t</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT32_TYPE</name></cpp:macro> <cpp:value>unsigned int</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UINT16_TYPE</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_UINT16_T</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT16_TYPE</name></cpp:macro> <cpp:value>uint16_t</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT16_TYPE</name></cpp:macro> <cpp:value>unsigned short int</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><name>sqlite3_int64</name></type> <name>i64</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<typedef>typedef <type><name>UINT32_TYPE</name></type> <name>u32</name>;</typedef>           <comment type="block">/* 4-byte unsigned integer */</comment>
<typedef>typedef <type><name>UINT16_TYPE</name></type> <name>u16</name>;</typedef>           <comment type="block">/* 2-byte unsigned integer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a)&lt;(b) ? (a) : (b))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MUTATION_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(0)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>((X)?1:(assert(0),0))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>((X)?(assert(0),1):0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SQLITE_AMALGAMATION */</comment>

<comment type="block">/*
** Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
**
** In some ways it would be better to obtain these values from system 
** header files. But, the dependency is undesirable and (a) these
** have been stable for decades, (b) the values are part of POSIX and
** are also made explicit in [man stat], and (c) are part of the 
** file format for zip archives.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_IFDIR</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFDIR</name></cpp:macro> <cpp:value>0040000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_IFREG</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFREG</name></cpp:macro> <cpp:value>0100000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_IFLNK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFLNK</name></cpp:macro> <cpp:value>0120000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ZIPFILE_SCHEMA</name><index>[]</index></name> <init>= 
  <expr><literal type="string">"CREATE TABLE y("</literal>
    <literal type="string">"name PRIMARY KEY,"</literal>  <comment type="block">/* 0: Name of file in zip archive */</comment>
    <literal type="string">"mode,"</literal>              <comment type="block">/* 1: POSIX mode for file */</comment>
    <literal type="string">"mtime,"</literal>             <comment type="block">/* 2: Last modification time (secs since 1970)*/</comment>
    <literal type="string">"sz,"</literal>                <comment type="block">/* 3: Size of object */</comment>
    <literal type="string">"rawdata,"</literal>           <comment type="block">/* 4: Raw data */</comment>
    <literal type="string">"data,"</literal>              <comment type="block">/* 5: Uncompressed data */</comment>
    <literal type="string">"method,"</literal>            <comment type="block">/* 6: Compression method (integer) */</comment>
    <literal type="string">"z HIDDEN"</literal>           <comment type="block">/* 7: Name of zip file */</comment>
  <literal type="string">") WITHOUT ROWID;"</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_F_COLUMN_IDX</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>    <comment type="block">/* Index of column "file" in the above */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_BUFFER_SIZE</name></cpp:macro> <cpp:value>(64*1024)</cpp:value></cpp:define>


<comment type="block">/*
** Magic numbers used to read and write zip files.
**
** ZIPFILE_NEWENTRY_MADEBY:
**   Use this value for the "version-made-by" field in new zip file
**   entries. The upper byte indicates "unix", and the lower byte 
**   indicates that the zip file matches pkzip specification 3.0. 
**   This is what info-zip seems to do.
**
** ZIPFILE_NEWENTRY_REQUIRED:
**   Value for "version-required-to-extract" field of new entries.
**   Version 2.0 is required to support folders and deflate compression.
**
** ZIPFILE_NEWENTRY_FLAGS:
**   Value for "general-purpose-bit-flags" field of new entries. Bit
**   11 means "utf-8 filename and comment".
**
** ZIPFILE_SIGNATURE_CDS:
**   First 4 bytes of a valid CDS record.
**
** ZIPFILE_SIGNATURE_LFH:
**   First 4 bytes of a valid LFH record.
**
** ZIPFILE_SIGNATURE_EOCD
**   First 4 bytes of a valid EOCD record.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_EXTRA_TIMESTAMP</name></cpp:macro>   <cpp:value>0x5455</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_NEWENTRY_MADEBY</name></cpp:macro>   <cpp:value>((3&lt;&lt;8) + 30)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_NEWENTRY_REQUIRED</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_NEWENTRY_FLAGS</name></cpp:macro>    <cpp:value>0x800</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_SIGNATURE_CDS</name></cpp:macro>     <cpp:value>0x02014b50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_SIGNATURE_LFH</name></cpp:macro>     <cpp:value>0x04034b50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_SIGNATURE_EOCD</name></cpp:macro>    <cpp:value>0x06054b50</cpp:value></cpp:define>

<comment type="block">/*
** The sizes of the fixed-size part of each of the three main data 
** structures in a zip archive.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_LFH_FIXED_SZ</name></cpp:macro>      <cpp:value>30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_EOCD_FIXED_SZ</name></cpp:macro>     <cpp:value>22</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_CDS_FIXED_SZ</name></cpp:macro>      <cpp:value>46</cpp:value></cpp:define>

<comment type="block">/*
*** 4.3.16  End of central directory record:
***
***   end of central dir signature    4 bytes  (0x06054b50)
***   number of this disk             2 bytes
***   number of the disk with the
***   start of the central directory  2 bytes
***   total number of entries in the
***   central directory on this disk  2 bytes
***   total number of entries in
***   the central directory           2 bytes
***   size of the central directory   4 bytes
***   offset of start of central
***   directory with respect to
***   the starting disk number        4 bytes
***   .ZIP file comment length        2 bytes
***   .ZIP file comment       (variable size)
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileEOCD</name></name></type> <name>ZipfileEOCD</name>;</typedef>
<struct>struct <name>ZipfileEOCD</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>iDisk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iFirstDisk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEntryTotal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iOffset</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
*** 4.3.12  Central directory structure:
***
*** ...
***
***   central file header signature   4 bytes  (0x02014b50)
***   version made by                 2 bytes
***   version needed to extract       2 bytes
***   general purpose bit flag        2 bytes
***   compression method              2 bytes
***   last mod file time              2 bytes
***   last mod file date              2 bytes
***   crc-32                          4 bytes
***   compressed size                 4 bytes
***   uncompressed size               4 bytes
***   file name length                2 bytes
***   extra field length              2 bytes
***   file comment length             2 bytes
***   disk number start               2 bytes
***   internal file attributes        2 bytes
***   external file attributes        4 bytes
***   relative offset of local header 4 bytes
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileCDS</name></name></type> <name>ZipfileCDS</name>;</typedef>
<struct>struct <name>ZipfileCDS</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>iVersionMadeBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iVersionExtract</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iCompression</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mDate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>crc32</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szCompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szUncompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nExtra</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nComment</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iDiskStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iInternalAttr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iExternalAttr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>                    <comment type="block">/* Filename (sqlite3_malloc()) */</comment>
}</block>;</struct>

<comment type="block">/*
*** 4.3.7  Local file header:
***
***   local file header signature     4 bytes  (0x04034b50)
***   version needed to extract       2 bytes
***   general purpose bit flag        2 bytes
***   compression method              2 bytes
***   last mod file time              2 bytes
***   last mod file date              2 bytes
***   crc-32                          4 bytes
***   compressed size                 4 bytes
***   uncompressed size               4 bytes
***   file name length                2 bytes
***   extra field length              2 bytes
***   
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileLFH</name></name></type> <name>ZipfileLFH</name>;</typedef>
<struct>struct <name>ZipfileLFH</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>iVersionExtract</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iCompression</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mDate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>crc32</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szCompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szUncompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nExtra</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileEntry</name></name></type> <name>ZipfileEntry</name>;</typedef>
<struct>struct <name>ZipfileEntry</name> <block>{
  <decl_stmt><decl><type><name>ZipfileCDS</name></type> <name>cds</name></decl>;</decl_stmt>            <comment type="block">/* Parsed CDS record */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mUnixTime</name></decl>;</decl_stmt>             <comment type="block">/* Modification time, in UNIX format */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aExtra</name></decl>;</decl_stmt>                <comment type="block">/* cds.nExtra+cds.nComment bytes of extra data */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iDataOff</name></decl>;</decl_stmt>              <comment type="block">/* Offset to data in file (if aData==0) */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                 <comment type="block">/* cds.szCompressed bytes of compressed data */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>       <comment type="block">/* Next element in in-memory CDS */</comment>
}</block>;</struct>

<comment type="block">/* 
** Cursor type for zipfile tables.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileCsr</name></name></type> <name>ZipfileCsr</name>;</typedef>
<struct>struct <name>ZipfileCsr</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iId</name></decl>;</decl_stmt>                   <comment type="block">/* Cursor ID */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bEof</name></decl>;</decl_stmt>                   <comment type="block">/* True when at EOF */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bNoop</name></decl>;</decl_stmt>                  <comment type="block">/* If next xNext() call is no-op */</comment>

  <comment type="block">/* Used outside of write transactions */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>               <comment type="block">/* Zip file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iNextOff</name></decl>;</decl_stmt>              <comment type="block">/* Offset of next record in central directory */</comment>
  <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>          <comment type="block">/* Parse of central directory record */</comment>

  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pFreeEntry</name></decl>;</decl_stmt>  <comment type="block">/* Free this list when cursor is closed or reset */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pCurrent</name></decl>;</decl_stmt>    <comment type="block">/* Current entry */</comment>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsrNext</name></decl>;</decl_stmt>      <comment type="block">/* Next cursor on same virtual table */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileTab</name></name></type> <name>ZipfileTab</name>;</typedef>
<struct>struct <name>ZipfileTab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>               <comment type="block">/* Zip file this table accesses (may be NULL) */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Host database connection */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuffer</name></decl>;</decl_stmt>               <comment type="block">/* Temporary buffer used for various tasks */</comment>

  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsrList</name></decl>;</decl_stmt>      <comment type="block">/* List of cursors */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iNextCsrid</name></decl>;</decl_stmt>

  <comment type="block">/* The following are used by write transactions only */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pFirstEntry</name></decl>;</decl_stmt> <comment type="block">/* Linked list of all files (if pWriteFd!=0) */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pLastEntry</name></decl>;</decl_stmt>  <comment type="block">/* Last element in pFirstEntry list */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pWriteFd</name></decl>;</decl_stmt>            <comment type="block">/* File handle open on zip archive */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>szCurrent</name></decl>;</decl_stmt>             <comment type="block">/* Current size of zip archive */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>szOrig</name></decl>;</decl_stmt>                <comment type="block">/* Size of archive at start of transaction */</comment>
}</block>;</struct>

<comment type="block">/*
** Set the error message contained in context ctx to the results of
** vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileCtxErrorMsg</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If string zIn is quoted, dequote it in place. Otherwise, if the string
** is not quoted, do nothing.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileDequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'`'</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>zIn</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>q</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name><operator>!=</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zIn</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>zIn</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Construct a new ZipfileTab virtual table object.
** 
**   argv[0]   -&gt; module name  ("zipfile")
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[...] -&gt; "column name" and other module argument fields.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileTab</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>ZIPFILE_BUFFER_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* If the table name is not "zipfile", require that the argument be
  ** specified. This stops zipfile tables from being created as:
  **
  **   CREATE VIRTUAL TABLE zzz USING zipfile();
  **
  ** It does not prevent:
  **
  **   CREATE VIRTUAL TABLE zipfile USING zipfile();
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">0</literal><operator>!=</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argc</name><operator>&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>||</operator> <name>argc</name><operator>&gt;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile constructor requires one argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFile</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>ZIPFILE_SCHEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nByte</name><operator>+</operator><name>nFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><name>nFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zFile</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFile</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>ZIPFILE_BUFFER_SIZE</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>nFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>zipfileDequote</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_DIRECTONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the ZipfileEntry structure indicated by the only argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileEntryFree</name><parameter_list>(<parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release resources that should be freed at the end of a write 
** transaction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileCleanupTransaction</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szOrig</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for zipfile vtab objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>zipfileCleanupTransaction</name><argument_list>(<argument><expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new ZipfileCsr object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name><operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iId</name></name> <operator>=</operator> <operator>++</operator><name><name>pTab</name><operator>-&gt;</operator><name>iNextCsrid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset a cursor back to the state it was in when first returned
** by zipfileOpen().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileResetCursor</name><parameter_list>(<parameter><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for an ZipfileCsr.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>zipfileResetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove this cursor from the ZipfileTab.pCsrList list. */</comment>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pCsr</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pCsrNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the error message for the virtual table associated with cursor
** pCsr to the results of vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileTableErr</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileCursorErr</name><parameter_list>(<parameter><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Read nRead bytes of data from offset iOff of file pFile into buffer
** aRead[]. Return SQLITE_OK if successful, or an SQLite error code
** otherwise. 
**
** If an error does occur, output variable (*pzErrmsg) may be set to point
** to an English language error message. It is the responsibility of the
** caller to eventually free this buffer using
** sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadData</name><parameter_list>(
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,                    <comment type="block">/* Read from this file */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name></decl></parameter>,                      <comment type="block">/* Read into this buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRead</name></decl></parameter>,                      <comment type="block">/* Number of bytes to read */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>,                       <comment type="block">/* Offset to read from */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>                 <comment type="block">/* OUT: Error message (from sqlite3_malloc) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>iOff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name><operator>!=</operator><name>nRead</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErrmsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error in fread()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileAppendData</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aWrite</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nWrite</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>nWrite</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>aWrite</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name><operator>!=</operator><name>nWrite</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error in fwrite()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>zipfileGetU16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileGetU32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator>
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator>
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator>
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write a 16-bit little endiate integer into buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfilePutU16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write a 32-bit little endiate integer into buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfilePutU32</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileRead32</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( aBuf+=4, zipfileGetU32(aBuf-4) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileRead16</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( aBuf+=2, zipfileGetU16(aBuf-2) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileWrite32</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ zipfilePutU32(aBuf,val); aBuf+=4; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileWrite16</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ zipfilePutU16(aBuf,val); aBuf+=2; }</cpp:value></cpp:define>

<comment type="block">/*
** Magic numbers used to read CDS records.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_CDS_NFILE_OFF</name></cpp:macro>        <cpp:value>28</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_CDS_SZCOMPRESSED_OFF</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<comment type="block">/*
** Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
** if the record is not well-formed, or SQLITE_OK otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadCDS</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>sig</name> <init>= <expr><call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>sig</name><operator>!=</operator><name>ZIPFILE_SIGNATURE_CDS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionMadeBy</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionExtract</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szCompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aRead</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nComment</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iDiskStart</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iInternalAttr</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aRead</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_CDS_FIXED_SZ</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
** if the record is not well-formed, or SQLITE_OK otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadLFH</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuffer</name></decl></parameter>,
  <parameter><decl><type><name>ZipfileLFH</name> <modifier>*</modifier></type><name>pLFH</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name> <init>= <expr><name>aBuffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>u32</name></type> <name>sig</name> <init>= <expr><call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>sig</name><operator>!=</operator><name>ZIPFILE_SIGNATURE_LFH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>iVersionExtract</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>iCompression</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>szCompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>szUncompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>nFile</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
** Scan through this buffer to find an "extra-timestamp" field. If one
** exists, extract the 32-bit modification-timestamp from it and store
** the value in output parameter *pmTime.
**
** Zero is returned if no extra-timestamp record could be found (and so
** *pmTime is left unchanged), or non-zero otherwise.
**
** The general format of an extra field is:
**
**   Header ID    2 bytes
**   Data Size    2 bytes
**   Data         N bytes
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileScanExtra</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aExtra</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nExtra</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pmTime</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>aExtra</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aExtra</name><index>[<expr><name>nExtra</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>id</name> <init>= <expr><call><name>zipfileRead16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>nByte</name> <init>= <expr><call><name>zipfileRead16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>( <expr><name>id</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>ZIPFILE_EXTRA_TIMESTAMP</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>b</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>b</name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr> )</condition><block>{<block_content>     <comment type="block">/* 0x01 -&gt; modtime is present */</comment>
          <expr_stmt><expr><operator>*</operator><name>pmTime</name> <operator>=</operator> <call><name>zipfileGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert the standard MS-DOS timestamp stored in the mTime and mDate
** fields of the CDS structure passed as the only argument to a 32-bit
** UNIX seconds-since-the-epoch timestamp. Return the result.
**
** "Standard" MS-DOS time format:
**
**   File modification time:
**     Bits 00-04: seconds divided by 2
**     Bits 05-10: minute
**     Bits 11-15: hour
**   File modification date:
**     Bits 00-04: day
**     Bits 05-08: month (1-12)
**     Bits 09-15: years from 1980 
**
** https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileMtime</name><parameter_list>(<parameter><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>Y</name></decl>,<decl><type ref="prev"/><name>M</name></decl>,<decl><type ref="prev"/><name>D</name></decl>,<decl><type ref="prev"/><name>X1</name></decl>,<decl><type ref="prev"/><name>X2</name></decl>,<decl><type ref="prev"/><name>A</name></decl>,<decl><type ref="prev"/><name>B</name></decl>,<decl><type ref="prev"/><name>sec</name></decl>,<decl><type ref="prev"/><name>min</name></decl>,<decl><type ref="prev"/><name>hr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>JDsec</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>Y</name> <operator>=</operator> <operator>(</operator><literal type="number">1980</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>M</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>D</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>&amp;</operator> <literal type="number">0x1F</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>&amp;</operator> <literal type="number">0x1F</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>hr</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>&gt;&gt;</operator> <literal type="number">11</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1F</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>M</name><operator>&lt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>Y</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>M</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>X1</name> <operator>=</operator> <literal type="number">36525</literal><operator>*</operator><operator>(</operator><name>Y</name><operator>+</operator><literal type="number">4716</literal><operator>)</operator><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>X2</name> <operator>=</operator> <literal type="number">306001</literal><operator>*</operator><operator>(</operator><name>M</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">10000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>A</name> <operator>=</operator> <name>Y</name><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>B</name> <operator>=</operator> <literal type="number">2</literal> <operator>-</operator> <name>A</name> <operator>+</operator> <operator>(</operator><name>A</name><operator>/</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>JDsec</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>X1</name> <operator>+</operator> <name>X2</name> <operator>+</operator> <name>D</name> <operator>+</operator> <name>B</name> <operator>-</operator> <literal type="number">1524.5</literal><operator>)</operator><operator>*</operator><literal type="number">86400</literal><operator>)</operator> <operator>+</operator> <name>hr</name><operator>*</operator><literal type="number">3600</literal> <operator>+</operator> <name>min</name><operator>*</operator><literal type="number">60</literal> <operator>+</operator> <name>sec</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>JDsec</name> <operator>-</operator> <operator>(</operator><name>i64</name><operator>)</operator><literal type="number">24405875</literal><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">8640</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The opposite of zipfileMtime(). This function populates the mTime and
** mDate fields of the CDS structure passed as the first argument according
** to the UNIX timestamp value passed as the second.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileMtimeToDos</name><parameter_list>(<parameter><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCds</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>mUnixTime</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Convert unix timestamp to JD (2440588 is noon on 1/1/1970) */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>JD</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">2440588</literal> <operator>+</operator> <name>mUnixTime</name> <operator>/</operator> <operator>(</operator><literal type="number">24</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>A</name></decl>, <decl><type ref="prev"/><name>B</name></decl>, <decl><type ref="prev"/><name>C</name></decl>, <decl><type ref="prev"/><name>D</name></decl>, <decl><type ref="prev"/><name>E</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>yr</name></decl>, <decl><type ref="prev"/><name>mon</name></decl>, <decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hr</name></decl>, <decl><type ref="prev"/><name>min</name></decl>, <decl><type ref="prev"/><name>sec</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>A</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>JD</name> <operator>-</operator> <literal type="number">1867216.25</literal><operator>)</operator><operator>/</operator><literal type="number">36524.25</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>A</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>JD</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>A</name> <operator>-</operator> <operator>(</operator><name>A</name><operator>/</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>B</name> <operator>=</operator> <name>A</name> <operator>+</operator> <literal type="number">1524</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>C</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>B</name> <operator>-</operator> <literal type="number">122.1</literal><operator>)</operator><operator>/</operator><literal type="number">365.25</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>D</name> <operator>=</operator> <operator>(</operator><literal type="number">36525</literal><operator>*</operator><operator>(</operator><name>C</name><operator>&amp;</operator><literal type="number">32767</literal><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>E</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>B</name><operator>-</operator><name>D</name><operator>)</operator><operator>/</operator><literal type="number">30.6001</literal><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>day</name> <operator>=</operator> <name>B</name> <operator>-</operator> <name>D</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">30.6001</literal><operator>*</operator><name>E</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>mon</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>E</name><operator>&lt;</operator><literal type="number">14</literal></expr> ?</condition><then> <expr><name>E</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>E</name><operator>-</operator><literal type="number">13</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>yr</name> <operator>=</operator> <ternary><condition><expr><name>mon</name><operator>&gt;</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name>C</name><operator>-</operator><literal type="number">4716</literal></expr> </then><else>: <expr><name>C</name><operator>-</operator><literal type="number">4715</literal></expr></else></ternary></expr>;</expr_stmt>

  <expr_stmt><expr><name>hr</name> <operator>=</operator> <operator>(</operator><name>mUnixTime</name> <operator>%</operator> <operator>(</operator><literal type="number">24</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>(</operator><name>mUnixTime</name> <operator>%</operator> <operator>(</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">60</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>(</operator><name>mUnixTime</name> <operator>%</operator> <literal type="number">60</literal><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>yr</name><operator>&gt;=</operator><literal type="number">1980</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>day</name> <operator>+</operator> <operator>(</operator><name>mon</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>yr</name><operator>-</operator><literal type="number">1980</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">9</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>sec</name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>min</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>hr</name><operator>&lt;&lt;</operator><literal type="number">11</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <name><name>pCds</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mUnixTime</name><operator>&lt;</operator><literal type="number">315507600</literal> 
       <operator>||</operator> <name>mUnixTime</name><operator>==</operator><call><name>zipfileMtime</name><argument_list>(<argument><expr><name>pCds</name></expr></argument>)</argument_list></call> 
       <operator>||</operator> <operator>(</operator><operator>(</operator><name>mUnixTime</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>mUnixTime</name><operator>-</operator><literal type="number">1</literal><operator>==</operator><call><name>zipfileMtime</name><argument_list>(<argument><expr><name>pCds</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> 
       <comment type="block">/* || (mUnixTime % 2) */</comment>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
** size) containing an entire zip archive image. Or, if aBlob is NULL,
** then pFile is a file-handle open on a zip file. In either case, this
** function creates a ZipfileEntry object based on the zip archive entry
** for which the CDS record is at offset iOff.
**
** If successful, SQLITE_OK is returned and (*ppEntry) set to point to
** the new object. Otherwise, an SQLite error code is returned and the
** final value of (*ppEntry) undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileGetEntry</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,               <comment type="block">/* Store any error message here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name></decl></parameter>,                <comment type="block">/* Pointer to in-memory file image */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>,                      <comment type="block">/* Size of aBlob[] in bytes */</comment>
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,                    <comment type="block">/* If aBlob==0, read from this file */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>,                       <comment type="block">/* Offset of CDS record */</comment>
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppEntry</name></decl></parameter>          <comment type="block">/* OUT: Pointer to new object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aRead</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>ZIPFILE_CDS_FIXED_SZ</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name>iOff</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nFile</name> <init>= <expr><call><name>zipfileGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><call><name>zipfileGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nExtra</name> <operator>+=</operator> <call><name>zipfileGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nExtra</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aBlob</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <call><name>zipfileGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_SZCOMPRESSED_OFF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>ZipfileEntry</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadCDS</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"failed to read CDS at offset %lld"</literal></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(
            <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>nExtra</name><operator>+</operator><name>nFile</name></expr></argument>, <argument><expr><name>iOff</name><operator>+</operator><name>ZIPFILE_CDS_FIXED_SZ</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name>iOff</name> <operator>+</operator> <name>ZIPFILE_CDS_FIXED_SZ</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>nFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aExtra</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aExtra</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>nFile</name></expr>]</index></name></expr></argument>, <argument><expr><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>zipfileScanExtra</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>nFile</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nExtra</name></name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>mUnixTime</name></name> <operator>=</operator> <call><name>zipfileMtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>szFix</name> <init>= <expr><name>ZIPFILE_LFH_FIXED_SZ</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ZipfileLFH</name></type> <name>lfh</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pFile</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>szFix</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadLFH</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lfh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iDataOff</name></name> <operator>=</operator>  <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name> <operator>+</operator> <name>ZIPFILE_LFH_FIXED_SZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iDataOff</name></name> <operator>+=</operator> <name><name>lfh</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <name><name>lfh</name><operator>.</operator><name>nExtra</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aBlob</name> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aExtra</name><index>[<expr><name>nExtra</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>iDataOff</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"failed to read LFH at offset %d"</literal></expr></argument>, 
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppEntry</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance an ZipfileCsr to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iEof</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>iOffset</name></name> <operator>+</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>nSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name><operator>&gt;=</operator><name>iEof</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name> <operator>+=</operator> <name>ZIPFILE_CDS_FIXED_SZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nExtra</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nComment</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content> 
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<comment type="block">/*
** Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
** size is nOut bytes. This function uncompresses the data and sets the
** return value in context pCtx to the result (a blob).
**
** If an error occurs, an error code is left in pCtx instead.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileInflate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* Store result here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aIn</name></decl></parameter>,                  <comment type="block">/* Compressed data */</comment>
  <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>,                        <comment type="block">/* Size of buffer aIn[] in bytes */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOut</name></decl></parameter>                        <comment type="block">/* Expected output size */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRes</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aRes</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_stream</name></type> <name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Byte</name><operator>*</operator><operator>)</operator><name>aIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <operator>(</operator><name>Byte</name><operator>*</operator><operator>)</operator><name>aRes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>inflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>err</name><operator>!=</operator><name>Z_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileCtxErrorMsg</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"inflateInit2() failed (%d)"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>err</name><operator>!=</operator><name>Z_STREAM_END</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>zipfileCtxErrorMsg</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"inflate() failed (%d)"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aRes</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>zipfileFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Buffer aIn (size nIn bytes) contains uncompressed data. This function
** compresses it and sets (*ppOut) to point to a buffer containing the
** compressed data. The caller is responsible for eventually calling
** sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut) 
** is set to the size of buffer (*ppOut) in bytes.
**
** If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
** code is returned and an error message left in virtual-table handle
** pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
** case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileDeflate</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>,         <comment type="block">/* Input */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,         <comment type="block">/* Output */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>z_stream</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name><operator>*</operator><operator>)</operator><name>aIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>deflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <call><name>deflateBound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOut</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>nAlloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><name>Z_STREAM_END</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>str</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: deflate() error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>deflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>   <comment type="block">/* name */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">1</literal></expr>:</case>   <comment type="block">/* mode */</comment>
      <comment type="block">/* TODO: Whether or not the following is correct surely depends on
      ** the platform on which the archive was created.  */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content> <comment type="block">/* mtime */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content> <comment type="block">/* sz */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_vtab_nochange</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">4</literal></expr>:</case>   <comment type="block">/* rawdata */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_vtab_nochange</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content> <comment type="block">/* data */</comment>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">4</literal> <operator>||</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>pCDS</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>szFinal</name> <init>= <expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>szFinal</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>aData</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <name>aFree</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if<condition>( <expr><name>pFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>pFile</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>pWriteFd</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>iDataOff</name></name></expr></argument>,
                  <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>zipfileInflate</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>szFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Figure out if this is a directory or a zero-sized file. Consider
          ** it to be a directory either if the mode suggests so, or if
          ** the final character in the name is '/'.  */</comment>
          <decl_stmt><decl><type><name>u32</name></type> <name>mode</name> <init>= <expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>S_IFDIR</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>zFile</name><index>[<expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case>   <comment type="block">/* method */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>  <comment type="block">/* z */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">7</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor is at EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If aBlob is not NULL, then it points to a buffer nBlob bytes in size
** containing an entire zip archive image. Or, if aBlob is NULL, then pFile
** is guaranteed to be a file-handle open on a zip file.
**
** This function attempts to locate the EOCD record within the zip archive
** and populate *pEOCD with the results of decoding it. SQLITE_OK is
** returned if successful. Otherwise, an SQLite error code is returned and
** an English language error message may be left in virtual-table pTab.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadEOCD</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,               <comment type="block">/* Return errors here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name></decl></parameter>,                <comment type="block">/* Pointer to in-memory file image */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>,                      <comment type="block">/* Size of aBlob[] in bytes */</comment>
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,                    <comment type="block">/* Read from this file if aBlob==0 */</comment>
  <parameter><decl><type><name>ZipfileEOCD</name> <modifier>*</modifier></type><name>pEOCD</name></decl></parameter>              <comment type="block">/* Object to populate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Temporary buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                      <comment type="block">/* Bytes to read from file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pEOCD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEOCD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>                     <comment type="block">/* Offset to read from */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>szFile</name></decl>;</decl_stmt>                   <comment type="block">/* Total size of file in bytes */</comment>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szFile</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>ftell</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>szFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nRead</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>MIN</name><argument_list>(<argument><expr><name>szFile</name></expr></argument>, <argument><expr><name>ZIPFILE_BUFFER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name>szFile</name> <operator>-</operator> <name>nRead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nRead</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>MIN</name><argument_list>(<argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name>ZIPFILE_BUFFER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name>nBlob</name><operator>-</operator><name>nRead</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Scan backwards looking for the signature bytes */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nRead</name><operator>-</operator><literal type="number">20</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aRead</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0x50</literal> <operator>&amp;&amp;</operator> <name><name>aRead</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0x4b</literal> 
       <operator>&amp;&amp;</operator> <name><name>aRead</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0x05</literal> <operator>&amp;&amp;</operator> <name><name>aRead</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="number">0x06</literal></expr> 
      )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"cannot find end of central directory record"</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>aRead</name> <operator>+=</operator> <name>i</name><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>iDisk</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>iFirstDisk</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>nEntryTotal</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry 
** and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
** to the end of the list. Otherwise, it is added to the list immediately
** before pBefore (which is guaranteed to be a part of said list).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileAddEntry</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, 
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pBefore</name></decl></parameter>, 
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBefore</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pBefore</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pBefore</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileLoadDirectory</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadEOCD</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name><name>eocd</name><operator>.</operator><name>iOffset</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>eocd</name><operator>.</operator><name>nEntry</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileAddEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <name>ZIPFILE_CDS_FIXED_SZ</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nExtra</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nComment</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xFilter callback.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Zip file to scan */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bInMemory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* True for an in-memory zipfile */</comment>

  <expr_stmt><expr><call><name>zipfileResetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>zipfileCursorErr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"zipfile() function requires an argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name>aEmptyBlob</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aBlob</name> <operator>=</operator> <operator>&amp;</operator><name>aEmptyBlob</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBlob</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileLoadDirectory</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bInMemory</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><name>bInMemory</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileCursorErr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"cannot open file: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadEOCD</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>nEntry</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>iOffset</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileNext</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name></expr> ?</condition><then> <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileNext</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xBestIndex callback.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>unusable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pCons</name> <init>= <expr><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name>ZIPFILE_F_COLUMN_IDX</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>unusable</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>unusable</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZipfileEntry</name> <modifier>*</modifier></type><name>zipfileNewEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileSerializeLFH</name><parameter_list>(<parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCds</name> <init>= <expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>

  <comment type="block">/* Write the LFH itself */</comment>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_SIGNATURE_LFH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>iVersionExtract</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>mTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>mDate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><name><name>pCds</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>a</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_LFH_FIXED_SZ</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add the file name */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pCds</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pCds</name><operator>-&gt;</operator><name>nFile</name></name></expr>;</expr_stmt>

  <comment type="block">/* The "extra" data */</comment>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_EXTRA_TIMESTAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>a</name><operator>++</operator> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>a</name><operator>-</operator><name>aBuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileAppendEntry</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <call><name>zipfileSerializeLFH</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>iDataOff</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileGetMode</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bIsDir</name></decl></parameter>,                     <comment type="block">/* If true, default to directory */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pMode</name></decl></parameter>,                     <comment type="block">/* OUT: Mode value */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bIsDir</name></expr> ?</condition><then> <expr><operator>(</operator><name>S_IFDIR</name> <operator>+</operator> <literal type="number">0755</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>S_IFREG</name> <operator>+</operator> <literal type="number">0644</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>zTemplate</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <init>= <expr><literal type="string">"-rwxrwxrwx"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="char">'-'</literal></expr>:</case> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <name>S_IFREG</name></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'d'</literal></expr>:</case> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <name>S_IFDIR</name></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'l'</literal></expr>:</case> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <name>S_IFLNK</name></expr>;</expr_stmt> <break>break;</break>
      <default>default:</default> <goto>goto <name>parse_error</name>;</goto>
    </block_content>}</block></switch>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name><name>zTemplate</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">9</literal><operator>-</operator><name>i</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>S_IFDIR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><name>bIsDir</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The "mode" attribute is a directory, but data has been specified.
    ** Or vice-versa - no data but "mode" is a file or symlink.  */</comment>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: mode does not match data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pMode</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

 <label><name>parse_error</name>:</label>
  <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: parse error in mode: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Both (const char*) arguments point to nul-terminated strings. Argument
** nB is the value of strlen(zB). This function returns 0 if the strings are
** identical, ignoring any trailing '/' character in either path.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileComparePath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nA</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zA</name><index>[<expr><name>nA</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nA</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nB</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zB</name><index>[<expr><name>nB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nB</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nA</name><operator>==</operator><name>nB</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zA</name></expr></argument>, <argument><expr><name>zB</name></expr></argument>, <argument><expr><name>nA</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileBegin</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: missing filename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open a write fd on the file. Also load the entire central directory
  ** structure into memory. During the transaction any new file data is 
  ** appended to the archive file, but the central directory is accumulated
  ** in main-memory until the transaction is committed.  */</comment>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><literal type="string">"ab+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"zipfile: failed to open file %s for writing"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>szOrig</name></name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>ftell</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileLoadDirectory</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>zipfileCleanupTransaction</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the current time as a 32-bit timestamp in UNIX epoch format (like
** time(2)).
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>ret</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVfs</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>ms</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ms</name><operator>/</operator><literal type="number">1000</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">24405875</literal> <operator>*</operator> <literal type="number">8640</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>day</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>day</name> <operator>-</operator> <literal type="number">2440587.5</literal><operator>)</operator> <operator>*</operator> <literal type="number">86400</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a 32-bit timestamp in UNIX epoch format.
**
** If the value passed as the only argument is either NULL or an SQL NULL,
** return the current time. Otherwise, return the value stored in (*pVal)
** cast to a 32-bit unsigned integer.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileGetTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>zipfileTime</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Unless it is NULL, entry pOld is currently part of the pTab-&gt;pFirstEntry
** linked list.  Remove it from the list and free the object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileRemoveEntryFromList</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pOld</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>pOld</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xUpdate method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileUpdate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* New in-memory CDS entry */</comment>

  <decl_stmt><decl><type><name>u32</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Mode for new entry */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Modification time for new entry */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Uncompressed size */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Path for new entry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* strlen(zPath) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Pointer to buffer containing content */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of pData buffer in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMethod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Compression method for new entry */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Free this */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Also free this */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pOld2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bUpdate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* True for an update that modifies "name" */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIsDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iCrc32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileBegin</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is a DELETE or UPDATE, find the archive entry to delete. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDelete</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDelete</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zDelete</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUpdate</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zUpdate</name> <operator>&amp;&amp;</operator> <call><name>zipfileComparePath</name><argument_list>(<argument><expr><name>zUpdate</name></expr></argument>, <argument><expr><name>zDelete</name></expr></argument>, <argument><expr><name>nDelete</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bUpdate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pOld</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><literal type="number">1</literal></expr>;</condition> <incr><expr><name>pOld</name><operator>=</operator><name><name>pOld</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>zipfileComparePath</name><argument_list>(<argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zDelete</name></expr></argument>, <argument><expr><name>nDelete</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>pNext</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Check that "sz" and "rawdata" are both NULL: */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"sz must be NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"rawdata must be NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* data=NULL. A directory */</comment>
        <expr_stmt><expr><name>bIsDir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Value specified for "data", and possibly "method". This must be
        ** a regular file or a symlink. */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aIn</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bAuto</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pData</name> <operator>=</operator> <name>aIn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nData</name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iMethod</name><operator>!=</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"unknown compression method: %d"</literal></expr></argument>, <argument><expr><name>iMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>bAuto</name> <operator>||</operator> <name>iMethod</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileDeflate</name><argument_list>(<argument><expr><name>aIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>iMethod</name> <operator>||</operator> <name>nCmp</name><operator>&lt;</operator><name>nIn</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>pData</name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nData</name> <operator>=</operator> <name>nCmp</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>iCrc32</name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetMode</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bIsDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zPath</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nPath</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mTime</name> <operator>=</operator> <call><name>zipfileGetTime</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bIsDir</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* For a directory, check that the last character in the path is a
      ** '/'. This appears to be required for compatibility with info-zip
      ** (the unzip command on unix). It does not create directories
      ** otherwise.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>nPath</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zPath</name><index>[<expr><name>nPath</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFree</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zFree</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zFree</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nPath</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>nPath</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check that we're not inserting a duplicate entry -OR- updating an
    ** entry with a path, thereby making it into a duplicate. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pOld</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bUpdate</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>zipfileComparePath</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>nPath</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <switch>switch<condition>( <expr><call><name>sqlite3_vtab_on_conflict</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <case>case <expr><name>SQLITE_IGNORE</name></expr>:</case> <block>{<block_content>
              <goto>goto <name>zipfile_update_done</name>;</goto>
            </block_content>}</block>
            <case>case <expr><name>SQLITE_REPLACE</name></expr>:</case> <block>{<block_content>
              <expr_stmt><expr><name>pOld2</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block>
            <default>default:</default> <block>{<block_content>
              <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"duplicate name: \"%s\""</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block>
          </block_content>}</block></switch>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Create the new CDS record. */</comment>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>zipfileNewEntry</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iVersionMadeBy</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_MADEBY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iVersionExtract</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_REQUIRED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_FLAGS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iCompression</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iMethod</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zipfileMtimeToDos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>, <argument><expr><name>mTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>crc32</name></name> <operator>=</operator> <name>iCrc32</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szUncompressed</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iExternalAttr</name></name> <operator>=</operator> <operator>(</operator><name>mode</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nPath</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>mUnixTime</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>mTime</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zipfileAddEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pOld</name> <operator>||</operator> <name>pOld2</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</init> <condition><expr><name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><name>pOld</name> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><name>pOld2</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>zipfileRemoveEntryFromList</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileRemoveEntryFromList</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pOld2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>zipfile_update_done</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileSerializeEOCD</name><parameter_list>(<parameter><decl><type><name>ZipfileEOCD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_SIGNATURE_EOCD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iFirstDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nEntryTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* Size of trailing comment in bytes*/</comment>

  <return>return <expr><name>a</name><operator>-</operator><name>aBuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileAppendEOCD</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>ZipfileEOCD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name> <init>= <expr><call><name>zipfileSerializeEOCD</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nBuf</name><operator>==</operator><name>ZIPFILE_EOCD_FIXED_SZ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Serialize the CDS structure into buffer aBuf[]. Return the number
** of bytes written.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileSerializeCDS</name><parameter_list>(<parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name> <init>= <expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>aExtra</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_SIGNATURE_CDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionMadeBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionExtract</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>a</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iDiskStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iInternalAttr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>+=</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>aExtra</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pCDS</name><operator>-&gt;</operator><name>nComment</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>aExtra</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name><operator>==</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_EXTRA_TIMESTAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>a</name><operator>++</operator> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>a</name><operator>-</operator><name>aBuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileCommit</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Write out all entries */</comment>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>zipfileSerializeCDS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nEntry</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Write out the EOCD record */</comment>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iDisk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iFirstDisk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntry</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntryTotal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>-</operator> <name>iOffset</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendEOCD</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>zipfileCleanupTransaction</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileRollback</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>zipfileCommit</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZipfileCsr</name> <modifier>*</modifier></type><name>zipfileFindCursor</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</init> <condition><expr><name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iId</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iId</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pCsr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileFunctionCds</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>zipfileFindCursor</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRes</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"{"</literal>
        <literal type="string">"\"version-made-by\" : %u, "</literal>
        <literal type="string">"\"version-to-extract\" : %u, "</literal>
        <literal type="string">"\"flags\" : %u, "</literal>
        <literal type="string">"\"compression\" : %u, "</literal>
        <literal type="string">"\"time\" : %u, "</literal>
        <literal type="string">"\"date\" : %u, "</literal>
        <literal type="string">"\"crc32\" : %u, "</literal>
        <literal type="string">"\"compressed-size\" : %u, "</literal>
        <literal type="string">"\"uncompressed-size\" : %u, "</literal>
        <literal type="string">"\"file-name-length\" : %u, "</literal>
        <literal type="string">"\"extra-field-length\" : %u, "</literal>
        <literal type="string">"\"file-comment-length\" : %u, "</literal>
        <literal type="string">"\"disk-number-start\" : %u, "</literal>
        <literal type="string">"\"internal-attr\" : %u, "</literal>
        <literal type="string">"\"external-attr\" : %u, "</literal>
        <literal type="string">"\"offset\" : %u }"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iVersionMadeBy</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iVersionExtract</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>mTime</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>mDate</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>crc32</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nComment</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iDiskStart</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iInternalAttr</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iExternalAttr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>zRes</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zRes</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xFindFunction method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileFindFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,            <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                       <comment type="block">/* Number of SQL function arguments */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name of SQL function */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>pxFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* OUT: Result */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>                    <comment type="block">/* OUT: User data for *pxFunc */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"zipfile_cds"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>zipfileFunctionCds</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppArg</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileBuffer</name></name></type> <name>ZipfileBuffer</name>;</typedef>
<struct>struct <name>ZipfileBuffer</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>                          <comment type="block">/* Pointer to buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                          <comment type="block">/* Size of buffer in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>                     <comment type="block">/* Byte allocated at a[] */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileCtx</name></name></type> <name>ZipfileCtx</name>;</typedef>
<struct>struct <name>ZipfileCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileBuffer</name></type> <name>body</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileBuffer</name></type> <name>cds</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileBufferGrow</name><parameter_list>(<parameter><decl><type><name>ZipfileBuffer</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><name>nByte</name><operator>&gt;</operator><name><name>pBuf</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNew</name> <init>= <expr><ternary><condition><expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">512</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nReq</name> <init>= <expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name>nByte</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nReq</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>nNew</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pBuf</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xStep() callback for the zipfile() aggregate. This can be called in
** any of the following ways:
**
**   SELECT zipfile(name,data) ...
**   SELECT zipfile(name,mode,mtime,data) ...
**   SELECT zipfile(name,mode,mtime,data,method) ...
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* Aggregate function context */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name></type> <name>e</name></decl>;</decl_stmt>                 <comment type="block">/* New entry to add to zip archive */</comment>

  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pMtime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pMethod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>bIsDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>iMethod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Compression method to use (0 or 8) */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Possibly compressed data for new entry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of aData[] in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szUncompressed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Size of data before compression */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Free this before returning */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iCrc32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* crc32 of uncompressed data */</comment>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Path (name) of new entry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of zName in bytes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Free this before returning */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>ZipfileCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Martial the arguments into stack variables */</comment>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>nVal</name><operator>!=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>nVal</name><operator>!=</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"wrong number of arguments to function zipfile()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>zipfile_step_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pName</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pMode</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMtime</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>==</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pMethod</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Check that the 'name' parameter looks ok. */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"first argument to zipfile() must be non-NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>zipfile_step_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Inspect the 'method' parameter. This must be either 0 (store), 8 (use
  ** deflate compression) or NULL (choose automatically).  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pMethod</name> <operator>&amp;&amp;</operator> <name>SQLITE_NULL</name><operator>!=</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pMethod</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iMethod</name><operator>!=</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"illegal method value: %d"</literal></expr></argument>, <argument><expr><name>iMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <goto>goto <name>zipfile_step_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now inspect the data. If this is NULL, then the new entry must be a
  ** directory.  Otherwise, figure out whether or not the data should
  ** be deflated or simply stored in the zip archive. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bIsDir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szUncompressed</name> <operator>=</operator> <name>nData</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCrc32</name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iMethod</name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileDeflate</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aFree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>zipfile_step_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>==</operator><literal type="number">8</literal> <operator>||</operator> <name>nOut</name><operator>&lt;</operator><name>nData</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <name>aFree</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nData</name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Decode the "mode" argument. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetMode</name><argument_list>(<argument><expr><name>pMode</name></expr></argument>, <argument><expr><name>bIsDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Decode the "mtime" argument. */</comment>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>mUnixTime</name></name> <operator>=</operator> <call><name>zipfileGetTime</name><argument_list>(<argument><expr><name>pMtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a directory entry, ensure that there is exactly one '/'
  ** at the end of the path. Or, if this is not a directory and the path
  ** ends in '/' it is an error. */</comment>
  <if_stmt><if>if<condition>( <expr><name>bIsDir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nName</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zName</name><index>[<expr><name>nName</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"non-directory name must not end with /"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <goto>goto <name>zipfile_step_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><name>nName</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zName</name> <operator>=</operator> <name>zFree</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>zipfile_step_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nName</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><name>nName</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zName</name><index>[<expr><name>nName</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nName</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Assemble the ZipfileEntry object for the new zip archive entry */</comment>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iVersionMadeBy</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_MADEBY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iVersionExtract</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_REQUIRED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_FLAGS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iCompression</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iMethod</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileMtimeToDos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>.</operator><name>cds</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>e</name><operator>.</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>crc32</name></name> <operator>=</operator> <name>iCrc32</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>szUncompressed</name></name> <operator>=</operator> <name>szUncompressed</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iExternalAttr</name></name> <operator>=</operator> <operator>(</operator><name>mode</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>

  <comment type="block">/* Append the LFH to the body of the new archive */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>ZIPFILE_LFH_FIXED_SZ</name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>zipfileBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+=</operator> <call><name>zipfileSerializeLFH</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Append the data to the body of the new archive */</comment>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>zipfileBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+=</operator> <name>nData</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Append the CDS record to the directory of the new archive */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>ZIPFILE_CDS_FIXED_SZ</name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>zipfileBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name> <operator>+=</operator> <call><name>zipfileSerializeCDS</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Increment the count of entries in the archive */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name><operator>++</operator></expr>;</expr_stmt>

 <label><name>zipfile_step_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xFinalize() callback for zipfile aggregate function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileFinal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nZip</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aZip</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>ZipfileCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>eocd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntry</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntryTotal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nZip</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name>ZIPFILE_EOCD_FIXED_SZ</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aZip</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nZip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aZip</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aZip</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aZip</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>zipfileSerializeEOCD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aZip</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aZip</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nZip</name></expr></argument>, <argument><expr><name>zipfileFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Register the "zipfile" virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileRegister</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>zipfileModule</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,                         <comment type="block">/* iVersion */</comment>
    <expr><name>zipfileConnect</name></expr>,            <comment type="block">/* xCreate */</comment>
    <expr><name>zipfileConnect</name></expr>,            <comment type="block">/* xConnect */</comment>
    <expr><name>zipfileBestIndex</name></expr>,          <comment type="block">/* xBestIndex */</comment>
    <expr><name>zipfileDisconnect</name></expr>,         <comment type="block">/* xDisconnect */</comment>
    <expr><name>zipfileDisconnect</name></expr>,         <comment type="block">/* xDestroy */</comment>
    <expr><name>zipfileOpen</name></expr>,               <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>zipfileClose</name></expr>,              <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>zipfileFilter</name></expr>,             <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>zipfileNext</name></expr>,               <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>zipfileEof</name></expr>,                <comment type="block">/* xEof - check for end of scan */</comment>
    <expr><name>zipfileColumn</name></expr>,             <comment type="block">/* xColumn - read data */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRowid - read data */</comment>
    <expr><name>zipfileUpdate</name></expr>,             <comment type="block">/* xUpdate */</comment>
    <expr><name>zipfileBegin</name></expr>,              <comment type="block">/* xBegin */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
    <expr><name>zipfileCommit</name></expr>,             <comment type="block">/* xCommit */</comment>
    <expr><name>zipfileRollback</name></expr>,           <comment type="block">/* xRollback */</comment>
    <expr><name>zipfileFindFunction</name></expr>,       <comment type="block">/* xFindMethod */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
    <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>  , <argument><expr><operator>&amp;</operator><name>zipfileModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"zipfile_cds"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
        <argument><expr><name>zipfileStep</name></expr></argument>, <argument><expr><name>zipfileFinal</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u16</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>         <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileRegister</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_zipfile_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <return>return <expr><call><name>zipfileRegister</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
