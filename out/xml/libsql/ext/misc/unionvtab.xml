<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/misc/unionvtab.c"><comment type="block">/*
** 2017 July 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains the implementation of the "unionvtab" and "swarmvtab"
** virtual tables. These modules provide read-only access to multiple tables,
** possibly in multiple database files, via a single database object.
** The source tables must have the following characteristics:
**
**   * They must all be rowid tables (not VIRTUAL or WITHOUT ROWID
**     tables or views).
**
**   * Each table must have the same set of columns, declared in
**     the same order and with the same declared types.
**
**   * The tables must not feature a user-defined column named "_rowid_".
**
**   * Each table must contain a distinct range of rowid values.
**
** The difference between the two virtual table modules is that for 
** "unionvtab", all source tables must be located in the main database or
** in databases ATTACHed to the main database by the user. For "swarmvtab",
** the tables may be located in any database file on disk. The "swarmvtab"
** implementation takes care of opening and closing database files
** automatically.
**
** UNIONVTAB
**
**   A "unionvtab" virtual table is created as follows:
**
**     CREATE VIRTUAL TABLE &lt;name&gt; USING unionvtab(&lt;sql-statement&gt;);
**
**   The implementation evalutes &lt;sql statement&gt; whenever a unionvtab virtual
**   table is created or opened. It should return one row for each source
**   database table. The four columns required of each row are:
**
**     1. The name of the database containing the table ("main" or "temp" or
**        the name of an attached database). Or NULL to indicate that all
**        databases should be searched for the table in the usual fashion.
**
**     2. The name of the database table.
**
**     3. The smallest rowid in the range of rowids that may be stored in the
**        database table (an integer).
**
**     4. The largest rowid in the range of rowids that may be stored in the
**        database table (an integer).
**
** SWARMVTAB
**
**  LEGACY SYNTAX:
**
**   A "swarmvtab" virtual table is created similarly to a unionvtab table:
**
**     CREATE VIRTUAL TABLE &lt;name&gt;
**      USING swarmvtab(&lt;sql-statement&gt;, &lt;callback&gt;);
**
**   The difference is that for a swarmvtab table, the first column returned
**   by the &lt;sql statement&gt; must return a path or URI that can be used to open
**   the database file containing the source table.  The &lt;callback&gt; option
**   is optional.  If included, it is the name of an application-defined
**   SQL function that is invoked with the URI of the file, if the file
**   does not already exist on disk when required by swarmvtab.
**
**  NEW SYNTAX:
**
**   Using the new syntax, a swarmvtab table is created with:
**
**      CREATE VIRTUAL TABLE &lt;name&gt; USING swarmvtab(
**        &lt;sql-statement&gt; [, &lt;options&gt;]
**      );
**
**   where valid &lt;options&gt; are:
**
**      missing=&lt;udf-function-name&gt;
**      openclose=&lt;udf-function-name&gt;
**      maxopen=&lt;integer&gt;
**      &lt;sql-parameter&gt;=&lt;text-value&gt;
**
**   The &lt;sql-statement&gt; must return the same 4 columns as for a swarmvtab
**   table in legacy mode. However, it may also return a 5th column - the
**   "context" column. The text value returned in this column is not used
**   at all by the swarmvtab implementation, except that it is passed as
**   an additional argument to the two UDF functions that may be invoked
**   (see below).
**
**   The "missing" option, if present, specifies the name of an SQL UDF
**   function to be invoked if a database file is not already present on
**   disk when required by swarmvtab. If the &lt;sql-statement&gt; did not provide
**   a context column, it is invoked as:
**
**     SELECT &lt;missing-udf&gt;(&lt;database filename/uri&gt;);
**
**   Or, if there was a context column:
**
**     SELECT &lt;missing-udf&gt;(&lt;database filename/uri&gt;, &lt;context&gt;);
**
**   The "openclose" option may also specify a UDF function. This function
**   is invoked right before swarmvtab opens a database, and right after
**   it closes one. The first argument - or first two arguments, if
**   &lt;sql-statement&gt; supplied the context column - is the same as for
**   the "missing" UDF. Following this, the UDF is passed integer value
**   0 before a db is opened, and 1 right after it is closed. If both
**   a missing and openclose UDF is supplied, the application should expect
**   the following sequence of calls (for a single database):
**
**      SELECT &lt;openclose-udf&gt;(&lt;db filename&gt;, &lt;context&gt;, 0);
**      if( db not already on disk ){
**          SELECT &lt;missing-udf&gt;(&lt;db filename&gt;, &lt;context&gt;);
**      }
**      ... swarmvtab uses database ...
**      SELECT &lt;openclose-udf&gt;(&lt;db filename&gt;, &lt;context&gt;, 1);
**
**   The "maxopen" option is used to configure the maximum number of
**   database files swarmvtab will hold open simultaneously (default 9).
**
**   If an option name begins with a ":" character, then it is assumed
**   to be an SQL parameter. In this case, the specified text value is
**   bound to the same variable of the &lt;sql-statement&gt; before it is 
**   executed. It is an error of the named SQL parameter does not exist.
**   For example:
**
**     CREATE VIRTUAL TABLE swarm USING swarmvtab(
**       'SELECT :path || localfile, tbl, min, max FROM swarmdir',
**       :path='/home/user/databases/'
**       missing='missing_func'
**     );
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Largest and smallest possible 64-bit signed integers. These macros
** copied from sqliteInt.h.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LARGEST_INT64</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LARGEST_INT64</name></cpp:macro>  <cpp:value>(0xffffffff|(((sqlite3_int64)0x7fffffff)&lt;&lt;32))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SMALLEST_INT64</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLEST_INT64</name></cpp:macro> <cpp:value>(((sqlite3_int64)-1) - LARGEST_INT64)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following is also copied from sqliteInt.h. To facilitate coverage
** testing.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ALWAYS</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MUTATION_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(0)</cpp:value></cpp:define>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>((X)?1:(assert(0),0))</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>((X)?(assert(0),1):0)</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(X)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(X)</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The swarmvtab module attempts to keep the number of open database files
** at or below this limit. This may not be possible if there are too many
** simultaneous queries.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWARMVTAB_MAX_OPEN</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>UnionCsr</name></name></type> <name>UnionCsr</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>UnionTab</name></name></type> <name>UnionTab</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>UnionSrc</name></name></type> <name>UnionSrc</name>;</typedef>

<comment type="block">/*
** Each source table (row returned by the initialization query) is 
** represented by an instance of the following structure stored in the
** UnionTab.aSrc[] array.
*/</comment>
<struct>struct <name>UnionSrc</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                      <comment type="block">/* Database containing source table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>                     <comment type="block">/* Source table name */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMin</name></decl>;</decl_stmt>             <comment type="block">/* Minimum rowid */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMax</name></decl>;</decl_stmt>             <comment type="block">/* Maximum rowid */</comment>

  <comment type="block">/* Fields used by swarmvtab only */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>                    <comment type="block">/* Database file containing table zTab */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zContext</name></decl>;</decl_stmt>                 <comment type="block">/* Context string, if any */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nUser</name></decl>;</decl_stmt>                      <comment type="block">/* Current number of users */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pNextClosable</name></decl>;</decl_stmt>        <comment type="block">/* Next in list of closable sources */</comment>
}</block>;</struct>

<comment type="block">/*
** Virtual table  type for union vtab.
*/</comment>
<struct>struct <name>UnionTab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSwarm</name></decl>;</decl_stmt>                     <comment type="block">/* 1 for "swarmvtab", 0 for "unionvtab" */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPK</name></decl>;</decl_stmt>                        <comment type="block">/* INTEGER PRIMARY KEY column, or -1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSrc</name></decl>;</decl_stmt>                       <comment type="block">/* Number of elements in the aSrc[] array */</comment>
  <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>aSrc</name></decl>;</decl_stmt>                 <comment type="block">/* Array of source tables, sorted by rowid */</comment>

  <comment type="block">/* Used by swarmvtab only */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHasContext</name></decl>;</decl_stmt>                <comment type="block">/* Has context strings */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSourceStr</name></decl>;</decl_stmt>               <comment type="block">/* Expected unionSourceToStr() value */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pNotFound</name></decl>;</decl_stmt>        <comment type="block">/* UDF to invoke if file not found on open */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pOpenClose</name></decl>;</decl_stmt>       <comment type="block">/* UDF to invoke on open and close */</comment>

  <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pClosable</name></decl>;</decl_stmt>            <comment type="block">/* First in list of closable sources */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOpen</name></decl>;</decl_stmt>                      <comment type="block">/* Current number of open sources */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxOpen</name></decl>;</decl_stmt>                   <comment type="block">/* Maximum number of open sources */</comment>
}</block>;</struct>

<comment type="block">/*
** Virtual table cursor type for union vtab.
*/</comment>
<struct>struct <name>UnionCsr</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>       <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>            <comment type="block">/* SQL statement to run */</comment>

  <comment type="block">/* Used by swarmvtab only */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMaxRowid</name></decl>;</decl_stmt>        <comment type="block">/* Last rowid to visit */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>                       <comment type="block">/* Index of table read by pStmt */</comment>
}</block>;</struct>

<comment type="block">/*
** Given UnionTab table pTab and UnionSrc object pSrc, return the database
** handle that should be used to access the table identified by pSrc. This
** is the main db handle for "unionvtab" tables, or the source-specific 
** handle for "swarmvtab".
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unionGetDb</name><parameter_list>(<parameter><type><name>pTab</name></type></parameter>, <parameter><type><name>pSrc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pTab)-&gt;bSwarm ? (pSrc)-&gt;db : (pTab)-&gt;db)</cpp:value></cpp:define>

<comment type="block">/*
** If *pRc is other than SQLITE_OK when this function is called, it
** always returns NULL. Otherwise, it attempts to allocate and return
** a pointer to nByte bytes of zeroed memory. If the memory allocation
** is attempted but fails, NULL is returned and *pRc is set to 
** SQLITE_NOMEM.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>unionMalloc</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If *pRc is other than SQLITE_OK when this function is called, it
** always returns NULL. Otherwise, it attempts to allocate and return
** a copy of the nul-terminated string passed as the second argument.
** If the allocation is attempted but fails, NULL is returned and *pRc is 
** set to SQLITE_NOMEM.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>unionStrdup</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zIn</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>unionMalloc</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the first character of the string passed as the only argument to this
** function is one of the 4 that may be used as an open quote character
** in SQL, this function assumes that the input is a well-formed quoted SQL 
** string. In this case the string is dequoted in place.
**
** If the first character of the input is not an open quote, then this
** function is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unionDequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Set stack variable q to the close-quote character */</comment>
    <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'['</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'`'</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iIn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  
      <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>iIn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><name>q</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>iIn</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name>q</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Character iIn was the close quote. */</comment>
            <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* Character iIn and iIn+1 form an escaped quote character. Skip
            ** the input cursor past both and copy a single quote character 
            ** to the output buffer. */</comment>
            <expr_stmt><expr><name>iIn</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>z</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>z</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is set to other than SQLITE_OK when it
** is called. NULL is returned in this case.
**
** Otherwise, the SQL statement passed as the third argument is prepared
** against the database handle passed as the second. If the statement is
** successfully prepared, a pointer to the new statement handle is 
** returned. It is the responsibility of the caller to eventually free the
** statement by calling sqlite3_finalize(). Alternatively, if statement
** compilation fails, NULL is returned, *pRc is set to an SQLite error
** code and *pzErr may be set to an error message buffer allocated by
** sqlite3_malloc().
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>unionPrepare</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,               <comment type="block">/* SQL statement to prepare */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pzErr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"sql error: %s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Like unionPrepare(), except prepare the results of vprintf(zFmt, ...)
** instead of a constant SQL string.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>unionPreparePrintf</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>,                   <comment type="block">/* OUT: Error message */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>,               <comment type="block">/* printf() format string */</comment>
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>                             <comment type="block">/* Trailing printf args */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>unionPrepare</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Call sqlite3_reset() on SQL statement pStmt. If *pRc is set to 
** SQLITE_OK when this function is called, then it is set to the
** value returned by sqlite3_reset() before this function exits.
** In this case, *pzErr may be set to point to an error message
** buffer allocated by sqlite3_malloc().
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void unionReset(int *pRc, sqlite3_stmt *pStmt, char **pzErr){
  int rc = sqlite3_reset(pStmt);
  if( *pRc==SQLITE_OK ){
    *pRc = rc;
    if( rc ){
      *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(sqlite3_db_handle(pStmt)));
    }
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Call sqlite3_finalize() on SQL statement pStmt. If *pRc is set to 
** SQLITE_OK when this function is called, then it is set to the
** value returned by sqlite3_finalize() before this function exits.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unionFinalize</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_db_handle</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If an "openclose" UDF was supplied when this virtual table was created,
** invoke it now. The first argument passed is the name of the database
** file for source pSrc. The second is integer value bClose.
**
** If successful, return SQLITE_OK. Otherwise an SQLite error code. In this
** case if argument pzErr is not NULL, also set (*pzErr) to an English
** language error message. The caller is responsible for eventually freeing 
** any error message using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionInvokeOpenClose</name><parameter_list>(
  <parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, 
  <parameter><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClose</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bHasContext</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zContext</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name><name>pTab</name><operator>-&gt;</operator><name>bHasContext</name></name></expr></argument>, <argument><expr><name>bClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pzErr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op for unionvtab. For swarmvtab, it attempts to
** close open database files until at most nMax are open. An SQLite error
** code is returned if an error occurs, or SQLITE_OK otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unionCloseSources</name><parameter_list>(<parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pClosable</name></name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nOpen</name></name><operator>&gt;</operator><name>nMax</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pClosable</name></name></expr>;</init> <condition><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNextClosable</name></name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNextClosable</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nOpen</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unionInvokeOpenClose</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** xDisconnect method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pVtab</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>UnionTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bHaveSrcDb</name> <init>= <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bHaveSrcDb</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>unionInvokeOpenClose</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zSourceStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check that the table identified by pSrc is a rowid table. If not,
** return SQLITE_ERROR and set (*pzErr) to point to an English language
** error message. If the table is a rowid table and no error occurs,
** return SQLITE_OK and leave (*pzErr) unmodified.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionIsIntkeyTable</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,                 <comment type="block">/* Source table to test */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_table_column_metadata</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><literal type="string">"_rowid_"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bPk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name> 
   <operator>||</operator> <operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>bPk</name> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"integer"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no such rowid table: %s%s%s"</literal></expr></argument>,
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr> ?</condition><then> <expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr> ?</condition><then> <expr><literal type="string">"."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
        <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is
** called. In this case it returns NULL.
**
** Otherwise, this function checks that the source table passed as the
** second argument (a) exists, (b) is not a view and (c) has a column 
** named "_rowid_" of type "integer" that is the primary key.
** If this is not the case, *pRc is set to SQLITE_ERROR and NULL is
** returned.
**
** Finally, if the source table passes the checks above, a nul-terminated
** string describing the column names and types belonging to the source
** table is returned. Tables with the same set of column names and types 
** cause this function to return identical strings. Is is the responsibility
** of the caller to free the returned string using sqlite3_free() when
** it is no longer required.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>unionSourceToStr</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                 <comment type="block">/* Virtual table object */</comment>
  <parameter><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,                 <comment type="block">/* Source table to test */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>unionGetDb</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>unionIsIntkeyTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><call><name>unionPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
        <argument><expr><literal type="string">"SELECT group_concat(quote(name) || '.' || quote(type)) "</literal>
        <literal type="string">"FROM pragma_table_info(?, ?)"</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>unionFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check that all configured source tables exist and have the same column
** names and datatypes. If this is not the case, or if some other error
** occurs, return an SQLite error code. In this case *pzErr may be set
** to point to an error message buffer allocated by sqlite3_mprintf().
** Or, if no problems regarding the source tables are detected and no
** other error occurs, SQLITE_OK is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionSourceCheck</name><parameter_list>(<parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pzErr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z0</name> <operator>=</operator> <call><name>unionSourceToStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>unionSourceToStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>z0</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"source table schema mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to open the swarmvtab database.  If initially unable, invoke the
** not-found callback UDF and then try again.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionOpenDatabaseInner</name><parameter_list>(<parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>openFlags</name> <init>= <expr><name>SQLITE_OPEN_READONLY</name> <operator>|</operator> <name>SQLITE_OPEN_URI</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unionInvokeOpenClose</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bHasContext</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zContext</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called for swarmvtab tables. The results of
** calling it on a unionvtab table are undefined.
**
** For a swarmvtab table, this function ensures that source database iSrc
** is open. If the database is opened successfully and the schema is as
** expected, or if it is already open when this function is called, SQLITE_OK
** is returned.
**
** Alternatively If an error occurs while opening the databases, or if the
** database schema is unsuitable, an SQLite error code is returned and (*pzErr)
** may be set to point to an English language error message. In this case it is
** the responsibility of the caller to eventually free the error message buffer
** using sqlite3_free(). 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionOpenDatabase</name><parameter_list>(<parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSrc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name>iSrc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>bSwarm</name></name> <operator>&amp;&amp;</operator> <name>iSrc</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unionCloseSources</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nMaxOpen</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unionOpenDatabaseInner</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>unionSourceToStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>zSourceStr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zSourceStr</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zSourceStr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"source table schema mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pNextClosable</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pClosable</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pClosable</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nOpen</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unionInvokeOpenClose</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is a no-op for unionvtab tables. For swarmvtab, increment 
** the reference count for source table iTab. If the reference count was
** zero before it was incremented, also remove the source from the closable
** list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unionIncrRefcount</name><parameter_list>(<parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bSwarm</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name>iTab</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nUser</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nUser</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pClosable</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pSrc</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNextClosable</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pNextClosable</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pNextClosable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nUser</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Finalize the SQL statement pCsr-&gt;pStmt and return the result.
**
** If this is a swarmvtab table (not unionvtab) and pCsr-&gt;pStmt was not
** NULL when this function was called, also decrement the reference
** count on the associated source table. If this means the source tables
** refcount is now zero, add it to the closable list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionFinalizeCsrStmt</name><parameter_list>(<parameter><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>UnionTab</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bSwarm</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nUser</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nUser</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nUser</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pNextClosable</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pClosable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pClosable</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>unionCloseSources</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nMaxOpen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return true if the argument is a space, tab, CR or LF character.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>union_isspace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\r'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\t'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return true if the argument is an alphanumeric character in the 
** ASCII range.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>union_isidchar</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;</operator><literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to handle all arguments following the first 
** (the SQL statement) passed to a swarmvtab (not unionvtab) CREATE 
** VIRTUAL TABLE statement. It may bind parameters to the SQL statement 
** or configure members of the UnionTab object passed as the second
** argument.
**
** Refer to header comments at the top of this file for a description
** of the arguments parsed.
**
** This function is a no-op if *pRc is other than SQLITE_OK when it is
** called. Otherwise, if an error occurs, *pRc is set to an SQLite error
** code. In this case *pzErr may be set to point to a buffer containing
** an English language error message. It is the responsibility of the 
** caller to eventually free the buffer using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unionConfigureVtab</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                 <comment type="block">/* Table to configure */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,            <comment type="block">/* SQL statement to find sources */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                       <comment type="block">/* Number of entries in azArg[] array */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>azArg</name></decl></parameter>,      <comment type="block">/* Array of arguments to consider */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bHasContext</name></name> <operator>=</operator> <operator>(</operator><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zArg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nOpt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Size of option name in bytes */</comment>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl>;</decl_stmt>                 <comment type="block">/* Pointer to option name */</comment>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>                 <comment type="block">/* Pointer to value */</comment>

      <expr_stmt><expr><call><name>unionDequote</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zOpt</name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>union_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zOpt</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zOpt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>zVal</name> <operator>=</operator> <name>zOpt</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zVal</name><operator>==</operator><literal type="char">':'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zVal</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <while>while<condition>( <expr><call><name>union_isidchar</name><argument_list>(<argument><expr><operator>*</operator><name>zVal</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zVal</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>nOpt</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zVal</name><operator>-</operator><name>zOpt</name><operator>)</operator></expr>;</expr_stmt>

      <while>while<condition>( <expr><call><name>union_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zVal</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zVal</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zVal</name><operator>==</operator><literal type="char">'='</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zOpt</name><index>[<expr><name>nOpt</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zVal</name><operator>++</operator></expr>;</expr_stmt>
        <while>while<condition>( <expr><call><name>union_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zVal</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zVal</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>unionDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>zOpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">':'</literal></expr> )</condition><block>{<block_content>
            <comment type="block">/* A value to bind to the SQL statement */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>iParam</name> <init>= <expr><call><name>sqlite3_bind_parameter_index</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>iParam</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
                  <argument><expr><literal type="string">"swarmvtab: no such SQL parameter: %s"</literal></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iParam</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="string">"maxopen"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nMaxOpen</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nMaxOpen</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"swarmvtab: illegal maxopen value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="string">"missing"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
                  <argument><expr><literal type="string">"swarmvtab: duplicate \"missing\" option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name> <operator>=</operator> <call><name>unionPreparePrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
                  <argument><expr><literal type="string">"SELECT \"%w\"(?%s)"</literal></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTab</name><operator>-&gt;</operator><name>bHasContext</name></name></expr> ?</condition><then> <expr><literal type="string">",?"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">9</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="string">"openclose"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
                  <argument><expr><literal type="string">"swarmvtab: duplicate \"openclose\" option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pOpenClose</name></name> <operator>=</operator> <call><name>unionPreparePrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
                  <argument><expr><literal type="string">"SELECT \"%w\"(?,?%s)"</literal></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTab</name><operator>-&gt;</operator><name>bHasContext</name></name></expr> ?</condition><then> <expr><literal type="string">",?"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"swarmvtab: unrecognized option: %s"</literal></expr></argument>,<argument><expr><name>zOpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNotFound</name></name> <operator>=</operator> <call><name>unionPreparePrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
              <argument><expr><literal type="string">"SELECT \"%w\"(?)"</literal></expr></argument>, <argument><expr><name>zArg</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>( <argument><expr><literal type="string">"swarmvtab: parse error: %s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** xConnect/xCreate method.
**
** The argv[] array contains the following:
**
**   argv[0]   -&gt; module name  ("unionvtab" or "swarmvtab")
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[3]   -&gt; SQL statement
**   argv[4]   -&gt; not-found callback UDF name
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bSwarm</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>pAux</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVtab</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bSwarm</name></expr> ?</condition><then> <expr><literal type="string">"swarmvtab"</literal></expr> </then><else>: <expr><literal type="string">"unionvtab"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"temp"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* unionvtab tables may only be created in the temp schema */</comment>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s tables must be created in TEMP schema"</literal></expr></argument>, <argument><expr><name>zVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">4</literal> <operator>||</operator> <operator>(</operator><name>argc</name><operator>&gt;</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>bSwarm</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"wrong number of arguments for %s"</literal></expr></argument>, <argument><expr><name>zVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Allocated size of pTab-&gt;aSrc[] */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Argument statement */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>      <comment type="block">/* Copy of argument to CVT */</comment>

    <comment type="block">/* Prepare the SQL statement. Instead of executing it directly, sort
    ** the results by the "minimum rowid" field. This makes it easier to
    ** check that there are no rowid range overlaps between source tables 
    ** and that the UnionTab.aSrc[] array is always sorted by rowid.  */</comment>
    <expr_stmt><expr><call><name>unionDequote</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>unionPreparePrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
        <argument><expr><literal type="string">"SELECT * FROM (%z) ORDER BY 3"</literal></expr></argument>, <argument><expr><name>zArg</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate the UnionTab structure */</comment>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>unionMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnionTab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bSwarm</name></name> <operator>=</operator> <name>bSwarm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nMaxOpen</name></name> <operator>=</operator> <name>SWARMVTAB_MAX_OPEN</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse other CVT arguments, if any */</comment>
    <if_stmt><if>if<condition>( <expr><name>bSwarm</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>unionConfigureVtab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>argc</name><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Iterate through the rows returned by the SQL statement specified
    ** as an argument to the CREATE VIRTUAL TABLE statement. */</comment>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMin</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMax</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>

      <comment type="block">/* Grow the pTab-&gt;aSrc[] array if required. */</comment>
      <if_stmt><if>if<condition>( <expr><name>nAlloc</name><operator>&lt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><ternary><condition><expr><name>nAlloc</name></expr> ?</condition><then> <expr><name>nAlloc</name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>aNew</name> <init>= <expr><operator>(</operator><name>UnionSrc</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(
            <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name></name></expr></argument>, <argument><expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>UnionSrc</name></expr></argument>)</argument_list></sizeof></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>nNew</name><operator>-</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>UnionSrc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Check for problems with the specified range of rowids */</comment>
      <if_stmt><if>if<condition>( <expr><name>iMax</name><operator>&lt;</operator><name>iMin</name> <operator>||</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iMin</name><operator>&lt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iMax</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"rowid range mismatch error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name> <operator>=</operator> <call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iMin</name></name> <operator>=</operator> <name>iMin</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iMax</name></name> <operator>=</operator> <name>iMax</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bSwarm</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zFile</name></name> <operator>=</operator> <call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bHasContext</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zContext</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zContext</name></name> <operator>=</operator> <call><name>unionStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>unionFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* It is an error if the SELECT statement returned zero rows. If only
    ** because there is no way to determine the schema of the virtual 
    ** table in this case.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no source tables configured"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* For unionvtab, verify that all source tables exist and have 
    ** compatible schemas. For swarmvtab, attach the first database and
    ** check that the first table is a rowid table only.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bSwarm</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unionOpenDatabase</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unionSourceCheck</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compose a CREATE TABLE statement and pass it to declare_vtab() */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>tdb</name> <init>= <expr><call><name>unionGetDb</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>unionPreparePrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>tdb</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
          <literal type="string">"'CREATE TABLE xyz('"</literal>
          <literal type="string">"    || group_concat(quote(name) || ' ' || type, ', ')"</literal>
          <literal type="string">"    || ')',"</literal>
          <literal type="string">"max((cid+1) * (type='INTEGER' COLLATE nocase AND pk=1))-1 "</literal>
          <literal type="string">"FROM pragma_table_info(%Q, ?)"</literal></expr></argument>, 
          <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDecl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPK</name></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>unionFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unionDisconnect</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pTab</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xOpen
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>p</name></expr>;</expr_stmt>  <comment type="block">/* Suppress harmless warning */</comment>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>UnionCsr</name><operator>*</operator><operator>)</operator><call><name>unionMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnionCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xClose
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>UnionCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>unionFinalizeCsrStmt</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function does the work of the xNext() method. Except that, if it
** returns SQLITE_ROW, it should be called again within the same xNext()
** method call. See unionNext() for details.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>doUnionNext</name><parameter_list>(<parameter><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>UnionTab</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unionFinalizeCsrStmt</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>bSwarm</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iMaxRowid</name></name><operator>&gt;=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iMin</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* It is necessary to scan the next table. */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unionOpenDatabase</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <call><name>unionPreparePrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
              <argument><expr><literal type="string">"SELECT rowid, * FROM %Q %s %lld"</literal></expr></argument>,
              <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>,
              <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iMax</name></name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iMaxRowid</name></name></expr> ?</condition><then> <expr><literal type="string">"WHERE _rowid_ &lt;="</literal></expr> </then><else>: <expr><literal type="string">"-- "</literal></expr></else></ternary><operator>)</operator></expr></argument>,
              <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iMaxRowid</name></name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unionIncrRefcount</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xNext
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>doUnionNext</name><argument_list>(<argument><expr><operator>(</operator><name>UnionCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition>;</do>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xColumn
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>UnionCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xRowid
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>UnionCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xEof
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>UnionCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xFilter
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>UnionTab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pVtabCursor</name><operator>-&gt;</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnionCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>UnionCsr</name><operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bZero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMin</name> <init>= <expr><name>SMALLEST_INT64</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMax</name> <init>= <expr><name>LARGEST_INT64</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <name>idxNum</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name>
       <operator>||</operator> <name>idxNum</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name>
       <operator>||</operator> <name>idxNum</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GE</name>
       <operator>||</operator> <name>idxNum</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name>
       <operator>||</operator> <name>idxNum</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GT</name>
       <operator>||</operator> <name>idxNum</name><operator>==</operator><operator>(</operator><name>SQLITE_INDEX_CONSTRAINT_GE</name><operator>|</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxStr</name></expr>;</expr_stmt>  <comment type="block">/* Suppress harmless warning */</comment>
  
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iMax</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>

    <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name><operator>|</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMax</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <name>SQLITE_INDEX_CONSTRAINT_LT</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iMax</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bZero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iMax</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_INDEX_CONSTRAINT_GE</name><operator>|</operator><name>SQLITE_INDEX_CONSTRAINT_GT</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMin</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <name>SQLITE_INDEX_CONSTRAINT_GT</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iMin</name><operator>==</operator><name>LARGEST_INT64</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bZero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iMin</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>unionFinalizeCsrStmt</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bZero</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>UnionSrc</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iMin</name><operator>&gt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iMax</name></name> <operator>||</operator> <name>iMax</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iMin</name></name></expr> )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z%sSELECT rowid, * FROM %s%q%s%Q"</literal></expr></argument>
        , <argument><expr><name>zSql</name></expr></argument>
        , <argument><expr><operator>(</operator><ternary><condition><expr><name>zSql</name></expr> ?</condition><then> <expr><literal type="string">" UNION ALL "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>
        , <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr> ?</condition><then> <expr><literal type="string">"'"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>
        , <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr> ?</condition><then> <expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>
        , <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zDb</name></name></expr> ?</condition><then> <expr><literal type="string">"'."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>
        , <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iMin</name><operator>==</operator><name>iMax</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z WHERE rowid=%lld"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>iMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="string">"WHERE"</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iMin</name><operator>!=</operator><name>SMALLEST_INT64</name> <operator>&amp;&amp;</operator> <name>iMin</name><operator>&gt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iMin</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z WHERE rowid&gt;=%lld"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>iMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iMax</name><operator>!=</operator><name>LARGEST_INT64</name> <operator>&amp;&amp;</operator> <name>iMax</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iMax</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z %s rowid&lt;=%lld"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>iMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bSwarm</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iMaxRowid</name></name> <operator>=</operator> <name>iMax</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unionOpenDatabase</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>unionGetDb</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aSrc</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <call><name>unionPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>unionIncrRefcount</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>unionNext</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xBestIndex.
**
** This implementation searches for constraints on the rowid field. EQ, 
** LE, LT, GE and GT are handled.
**
** If there is an EQ comparison, then idxNum is set to INDEX_CONSTRAINT_EQ.
** In this case the only argument passed to xFilter is the rhs of the ==
** operator.
**
** Otherwise, if an LE or LT constraint is found, then the INDEX_CONSTRAINT_LE
** or INDEX_CONSTRAINT_LT (but not both) bit is set in idxNum. The first
** argument to xFilter is the rhs of the &lt;= or &lt; operator.  Similarly, if 
** an GE or GT constraint is found, then the INDEX_CONSTRAINT_GE or
** INDEX_CONSTRAINT_GT bit is set in idxNum. The rhs of the &gt;= or &gt; operator
** is passed as either the first or second argument to xFilter, depending
** on whether or not there is also a LT|LE constraint.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unionBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnionTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>UnionTab</name><operator>*</operator><operator>)</operator><name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEq</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLt</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iGt</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>usable</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPK</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>:</case>
          <expr_stmt><expr><name>iEq</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr>:</case>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr>:</case>
          <expr_stmt><expr><name>iLt</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr>:</case>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GT</name></expr>:</case>
          <expr_stmt><expr><name>iGt</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>iEq</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>=</operator> <name>SQLITE_INDEX_SCAN_UNIQUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">3.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iEq</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iEq</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCons</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nRow</name> <init>= <expr><literal type="number">1000000</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iLt</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRow</name> <operator>=</operator> <name>nRow</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iLt</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>iCons</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iLt</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>iLt</name></expr>]</index></name><operator>.</operator><name>op</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iGt</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRow</name> <operator>=</operator> <name>nRow</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iGt</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>iCons</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iGt</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>iGt</name></expr>]</index></name><operator>.</operator><name>op</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <name>nRow</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">3.0</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name>nRow</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register the unionvtab virtual table module with database handle db.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>createUnionVtab</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>unionModule</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><name>unionConnect</name></expr>,
    <expr><name>unionConnect</name></expr>,
    <expr><name>unionBestIndex</name></expr>,               <comment type="block">/* xBestIndex - query planner */</comment>
    <expr><name>unionDisconnect</name></expr>, 
    <expr><name>unionDisconnect</name></expr>,
    <expr><name>unionOpen</name></expr>,                    <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>unionClose</name></expr>,                   <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>unionFilter</name></expr>,                  <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>unionNext</name></expr>,                    <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>unionEof</name></expr>,                     <comment type="block">/* xEof - check for end of scan */</comment>
    <expr><name>unionColumn</name></expr>,                  <comment type="block">/* xColumn - read data */</comment>
    <expr><name>unionRowid</name></expr>,                   <comment type="block">/* xRowid - read data */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xUpdate */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xBegin */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSync */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xCommit */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollback */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xFindMethod */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRename */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollbackTo */</comment>
    <expr><literal type="number">0</literal></expr>                             <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"unionvtab"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>unionModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"swarmvtab"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>unionModule</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_unionvtab_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Suppress harmless warning */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>createUnionVtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
