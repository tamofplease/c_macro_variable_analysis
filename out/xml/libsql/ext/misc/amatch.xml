<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/misc/amatch.c"><comment type="block">/*
** 2013-03-14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code for a demonstration virtual table that finds
** "approximate matches" - strings from a finite set that are nearly the
** same as a single input string.  The virtual table is called "amatch".
**
** A amatch virtual table is created like this:
**
**     CREATE VIRTUAL TABLE f USING approximate_match(
**        vocabulary_table=&lt;tablename&gt;,      -- V
**        vocabulary_word=&lt;columnname&gt;,      -- W
**        vocabulary_language=&lt;columnname&gt;,  -- L
**        edit_distances=&lt;edit-cost-table&gt;
**     );
**
** When it is created, the new amatch table must be supplied with the
** the name of a table V and columns V.W and V.L such that 
**
**     SELECT W FROM V WHERE L=$language
**
** returns the allowed vocabulary for the match.  If the "vocabulary_language"
** or L columnname is left unspecified or is an empty string, then no
** filtering of the vocabulary by language is performed. 
**
** For efficiency, it is essential that the vocabulary table be indexed:
**
**     CREATE vocab_index ON V(W)
**
** A separate edit-cost-table provides scoring information that defines 
** what it means for one string to be "close" to another.
**
** The edit-cost-table must contain exactly four columns (more precisely,
** the statement "SELECT * FROM &lt;edit-cost-table&gt;" must return records
** that consist of four columns). It does not matter what the columns are
** named. 
**
** Each row in the edit-cost-table represents a single character
** transformation going from user input to the vocabulary. The leftmost 
** column of the row (column 0) contains an integer identifier of the
** language to which the transformation rule belongs (see "MULTIPLE LANGUAGES"
** below). The second column of the row (column 1) contains the input
** character or characters - the characters of user input. The third 
** column contains characters as they appear in the vocabulary table.
** And the fourth column contains the integer cost of making the
** transformation. For example:
**
**    CREATE TABLE f_data(iLang, cFrom, cTo, Cost);
**    INSERT INTO f_data(iLang, cFrom, cTo, Cost) VALUES(0, '', 'a', 100);
**    INSERT INTO f_data(iLang, cFrom, cTo, Cost) VALUES(0, 'b', '', 87);
**    INSERT INTO f_data(iLang, cFrom, cTo, Cost) VALUES(0, 'o', 'oe', 38);
**    INSERT INTO f_data(iLang, cFrom, cTo, Cost) VALUES(0, 'oe', 'o', 40);
**
** The first row inserted into the edit-cost-table by the SQL script
** above indicates that the cost of having an extra 'a' in the vocabulary
** table that is missing in the user input 100.  (All costs are integers.
** Overall cost must not exceed 16777216.)  The second INSERT statement 
** creates a rule saying that the cost of having a single letter 'b' in
** user input which is missing in the vocabulary table is 87.  The third
** INSERT statement mean that the cost of matching an 'o' in user input 
** against an 'oe' in the vocabulary table is 38.  And so forth.
**
** The following rules are special:
**
**    INSERT INTO f_data(iLang, cFrom, cTo, Cost) VALUES(0, '?', '', 97);
**    INSERT INTO f_data(iLang, cFrom, cTo, Cost) VALUES(0, '', '?', 98);
**    INSERT INTO f_data(iLang, cFrom, cTo, Cost) VALUES(0, '?', '?', 99);
**
** The '?' to '' rule is the cost of having any single character in the input
** that is not found in the vocabular.  The '' to '?' rule is the cost of
** having a character in the vocabulary table that is missing from input.
** And the '?' to '?' rule is the cost of doing an arbitrary character
** substitution.  These three generic rules apply across all languages.
** In other words, the iLang field is ignored for the generic substitution
** rules.  If more than one cost is given for a generic substitution rule,
** then the lowest cost is used.
**
** Once it has been created, the amatch virtual table can be queried
** as follows:
**
**    SELECT word, distance FROM f
**     WHERE word MATCH 'abcdefg'
**       AND distance&lt;200;
**
** This query outputs the strings contained in the T(F) field that
** are close to "abcdefg" and in order of increasing distance.  No string
** is output more than once.  If there are multiple ways to transform the
** target string ("abcdefg") into a string in the vocabulary table then
** the lowest cost transform is the one that is returned.  In this example,
** the search is limited to strings with a total distance of less than 200.
**
** For efficiency, it is important to put tight bounds on the distance.
** The time and memory space needed to perform this query is exponential
** in the maximum distance.  A good rule of thumb is to limit the distance
** to no more than 1.5 or 2 times the maximum cost of any rule in the
** edit-cost-table.
**
** The amatch is a read-only table.  Any attempt to DELETE, INSERT, or
** UPDATE on a amatch table will throw an error.
**
** It is important to put some kind of a limit on the amatch output.  This
** can be either in the form of a LIMIT clause at the end of the query,
** or better, a "distance&lt;NNN" constraint where NNN is some number.  The
** running time and memory requirement is exponential in the value of NNN 
** so you want to make sure that NNN is not too big.  A value of NNN that
** is about twice the average transformation cost seems to give good results.
**
** The amatch table can be useful for tasks such as spelling correction.
** Suppose all allowed words are in table vocabulary(w).  Then one would create
** an amatch virtual table like this:
**
**   CREATE VIRTUAL TABLE ex1 USING amatch(
**       vocabtable=vocabulary,
**       vocabcolumn=w,
**       edit_distances=ec1
**   );
**
** Then given an input word $word, look up close spellings this way:
**
**   SELECT word, distance FROM ex1
**    WHERE word MATCH $word AND distance&lt;200;
**
** MULTIPLE LANGUAGES
**
** Normally, the "iLang" value associated with all character transformations
** in the edit-cost-table is zero. However, if required, the amatch 
** virtual table allows multiple languages to be defined. Each query uses 
** only a single iLang value.   This allows, for example, a single 
** amatch table to support multiple languages.
**
** By default, only the rules with iLang=0 are used. To specify an 
** alternative language, a "language = ?" expression must be added to the
** WHERE clause of a SELECT, where ? is the integer identifier of the desired 
** language. For example:
**
**   SELECT word, distance FROM ex1
**    WHERE word MATCH $word
**      AND distance&lt;=200
**      AND language=1 -- Specify use language 1 instead of 0
**
** If no "language = ?" constraint is specified in the WHERE clause, language
** 0 is used.
**
** LIMITS
**
** The maximum language number is 2147483647.  The maximum length of either
** of the strings in the second or third column of the amatch data table
** is 50 bytes.  The maximum cost on a rule is 1000.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Forward declaration of objects used by this implementation
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>amatch_vtab</name></name></type> <name>amatch_vtab</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>amatch_cursor</name></name></type> <name>amatch_cursor</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>amatch_rule</name></name></type> <name>amatch_rule</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>amatch_word</name></name></type> <name>amatch_word</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>amatch_avl</name></name></type> <name>amatch_avl</name>;</typedef>


<comment type="block" format="doxygen">/*****************************************************************************
** AVL Tree implementation
*/</comment>
<comment type="block">/*
** Objects that want to be members of the AVL tree should embedded an
** instance of this structure.
*/</comment>
<struct>struct <name>amatch_avl</name> <block>{
  <decl_stmt><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pWord</name></decl>;</decl_stmt>   <comment type="block">/* Points to the object being stored in the tree */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>           <comment type="block">/* Key.  zero-terminated string.  Must be unique */</comment>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pBefore</name></decl>;</decl_stmt>  <comment type="block">/* Other elements less than zKey */</comment>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pAfter</name></decl>;</decl_stmt>   <comment type="block">/* Other elements greater than zKey */</comment>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pUp</name></decl>;</decl_stmt>      <comment type="block">/* Parent element */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>height</name></decl>;</decl_stmt>     <comment type="block">/* Height of this node.  Leaf==1 */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>imbalance</name></decl>;</decl_stmt>  <comment type="block">/* Height difference between pBefore and pAfter */</comment>
}</block>;</struct>

<comment type="block">/* Recompute the amatch_avl.height and amatch_avl.imbalance fields for p.
** Assume that the children of p have correct heights.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchAvlRecomputeHeight</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>hBefore</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name><operator>-&gt;</operator><name>height</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>hAfter</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name><operator>-&gt;</operator><name>height</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>imbalance</name></name> <operator>=</operator> <name>hBefore</name> <operator>-</operator> <name>hAfter</name></expr>;</expr_stmt>  <comment type="block">/* -: pAfter higher.  +: pBefore higher */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>hBefore</name><operator>&gt;</operator><name>hAfter</name></expr> ?</condition><then> <expr><name>hBefore</name></expr> </then><else>: <expr><name>hAfter</name></expr></else></ternary><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
**     P                B
**    / \              / \
**   B   Z    ==&gt;     X   P
**  / \                  / \
** X   Y                Y   Z
**
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_avl</name> <modifier>*</modifier></type><name>amatchAvlRotateBefore</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pP</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><name><name>pP</name><operator>-&gt;</operator><name>pBefore</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pY</name> <init>= <expr><name><name>pB</name><operator>-&gt;</operator><name>pAfter</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <name>pY</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pY</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>amatchAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>amatchAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pB</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
**     P                A
**    / \              / \
**   X   A    ==&gt;     P   Z
**      / \          / \
**     Y   Z        X   Y
**
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_avl</name> <modifier>*</modifier></type><name>amatchAvlRotateAfter</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pP</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><name><name>pP</name><operator>-&gt;</operator><name>pAfter</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pY</name> <init>= <expr><name><name>pA</name><operator>-&gt;</operator><name>pBefore</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <name>pY</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pY</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>amatchAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>amatchAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pA</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the pBefore or pAfter pointer in the parent
** of p that points to p.  Or if p is the root node, return pp.
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>amatchAvlFromPtr</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pp</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pUp</name><operator>-&gt;</operator><name>pAfter</name></name><operator>==</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>&amp;</operator><name><name>pUp</name><operator>-&gt;</operator><name>pAfter</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>&amp;</operator><name><name>pUp</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rebalance all nodes starting with p and working up to the root.
** Return the new root.
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_avl</name> <modifier>*</modifier></type><name>amatchAvlBalance</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pTop</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>amatchAvlRecomputeHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pB</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <call><name>amatchAvlRotateAfter</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>amatchAvlFromPtr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name> <operator>=</operator> <call><name>amatchAvlRotateBefore</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&lt;=</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <call><name>amatchAvlRotateBefore</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>amatchAvlFromPtr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name> <operator>=</operator> <call><name>amatchAvlRotateAfter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pTop</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pTop</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Search the tree rooted at p for an entry with zKey.  Return a pointer
** to the entry or return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_avl</name> <modifier>*</modifier></type><name>amatchAvlSearch</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the first node (the one with the smallest key).
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_avl</name> <modifier>*</modifier></type><name>amatchAvlFirst</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* NOT USED */</comment>
<comment type="block">/* Return the node with the next larger key after p.
*/</comment>
static amatch_avl *amatchAvlNext(amatch_avl *p){
  amatch_avl *pPrev = 0;
  while( p &amp;&amp; p-&gt;pAfter==pPrev ){
    pPrev = p;
    p = p-&gt;pUp;
  }
  if( p &amp;&amp; pPrev==0 ){
    p = amatchAvlFirst(p-&gt;pAfter);
  }
  return p;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* NOT USED */</comment>
<comment type="block">/* Verify AVL tree integrity
*/</comment>
static int amatchAvlIntegrity(amatch_avl *pHead){
  amatch_avl *p;
  if( pHead==0 ) return 1;
  if( (p = pHead-&gt;pBefore)!=0 ){
    assert( p-&gt;pUp==pHead );
    assert( amatchAvlIntegrity(p) );
    assert( strcmp(p-&gt;zKey, pHead-&gt;zKey)&lt;0 );
    while( p-&gt;pAfter ) p = p-&gt;pAfter;
    assert( strcmp(p-&gt;zKey, pHead-&gt;zKey)&lt;0 );
  }
  if( (p = pHead-&gt;pAfter)!=0 ){
    assert( p-&gt;pUp==pHead );
    assert( amatchAvlIntegrity(p) );
    assert( strcmp(p-&gt;zKey, pHead-&gt;zKey)&gt;0 );
    p = amatchAvlFirst(p);
    assert( strcmp(p-&gt;zKey, pHead-&gt;zKey)&gt;0 );
  }
  return 1;
}
static int amatchAvlIntegrity2(amatch_avl *pHead){
  amatch_avl *p, *pNext;
  for(p=amatchAvlFirst(pHead); p; p=pNext){
    pNext = amatchAvlNext(p);
    if( pNext==0 ) break;
    assert( strcmp(p-&gt;zKey, pNext-&gt;zKey)&lt;0 );
  }
  return 1;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Insert a new node pNew.  Return NULL on success.  If the key is not
** unique, then do not perform the insert but instead leave pNew unchanged
** and return a pointer to an existing node with the same key.
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_avl</name> <modifier>*</modifier></type><name>amatchAvlInsert</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppHead</name></decl></parameter>, <parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppHead</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><name>p</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>imbalance</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppHead</name> <operator>=</operator> <call><name>amatchAvlBalance</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* assert( amatchAvlIntegrity(*ppHead) ); */</comment>
  <comment type="block">/* assert( amatchAvlIntegrity2(*ppHead) ); */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove node pOld from the tree.  pOld must be an element of the tree or
** the AVL tree will become corrupt.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchAvlRemove</name><parameter_list>(<parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppHead</name></decl></parameter>, <parameter><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pBalance</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* assert( amatchAvlSearch(*ppHead, pOld-&gt;zKey)==pOld ); */</comment>
  <expr_stmt><expr><name>ppParent</name> <operator>=</operator> <call><name>amatchAvlFromPtr</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>ppHead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>pBefore</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pAfter</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppParent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBalance</name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>&amp;&amp;</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pAfter</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pX</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pY</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>amatchAvlFirst</name><argument_list>(<argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>pAfter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><call><name>amatchAvlFromPtr</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pAfter</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>pAfter</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pAfter</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pBalance</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pAfter</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>pAfter</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pAfter</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBalance</name><operator>==</operator><name>pOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBalance</name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <name>pY</name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pY</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppParent</name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>pBefore</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppParent</name> <operator>=</operator> <name>pBalance</name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pAfter</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBalance</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>pAfter</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppParent</name> <operator>=</operator> <name>pBalance</name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBalance</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppHead</name> <operator>=</operator> <call><name>amatchAvlBalance</name><argument_list>(<argument><expr><name>pBalance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOld</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOld</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOld</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* assert( amatchAvlIntegrity(*ppHead) ); */</comment>
  <comment type="block">/* assert( amatchAvlIntegrity2(*ppHead) ); */</comment>
</block_content>}</block></function>
<comment type="block">/*
** End of the AVL Tree implementation
******************************************************************************/</comment>


<comment type="block">/*
** Various types.
**
** amatch_cost is the "cost" of an edit operation.
**
** amatch_len is the length of a matching string.  
**
** amatch_langid is an ruleset identifier.
*/</comment>
<typedef>typedef <type><name>int</name></type> <name>amatch_cost</name>;</typedef>
<typedef>typedef <type><name>signed</name> <name>char</name></type> <name>amatch_len</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>amatch_langid</name>;</typedef>

<comment type="block">/*
** Limits
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_MX_LENGTH</name></cpp:macro>          <cpp:value>50</cpp:value></cpp:define>  <comment type="block">/* Maximum length of a rule string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_MX_LANGID</name></cpp:macro>  <cpp:value>2147483647</cpp:value></cpp:define>  <comment type="block">/* Maximum rule ID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_MX_COST</name></cpp:macro>          <cpp:value>1000</cpp:value></cpp:define>  <comment type="block">/* Maximum single-rule cost */</comment>

<comment type="block">/*
** A match or partial match
*/</comment>
<struct>struct <name>amatch_word</name> <block>{
  <decl_stmt><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>   <comment type="block">/* Next on a list of all amatch_words */</comment>
  <decl_stmt><decl><type><name>amatch_avl</name></type> <name>sCost</name></decl>;</decl_stmt>     <comment type="block">/* Linkage of this node into the cost tree */</comment>
  <decl_stmt><decl><type><name>amatch_avl</name></type> <name>sWord</name></decl>;</decl_stmt>     <comment type="block">/* Linkage of this node into the word tree */</comment>
  <decl_stmt><decl><type><name>amatch_cost</name></type> <name>rCost</name></decl>;</decl_stmt>    <comment type="block">/* Cost of the match so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSeq</name></decl>;</decl_stmt>             <comment type="block">/* Sequence number */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zCost</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Cost key (text rendering of rCost) */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>nMatch</name></decl>;</decl_stmt>     <comment type="block">/* Input characters matched */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zWord</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Text of the word.  Extra space appended as needed */</comment>
}</block>;</struct>

<comment type="block">/*
** Each transformation rule is stored as an instance of this object.
** All rules are kept on a linked list sorted by rCost.
*/</comment>
<struct>struct <name>amatch_rule</name> <block>{
  <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>      <comment type="block">/* Next rule in order of increasing rCost */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl>;</decl_stmt>             <comment type="block">/* Transform from (a string from user input) */</comment>
  <decl_stmt><decl><type><name>amatch_cost</name></type> <name>rCost</name></decl>;</decl_stmt>       <comment type="block">/* Cost of this transformation */</comment>
  <decl_stmt><decl><type><name>amatch_langid</name></type> <name>iLang</name></decl>;</decl_stmt>     <comment type="block">/* The langauge to which this rule belongs */</comment>
  <decl_stmt><decl><type><name>amatch_len</name></type> <name>nFrom</name></decl>, <decl><type ref="prev"/><name>nTo</name></decl>;</decl_stmt>   <comment type="block">/* Length of the zFrom and zTo strings */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTo</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Tranform to V.W value (extra space appended) */</comment>
}</block>;</struct>

<comment type="block">/* 
** A amatch virtual-table object 
*/</comment>
<struct>struct <name>amatch_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zClassName</name></decl>;</decl_stmt>          <comment type="block">/* Name of this class.  Default: "amatch" */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                 <comment type="block">/* Name of database.  (ex: "main") */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSelf</name></decl>;</decl_stmt>               <comment type="block">/* Name of this virtual table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCostTab</name></decl>;</decl_stmt>            <comment type="block">/* Name of edit-cost-table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVocabTab</name></decl>;</decl_stmt>           <comment type="block">/* Name of vocabulary table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVocabWord</name></decl>;</decl_stmt>          <comment type="block">/* Name of vocabulary table word column */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVocabLang</name></decl>;</decl_stmt>          <comment type="block">/* Name of vocabulary table language column */</comment>
  <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pRule</name></decl>;</decl_stmt>        <comment type="block">/* All active rules in this amatch */</comment>
  <decl_stmt><decl><type><name>amatch_cost</name></type> <name>rIns</name></decl>;</decl_stmt>          <comment type="block">/* Generic insertion cost  '' -&gt; ? */</comment>
  <decl_stmt><decl><type><name>amatch_cost</name></type> <name>rDel</name></decl>;</decl_stmt>          <comment type="block">/* Generic deletion cost  ? -&gt; '' */</comment>
  <decl_stmt><decl><type><name>amatch_cost</name></type> <name>rSub</name></decl>;</decl_stmt>          <comment type="block">/* Generic substitution cost ? -&gt; ? */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pVCheck</name></decl>;</decl_stmt>     <comment type="block">/* Query to check zVocabTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCursor</name></decl>;</decl_stmt>               <comment type="block">/* Number of active cursors */</comment>
}</block>;</struct>

<comment type="block">/* A amatch cursor object */</comment>
<struct>struct <name>amatch_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>      <comment type="block">/* The rowid of the current word */</comment>
  <decl_stmt><decl><type><name>amatch_langid</name></type> <name>iLang</name></decl>;</decl_stmt>       <comment type="block">/* Use this language ID */</comment>
  <decl_stmt><decl><type><name>amatch_cost</name></type> <name>rLimit</name></decl>;</decl_stmt>        <comment type="block">/* Maximum cost of any term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name></decl>;</decl_stmt>                  <comment type="block">/* Space allocated for zBuf */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>oomErr</name></decl>;</decl_stmt>                <comment type="block">/* True following an OOM error */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWord</name></decl>;</decl_stmt>                 <comment type="block">/* Number of amatch_word objects */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>                <comment type="block">/* Temp-use buffer space */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zInput</name></decl>;</decl_stmt>              <comment type="block">/* Input word to match against */</comment>
  <decl_stmt><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>        <comment type="block">/* The virtual table this cursor belongs to */</comment>
  <decl_stmt><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pAllWords</name></decl>;</decl_stmt>    <comment type="block">/* List of all amatch_word objects */</comment>
  <decl_stmt><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pCurrent</name></decl>;</decl_stmt>     <comment type="block">/* Most recent solution */</comment>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pCost</name></decl>;</decl_stmt>         <comment type="block">/* amatch_word objects keyed by iCost */</comment>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pWord</name></decl>;</decl_stmt>         <comment type="block">/* amatch_word objects keyed by zWord */</comment>
}</block>;</struct>

<comment type="block">/*
** The two input rule lists are both sorted in order of increasing
** cost.  Merge them together into a single list, sorted by cost, and
** return a pointer to the head of that list.
*/</comment>
<function><type><specifier>static</specifier> <name>amatch_rule</name> <modifier>*</modifier></type><name>amatchMergeRules</name><parameter_list>(<parameter><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_rule</name></type> <name>head</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTail</name> <operator>=</operator>  <operator>&amp;</operator><name>head</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>rCost</name></name><operator>&lt;=</operator><name><name>pB</name><operator>-&gt;</operator><name>rCost</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name><name>head</name><operator>.</operator><name>pNext</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Statement pStmt currently points to a row in the amatch data table. This
** function allocates and populates a amatch_rule structure according to
** the content of the row.
**
** If successful, *ppRule is set to point to the new object and SQLITE_OK
** is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
** to an error message and an SQLite error code returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchLoadOneRule</name><parameter_list>(
  <parameter><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                 <comment type="block">/* Fuzzer virtual table handle */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,            <comment type="block">/* Base rule on statements current row */</comment>
  <parameter><decl><type><name>amatch_rule</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRule</name></decl></parameter>,           <comment type="block">/* OUT: New rule object */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLang</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTo</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_cost</name></type> <name>rCost</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFrom</name></decl>;</decl_stmt>                      <comment type="block">/* Size of string zFrom, in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTo</name></decl>;</decl_stmt>                        <comment type="block">/* Size of string zTo, in bytes */</comment>
  <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pRule</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* New rule object to return */</comment>

  <if_stmt><if>if<condition>( <expr><name>zFrom</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zFrom</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zTo</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nFrom</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Silently ignore null transformations */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>zTo</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>zFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <name><name>zFrom</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rSub</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rSub</name></name><operator>&gt;</operator><name>rCost</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rSub</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppRule</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rCost</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>rCost</name><operator>&gt;</operator><name>AMATCH_MX_COST</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: cost must be between 1 and %d"</literal></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>AMATCH_MX_COST</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><name>nFrom</name><operator>&gt;</operator><name>AMATCH_MX_LENGTH</name> <operator>||</operator> <name>nTo</name><operator>&gt;</operator><name>AMATCH_MX_LENGTH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: maximum string length is %d"</literal></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>AMATCH_MX_LENGTH</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>    
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><name><name>iLang</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>iLang</name></expr></argument>&gt;</argument_list></name><name>AMATCH_MX_LANGID</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: iLang must be between 0 and %d"</literal></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>AMATCH_MX_LANGID</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>    
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>zTo</name></expr></argument>,<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rIns</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rIns</name></name><operator>&gt;</operator><name>rCost</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rIns</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>,<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>zTo</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rDel</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rDel</name></name><operator>&gt;</operator><name>rCost</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rDel</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else
  <block>{<block_content>
    <expr_stmt><expr><name>pRule</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRule</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nFrom</name> <operator>+</operator> <name>nTo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRule</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRule</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>zFrom</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRule</name><operator>-&gt;</operator><name>zTo</name><index>[<expr><name>nTo</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name> <operator>=</operator> <operator>(</operator><name>amatch_len</name><operator>)</operator><name>nFrom</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zFrom</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nFrom</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><name>zTo</name></expr></argument>, <argument><expr><name>nTo</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>nTo</name></name> <operator>=</operator> <operator>(</operator><name>amatch_len</name><operator>)</operator><name>nTo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>rCost</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>iLang</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>iLang</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppRule</name> <operator>=</operator> <name>pRule</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all the content in the edit-cost-table
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchFreeRules</name><parameter_list>(<parameter><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pRule</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <name><name>pRule</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Load the content of the amatch data table into memory.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchLoadRules</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                 <comment type="block">/* Virtual amatch table to configure */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                     <comment type="block">/* SELECT used to read from rules table */</comment>
  <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pHead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM %Q.%Q"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>                      <comment type="block">/* finalize() return code */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: %s has %d columns, expected 4"</literal></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTab</name></name></expr></argument>, <argument><expr><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pRule</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>amatchLoadOneRule</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRule</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pRule</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pHead</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pHead</name> <operator>=</operator> <name>pRule</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All rules are now in a singly linked list starting at pHead. This
  ** block sorts them by cost and then sets amatch_vtab.pRule to point to 
  ** point to the head of the sorted list.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <while>while<condition>( <expr><operator>(</operator><name>pX</name> <operator>=</operator> <name>pHead</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pHead</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>amatchMergeRules</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>amatchMergeRules</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>amatchMergeRules</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <call><name>amatchMergeRules</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* An error has occurred. Setting p-&gt;pRule to point to the head of the
    ** allocated list ensures that the list will be cleaned up in this case.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <name>pHead</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function converts an SQL quoted string into an unquoted string
** and returns a pointer to a buffer allocated using sqlite3_malloc() 
** containing the result. The caller should eventually free this buffer
** using sqlite3_free.
**
** Examples:
**
**     "abc"   becomes   abc
**     'xyz'   becomes   xyz
**     [pqr]   becomes   pqr
**     `mno`   becomes   mno
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>amatchDequote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nIn</name></decl>;</decl_stmt>              <comment type="block">/* Size of input string, in bytes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>                     <comment type="block">/* Output (dequoted) string */</comment>

  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nIn</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Quote character (if any ) */</comment>

    <if_stmt><if>if<condition>( <expr><name>q</name><operator>!=</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator><literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator><literal type="char">'`'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nIn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Index of next byte to write to output */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iIn</name></decl>;</decl_stmt>                    <comment type="block">/* Index of next byte to read from input */</comment>

      <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><name>nIn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate the pVCheck prepared statement.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchVCheckClear</name><parameter_list>(<parameter><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate an amatch_vtab object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchFree</name><parameter_list>(<parameter><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>amatchFreeRules</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>amatchVCheckClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabLang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSelf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xDisconnect/xDestroy method for the amatch module.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>amatch_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>amatchFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the argument is of the form:
**
**       KEY = VALUE
**
** If it is, return a pointer to the first character of VALUE.
** If not, return NULL.  Spaces around the = are ignored.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>amatchValueOfKey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nStr</name><operator>&lt;</operator><name>nKey</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nKey</name></expr>;</init> <condition><expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'='</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><name>zStr</name><operator>+</operator><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xConnect/xCreate method for the amatch module. Arguments are:
**
**   argv[0]    -&gt; module name  ("approximate_match")
**   argv[1]    -&gt; database name
**   argv[2]    -&gt; table name
**   argv[3...] -&gt; arguments
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* New virtual table */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zModule</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pAux</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zClassName</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zClassName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>amatchConnectError</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zDb</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>amatchConnectError</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zSelf</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zSelf</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>amatchConnectError</name>;</goto></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>amatchValueOfKey</name><argument_list>(<argument><expr><literal type="string">"vocabulary_table"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabTab</name></name> <operator>=</operator> <call><name>amatchDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>amatchConnectError</name>;</goto></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>amatchValueOfKey</name><argument_list>(<argument><expr><literal type="string">"vocabulary_word"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabWord</name></name> <operator>=</operator> <call><name>amatchDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabWord</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>amatchConnectError</name>;</goto></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>amatchValueOfKey</name><argument_list>(<argument><expr><literal type="string">"vocabulary_language"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabLang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabLang</name></name> <operator>=</operator> <call><name>amatchDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zVocabLang</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>amatchConnectError</name>;</goto></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>amatchValueOfKey</name><argument_list>(<argument><expr><literal type="string">"edit_distances"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zCostTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zCostTab</name></name> <operator>=</operator> <call><name>amatchDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zCostTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>amatchConnectError</name>;</goto></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"unrecognized argument: [%s]\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>amatchFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zCostTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no edit_distances table specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>amatchLoadRules</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
           <argument><expr><literal type="string">"CREATE TABLE x(word,distance,language,"</literal>
           <literal type="string">"command HIDDEN,nword HIDDEN)"</literal></expr></argument>
         )</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_COL_WORD</name></cpp:macro>       <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_COL_DISTANCE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_COL_LANGUAGE</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_COL_COMMAND</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMATCH_COL_NWORD</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>amatchFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>

<label><name>amatchConnectError</name>:</label>
  <expr_stmt><expr><call><name>amatchFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new amatch cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>amatch_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free up all the memory allocated by a cursor.  Set it rLimit to 0
** to indicate that it is at EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchClearCursor</name><parameter_list>(<parameter><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pWord</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNextWord</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pWord</name><operator>=</operator><name><name>pCur</name><operator>-&gt;</operator><name>pAllWords</name></name></expr>;</init> <condition><expr><name>pWord</name></expr>;</condition> <incr><expr><name>pWord</name><operator>=</operator><name>pNextWord</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNextWord</name> <operator>=</operator> <name><name>pWord</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pAllWords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pWord</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLang</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nWord</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a amatch cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>amatch_cursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>amatchClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nCursor</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Render a 24-bit unsigned integer as a 4-byte base-64 number.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchEncodeInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>a</name><index>[]</index></name> <init>= 
    <expr><literal type="string">"0123456789"</literal>
    <literal type="string">"ABCDEFGHIJ"</literal>
    <literal type="string">"KLMNOPQRST"</literal>
    <literal type="string">"UVWXYZ^abc"</literal>
    <literal type="string">"defghijklm"</literal>
    <literal type="string">"nopqrstuvw"</literal>
    <literal type="string">"xyz~"</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">18</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><name>x</name><operator>&amp;</operator><literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write the zCost[] field for a amatch_word object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchWriteCost</name><parameter_list>(<parameter><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pWord</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>amatchEncodeInt</name><argument_list>(<argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>amatchEncodeInt</name><argument_list>(<argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>iSeq</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zCost</name></name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>zCost</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Circumvent compiler warnings about the use of strcpy() by supplying
** our own implementation.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchStrcpy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>dest</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>src</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content/>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchStrcat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><operator>*</operator><name>dest</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dest</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>amatchStrcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add a new amatch_word object to the queue.
**
** If a prior amatch_word object with the same zWord, and nMatch
** already exists, update its rCost (if the new rCost is less) but
** otherwise leave it unchanged.  Do not add a duplicate.
**
** Do nothing if the cost exceeds threshold.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>amatchAddWord</name><parameter_list>(
  <parameter><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,
  <parameter><decl><type><name>amatch_cost</name></type> <name>rCost</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nMatch</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWordBase</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWordTail</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pWord</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pOther</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBase</name></decl>, <decl><type ref="prev"/><name>nTail</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rCost</name><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nBase</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zWordBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTail</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zWordTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nBase</name><operator>+</operator><name>nTail</name><operator>+</operator><literal type="number">3</literal><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>nBase</name><operator>+</operator><name>nTail</name><operator>+</operator><literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>amatchEncodeInt</name><argument_list>(<argument><expr><name>nMatch</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name>zBuf</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>zWordBase</name></expr></argument>, <argument><expr><name>nBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nBase</name></expr></argument>, <argument><expr><name>zWordTail</name></expr></argument>, <argument><expr><name>nTail</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>amatchAvlSearch</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pWord</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pWord</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pWord</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name><operator>&gt;</operator><name>rCost</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMATCH_TRACE_1</name></cpp:ifdef>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"UPDATE [%s][%.*s^%s] %d (\"%s\" \"%s\")\n"</literal></expr></argument>,
             <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name></expr></argument>,
             <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>amatchAvlRemove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pCost</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWord</name><operator>-&gt;</operator><name>sCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>amatchWriteCost</name><argument_list>(<argument><expr><name>pWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMATCH_TRACE_1</name></cpp:ifdef>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  ---&gt; %d (\"%s\" \"%s\")\n"</literal></expr></argument>,
             <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>pOther</name> <operator>=</operator> <call><name>amatchAvlInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pCost</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWord</name><operator>-&gt;</operator><name>sCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOther</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pOther</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pWord</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pWord</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nBase</name> <operator>+</operator> <name>nTail</name> <operator>-</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pWord</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pWord</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pWord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>iSeq</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nWord</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>amatchWriteCost</name><argument_list>(<argument><expr><name>pWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator><name>nMatch</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pAllWords</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pAllWords</name></name> <operator>=</operator> <name>pWord</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>sCost</name><operator>.</operator><name>zKey</name></name> <operator>=</operator> <name><name>pWord</name><operator>-&gt;</operator><name>zCost</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>sCost</name><operator>.</operator><name>pWord</name></name> <operator>=</operator> <name>pWord</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOther</name> <operator>=</operator> <call><name>amatchAvlInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pCost</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWord</name><operator>-&gt;</operator><name>sCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOther</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pOther</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>sWord</name><operator>.</operator><name>zKey</name></name> <operator>=</operator> <name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWord</name><operator>-&gt;</operator><name>sWord</name><operator>.</operator><name>pWord</name></name> <operator>=</operator> <name>pWord</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>amatchStrcpy</name><argument_list>(<argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOther</name> <operator>=</operator> <call><name>amatchAvlInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pWord</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWord</name><operator>-&gt;</operator><name>sWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOther</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pOther</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMATCH_TRACE_1</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"INSERT [%s][%.*s^%s] %d (\"%s\" \"%s\")\n"</literal></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,
       <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name><operator>+</operator><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr></argument>, <argument><expr><name>rCost</name></expr></argument>,
       <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
** Advance a cursor to its next row of output
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>amatch_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_word</name> <modifier>*</modifier></type><name>pWord</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_avl</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWord</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zW</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>amatch_rule</name> <modifier>*</modifier></type><name>pRule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>nBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zNext</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zNextIn</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNextIn</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zVocabLang</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>zVocabLang</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT \"%w\" FROM \"%w\""</literal></expr></argument>,
          <argument><expr><literal type="string">" WHERE \"%w\"&gt;=?1 AND \"%w\"=?2"</literal>
          <literal type="string">" ORDER BY 1"</literal></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabWord</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabTab</name></name></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabWord</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabLang</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT \"%w\" FROM \"%w\""</literal>
          <literal type="string">" WHERE \"%w\"&gt;=?1"</literal>
          <literal type="string">" ORDER BY 1"</literal></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabWord</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabTab</name></name></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zVocabWord</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <do>do<block>{<block_content>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>amatchAvlFirst</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pWord</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pWord</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pWord</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>amatchAvlRemove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pCost</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWord</name><operator>-&gt;</operator><name>sCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMATCH_TRACE_1</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"PROCESS [%s][%.*s^%s] %d (\"%s\" \"%s\")\n"</literal></expr></argument>,
       <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name><operator>+</operator><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr></argument>,
       <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>nWord</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nWord</name><operator>+</operator><literal type="number">20</literal><operator>&gt;</operator><name>nBuf</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>nWord</name><operator>+</operator><literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>amatchStrcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zNext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zNextIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zInput</name><index>[<expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zNextIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name><index>[<expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>zNextIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zInput</name><index>[<expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>zNextIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nNextIn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nNextIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>zNextIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zNextIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>amatchStrcat</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zNextIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nWord</name><operator>+</operator><name>nNextIn</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zW</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zW</name></expr></argument>, <argument><expr><name>nWord</name><operator>+</operator><name>nNextIn</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>amatchAddWord</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><name>nNextIn</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>nWord</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>amatchStrcpy</name><argument_list>(<argument><expr><name>zBuf</name><operator>+</operator><name>nWord</name></expr></argument>, <argument><expr><name>zNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>zW</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>amatchStrcpy</name><argument_list>(<argument><expr><name>zBuf</name><operator>+</operator><name>nWord</name></expr></argument>, <argument><expr><name>zNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zW</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nWord</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>zNextIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>zNextIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name><name>zNextIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zW</name><index>[<expr><name>nWord</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zNextIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNextIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zNext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zW</name><index>[<expr><name>nWord</name></expr>]</index></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zW</name><index>[<expr><name>nWord</name><operator>+</operator><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>zNext</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zW</name><index>[<expr><name>nWord</name><operator>+</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>zNext</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>nWord</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rIns</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>amatchAddWord</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>rIns</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr></argument>, 
                      <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rSub</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>amatchAddWord</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>rSub</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><name>nNextIn</name></expr></argument>, 
                      <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rIns</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rSub</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zNext</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* FIX ME */</comment>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rDel</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>nWord</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>amatchAddWord</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>rDel</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><name>nNextIn</name></expr></argument>,
                    <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>pRule</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name></expr>;</init> <condition><expr><name>pRule</name></expr>;</condition> <incr><expr><name>pRule</name><operator>=</operator><name><name>pRule</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pRule</name><operator>-&gt;</operator><name>iLang</name></name><operator>!=</operator><name><name>pCur</name><operator>-&gt;</operator><name>iLang</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zFrom</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name><operator>+</operator><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name></expr></argument>, <argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>amatchAddWord</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>rCost</name></name><operator>+</operator><name><name>pRule</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>,
                      <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name></expr></argument>, <argument><expr><name><name>pWord</name><operator>-&gt;</operator><name>zWord</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block>while<condition>( <expr><operator>!</operator><name>isMatch</name></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name>pWord</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Called to "rewind" a cursor back to the beginning so that
** it starts its output over again.  Always called at least once
** prior to any amatchColumn, amatchRowid, or amatchEof call.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>amatch_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWord</name> <init>= <expr><literal type="string">"*"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>amatchClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zWord</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name> <operator>=</operator> <operator>(</operator><name>amatch_cost</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLang</name></name> <operator>=</operator> <operator>(</operator><name>amatch_cost</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zInput</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>amatchAddWord</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>amatchNext</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Only the word and distance columns have values.  All other columns
** return NULL
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>amatch_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>AMATCH_COL_WORD</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>zWord</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AMATCH_COL_DISTANCE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AMATCH_COL_LANGUAGE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AMATCH_COL_NWORD</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The rowid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>amatch_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** EOF indicator
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>amatch_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search for terms of these forms:
**
**   (A)    word MATCH $str
**   (B1)   distance &lt; $value
**   (B2)   distance &lt;= $value
**   (C)    language == $language
**
** The distance&lt; and distance&lt;= are both treated as distance&lt;=.
** The query plan number is a bit vector:
**
**   bit 1:   Term of the form (A) found
**   bit 2:   Term like (B1) or (B2) found
**   bit 3:   Term like (C) found
**
** If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
** then $value is in filter.argv[0] if bit-1 is clear and is in 
** filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
** in filter.argv[0] if bit-1 and bit-2 are both zero, is in
** filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
** filter.argv[2] if both bit-1 and bit-2 are set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPlan</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDistTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLangTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>tab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">1</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name>
           <operator>||</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDistTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">4</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">2</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iLangTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iDistTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><operator>(</operator><name>iPlan</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iLangTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>iPlan</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>==</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iColumn</name><operator>==</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">10000</literal></expr>;</expr_stmt>
   
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xUpdate() method.  
**
** This implementation disallows DELETE and UPDATE.  The only thing
** allowed is INSERT into the "command" column.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>amatchUpdate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>amatch_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>amatch_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zCmd</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pRowid</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"DELETE from %s is not allowed"</literal></expr></argument>, 
                                      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSelf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"UPDATE of %s is not allowed"</literal></expr></argument>, 
                                      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSelf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name>AMATCH_COL_WORD</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name>
   <operator>||</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name>AMATCH_COL_DISTANCE</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name>
   <operator>||</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name>AMATCH_COL_LANGUAGE</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
            <argument><expr><literal type="string">"INSERT INTO %s allowed for column [command] only"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSelf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name>AMATCH_COL_COMMAND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCmd</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A virtual table module that implements the "approximate_match".
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>amatchModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* iVersion */</comment>
  <expr><name>amatchConnect</name></expr>,          <comment type="block">/* xCreate */</comment>
  <expr><name>amatchConnect</name></expr>,          <comment type="block">/* xConnect */</comment>
  <expr><name>amatchBestIndex</name></expr>,        <comment type="block">/* xBestIndex */</comment>
  <expr><name>amatchDisconnect</name></expr>,       <comment type="block">/* xDisconnect */</comment>
  <expr><name>amatchDisconnect</name></expr>,       <comment type="block">/* xDestroy */</comment>
  <expr><name>amatchOpen</name></expr>,             <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>amatchClose</name></expr>,            <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>amatchFilter</name></expr>,           <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>amatchNext</name></expr>,             <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>amatchEof</name></expr>,              <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>amatchColumn</name></expr>,           <comment type="block">/* xColumn - read data */</comment>
  <expr><name>amatchRowid</name></expr>,            <comment type="block">/* xRowid - read data */</comment>
  <expr><name>amatchUpdate</name></expr>,           <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRollbackTo */</comment>
  <expr><literal type="number">0</literal></expr>                       <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Register the amatch virtual table
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_amatch_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Not used */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"approximate_match"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amatchModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
