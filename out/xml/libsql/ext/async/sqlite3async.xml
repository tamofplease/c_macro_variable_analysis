<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/async/sqlite3async.c"><comment type="block">/*
** 2005 December 14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** $Id: sqlite3async.c,v 1.7 2009/07/18 11:52:04 danielk1977 Exp $
**
** This file contains the implementation of an asynchronous IO backend 
** for SQLite.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_ASYNCIO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Useful macros used in several places */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)&lt;(y)?(x):(y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)&gt;(y)?(x):(y))</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<comment type="block">/* Macro to mark parameters as unused and silence compiler warnings. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_PARAMETER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Forward references */</comment>
<typedef>typedef <type><name><name>struct</name> <name>AsyncWrite</name></name></type> <name>AsyncWrite</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>AsyncFile</name></name></type> <name>AsyncFile</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>AsyncFileData</name></name></type> <name>AsyncFileData</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>AsyncFileLock</name></name></type> <name>AsyncFileLock</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>AsyncLock</name></name></type> <name>AsyncLock</name>;</typedef>

<comment type="block">/* Enable for debugging */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3async_trace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_TRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if( sqlite3async_trace ) asyncTrace X</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asyncTrace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[%d] %s"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* (int)pthread_self() */</comment>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_TRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** THREAD SAFETY NOTES
**
** Basic rules:
**
**     * Both read and write access to the global write-op queue must be 
**       protected by the async.queueMutex. As are the async.ioError and
**       async.nFile variables.
**
**     * The async.pLock list and all AsyncLock and AsyncFileLock
**       structures must be protected by the async.lockMutex mutex.
**
**     * The file handles from the underlying system are not assumed to 
**       be thread safe.
**
**     * See the last two paragraphs under "The Writer Thread" for
**       an assumption to do with file-handle synchronization by the Os.
**
** Deadlock prevention:
**
**     There are three mutex used by the system: the "writer" mutex, 
**     the "queue" mutex and the "lock" mutex. Rules are:
**
**     * It is illegal to block on the writer mutex when any other mutex
**       are held, and 
**
**     * It is illegal to block on the queue mutex when the lock mutex
**       is held.
**
**     i.e. mutex's must be grabbed in the order "writer", "queue", "lock".
**
** File system operations (invoked by SQLite thread):
**
**     xOpen
**     xDelete
**     xFileExists
**
** File handle operations (invoked by SQLite thread):
**
**         asyncWrite, asyncClose, asyncTruncate, asyncSync 
**    
**     The operations above add an entry to the global write-op list. They
**     prepare the entry, acquire the async.queueMutex momentarily while
**     list pointers are  manipulated to insert the new entry, then release
**     the mutex and signal the writer thread to wake up in case it happens
**     to be asleep.
**
**    
**         asyncRead, asyncFileSize.
**
**     Read operations. Both of these read from both the underlying file
**     first then adjust their result based on pending writes in the 
**     write-op queue.   So async.queueMutex is held for the duration
**     of these operations to prevent other threads from changing the
**     queue in mid operation.
**    
**
**         asyncLock, asyncUnlock, asyncCheckReservedLock
**    
**     These primitives implement in-process locking using a hash table
**     on the file name.  Files are locked correctly for connections coming
**     from the same process.  But other processes cannot see these locks
**     and will therefore not honor them.
**
**
** The writer thread:
**
**     The async.writerMutex is used to make sure only there is only
**     a single writer thread running at a time.
**
**     Inside the writer thread is a loop that works like this:
**
**         WHILE (write-op list is not empty)
**             Do IO operation at head of write-op list
**             Remove entry from head of write-op list
**         END WHILE
**
**     The async.queueMutex is always held during the &lt;write-op list is 
**     not empty&gt; test, and when the entry is removed from the head
**     of the write-op list. Sometimes it is held for the interim
**     period (while the IO is performed), and sometimes it is
**     relinquished. It is relinquished if (a) the IO op is an
**     ASYNC_CLOSE or (b) when the file handle was opened, two of
**     the underlying systems handles were opened on the same
**     file-system entry.
**
**     If condition (b) above is true, then one file-handle 
**     (AsyncFile.pBaseRead) is used exclusively by sqlite threads to read the
**     file, the other (AsyncFile.pBaseWrite) by sqlite3_async_flush() 
**     threads to perform write() operations. This means that read 
**     operations are not blocked by asynchronous writes (although 
**     asynchronous writes may still be blocked by reads).
**
**     This assumes that the OS keeps two handles open on the same file
**     properly in sync. That is, any read operation that starts after a
**     write operation on the same file system entry has completed returns
**     data consistent with the write. We also assume that if one thread 
**     reads a file while another is writing it all bytes other than the
**     ones actually being written contain valid data.
**
**     If the above assumptions are not true, set the preprocessor symbol
**     SQLITE_ASYNC_TWO_FILEHANDLES to 0.
*/</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TESTONLY</name><parameter_list>( <parameter><type><name>X</name></type></parameter> )</parameter_list></cpp:macro> <cpp:value>X</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TESTONLY</name><parameter_list>( <parameter><type><name>X</name></type></parameter> )</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** PORTING FUNCTIONS
**
** There are two definitions of the following functions. One for pthreads
** compatible systems and one for Win32. These functions isolate the OS
** specific code required by each platform.
**
** The system uses three mutexes and a single condition variable. To
** block on a mutex, async_mutex_enter() is called. The parameter passed
** to async_mutex_enter(), which must be one of ASYNC_MUTEX_LOCK,
** ASYNC_MUTEX_QUEUE or ASYNC_MUTEX_WRITER, identifies which of the three
** mutexes to lock. Similarly, to unlock a mutex, async_mutex_leave() is
** called with a parameter identifying the mutex being unlocked. Mutexes
** are not recursive - it is an error to call async_mutex_enter() to
** lock a mutex that is already locked, or to call async_mutex_leave()
** to unlock a mutex that is not currently locked.
**
** The async_cond_wait() and async_cond_signal() functions are modelled
** on the pthreads functions with similar names. The first parameter to
** both functions is always ASYNC_COND_QUEUE. When async_cond_wait()
** is called the mutex identified by the second parameter must be held.
** The mutex is unlocked, and the calling thread simultaneously begins 
** waiting for the condition variable to be signalled by another thread.
** After another thread signals the condition variable, the calling
** thread stops waiting, locks mutex eMutex and returns. The 
** async_cond_signal() function is used to signal the condition variable. 
** It is assumed that the mutex used by the thread calling async_cond_wait() 
** is held by the caller of async_cond_signal() (otherwise there would be 
** a race condition).
**
** It is guaranteed that no other thread will call async_cond_wait() when
** there is already a thread waiting on the condition variable.
**
** The async_sched_yield() function is called to suggest to the operating
** system that it would be a good time to shift the current thread off the
** CPU. The system will still work if this function is not implemented
** (it is not currently implemented for win32), but it might be marginally
** more efficient if it is.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_mutex_enter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_mutex_leave</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_cond_wait</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eCond</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_cond_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eCond</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_sched_yield</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** There are also two definitions of the following. async_os_initialize()
** is called when the asynchronous VFS is first installed, and os_shutdown()
** is called when it is uninstalled (from within sqlite3async_shutdown()).
**
** For pthreads builds, both of these functions are no-ops. For win32,
** they provide an opportunity to initialize and finalize the required
** mutex and condition variables.
**
** If async_os_initialize() returns other than zero, then the initialization
** fails and SQLITE_ERROR is returned to the user.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>async_os_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_os_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Values for use as the 'eMutex' argument of the above functions. The
** integer values assigned to these constants are important for assert()
** statements that verify that mutexes are locked in the correct order.
** Specifically, it is unsafe to try to lock mutex N while holding a lock 
** on mutex M if (M&lt;=N).
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_MUTEX_LOCK</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_MUTEX_QUEUE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_MUTEX_WRITER</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Values for use as the 'eCond' argument of the above functions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_COND_QUEUE</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*************************************************************************
** Start of OS specific code.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<comment type="block">/* The following block contains the win32 specific code. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mutex_held</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(GetCurrentThreadId()==primitives.aHolder[X])</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct <name>AsyncPrimitives</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>isInit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name><name>aHolder</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CRITICAL_SECTION</name></type> <name><name>aMutex</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name><name>aCond</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>primitives</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>async_os_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>primitives</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>primitives</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_os_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>primitives</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>DeleteCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DeleteCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DeleteCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>primitives</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* The following block contains the Win32 specific code. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_mutex_enter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>!=</operator><literal type="number">2</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><name>eMutex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>primitives.aHolder[eMutex] = GetCurrentThreadId();</argument> )</argument_list></macro>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_mutex_leave</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>mutex_held</name><argument_list>(<argument><expr><name>eMutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>primitives.aHolder[eMutex] = <literal type="number">0</literal>;</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><name>eMutex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_cond_wait</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eCond</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>ResetEvent</name><argument_list>(<argument><expr><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><name>eCond</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>eMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><name>eCond</name></expr>]</index></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>eMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_cond_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eCond</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>mutex_held</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><name>eCond</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_sched_yield</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* The following block contains the pthreads specific code. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sched.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mutex_held</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_equal(primitives.aHolder[X], pthread_self())</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>  <name>async_os_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_os_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>

<struct><specifier>static</specifier> struct <name>AsyncPrimitives</name> <block>{
  <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name><name>aMutex</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_cond_t</name></type> <name><name>aCond</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name><name>aHolder</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>primitives</name> <init>= <expr><block>{
  <expr><block>{ <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, 
    <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, 
    <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>
  }</block></expr> , <expr><block>{
    <expr><name>PTHREAD_COND_INITIALIZER</name></expr>
  }</block></expr> , <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>async_mutex_enter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>!=</operator><literal type="number">2</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>mutex_held</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><name>eMutex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>primitives.aHolder[eMutex] = pthread_self();</argument> )</argument_list></macro>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_mutex_leave</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>mutex_held</name><argument_list>(<argument><expr><name>eMutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>primitives.aHolder[eMutex] = <literal type="number">0</literal>;</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><name>eMutex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_cond_wait</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eCond</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMutex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMutex</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eMutex</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>mutex_held</name><argument_list>(<argument><expr><name>eMutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>primitives.aHolder[eMutex] = <literal type="number">0</literal>;</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><name>eCond</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aMutex</name><index>[<expr><name>eMutex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>primitives.aHolder[eMutex] = pthread_self();</argument> )</argument_list></macro>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_cond_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eCond</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>mutex_held</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primitives</name><operator>.</operator><name>aCond</name><index>[<expr><name>eCond</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>async_sched_yield</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sched_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** End of OS specific code.
*************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert_mutex_is_held</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>assert( mutex_held(X) )</cpp:value></cpp:define>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ASYNC_TWO_FILEHANDLES</name></cpp:ifndef>
<comment type="block">/* #define SQLITE_ASYNC_TWO_FILEHANDLES 0 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ASYNC_TWO_FILEHANDLES</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** State information is held in the static variable "async" defined
** as the following structure.
**
** Both async.ioError and async.nFile are protected by async.queueMutex.
*/</comment>
<struct><specifier>static</specifier> struct <name>TestAsyncStaticData</name> <block>{
  <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>pQueueFirst</name></decl>;</decl_stmt>     <comment type="block">/* Next write operation to be processed */</comment>
  <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>pQueueLast</name></decl>;</decl_stmt>      <comment type="block">/* Last write operation on the list */</comment>
  <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>pLock</name></decl>;</decl_stmt>            <comment type="block">/* Linked list of all AsyncLock structures */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>ioDelay</name></decl>;</decl_stmt>        <comment type="block">/* Extra delay between write operations */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>eHalt</name></decl>;</decl_stmt>          <comment type="block">/* One of the SQLITEASYNC_HALT_XXX values */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>bLockFiles</name></decl>;</decl_stmt>     <comment type="block">/* Current value of "lockfiles" parameter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ioError</name></decl>;</decl_stmt>                 <comment type="block">/* True if an IO error has occurred */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFile</name></decl>;</decl_stmt>                   <comment type="block">/* Number of open files (from sqlite pov) */</comment>
}</block> <decl><name>async</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</struct>

<comment type="block">/* Possible values of AsyncWrite.op */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_NOOP</name></cpp:macro>          <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_WRITE</name></cpp:macro>         <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_SYNC</name></cpp:macro>          <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_TRUNCATE</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_CLOSE</name></cpp:macro>         <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_DELETE</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_OPENEXCLUSIVE</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASYNC_UNLOCK</name></cpp:macro>        <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/* Names of opcodes.  Used for debugging only.
** Make sure these stay in sync with the macros above!
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azOpcodeName</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"NOOP"</literal></expr>, <expr><literal type="string">"WRITE"</literal></expr>, <expr><literal type="string">"SYNC"</literal></expr>, <expr><literal type="string">"TRUNCATE"</literal></expr>, <expr><literal type="string">"CLOSE"</literal></expr>, <expr><literal type="string">"DELETE"</literal></expr>, <expr><literal type="string">"OPENEX"</literal></expr>, <expr><literal type="string">"UNLOCK"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Entries on the write-op queue are instances of the AsyncWrite
** structure, defined here.
**
** The interpretation of the iOffset and nByte variables varies depending 
** on the value of AsyncWrite.op:
**
** ASYNC_NOOP:
**     No values used.
**
** ASYNC_WRITE:
**     iOffset -&gt; Offset in file to write to.
**     nByte   -&gt; Number of bytes of data to write (pointed to by zBuf).
**
** ASYNC_SYNC:
**     nByte   -&gt; flags to pass to sqlite3OsSync().
**
** ASYNC_TRUNCATE:
**     iOffset -&gt; Size to truncate file to.
**     nByte   -&gt; Unused.
**
** ASYNC_CLOSE:
**     iOffset -&gt; Unused.
**     nByte   -&gt; Unused.
**
** ASYNC_DELETE:
**     iOffset -&gt; Contains the "syncDir" flag.
**     nByte   -&gt; Number of bytes of zBuf points to (file name).
**
** ASYNC_OPENEXCLUSIVE:
**     iOffset -&gt; Value of "delflag".
**     nByte   -&gt; Number of bytes of zBuf points to (file name).
**
** ASYNC_UNLOCK:
**     nByte   -&gt; Argument to sqlite3OsUnlock().
**
**
** For an ASYNC_WRITE operation, zBuf points to the data to write to the file. 
** This space is sqlite3_malloc()d along with the AsyncWrite structure in a
** single blob, so is deleted when sqlite3_free() is called on the parent 
** structure.
*/</comment>
<struct>struct <name>AsyncWrite</name> <block>{
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pFileData</name></decl>;</decl_stmt>    <comment type="block">/* File to write data to or sync */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                      <comment type="block">/* One of ASYNC_xxx etc. */</comment>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iOffset</name></decl>;</decl_stmt>        <comment type="block">/* See above */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>          <comment type="block">/* See above */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>         <comment type="block">/* Data to write to file (or NULL if op!=ASYNC_WRITE) */</comment>
  <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>  <comment type="block">/* Next write operation (to any file) */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of this structure is created for each distinct open file 
** (i.e. if two handles are opened on the one file, only one of these
** structures is allocated) and stored in the async.aLock hash table. The
** keys for async.aLock are the full pathnames of the opened files.
**
** AsyncLock.pList points to the head of a linked list of AsyncFileLock
** structures, one for each handle currently open on the file.
**
** If the opened file is not a main-database (the SQLITE_OPEN_MAIN_DB is
** not passed to the sqlite3OsOpen() call), or if async.bLockFiles is 
** false, variables AsyncLock.pFile and AsyncLock.eLock are never used. 
** Otherwise, pFile is a file handle opened on the file in question and 
** used to obtain the file-system locks required by database connections 
** within this process.
**
** See comments above the asyncLock() function for more details on 
** the implementation of database locking used by this backend.
*/</comment>
<struct>struct <name>AsyncLock</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eLock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileLock</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* Next in linked list headed by async.pLock */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of the following structure is allocated along with each
** AsyncFileData structure (see AsyncFileData.lock), but is only used if the
** file was opened with the SQLITE_OPEN_MAIN_DB.
*/</comment>
<struct>struct <name>AsyncFileLock</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>eLock</name></decl>;</decl_stmt>                <comment type="block">/* Internally visible lock state (sqlite pov) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eAsyncLock</name></decl>;</decl_stmt>           <comment type="block">/* Lock-state with write-queue unlock */</comment>
  <decl_stmt><decl><type><name>AsyncFileLock</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* 
** The AsyncFile structure is a subclass of sqlite3_file used for 
** asynchronous IO. 
**
** All of the actual data for the structure is stored in the structure
** pointed to by AsyncFile.pData, which is allocated as part of the
** sqlite3OsOpen() using sqlite3_malloc(). The reason for this is that the
** lifetime of the AsyncFile structure is ended by the caller after OsClose()
** is called, but the data in AsyncFileData may be required by the
** writer thread after that point.
*/</comment>
<struct>struct <name>AsyncFile</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>pMethod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>AsyncFileData</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>               <comment type="block">/* Underlying OS filename - used for debugging */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                 <comment type="block">/* Number of characters in zName */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pBaseRead</name></decl>;</decl_stmt>   <comment type="block">/* Read handle to the underlying Os file */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pBaseWrite</name></decl>;</decl_stmt>  <comment type="block">/* Write handle to the underlying Os file */</comment>
  <decl_stmt><decl><type><name>AsyncFileLock</name></type> <name>lock</name></decl>;</decl_stmt>        <comment type="block">/* Lock state for this handle */</comment>
  <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>pLock</name></decl>;</decl_stmt>          <comment type="block">/* AsyncLock object for this file system entry */</comment>
  <decl_stmt><decl><type><name>AsyncWrite</name></type> <name>closeOp</name></decl>;</decl_stmt>        <comment type="block">/* Preallocated close operation */</comment>
}</block>;</struct>

<comment type="block">/*
** Add an entry to the end of the global write-op list. pWrite should point 
** to an AsyncWrite structure allocated using sqlite3_malloc().  The writer
** thread will call sqlite3_free() to free the structure after the specified
** operation has been completed.
**
** Once an AsyncWrite structure has been added to the list, it becomes the
** property of the writer thread and must not be read or modified by the
** caller.  
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addAsyncWrite</name><parameter_list>(<parameter><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* We must hold the queue mutex in order to modify the queue pointers */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>ASYNC_UNLOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Add the record to the end of the write-op queue */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pWrite</name><operator>-&gt;</operator><name>pNext</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>pQueueLast</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>async</name><operator>.</operator><name>pQueueLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pWrite</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name> <operator>=</operator> <name>pWrite</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>async</name><operator>.</operator><name>pQueueLast</name></name> <operator>=</operator> <name>pWrite</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"PUSH %p (%s %s %d)\n"</literal><operator>,</operator> <name>pWrite</name><operator>,</operator> <name><name>azOpcodeName</name><index>[<expr><name><name>pWrite</name><operator>-&gt;</operator><name>op</name></name></expr>]</index></name><operator>,</operator>
         <ternary><condition><expr><name><name>pWrite</name><operator>-&gt;</operator><name>pFileData</name></name></expr> ?</condition><then> <expr><name><name>pWrite</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary><operator>,</operator> <name><name>pWrite</name><operator>-&gt;</operator><name>iOffset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_CLOSE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>async</name><operator>.</operator><name>nFile</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The writer thread might have been idle because there was nothing
  ** on the write-op queue for it to do.  So wake it up. */</comment>
  <expr_stmt><expr><call><name>async_cond_signal</name><argument_list>(<argument><expr><name>ASYNC_COND_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Drop the queue mutex */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>ASYNC_UNLOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Increment async.nFile in a thread-safe manner.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>incrOpenFileCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* We must hold the queue mutex in order to modify async.nFile */</comment>
  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>nFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>async</name><operator>.</operator><name>ioError</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>async</name><operator>.</operator><name>nFile</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is a utility function to allocate and populate a new AsyncWrite
** structure and insert it (via addAsyncWrite() ) into the global list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addNewAsyncWrite</name><parameter_list>(
  <parameter><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pFileData</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOffset</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zByte</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>ASYNC_CLOSE</name> <operator>&amp;&amp;</operator> <name><name>async</name><operator>.</operator><name>ioError</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>async</name><operator>.</operator><name>ioError</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncWrite</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>zByte</name></expr>?</condition><then><expr><name>nByte</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The upper layer does not expect operations like OsWrite() to
    ** return SQLITE_NOMEM. This is partly because under normal conditions
    ** SQLite is required to do rollback without calling malloc(). So
    ** if malloc() fails here, treat it as an I/O error. The above
    ** layer knows how to handle that.
    */</comment>
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <name>iOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFileData</name></name> <operator>=</operator> <name>pFileData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zByte</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name>zByte</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>addAsyncWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close the file. This just adds an entry to the write-op list, the file is
** not actually closed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Unlock the file, if it is locked */</comment>
  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>addAsyncWrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>closeOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of sqlite3OsWrite() for asynchronous files. Instead of 
** writing to the underlying file, this function adds an entry to the end of
** the global AsyncWrite list. Either SQLITE_OK or SQLITE_NOMEM may be
** returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>amt</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>addNewAsyncWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ASYNC_WRITE</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read data from the file. First we read from the filesystem, then adjust 
** the contents of the buffer based on ASYNC_WRITE operations in the 
** write-op queue.
**
** This method holds the mutex from start to finish.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOffset</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>filesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pBase</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBaseRead</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iAmt64</name> <init>= <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>iAmt</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Grab the write queue mutex for the duration of the call */</comment>
  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If an I/O error has previously occurred in this virtual file 
  ** system, then all subsequent operations fail.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>ioError</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>async</name><operator>.</operator><name>ioError</name></name></expr>;</expr_stmt>
    <goto>goto <name>asyncread_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nRead</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pBase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>asyncread_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nRead</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>filesize</name> <operator>-</operator> <name>iOffset</name></expr></argument>, <argument><expr><name>iAmt64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nRead</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pBase</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nRead</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ %s %d bytes at %d\n"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name>nRead</name><operator>,</operator> <name>iOffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>pWrite</name><operator>=</operator><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name></expr>;</init> <condition><expr><name>pWrite</name></expr>;</condition> <incr><expr><name>pWrite</name> <operator>=</operator> <name><name>pWrite</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_WRITE</name> <operator>&amp;&amp;</operator> <operator>(</operator>
        <operator>(</operator><name><name>pWrite</name><operator>-&gt;</operator><name>pFileData</name></name><operator>==</operator><name>p</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>zName</name> <operator>&amp;&amp;</operator> <name><name>pWrite</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>zName</name><operator>)</operator>
      <operator>)</operator></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nCopy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte64</name> <init>= <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pWrite</name><operator>-&gt;</operator><name>nByte</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Set variable iBeginIn to the offset in buffer pWrite-&gt;zBuf[] from
        ** which data should be copied. Set iBeginOut to the offset within
        ** the output buffer to which data should be copied. If either of
        ** these offsets is a negative number, set them to 0.
        */</comment>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iBeginOut</name> <init>= <expr><operator>(</operator><name><name>pWrite</name><operator>-&gt;</operator><name>iOffset</name></name><operator>-</operator><name>iOffset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iBeginIn</name> <init>= <expr><operator>-</operator><name>iBeginOut</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>iBeginIn</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iBeginIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iBeginOut</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iBeginOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>filesize</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>filesize</name></expr></argument>, <argument><expr><name><name>pWrite</name><operator>-&gt;</operator><name>iOffset</name></name><operator>+</operator><name>nByte64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>nByte64</name><operator>-</operator><name>iBeginIn</name></expr></argument>, <argument><expr><name>iAmt64</name><operator>-</operator><name>iBeginOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nCopy</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zOut</name><operator>)</operator><index>[<expr><name>iBeginOut</name></expr>]</index></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWrite</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name>iBeginIn</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OVERREAD %d bytes at %d\n"</literal><operator>,</operator> <name>nCopy</name><operator>,</operator> <name>iBeginOut</name><operator>+</operator><name>iOffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

<label><name>asyncread_out</name>:</label>
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>filesize</name><operator>&lt;</operator><operator>(</operator><name>iOffset</name><operator>+</operator><name>iAmt</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_SHORT_READ</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate the file to nByte bytes in length. This just adds an entry to 
** the write-op list, no IO actually takes place.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>addNewAsyncWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ASYNC_TRUNCATE</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sync the file. This just adds an entry to the write-op list, the 
** sync() is done later by sqlite3_async_flush().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>addNewAsyncWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ASYNC_SYNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read the size of the file. First we read the size of the file system 
** entry, then adjust for any ASYNC_WRITE or ASYNC_TRUNCATE operations 
** currently in the write-op list. 
**
** This method holds the mutex from start to finish.
*/</comment>
<function><type><name>int</name></type> <name>asyncFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pBase</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the filesystem size from the base file. If pMethods is NULL, this
  ** means the file hasn't been opened yet. In this case all relevant data 
  ** must be in the write-op queue anyway, so we can omit reading from the
  ** file-system.
  */</comment>
  <expr_stmt><expr><name>pBase</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBaseRead</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pBase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pWrite</name><operator>=</operator><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name></expr>;</init> <condition><expr><name>pWrite</name></expr>;</condition> <incr><expr><name>pWrite</name> <operator>=</operator> <name><name>pWrite</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_DELETE</name> 
       <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>zName</name></name> 
       <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pWrite</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>pFileData</name></name> <operator>&amp;&amp;</operator> <operator>(</operator>
          <operator>(</operator><name><name>pWrite</name><operator>-&gt;</operator><name>pFileData</name></name><operator>==</operator><name>p</name><operator>)</operator> 
       <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>zName</name></name> <operator>&amp;&amp;</operator> <name><name>pWrite</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator> 
      <operator>)</operator></expr>)</condition><block>{<block_content>
        <switch>switch<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
          <case>case <expr><name>ASYNC_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>pWrite</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>+</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name><name>pWrite</name><operator>-&gt;</operator><name>nByte</name></name><operator>)</operator></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><name>ASYNC_TRUNCATE</name></expr>:</case>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>pWrite</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>piSize</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock or unlock the actual file-system entry.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getFileLock</name><parameter_list>(<parameter><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>pLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileLock</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eRequired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>pLock</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>eAsyncLock</name></name><operator>&gt;=</operator><name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>eAsyncLock</name></name><operator>&gt;</operator><name>eRequired</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eRequired</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eAsyncLock</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>eRequired</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eRequired</name><operator>&lt;=</operator><name>SQLITE_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>eRequired</name><operator>&gt;</operator><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>eRequired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <name>eRequired</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>eRequired</name><operator>&lt;</operator><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name> <operator>&amp;&amp;</operator> <name>eRequired</name><operator>&lt;=</operator><name>SQLITE_LOCK_SHARED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>eRequired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <name>eRequired</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the AsyncLock structure from the global async.pLock list 
** associated with the file-system entry identified by path zName 
** (a string of nName bytes). If no such structure exists, return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>AsyncLock</name> <modifier>*</modifier></type><name>findLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>async</name><operator>.</operator><name>pLock</name></name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nFile</name></name><operator>!=</operator><name>nName</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following two methods - asyncLock() and asyncUnlock() - are used
** to obtain and release locks on database files opened with the
** asynchronous backend.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name><operator>&lt;</operator><name>eLock</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>pLock</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pLock</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>AsyncFileLock</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pLock</name> <operator>&amp;&amp;</operator> <name><name>pLock</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>pLock</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pIter</name><operator>!=</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>lock</name></name> <operator>&amp;&amp;</operator> <operator>(</operator>
          <operator>(</operator><name>eLock</name><operator>==</operator><name>SQLITE_LOCK_EXCLUSIVE</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SQLITE_LOCK_SHARED</name><operator>)</operator> <operator>||</operator>
          <operator>(</operator><name>eLock</name><operator>==</operator><name>SQLITE_LOCK_PENDING</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SQLITE_LOCK_RESERVED</name><operator>)</operator> <operator>||</operator>
          <operator>(</operator><name>eLock</name><operator>==</operator><name>SQLITE_LOCK_RESERVED</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SQLITE_LOCK_RESERVED</name><operator>)</operator> <operator>||</operator>
          <operator>(</operator><name>eLock</name><operator>==</operator><name>SQLITE_LOCK_SHARED</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SQLITE_LOCK_PENDING</name><operator>)</operator>
        <operator>)</operator></expr>)</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name> <operator>=</operator> <name>eLock</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eAsyncLock</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eAsyncLock</name></name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eAsyncLock</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getFileLock</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK %d (%s) rc=%d\n"</literal><operator>,</operator> <name>eLock</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name>rc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>AsyncFileLock</name> <modifier>*</modifier></type><name>pLock</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>eLock</name></name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>addNewAsyncWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ASYNC_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when the pager layer first opens a database file
** and is checking for a hot-journal.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileLock</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>pData</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLock</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SQLITE_LOCK_RESERVED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CHECK-LOCK %d (%s)\n"</literal><operator>,</operator> <name>ret</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** sqlite3_file_control() implementation.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FCNTL_LOCKSTATE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AsyncFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return the device characteristics and sector-size of the device. It
** is tricky to implement these correctly, as this backend might 
** not have an open file handle at this point.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">512</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>unlinkAsyncFile</name><parameter_list>(<parameter><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AsyncFileLock</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>pLock</name> <init>= <expr><name><name>pData</name><operator>-&gt;</operator><name>pLock</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ppIter</name><operator>=</operator><operator>&amp;</operator><name><name>pLock</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ppIter</name></expr>;</condition> <incr><expr><name>ppIter</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>ppIter</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>ppIter</name><operator>)</operator><operator>==</operator><operator>&amp;</operator><name><name>pData</name><operator>-&gt;</operator><name>lock</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppIter</name> <operator>=</operator> <name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pLock</name><operator>-&gt;</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>async</name><operator>.</operator><name>pLock</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pLock</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pLock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getFileLock</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The parameter passed to this function is a copy of a 'flags' parameter
** passed to this modules xOpen() method. This function returns true
** if the file should be opened asynchronously, or false if it should
** be opened immediately.
**
** If the file is to be opened asynchronously, then asyncOpen() will add
** an entry to the event queue and the file will not actually be opened
** until the event is processed. Otherwise, the file is opened directly
** by the caller.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>doAsynchronousOpen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_CREATE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator>
      <operator>(</operator><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_TEMP_JOURNAL</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_DELETEONCLOSE</name><operator>)</operator>
  <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_io_methods</name></type> <name>async_methods</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,                               <comment type="block">/* iVersion */</comment>
    <expr><name>asyncClose</name></expr>,                      <comment type="block">/* xClose */</comment>
    <expr><name>asyncRead</name></expr>,                       <comment type="block">/* xRead */</comment>
    <expr><name>asyncWrite</name></expr>,                      <comment type="block">/* xWrite */</comment>
    <expr><name>asyncTruncate</name></expr>,                   <comment type="block">/* xTruncate */</comment>
    <expr><name>asyncSync</name></expr>,                       <comment type="block">/* xSync */</comment>
    <expr><name>asyncFileSize</name></expr>,                   <comment type="block">/* xFileSize */</comment>
    <expr><name>asyncLock</name></expr>,                       <comment type="block">/* xLock */</comment>
    <expr><name>asyncUnlock</name></expr>,                     <comment type="block">/* xUnlock */</comment>
    <expr><name>asyncCheckReservedLock</name></expr>,          <comment type="block">/* xCheckReservedLock */</comment>
    <expr><name>asyncFileControl</name></expr>,                <comment type="block">/* xFileControl */</comment>
    <expr><name>asyncSectorSize</name></expr>,                 <comment type="block">/* xSectorSize */</comment>
    <expr><name>asyncDeviceCharacteristics</name></expr>       <comment type="block">/* xDeviceCharacteristics */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>AsyncFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncLock</name> <modifier>*</modifier></type><name>pLock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isAsyncOpen</name> <init>= <expr><call><name>doAsynchronousOpen</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If zName is NULL, then the upper layer is requesting an anonymous file.
  ** Otherwise, allocate enough space to make a copy of the file name (along
  ** with the second nul-terminator byte required by xOpen).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nName</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator>
    <sizeof>sizeof<argument_list>(<argument><expr><name>AsyncFileData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>        <comment type="block">/* AsyncFileData structure */</comment>
    <literal type="number">2</literal> <operator>*</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name> <operator>+</operator>           <comment type="block">/* AsyncFileData.pBaseRead and pBaseWrite */</comment>
    <name>nName</name> <operator>+</operator> <literal type="number">2</literal>                      <comment type="block">/* AsyncFileData.zName */</comment>
  <operator>)</operator></expr>;</expr_stmt> 
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>z</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>=</operator> <operator>(</operator><name>AsyncFileData</name><operator>*</operator><operator>)</operator><name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>+=</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>closeOp</name><operator>.</operator><name>pFileData</name></name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>closeOp</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>ASYNC_CLOSE</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>nName</name></name> <operator>=</operator> <name>nName</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isAsyncOpen</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flagsout</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>flagsout</name><operator>&amp;</operator><name>SQLITE_OPEN_READWRITE</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_EXCLUSIVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOutFlags</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pOutFlags</name> <operator>=</operator> <name>flagsout</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zName</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pLock</name> <operator>=</operator> <call><name>findLock</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>nName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pLock</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AsyncLock</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pData</name><operator>-&gt;</operator><name>nName</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> 
      <expr_stmt><expr><name>pLock</name> <operator>=</operator> <operator>(</operator><name>AsyncLock</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pLock</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>bLockFiles</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_MAIN_DB</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pLock</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pLock</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pLock</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>nFile</name></name> <operator>=</operator> <name><name>pData</name><operator>-&gt;</operator><name>nName</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>zFile</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>pLock</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator><index>[<expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr>]</index></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pLock</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>async</name><operator>.</operator><name>pLock</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>async</name><operator>.</operator><name>pLock</name></name> <operator>=</operator> <name>pLock</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <operator>&amp;</operator><name>async_methods</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>

    <comment type="block">/* Link AsyncFileData.lock into the linked list of 
    ** AsyncFileLock structures for this file.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name><name>pLock</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLock</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pData</name><operator>-&gt;</operator><name>lock</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name><name>pLock</name><operator>-&gt;</operator><name>zFile</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>pLock</name></name> <operator>=</operator> <name>pLock</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>isAsyncOpen</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>addNewAsyncWrite</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>ASYNC_OPENEXCLUSIVE</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>flags</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pOutFlags</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pOutFlags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unlinkAsyncFile</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>incrOpenFileCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of sqlite3OsDelete. Add an entry to the end of the 
** write-op queue to perform the delete.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>syncDir</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pAsyncVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>addNewAsyncWrite</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ASYNC_DELETE</name></expr></argument>, <argument><expr><name>syncDir</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of sqlite3OsAccess. This method holds the mutex from
** start to finish.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncAccess</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READWRITE</name> 
      <operator>||</operator> <name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READ</name> 
      <operator>||</operator> <name>flags</name><operator>==</operator><name>SQLITE_ACCESS_EXISTS</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>flags</name><operator>==</operator><name>SQLITE_ACCESS_EXISTS</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_DELETE</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_OPENEXCLUSIVE</name> 
             <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name>
             <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ACCESS(%s): %s = %d\n"</literal><operator>,</operator> 
    <ternary><condition><expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READWRITE</name></expr>?</condition><then><expr><literal type="string">"read-write"</literal></expr></then><else>:
    <expr><ternary><condition><expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READ</name></expr>?</condition><then><expr><literal type="string">"read"</literal></expr></then><else>:<expr><literal type="string">"exists"</literal></expr></else></ternary></expr></else></ternary>
    <operator>,</operator> <name>zName</name><operator>,</operator> <name>ret</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Fill in zPathOut with the full path to the file identified by zPath.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncFullPathname</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nPathOut</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zPathOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xFullPathname</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>nPathOut</name></expr></argument>, <argument><expr><name>zPathOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Because of the way intra-process file locking works, this backend
  ** needs to return a canonical path. The following block assumes the
  ** file-system uses unix style paths. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zPathOut</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">2</literal><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">3</literal><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
          <while>while<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
          <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>asyncDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xDlOpen</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asyncDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xDlError</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*asyncDlSym(
  sqlite3_vfs *pAsyncVfs, 
  void *pHandle, 
  const char *zSymbol
)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>)</operator><block>{
  <expr><name>sqlite3_vfs</name> <operator>*</operator><name>pVfs</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr>;
  <return>return <expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xDlSym</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>zSymbol</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asyncDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pHandle</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xDlClose</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBufOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xRandomness</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zBufOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMicro</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xSleep</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>nMicro</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asyncCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pAsyncVfs</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pTimeOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>pAsyncVfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pTimeOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_vfs</name></type> <name>async_vfs</name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>,                    <comment type="block">/* iVersion */</comment>
  <expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncFile</name></expr></argument>)</argument_list></sizeof></expr>,    <comment type="block">/* szOsFile */</comment>
  <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* mxPathname */</comment>
  <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* pNext */</comment>
  <expr><name>SQLITEASYNC_VFSNAME</name></expr>,  <comment type="block">/* zName */</comment>
  <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* pAppData */</comment>
  <expr><name>asyncOpen</name></expr>,            <comment type="block">/* xOpen */</comment>
  <expr><name>asyncDelete</name></expr>,          <comment type="block">/* xDelete */</comment>
  <expr><name>asyncAccess</name></expr>,          <comment type="block">/* xAccess */</comment>
  <expr><name>asyncFullPathname</name></expr>,    <comment type="block">/* xFullPathname */</comment>
  <expr><name>asyncDlOpen</name></expr>,          <comment type="block">/* xDlOpen */</comment>
  <expr><name>asyncDlError</name></expr>,         <comment type="block">/* xDlError */</comment>
  <expr><name>asyncDlSym</name></expr>,           <comment type="block">/* xDlSym */</comment>
  <expr><name>asyncDlClose</name></expr>,         <comment type="block">/* xDlClose */</comment>
  <expr><name>asyncRandomness</name></expr>,      <comment type="block">/* xDlError */</comment>
  <expr><name>asyncSleep</name></expr>,           <comment type="block">/* xDlSym */</comment>
  <expr><name>asyncCurrentTime</name></expr>      <comment type="block">/* xDlClose */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* 
** This procedure runs in a separate thread, reading messages off of the
** write queue and processing them one by one.  
**
** If async.writerHaltNow is true, then this procedure exits
** after processing a single message.
**
** If async.writerHaltWhenIdle is true, then this procedure exits when
** the write queue is empty.
**
** If both of the above variables are false, this procedure runs
** indefinately, waiting for operations to be added to the write queue
** and processing them in the order in which they arrive.
**
** An artifical delay of async.ioDelay milliseconds is inserted before
** each write operation in order to simulate the effect of a slow disk.
**
** Only one instance of this procedure may be running at a time.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asyncWriterThread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>async_vfs</name><operator>.</operator><name>pAppData</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>holdingMutex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name><name>async</name><operator>.</operator><name>eHalt</name></name><operator>!=</operator><name>SQLITEASYNC_HALT_NOW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>doNotFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pBase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>holdingMutex</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>async</name><operator>.</operator><name>pQueueFirst</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>eHalt</name></name><operator>!=</operator><name>SQLITEASYNC_HALT_NEVER</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"IDLE\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>async_cond_wait</name><argument_list>(<argument><expr><name>ASYNC_COND_QUEUE</name></expr></argument>, <argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAKEUP\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>holdingMutex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Right now this thread is holding the mutex on the write-op queue.
    ** Variable 'p' points to the first entry in the write-op queue. In
    ** the general case, we hold on to the mutex for the entire body of
    ** the loop. 
    **
    ** However in the cases enumerated below, we relinquish the mutex,
    ** perform the IO, and then re-request the mutex before removing 'p' from
    ** the head of the write-op queue. The idea is to increase concurrency with
    ** sqlite threads.
    **
    **     * An ASYNC_CLOSE operation.
    **     * An ASYNC_OPENEXCLUSIVE operation. For this one, we relinquish 
    **       the mutex, call the underlying xOpenExclusive() function, then
    **       re-aquire the mutex before seting the AsyncFile.pBaseRead 
    **       variable.
    **     * ASYNC_SYNC and ASYNC_WRITE operations, if 
    **       SQLITE_ASYNC_TWO_FILEHANDLES was set at compile time and two
    **       file-handles are open for the particular file being "synced".
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>ioError</name></name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>ASYNC_CLOSE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>ASYNC_NOOP</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFileData</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pBase</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>pBaseWrite</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( 
        <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_CLOSE</name> <operator>||</operator> 
        <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_OPENEXCLUSIVE</name> <operator>||</operator>
        <operator>(</operator><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_SYNC</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_WRITE</name><operator>)</operator> <operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>holdingMutex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pBase</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>pBaseRead</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>ASYNC_NOOP</name></expr>:</case>
        <break>break;</break>

      <case>case <expr><name>ASYNC_WRITE</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBase</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WRITE %s %d bytes at %d\n"</literal><operator>,</operator>
                <name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>nByte</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pBase</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>ASYNC_SYNC</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBase</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC %s\n"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pBase</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>ASYNC_TRUNCATE</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBase</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRUNCATE %s to %d bytes\n"</literal><operator>,</operator> 
                <name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBase</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pBase</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>ASYNC_CLOSE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFileData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CLOSE %s\n"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>pFileData</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Unlink AsyncFileData.lock from the linked list of AsyncFileLock 
        ** structures for this file. Obtain the async.lockMutex mutex 
        ** before doing so.
        */</comment>
        <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unlinkAsyncFile</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>holdingMutex</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>holdingMutex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert_mutex_is_held</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>doNotFree</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>ASYNC_UNLOCK</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>AsyncWrite</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFileData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eLock</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nByte</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* When a file is locked by SQLite using the async backend, it is 
        ** locked within the 'real' file-system synchronously. When it is
        ** unlocked, an ASYNC_UNLOCK event is added to the write-queue to
        ** unlock the file asynchronously. The design of the async backend
        ** requires that the 'real' file-system file be locked from the
        ** time that SQLite first locks it (and probably reads from it)
        ** until all asynchronous write events that were scheduled before
        ** SQLite unlocked the file have been processed.
        **
        ** This is more complex if SQLite locks and unlocks the file multiple
        ** times in quick succession. For example, if SQLite does: 
        ** 
        **   lock, write, unlock, lock, write, unlock
        **
        ** Each "lock" operation locks the file immediately. Each "write" 
        ** and "unlock" operation adds an event to the event queue. If the
        ** second "lock" operation is performed before the first "unlock"
        ** operation has been processed asynchronously, then the first
        ** "unlock" cannot be safely processed as is, since this would mean
        ** the file was unlocked when the second "write" operation is
        ** processed. To work around this, when processing an ASYNC_UNLOCK
        ** operation, SQLite:
        **
        **   1) Unlocks the file to the minimum of the argument passed to
        **      the xUnlock() call and the current lock from SQLite's point
        **      of view, and
        **
        **   2) Only unlocks the file at all if this event is the last
        **      ASYNC_UNLOCK event on this file in the write-queue.
        */</comment> 
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>holdingMutex</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>async</name><operator>.</operator><name>pQueueFirst</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>pFileData</name></name><operator>==</operator><name>pData</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>ASYNC_UNLOCK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pIter</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eAsyncLock</name></name> <operator>=</operator> <call><name>MIN</name><argument_list>(
              <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eAsyncLock</name></name></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eAsyncLock</name></name><operator>&gt;=</operator><name><name>pData</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>eLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getFileLock</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>ASYNC_DELETE</name></expr>:</case>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DELETE %s\n"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_DELETE_NOENT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>ASYNC_OPENEXCLUSIVE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AsyncFileData</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFileData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ASYNC_TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN %s flags=%d\n"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pData</name><operator>-&gt;</operator><name>pBaseWrite</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pBaseRead</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>holdingMutex</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>holdingMutex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <default>default:</default> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"Illegal value for AsyncWrite.op"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* If we didn't hang on to the mutex during the IO op, obtain it now
    ** so that the AsyncWrite structure can be safely removed from the 
    ** global write-op queue.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>holdingMutex</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>holdingMutex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* ASYNC_TRACE(("UNLINK %p\n", p)); */</comment>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name><name>async</name><operator>.</operator><name>pQueueLast</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>async</name><operator>.</operator><name>pQueueLast</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>doNotFree</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert_mutex_is_held</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>holdingMutex</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* An IO error has occurred. We cannot report the error back to the
    ** connection that requested the I/O since the error happened 
    ** asynchronously.  The connection has already moved on.  There 
    ** really is nobody to report the error to.
    **
    ** The file for which the error occurred may have been a database or
    ** journal file. Regardless, none of the currently queued operations
    ** associated with the same database should now be performed. Nor should
    ** any subsequently requested IO on either a database or journal file 
    ** handle for the same database be accepted until the main database
    ** file handle has been closed and reopened.
    **
    ** Furthermore, no further IO should be queued or performed on any file
    ** handle associated with a database that may have been part of a 
    ** multi-file transaction that included the database associated with 
    ** the IO error (i.e. a database ATTACHed to the same handle at some 
    ** point in time).
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>async</name><operator>.</operator><name>ioError</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>ioError</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>async</name><operator>.</operator><name>pLock</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>async</name><operator>.</operator><name>ioError</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Drop the queue mutex before continuing to the next write operation
    ** in order to give other threads a chance to work with the write queue.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>async</name><operator>.</operator><name>pQueueFirst</name></name> <operator>||</operator> <operator>!</operator><name><name>async</name><operator>.</operator><name>ioError</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>holdingMutex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>ioDelay</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xSleep</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>async</name><operator>.</operator><name>ioDelay</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>async_sched_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Install the asynchronous VFS.
*/</comment> 
<function><type><name>int</name></type> <name>sqlite3async_initialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isDefault</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>async_vfs</name><operator>.</operator><name>pAppData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name>zParent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pParent</name> <operator>||</operator> <call><name>async_os_initialize</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name>async_vfs</name></expr></argument>, <argument><expr><name>isDefault</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>async_os_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>async_vfs</name><operator>.</operator><name>pAppData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pParent</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>async_vfs</name><operator>.</operator><name>mxPathname</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><name><name>async_vfs</name><operator>.</operator><name>pAppData</name></name><operator>)</operator><operator>-&gt;</operator><name>mxPathname</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Uninstall the asynchronous VFS.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3async_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>async_vfs</name><operator>.</operator><name>pAppData</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>async_os_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_vfs_unregister</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_vfs</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>async_vfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>async_vfs</name><operator>.</operator><name>pAppData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Process events on the write-queue.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3async_run</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>asyncWriterThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Control/configure the asynchronous IO system.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3async_control</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITEASYNC_HALT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>eWhen</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eWhen</name><operator>!=</operator><name>SQLITEASYNC_HALT_NEVER</name>
       <operator>&amp;&amp;</operator> <name>eWhen</name><operator>!=</operator><name>SQLITEASYNC_HALT_NOW</name>
       <operator>&amp;&amp;</operator> <name>eWhen</name><operator>!=</operator><name>SQLITEASYNC_HALT_IDLE</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>async</name><operator>.</operator><name>eHalt</name></name> <operator>=</operator> <name>eWhen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>async_cond_signal</name><argument_list>(<argument><expr><name>ASYNC_COND_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITEASYNC_DELAY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDelay</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iDelay</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>async</name><operator>.</operator><name>ioDelay</name></name> <operator>=</operator> <name>iDelay</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITEASYNC_LOCKFILES</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bLock</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>async_mutex_enter</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>async</name><operator>.</operator><name>nFile</name></name> <operator>||</operator> <name><name>async</name><operator>.</operator><name>pQueueFirst</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>async</name><operator>.</operator><name>bLockFiles</name></name> <operator>=</operator> <name>bLock</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>async_mutex_leave</name><argument_list>(<argument><expr><name>ASYNC_MUTEX_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
      
    <case>case <expr><name>SQLITEASYNC_GET_HALT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>peWhen</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>peWhen</name> <operator>=</operator> <name><name>async</name><operator>.</operator><name>eHalt</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITEASYNC_GET_DELAY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piDelay</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>piDelay</name> <operator>=</operator> <name><name>async</name><operator>.</operator><name>ioDelay</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITEASYNC_GET_LOCKFILES</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piDelay</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>piDelay</name> <operator>=</operator> <name><name>async</name><operator>.</operator><name>bLockFiles</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_ASYNCIO) */</comment>
</unit>
