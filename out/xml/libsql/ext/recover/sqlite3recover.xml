<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/recover/sqlite3recover.c"><comment type="block">/*
** 2022-08-27
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
*/</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3recover.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Declaration for public API function in file dbdata.c. This may be called
** with NULL as the final two arguments to register the sqlite_dbptr and
** sqlite_dbdata virtual tables with a database handle.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type> <name>sqlite3_dbdata_init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<typedef>typedef <type><name>sqlite3_int64</name></type> <name>i64</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>RecoverTable</name></name></type> <name>RecoverTable</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RecoverColumn</name></name></type> <name>RecoverColumn</name>;</typedef>

<comment type="block">/*
** When recovering rows of data that can be associated with table
** definitions recovered from the sqlite_schema table, each table is
** represented by an instance of the following object.
**
** iRoot:
**   The root page in the original database. Not necessarily (and usually
**   not) the same in the recovered database.
**
** zTab:
**   Name of the table.
**
** nCol/aCol[]:
**   aCol[] is an array of nCol columns. In the order in which they appear 
**   in the table.
**
** bIntkey:
**   Set to true for intkey tables, false for WITHOUT ROWID.
**
** iRowidBind:
**   Each column in the aCol[] array has associated with it the index of
**   the bind parameter its values will be bound to in the INSERT statement
**   used to construct the output database. If the table does has a rowid
**   but not an INTEGER PRIMARY KEY column, then iRowidBind contains the
**   index of the bind paramater to which the rowid value should be bound.
**   Otherwise, it contains -1. If the table does contain an INTEGER PRIMARY 
**   KEY column, then the rowid value should be bound to the index associated
**   with the column.
**
** pNext:
**   All RecoverTable objects used by the recovery operation are allocated
**   and populated as part of creating the recovered database schema in
**   the output database, before any non-schema data are recovered. They
**   are then stored in a singly-linked list linked by this variable beginning
**   at sqlite3_recover.pTblList.
*/</comment>
<struct>struct <name>RecoverTable</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>iRoot</name></decl>;</decl_stmt>                      <comment type="block">/* Root page in original database */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>                     <comment type="block">/* Name of table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in table */</comment>
  <decl_stmt><decl><type><name>RecoverColumn</name> <modifier>*</modifier></type><name>aCol</name></decl>;</decl_stmt>            <comment type="block">/* Array of columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIntkey</name></decl>;</decl_stmt>                    <comment type="block">/* True for intkey, false for without rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowidBind</name></decl>;</decl_stmt>                 <comment type="block">/* If &gt;0, bind rowid to INSERT here */</comment>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Each database column is represented by an instance of the following object
** stored in the RecoverTable.aCol[] array of the associated table.
**
** iField:
**   The index of the associated field within database records. Or -1 if
**   there is no associated field (e.g. for virtual generated columns).
**
** iBind:
**   The bind index of the INSERT statement to bind this columns values
**   to. Or 0 if there is no such index (iff (iField&lt;0)).
**
** bIPK:
**   True if this is the INTEGER PRIMARY KEY column.
**
** zCol:
**   Name of column.
**
** eHidden:
**   A RECOVER_EHIDDEN_* constant value (see below for interpretation of each).
*/</comment>
<struct>struct <name>RecoverColumn</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iField</name></decl>;</decl_stmt>                     <comment type="block">/* Field in record on disk */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBind</name></decl>;</decl_stmt>                      <comment type="block">/* Binding to use in INSERT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIPK</name></decl>;</decl_stmt>                       <comment type="block">/* True for IPK column */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eHidden</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_NONE</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>      <comment type="block">/* Normal database column */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_HIDDEN</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>      <comment type="block">/* Column is __HIDDEN__ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_VIRTUAL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>      <comment type="block">/* Virtual generated column */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_STORED</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>      <comment type="block">/* Stored generated column */</comment>

<comment type="block">/*
** Bitmap object used to track pages in the input database. Allocated
** and manipulated only by the following functions:
**
**     recoverBitmapAlloc()
**     recoverBitmapFree()
**     recoverBitmapSet()
**     recoverBitmapQuery()
**
** nPg:
**   Largest page number that may be stored in the bitmap. The range
**   of valid keys is 1 to nPg, inclusive.
**
** aElem[]:
**   Array large enough to contain a bit for each key. For key value
**   iKey, the associated bit is the bit (iKey%32) of aElem[iKey/32].
**   In other words, the following is true if bit iKey is set, or 
**   false if it is clear:
**
**       (aElem[iKey/32] &amp; (1 &lt;&lt; (iKey%32))) ? 1 : 0
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverBitmap</name></name></type> <name>RecoverBitmap</name>;</typedef>
<struct>struct <name>RecoverBitmap</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name></decl>;</decl_stmt>                        <comment type="block">/* Size of bitmap */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aElem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>                   <comment type="block">/* Array of 32-bit bitmasks */</comment>
}</block>;</struct>

<comment type="block">/*
** State variables (part of the sqlite3_recover structure) used while
** recovering data for tables identified in the recovered schema (state
** RECOVER_STATE_WRITING).
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverStateW1</name></name></type> <name>RecoverStateW1</name>;</typedef>
<struct>struct <name>RecoverStateW1</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pTbls</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nInsert</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>             <comment type="block">/* Table currently being written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMax</name></decl>;</decl_stmt>                       <comment type="block">/* Max column count in any schema table */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl>;</decl_stmt>          <comment type="block">/* Array of nMax values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>                       <comment type="block">/* Number of valid entries in apVal[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHaveRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iPrevPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrevCell</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** State variables (part of the sqlite3_recover structure) used while
** recovering data destined for the lost and found table (states
** RECOVER_STATE_LOSTANDFOUND[123]).
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverStateLAF</name></name></type> <name>RecoverStateLAF</name>;</typedef>
<struct>struct <name>RecoverStateLAF</name> <block>{
  <decl_stmt><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pUsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name></decl>;</decl_stmt>                        <comment type="block">/* Size of db in pages */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllAndParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pMapInsert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pMaxField</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUsedPages</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pFindRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name></decl>;</decl_stmt>          <comment type="block">/* INSERT INTO lost_and_found ... */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pPageData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxField</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Main recover handle structure.
*/</comment>
<struct>struct <name>sqlite3_recover</name> <block>{
  <comment type="block">/* Copies of sqlite3_recover_init[_sql]() parameters */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbIn</name></decl>;</decl_stmt>                  <comment type="block">/* Input database */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                      <comment type="block">/* Name of input db ("main" etc.) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zUri</name></decl>;</decl_stmt>                     <comment type="block">/* URI for output database */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pSqlCtx</name></decl>;</decl_stmt>                  <comment type="block">/* SQL callback context */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSql</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Pointer to SQL callback function */</comment>

  <comment type="block">/* Values configured by sqlite3_recover_config() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStateDb</name></decl>;</decl_stmt>                 <comment type="block">/* State database to use (or NULL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLostAndFound</name></decl>;</decl_stmt>            <comment type="block">/* Name of lost-and-found table (or NULL) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFreelistCorrupt</name></decl>;</decl_stmt>           <comment type="block">/* SQLITE_RECOVER_FREELIST_CORRUPT setting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRecoverRowid</name></decl>;</decl_stmt>              <comment type="block">/* SQLITE_RECOVER_ROWIDS setting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSlowIndexes</name></decl>;</decl_stmt>               <comment type="block">/* SQLITE_RECOVER_SLOWINDEXES setting */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>detected_pgsz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nReserve</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPage1Disk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPage1Cache</name></decl>;</decl_stmt>

  <comment type="block">/* Error code and error message */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errCode</name></decl>;</decl_stmt>                    <comment type="block">/* For sqlite3_recover_errcode() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl>;</decl_stmt>                  <comment type="block">/* For sqlite3_recover_errmsg() */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>eState</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bCloseTransaction</name></decl>;</decl_stmt>

  <comment type="block">/* Variables used with eState==RECOVER_STATE_WRITING */</comment>
  <decl_stmt><decl><type><name>RecoverStateW1</name></type> <name>w1</name></decl>;</decl_stmt>

  <comment type="block">/* Variables used with states RECOVER_STATE_LOSTANDFOUND[123] */</comment>
  <decl_stmt><decl><type><name>RecoverStateLAF</name></type> <name>laf</name></decl>;</decl_stmt>

  <comment type="block">/* Fields used within sqlite3_recover_run() */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbOut</name></decl>;</decl_stmt>                 <comment type="block">/* Output database */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pGetPage</name></decl>;</decl_stmt>         <comment type="block">/* SELECT against input db sqlite_dbdata */</comment>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTblList</name></decl>;</decl_stmt>         <comment type="block">/* List of tables recovered from schema */</comment>
}</block>;</struct>

<comment type="block">/*
** The various states in which an sqlite3_recover object may exist:
**
**   RECOVER_STATE_INIT:
**    The object is initially created in this state. sqlite3_recover_step()
**    has yet to be called. This is the only state in which it is permitted
**    to call sqlite3_recover_config().
**
**   RECOVER_STATE_WRITING:
**
**   RECOVER_STATE_LOSTANDFOUND1:
**    State to populate the bitmap of pages used by other tables or the
**    database freelist.
**
**   RECOVER_STATE_LOSTANDFOUND2:
**    Populate the recovery.map table - used to figure out a "root" page
**    for each lost page from in the database from which records are
**    extracted.
**
**   RECOVER_STATE_LOSTANDFOUND3:
**    Populate the lost-and-found table itself.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_INIT</name></cpp:macro>           <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_WRITING</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_LOSTANDFOUND1</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_LOSTANDFOUND2</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_LOSTANDFOUND3</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_SCHEMA2</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_DONE</name></cpp:macro>           <cpp:value>6</cpp:value></cpp:define>


<comment type="block">/*
** Global variables used by this extension.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverGlobal</name></name></type> <name>RecoverGlobal</name>;</typedef>
<struct>struct <name>RecoverGlobal</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>RecoverGlobal</name></type> <name>recover_g</name></decl>;</decl_stmt>

<comment type="block">/*
** Use this static SQLite mutex to protect the globals during the
** first call to sqlite3_recover_step().
*/</comment> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_MUTEX_ID</name></cpp:macro> <cpp:value>SQLITE_MUTEX_STATIC_APP2</cpp:value></cpp:define>


<comment type="block">/* 
** Default value for SQLITE_RECOVER_ROWIDS (sqlite3_recover.bRecoverRowid).
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_ROWID_DEFAULT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/*
** Mutex handling:
**
**    recoverEnterMutex()       -   Enter the recovery mutex
**    recoverLeaveMutex()       -   Leave the recovery mutex
**    recoverAssertMutexHeld()  -   Assert that the recovery mutex is held
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>recoverEnterMutex</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>recoverLeaveMutex</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverEnterMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>RECOVER_MUTEX_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLeaveMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>RECOVER_MUTEX_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name><operator>+</operator><literal type="number">0</literal><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverAssertMutexHeld</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>RECOVER_MUTEX_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>recoverAssertMutexHeld</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Like strlen(). But handles NULL pointer arguments.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverStrlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zStr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if the recover handle passed as the first 
** argument already contains an error (if p-&gt;errCode!=SQLITE_OK). 
**
** Otherwise, an attempt is made to allocate, zero and return a buffer nByte
** bytes in size. If successful, a pointer to the new buffer is returned. Or,
** if an OOM error occurs, NULL is returned and the handle error code
** (p-&gt;errCode) set to SQLITE_NOMEM.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>recoverMalloc</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the error code and error message for the recover handle passed as
** the first argument. The error code is set to the value of parameter
** errCode.
**
** Parameter zFmt must be a printf() style formatting string. The handle 
** error message is set to the result of using any trailing arguments for 
** parameter substitutions in the formatting string.
**
** For example:
**
**   recoverError(p, SQLITE_ERROR, "no such table: %s", zTablename);
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverError</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>errCode</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFmt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>errCode</name></expr>;</expr_stmt>
  <return>return <expr><name>errCode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is a no-op if p-&gt;errCode is initially other than SQLITE_OK.
** In this case it returns NULL.
**
** Otherwise, an attempt is made to allocate and return a bitmap object
** large enough to store a bit for all page numbers between 1 and nPg,
** inclusive. The bitmap is initially zeroed.
*/</comment>
<function><type><specifier>static</specifier> <name>RecoverBitmap</name> <modifier>*</modifier></type><name>recoverBitmapAlloc</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nElem</name> <init>= <expr><operator>(</operator><name>nPg</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">31</literal><operator>)</operator> <operator>/</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoverBitmap</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nElem</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><operator>(</operator><name>RecoverBitmap</name><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>nPg</name></name> <operator>=</operator> <name>nPg</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a bitmap object allocated by recoverBitmapAlloc().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverBitmapFree</name><parameter_list>(<parameter><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the bit associated with page iPg in bitvec pMap.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverBitmapSet</name><parameter_list>(<parameter><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>&lt;=</operator><name><name>pMap</name><operator>-&gt;</operator><name>nPg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iElem</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>/</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBit</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>%</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>aElem</name><index>[<expr><name>iElem</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>iBit</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Query bitmap object pMap for the state of the bit associated with page
** iPg. Return 1 if it is set, or 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverBitmapQuery</name><parameter_list>(<parameter><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>&lt;=</operator><name><name>pMap</name><operator>-&gt;</operator><name>nPg</name></name> <operator>&amp;&amp;</operator> <name>iPg</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iElem</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>/</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBit</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>%</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>aElem</name><index>[<expr><name>iElem</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>iBit</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the recover handle error to the error code and message returned by
** calling sqlite3_errcode() and sqlite3_errmsg(), respectively, on database
** handle db.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverDbError</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). 
**
** Otherwise, it attempts to prepare the SQL statement in zSql against
** database handle db. If successful, the statement handle is returned.
** Or, if an error occurs, NULL is returned and an error left in the
** recover handle.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverPrepare</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). 
**
** Otherwise, argument zFmt is used as a printf() style format string,
** along with any trailing arguments, to create an SQL statement. This
** SQL statement is prepared against database handle db and, if successful,
** the statment handle returned. Or, if an error occurs - either during
** the printf() formatting or when preparing the resulting SQL - an
** error code and message are left in the recover handle.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverPreparePrintf</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset SQLite statement handle pStmt. If the call to sqlite3_reset() 
** indicates that an error occurred, and there is not already an error
** in the recover handle passed as the first argument, set the error
** code and error message appropriately.
**
** This function returns a copy of the statement handle pointer passed
** as the second argument.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverReset</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_CONSTRAINT</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sqlite3_db_handle</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Finalize SQLite statement handle pStmt. If the call to sqlite3_reset() 
** indicates that an error occurred, and there is not already an error
** in the recover handle passed as the first argument, set the error
** code and error message appropriately.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_db_handle</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). A copy of p-&gt;errCode is returned in this 
** case.
**
** Otherwise, execute SQL script zSql. If successful, return SQLITE_OK.
** Or, if an error occurs, leave an error code and message in the recover
** handle and return a copy of the error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverExec</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Bind the value pVal to parameter iBind of statement pStmt. Leave an
** error in the recover handle passed as the first argument if an error
** (e.g. an OOM) occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverBindValue</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iBind</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iBind</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). NULL is returned in this case.
**
** Otherwise, an attempt is made to interpret zFmt as a printf() style
** formatting string and the result of using the trailing arguments for
** parameter substitution with it written into a buffer obtained from
** sqlite3_malloc(). If successful, a pointer to the buffer is returned.
** It is the responsibility of the caller to eventually free the buffer
** using sqlite3_free().
**
** Or, if an error occurs, an error code and message is left in the recover
** handle and NULL returned.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recoverMPrintf</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). Zero is returned in this case.
**
** Otherwise, execute "PRAGMA page_count" against the input database. If
** successful, return the integer result. Or, if an error occurs, leave an
** error code and error message in the sqlite3_recover handle and return
** zero.
*/</comment>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>recoverPageCount</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA %Q.page_count"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPg</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nPg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of SQL scalar function "read_i32". The first argument to 
** this function must be a blob. The second a non-negative integer. This 
** function reads and returns a 32-bit big-endian integer from byte
** offset (4*&lt;arg2&gt;) of the blob.
**
**     SELECT read_i32(&lt;blob&gt;, &lt;idx&gt;)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverReadI32</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iInt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nBlob</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iInt</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iInt</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal><operator>&lt;=</operator><name>nBlob</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>pBlob</name><index>[<expr><name>iInt</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> <init>= <expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator>
             <operator>+</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator>
             <operator>+</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator>
             <operator>+</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of SQL scalar function "page_is_used". This function
** is used as part of the procedure for locating orphan rows for the
** lost-and-found table, and it depends on those routines having populated
** the sqlite3_recover.laf.pUsed variable.
**
** The only argument to this function is a page-number. It returns true 
** if the page has already been used somehow during data recovery, or false
** otherwise.
**
**     SELECT page_is_used(&lt;pgno&gt;);
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverPageIsUsed</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>sqlite3_recover</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>pgno</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>recoverBitmapQuery</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The implementation of a user-defined SQL function invoked by the 
** sqlite_dbdata and sqlite_dbptr virtual table modules to access pages
** of the database being recovered.
**
** This function always takes a single integer argument. If the argument
** is zero, then the value returned is the number of pages in the db being
** recovered. If the argument is greater than zero, it is a page number. 
** The value returned in this case is an SQL blob containing the data for 
** the identified page of the db being recovered. e.g.
**
**     SELECT getpage(0);       -- return number of pages in db
**     SELECT getpage(4);       -- return page 4 of db as a blob of data 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverGetPage</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>sqlite3_recover</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>pgno</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name> <init>= <expr><call><name>recoverPageCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(
          <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT data FROM sqlite_dbpage(%Q) WHERE pgno=?"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aPg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nPg</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aPg</name> <operator>=</operator> <call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nPg</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nPg</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pgsz</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><name>nPg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>aPg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><name>nPg</name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nReserve</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Find a string that is not found anywhere in z[].  Return a pointer
** to that string.
**
** Try to use zA and zB first.  If both of those are already found in z[]
** then make up some string and store it in the buffer zBuf.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>recoverUnusedString</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,                    <comment type="block">/* Result must not appear anywhere in z */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB</name></decl></parameter>,   <comment type="block">/* Try these first */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>                        <comment type="block">/* Space to store a generated string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zA</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zA</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zB</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zB</name></expr>;</return></block_content></block></if></if_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><literal type="string">"(%s%u)"</literal></expr></argument>, <argument><expr><name>zA</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <return>return <expr><name>zBuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of scalar SQL function "escape_crnl".  The argument passed to
** this function is the output of built-in function quote(). If the first
** character of the input is "'", indicating that the value passed to quote()
** was a text value, then this function searches the input for "\n" and "\r"
** characters and adds a wrapper similar to the following:
**
**   replace(replace(&lt;input&gt;, '\n', char(10), '\r', char(13));
**
** Or, if the first character of the input is not "'", then a copy of the input
** is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverEscapeCrnl</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zText</name> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nText</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf1</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf2</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zNL</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zNL</name> <operator>=</operator> <call><name>recoverUnusedString</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>, <argument><expr><literal type="string">"\\012"</literal></expr></argument>, <argument><expr><name>zBuf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNL</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCR</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zCR</name> <operator>=</operator> <call><name>recoverUnusedString</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><literal type="string">"\\r"</literal></expr></argument>, <argument><expr><literal type="string">"\\015"</literal></expr></argument>, <argument><expr><name>zBuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCR</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>zNL</name> <operator>||</operator> <name>zCR</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>nMax</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nNL</name> <operator>&gt;</operator> <name>nCR</name><operator>)</operator></expr> ?</condition><then> <expr><name>nNL</name></expr> </then><else>: <expr><name>nCR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>nAlloc</name> <init>= <expr><name>nMax</name> <operator>*</operator> <name>nText</name> <operator>+</operator> <operator>(</operator><name>nMax</name><operator>+</operator><literal type="number">64</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>zNL</name> <operator>&amp;&amp;</operator> <name>zCR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"replace(replace("</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"replace("</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNL</name></expr></argument>, <argument><expr><name>nNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nNL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCR</name></expr></argument>, <argument><expr><name>nCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nCR</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name>zNL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">",'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNL</name></expr></argument>, <argument><expr><name>nNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nNL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"', char(10))"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">",'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCR</name></expr></argument>, <argument><expr><name>nCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nCR</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"', char(13))"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>iOut</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). A copy of the error code is returned in
** this case. 
**
** Otherwise, attempt to populate temporary table "recovery.schema" with the
** parts of the database schema that can be extracted from the input database.
**
** If no error occurs, SQLITE_OK is returned. Otherwise, an error code
** and error message are left in the recover handle and a copy of the
** error code returned. It is not considered an error if part of all of
** the database schema cannot be recovered due to corruption.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverCacheSchema</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
    <argument><expr><literal type="string">"WITH RECURSIVE pages(p) AS ("</literal>
    <literal type="string">"  SELECT 1"</literal>
    <literal type="string">"    UNION"</literal>
    <literal type="string">"  SELECT child FROM sqlite_dbptr('getpage()'), pages WHERE pgno=p"</literal>
    <literal type="string">")"</literal>
    <literal type="string">"INSERT INTO recovery.schema SELECT"</literal>
    <literal type="string">"  max(CASE WHEN field=0 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=1 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=2 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=3 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=4 THEN value ELSE NULL END)"</literal>
    <literal type="string">"FROM sqlite_dbdata('getpage()') WHERE pgno IN ("</literal>
    <literal type="string">"  SELECT p FROM pages"</literal>
    <literal type="string">") GROUP BY pgno, cell"</literal></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If this recover handle is not in SQL callback mode (i.e. was not created 
** using sqlite3_recover_init_sql()) of if an error has already occurred, 
** this function is a no-op. Otherwise, issue a callback with SQL statement
** zSql as the parameter. 
**
** If the callback returns non-zero, set the recover handle error code to
** the value returned (so that the caller will abandon processing).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverSqlCallback</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>xSql</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name><name>p</name><operator>-&gt;</operator><name>xSql</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSqlCtx</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"callback returned an error - %d"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Transfer the following settings from the input database to the output
** database:
**
**   + page-size,
**   + auto-vacuum settings,
**   + database encoding,
**   + user-version (PRAGMA user_version), and
**   + application-id (PRAGMA application_id), and
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverTransferSettings</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>aPragma</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"encoding"</literal></expr>,
    <expr><literal type="string">"page_size"</literal></expr>,
    <expr><literal type="string">"auto_vacuum"</literal></expr>,
    <expr><literal type="string">"user_version"</literal></expr>,
    <expr><literal type="string">"application_id"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <comment type="block">/* Truncate the output database to 0 pages in size. This is done by 
  ** opening a new, empty, temp db, then using the backup API to clobber 
  ** any existing output db with a copy of it. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>db2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aPragma</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aPragma</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPrag</name> <init>= <expr><name><name>aPragma</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA %Q.%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zPrag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA %s = %Q"</literal></expr></argument>, <argument><expr><name>zPrag</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db2</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE t1(a); DROP TABLE t1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_backup</name> <modifier>*</modifier></type><name>pBackup</name> <init>= <expr><call><name>sqlite3_backup_init</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBackup</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_backup_step</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_backup_finish</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). A copy of the error code is returned in
** this case. 
**
** Otherwise, an attempt is made to open the output database, attach
** and create the schema of the temporary database used to store
** intermediate data, and to register all required user functions and
** virtual table modules with the output handle.
**
** If no error occurs, SQLITE_OK is returned. Otherwise, an error code
** and error message are left in the recover handle and a copy of the
** error code returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverOpenOutput</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct>struct <name>Func</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aFunc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"getpage"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>recoverGetPage</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"page_is_used"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>recoverPageIsUsed</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"read_i32"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>recoverReadI32</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"escape_crnl"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>recoverEscapeCrnl</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>

  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= <expr><name>SQLITE_OPEN_URI</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name>SQLITE_OPEN_READWRITE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* New database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                         <comment type="block">/* For iterating through aFunc[] */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zUri</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register the sqlite_dbdata and sqlite_dbptr virtual table modules.
  ** These two are registered with the output database handle - this
  ** module depends on the input handle supporting the sqlite_dbpage
  ** virtual table only.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_dbdata_init</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register the custom user-functions with the output handle. */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFunc</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, 
        <argument><expr><name><name>aFunc</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attach the auxiliary database 'recovery' to the output database handle.
** This temporary database is used during the recovery process and then 
** discarded.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverOpenRecovery</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"ATTACH %Q AS recovery;"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"PRAGMA writable_schema = 1;"</literal>
      <literal type="string">"CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, parent INT);"</literal> 
      <literal type="string">"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK).
**
** Otherwise, argument zName must be the name of a table that has just been
** created in the output database. This function queries the output db
** for the schema of said table, and creates a RecoverTable object to
** store the schema in memory. The new RecoverTable object is linked into
** the list at sqlite3_recover.pTblList.
**
** Parameter iRoot must be the root page of table zName in the INPUT 
** database.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverAddTable</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name of table created in output db */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iRoot</name></decl></parameter>                       <comment type="block">/* Root page of same table in INPUT db */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, 
      <argument><expr><literal type="string">"PRAGMA table_xinfo(%Q)"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPk</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBind</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>recoverStrlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <operator>(</operator><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoverTable</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nCol</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RecoverColumn</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>csr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <operator>(</operator><name>RecoverColumn</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zTab</name></name> <operator>=</operator> <name>csr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iRoot</name></name> <operator>=</operator> <name>iRoot</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>csr</name> <operator>+=</operator> <name>nName</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iPKF</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eHidden</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name>iPk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iPKF</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"integer"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPk</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iPKF</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPk</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCol</name> <operator>=</operator> <name>csr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eHidden</name> <operator>=</operator> <name>eHidden</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eHidden</name><operator>==</operator><name>RECOVER_EHIDDEN_VIRTUAL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iField</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iField</name> <operator>=</operator> <name>iField</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_VIRTUAL</name>
         <operator>&amp;&amp;</operator> <name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_STORED</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBind</name> <operator>=</operator> <name>iBind</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>csr</name> <operator>+=</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bIntkey</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA index_xinfo(%Q)"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pStmt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iField</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>iField</name> <operator>=</operator> <name>iField</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bIntkey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPk</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iPk</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iPk</name></expr>]</index></name><operator>.</operator><name>bIPK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>bIntkey</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iRowidBind</name></name> <operator>=</operator> <name>iBind</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after recoverCacheSchema() has cached those parts
** of the input database schema that could be recovered in temporary table
** "recovery.schema". This function creates in the output database copies
** of all parts of that schema that must be created before the tables can
** be populated. Specifically, this means:
**
**     * all tables that are not VIRTUAL, and
**     * UNIQUE indexes.
**
** If the recovery handle uses SQL callbacks, then callbacks containing
** the associated "CREATE TABLE" and "CREATE INDEX" statements are made.
**
** Additionally, records are added to the sqlite_schema table of the
** output database for any VIRTUAL tables. The CREATE VIRTUAL TABLE
** records are written directly to sqlite_schema, not actually executed.
** If the handle is in SQL callback mode, then callbacks are invoked 
** with equivalent SQL statements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteSchema1</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pTblname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"WITH dbschema(rootpage, name, sql, tbl, isVirtual, isIndex) AS ("</literal>
      <literal type="string">"  SELECT rootpage, name, sql, "</literal>
      <literal type="string">"    type='table', "</literal>
      <literal type="string">"    sql LIKE 'create virtual%',"</literal>
      <literal type="string">"    (type='index' AND (sql LIKE '%unique%' OR ?1))"</literal>
      <literal type="string">"  FROM recovery.schema"</literal>
      <literal type="string">")"</literal>
      <literal type="string">"SELECT rootpage, tbl, isVirtual, name, sql"</literal>
      <literal type="string">" FROM dbschema "</literal>
      <literal type="string">"  WHERE tbl OR isIndex"</literal>
      <literal type="string">"  ORDER BY tbl DESC, name=='sqlite_sequence' DESC"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTblname</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"SELECT name FROM sqlite_schema "</literal>
      <literal type="string">"WHERE type='table' ORDER BY rowid DESC LIMIT 1"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bSlowIndexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iRoot</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bTable</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bVirtual</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>bVirtual</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>zFree</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
            <argument><expr><literal type="string">"INSERT INTO sqlite_schema VALUES('table', %Q, %Q, 0, %Q)"</literal></expr></argument>,
            <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>
        )</argument_list></call><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bTable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bVirtual</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pTblname</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pTblname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>recoverAddTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTblname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTblname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after the output database has been populated. It
** adds all recovered schema elements that were not created in the output
** database by recoverWriteSchema1() - everything except for tables and
** UNIQUE indexes. Specifically:
**
**     * views,
**     * triggers,
**     * non-UNIQUE indexes.
**
** If the recover handle is in SQL callback mode, then equivalent callbacks
** are issued to create the schema elements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteSchema2</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bSlowIndexes</name></name></expr> ?</condition><then>
      <expr><literal type="string">"SELECT rootpage, sql FROM recovery.schema "</literal>
      <literal type="string">"  WHERE type!='table' AND type!='index'"</literal></expr>
      </then><else>:
      <expr><literal type="string">"SELECT rootpage, sql FROM recovery.schema "</literal>
      <literal type="string">"  WHERE type!='table' AND (type!='index' OR sql NOT LIKE '%unique%')"</literal></expr></else></ternary></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). In this case it returns NULL.
**
** Otherwise, if the recover handle is configured to create an output
** database (was created by sqlite3_recover_init()), then this function
** prepares and returns an SQL statement to INSERT a new record into table
** pTab, assuming the first nField fields of a record extracted from disk
** are valid.
**
** For example, if table pTab is:
**
**     CREATE TABLE name(a, b GENERATED ALWAYS AS (a+1) STORED, c, d, e);
**
** And nField is 4, then the SQL statement prepared and returned is:
**
**     INSERT INTO (a, c, d) VALUES (?1, ?2, ?3);
**
** In this case even though 4 values were extracted from the input db,
** only 3 are written to the output, as the generated STORED column 
** cannot be written.
**
** If the recover handle is in SQL callback mode, then the SQL statement
** prepared is such that evaluating it returns a single row containing
** a single text value - itself an SQL statement similar to the above,
** except with SQL literals in place of the variables. For example:
**
**     SELECT 'INSERT INTO (a, c, d) VALUES (' 
**          || quote(?1) || ', '
**          || quote(?2) || ', '
**          || quote(?3) || ')';
**
** In either case, it is the responsibility of the caller to eventually
** free the statement handle using sqlite3_finalize().
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverInsertStmt</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSqlSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFinal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bSql</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>xSql</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nField</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&lt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"INSERT OR IGNORE INTO %Q("</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>bIntkey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z_rowid_"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%zquote(?%d)"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z?%d"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>zSqlSep</name> <operator>=</operator> <literal type="string">"||', '||"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nField</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eHidden</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>eHidden</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_VIRTUAL</name>
     <operator>&amp;&amp;</operator> <name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_STORED</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iField</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iBind</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%s%Q"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>bSql</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, 
            <argument><expr><literal type="string">"%z%sescape_crnl(quote(?%d))"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name>zSqlSep</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iBind</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSqlSep</name> <operator>=</operator> <literal type="string">"||', '||"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%s?%d"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>bSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFinal</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"SELECT %Q || ') VALUES (' || %s || ')'"</literal></expr></argument>, 
        <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFinal</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s) VALUES (%s)"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Search the list of RecoverTable objects at p-&gt;pTblList for one that
** has root page iRoot in the input database. If such an object is found,
** return a pointer to it. Otherwise, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>RecoverTable</name> <modifier>*</modifier></type><name>recoverFindTable</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iRoot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pRet</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</init> <condition><expr><name>pRet</name> <operator>&amp;&amp;</operator> <name><name>pRet</name><operator>-&gt;</operator><name>iRoot</name></name><operator>!=</operator><name>iRoot</name></expr>;</condition> <incr><expr><name>pRet</name><operator>=</operator><name><name>pRet</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function attempts to create a lost and found table within the 
** output db. If successful, it returns a pointer to a buffer containing
** the name of the new table. It is the responsibility of the caller to
** eventually free this buffer using sqlite3_free().
**
** If an error occurs, NULL is returned and an error code and error 
** message left in the recover handle.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recoverLostAndFoundCreate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Recover object */</comment>
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>                      <comment type="block">/* Number of column fields in new table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pProbe</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
    <argument><expr><literal type="string">"SELECT 1 FROM sqlite_schema WHERE name=?"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>zTbl</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><literal type="number">1000</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bFail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zTbl</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zTbl</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s_%d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bFail</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bFail</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zTbl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zTbl</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"rootpgno INTEGER, pgno INTEGER, nfield INTEGER, id INTEGER, "</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name>nField</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zField</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%sc%d"</literal></expr></argument>, <argument><expr><name>zField</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE %s(%s)"</literal></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>zField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverError</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create %s output table"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>zTbl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Synthesize and prepare an INSERT statement to write to the lost_and_found
** table in the output database. The name of the table is zTab, and it has
** nField c* fields.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverLostAndFoundInsert</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nTotal</name> <init>= <expr><name>nField</name> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xSql</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTotal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%s?"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zBind</name></expr>?</condition><then><expr><literal type="string">", "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s VALUES(%s)"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTotal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%squote(?)"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"|| ', ' ||"</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT 'INSERT INTO %s VALUES(' || %s || ')'"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Input database page iPg contains data that will be written to the
** lost-and-found table of the output database. This function attempts
** to identify the root page of the tree that page iPg belonged to.
** If successful, it sets output variable (*piRoot) to the page number
** of the root page and returns SQLITE_OK. Otherwise, if an error occurs,
** an SQLite error code is returned and the final value of *piRoot 
** undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFoundFindRoot</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name></type> <name>iPg</name></decl></parameter>,
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piRoot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
        <argument><expr><literal type="string">"WITH RECURSIVE p(pgno) AS ("</literal>
        <literal type="string">"  SELECT ?"</literal>
        <literal type="string">"    UNION"</literal>
        <literal type="string">"  SELECT parent FROM recovery.map AS m, p WHERE m.pgno=p.pgno"</literal>
        <literal type="string">") "</literal>
        <literal type="string">"SELECT p.pgno FROM p, recovery.map m WHERE m.pgno=p.pgno "</literal>
        <literal type="string">"    AND m.parent IS NULL"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piRoot</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piRoot</name> <operator>=</operator> <name>iPg</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Recover data from page iPage of the input database and write it to
** the lost-and-found table in the output database.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFoundOnePage</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name> <init>= <expr><name><name>pLaf</name><operator>-&gt;</operator><name>apVal</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pPageData</name> <init>= <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pPageData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name> <init>= <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pInsert</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrevCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bHaveRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>recoverLostAndFoundFindRoot</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRoot</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>iPrevCell</name><operator>!=</operator><name>iCell</name> <operator>&amp;&amp;</operator> <name>nVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Insert the new row */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* rootpgno */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* pgno */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* nfield */</comment>
      <if_stmt><if>if<condition>( <expr><name>bHaveRowid</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* id */</comment>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>recoverBindValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">5</literal><operator>+</operator><name>ii</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Discard the accumulated row data */</comment>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bHaveRowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iField</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bHaveRowid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iField</name><operator>&lt;</operator><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iField</name><operator>==</operator><name>nVal</name> <operator>||</operator> <operator>(</operator><name>nVal</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iField</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>iField</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>iPrevCell</name> <operator>=</operator> <name>iCell</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pPageData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_LOSTANDFOUND3 state - during which the lost-and-found 
** table of the output database is populated with recovered data that can 
** not be assigned to any recovered schema object.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFound3Step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pInsert</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>iPage</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>recoverBitmapQuery</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>recoverLostAndFoundOnePage</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required in RECOVER_STATE_LOSTANDFOUND3 
** state - during which the lost-and-found table of the output database 
** is populated with recovered data that can not be assigned to any 
** recovered schema object.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFound3Init</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Name of lost_and_found table */</comment>

    <expr_stmt><expr><name>zTab</name> <operator>=</operator> <call><name>recoverLostAndFoundCreate</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pInsert</name></name> <operator>=</operator> <call><name>recoverLostAndFoundInsert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
        <argument><expr><literal type="string">"WITH RECURSIVE seq(ii) AS ("</literal>
        <literal type="string">"  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii&lt;%lld"</literal>
        <literal type="string">")"</literal>
        <literal type="string">"SELECT ii FROM seq"</literal></expr></argument> , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>nPg</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pPageData</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
        <argument><expr><literal type="string">"SELECT cell, field, value "</literal>
        <literal type="string">"FROM sqlite_dbdata('getpage()') d WHERE d.pgno=? "</literal>
        <literal type="string">"UNION ALL "</literal>
        <literal type="string">"SELECT -1, -1, -1"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>apVal</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, 
        <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required in RECOVER_STATE_WRITING state - during which
** tables recovered from the schema of the input database are populated with
** recovered data.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteDataInit</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateW1</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>w1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTbl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Figure out the maximum number of columns for any table in the schema */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pTbl</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</init> <condition><expr><name>pTbl</name></expr>;</condition> <incr><expr><name>pTbl</name><operator>=</operator><name><name>pTbl</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTbl</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name> <operator>=</operator> <name><name>pTbl</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Allocate an array of (sqlite3_value*) in which to accumulate the values
  ** that will be written to the output database in a single row. */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Prepare the SELECT to loop through schema tables (pTbls) and the SELECT
  ** to loop through cells that appear to belong to a single table (pSel). */</comment>
  <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"SELECT rootpage FROM recovery.schema "</literal>
      <literal type="string">"  WHERE type='table' AND (sql NOT LIKE 'create virtual%')"</literal>
      <literal type="string">"  ORDER BY (tbl_name='sqlite_sequence') ASC"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pSel</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, 
      <argument><expr><literal type="string">"WITH RECURSIVE pages(page) AS ("</literal>
      <literal type="string">"  SELECT ?1"</literal>
      <literal type="string">"    UNION"</literal>
      <literal type="string">"  SELECT child FROM sqlite_dbptr('getpage()'), pages "</literal>
      <literal type="string">"    WHERE pgno=page"</literal>
      <literal type="string">") "</literal>
      <literal type="string">"SELECT page, cell, field, value "</literal>
      <literal type="string">"FROM sqlite_dbdata('getpage()') d, pages p WHERE p.page=d.pgno "</literal>
      <literal type="string">"UNION ALL "</literal>
      <literal type="string">"SELECT 0, 0, 0, 0"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clean up resources allocated by recoverWriteDataInit() (stuff in 
** sqlite3_recover.w1).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverWriteDataCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateW1</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>w1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pSel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_WRITING state - during which tables recovered from the
** schema of the input database are populated with recovered data.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteDataStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateW1</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>w1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>pSel</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iRoot</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <call><name>recoverFindTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* If this table is unknown, return early. The caller will invoke this
      ** function again and it will move on to the next table.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* If this is the sqlite_sequence table, delete any rows added by
      ** earlier INSERT statements on tables with AUTOINCREMENT primary
      ** keys before recovering its contents. The p1-&gt;pTbls SELECT statement
      ** is rigged to deliver "sqlite_sequence" last of all, so we don't
      ** worry about it being modified after it is recovered. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"sqlite_sequence"</literal></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM sqlite_sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM sqlite_sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Bind the root page of this table within the original database to 
      ** SELECT statement p1-&gt;pSel. The SELECT statement will then iterate
      ** through cells that look like they belong to table pTab.  */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevCell</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>i64</name></type> <name>iPage</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bNewCell</name> <init>= <expr><operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>iPrevPage</name></name><operator>!=</operator><name>iPage</name> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>iPrevCell</name></name><operator>!=</operator><name>iCell</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bNewCell</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iField</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>iField</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bNewCell</name> <operator>||</operator> <name>iField</name><operator>==</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bNewCell</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>!=</operator><name><name>p1</name><operator>-&gt;</operator><name>nInsert</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name> <operator>=</operator> <call><name>recoverInsertStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nInsert</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>RecoverColumn</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>iBind</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>iBind</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>iBind</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>bIPK</name></name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>iBind</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iField</name></name><operator>&lt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>recoverBindValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>iBind</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>iField</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecoverRowid</name></name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>||</operator> <name>pInsert</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pInsert</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iPage</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iField</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iField</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>( <argument><expr><name>pVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <name>iField</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevCell</name></name> <operator>=</operator> <name>iCell</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevPage</name></name> <operator>=</operator> <name>iPage</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required by sqlite3_recover_step() in
** RECOVER_STATE_LOSTANDFOUND1 state - during which the set of pages not
** already allocated to a recovered schema element is determined.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFound1Init</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nPg</name></name> <operator>=</operator> <call><name>recoverPageCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name> <operator>=</operator> <call><name>recoverBitmapAlloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Prepare a statement to iterate through all pages that are part of any tree
  ** in the recoverable part of the input database schema to the bitmap. And,
  ** if !p-&gt;bFreelistCorrupt, add all pages that appear to be part of the
  ** freelist.  */</comment>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(
      <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"WITH trunk(pgno) AS ("</literal>
      <literal type="string">"  SELECT read_i32(getpage(1), 8) AS x WHERE x&gt;0"</literal>
      <literal type="string">"    UNION"</literal>
      <literal type="string">"  SELECT read_i32(getpage(trunk.pgno), 0) AS x FROM trunk WHERE x&gt;0"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">"trunkdata(pgno, data) AS ("</literal>
      <literal type="string">"  SELECT pgno, getpage(pgno) FROM trunk"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">"freelist(data, n, freepgno) AS ("</literal>
      <literal type="string">"  SELECT data, min(16384, read_i32(data, 1)-1), pgno FROM trunkdata"</literal>
      <literal type="string">"    UNION ALL"</literal>
      <literal type="string">"  SELECT data, n-1, read_i32(data, 2+n) FROM freelist WHERE n&gt;=0"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">""</literal>
      <literal type="string">"roots(r) AS ("</literal>
      <literal type="string">"  SELECT 1 UNION ALL"</literal>
      <literal type="string">"  SELECT rootpage FROM recovery.schema WHERE rootpage&gt;0"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">"used(page) AS ("</literal>
      <literal type="string">"  SELECT r FROM roots"</literal>
      <literal type="string">"    UNION"</literal>
      <literal type="string">"  SELECT child FROM sqlite_dbptr('getpage()'), used "</literal>
      <literal type="string">"    WHERE pgno=page"</literal>
      <literal type="string">") "</literal>
      <literal type="string">"SELECT page FROM used"</literal>
      <literal type="string">" UNION ALL "</literal>
      <literal type="string">"SELECT freepgno FROM freelist WHERE NOT ?"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bFreelistCorrupt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_LOSTANDFOUND1 state - during which the set of pages not
** already allocated to a recovered schema element is determined.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFound1Step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iPg</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>recoverBitmapSet</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required by RECOVER_STATE_LOSTANDFOUND2 
** state - during which the pages identified in RECOVER_STATE_LOSTANDFOUND1
** are sorted into sets that likely belonged to the same database tree.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFound2Init</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMapInsert</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMaxField</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>nMaxField</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"INSERT OR IGNORE INTO recovery.map(pgno, parent) VALUES(?, ?)"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"WITH RECURSIVE seq(ii) AS ("</literal>
      <literal type="string">"  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii&lt;%lld"</literal>
      <literal type="string">")"</literal>
      <literal type="string">"SELECT pgno, child FROM sqlite_dbptr('getpage()') "</literal>
      <literal type="string">" UNION ALL "</literal>
      <literal type="string">"SELECT NULL, ii FROM seq"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>nPg</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"SELECT max(field)+1 FROM sqlite_dbdata('getpage') WHERE pgno = ?"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_LOSTANDFOUND2 state - during which the pages identified 
** in RECOVER_STATE_LOSTANDFOUND1 are sorted into sets that likely belonged 
** to the same database tree.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFound2Step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iChild</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>recoverBitmapQuery</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, 
            <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nMax</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nMax</name><operator>&gt;</operator><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name> <operator>=</operator> <name>nMax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name> <operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources allocated as part of sqlite3_recover_step() calls
** in one of the RECOVER_STATE_LOSTANDFOUND[123] states.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFoundCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>recoverBitmapFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsedPages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMapInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pFindRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pPageData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsedPages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMapInsert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMaxField</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pFindRoot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pInsert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pPageData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>apVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>apVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources allocated as part of sqlite3_recover_step() calls.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverFinalCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>recoverWriteDataCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverLostAndFoundCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_RESET_CACHE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       <expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Decode and return an unsigned 16-bit big-endian integer value from 
** buffer a[].
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>recoverGetU16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decode and return an unsigned 32-bit big-endian integer value from 
** buffer a[].
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>recoverGetU32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decode an SQLite varint from buffer a[]. Write the decoded value to (*pVal)
** and return the number of bytes consumed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverGetVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>u</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt> <return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>u</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">9</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The second argument points to a buffer n bytes in size. If this buffer
** or a prefix thereof appears to contain a well-formed SQLite b-tree page, 
** return the page-size in bytes. Otherwise, if the buffer does not 
** appear to contain a well-formed b-tree page, return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverIsValidPage</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aTmp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aUsed</name> <init>= <expr><name>aTmp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFrag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nActual</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Number of cells on page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Offset of cell array in page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iContent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><literal type="number">0x02</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><literal type="number">0x05</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><literal type="number">0x0A</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><literal type="number">0x0D</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>iFree</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iContent</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iContent</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iContent</name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nFrag</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iContent</name><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aUsed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aUsed</name></expr></argument>, <argument><expr><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>iContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Follow the free-list. This is the same format for all b-tree pages. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iFree</name> <operator>&amp;&amp;</operator> <name>iFree</name><operator>&lt;=</operator><name>iContent</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name>iFree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFree</name><operator>&gt;</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">4</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iNext</name> <operator>=</operator> <call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iFree</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iFree</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFree</name><operator>+</operator><name>nByte</name><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iNext</name> <operator>&amp;&amp;</operator> <name>iNext</name><operator>&lt;</operator><name>iFree</name><operator>+</operator><name>nByte</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aUsed</name><index>[<expr><name>iFree</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iFree</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Run through the cells */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0x02</literal> <operator>||</operator> <name>eType</name><operator>==</operator><literal type="number">0x05</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iCellOff</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iCellOff</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iCellOff</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>nCell</name><operator>)</operator><operator>&gt;</operator><name>iContent</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iByte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>nPayload</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iCellOff</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>iOff</name><argument_list type="generic">&lt;<argument><expr><name>iContent</name> <operator>||</operator> <name>iOff</name></expr></argument>&gt;</argument_list></name><name>n</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0x05</literal> <operator>||</operator> <name>eType</name><operator>==</operator><literal type="number">0x02</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>recoverGetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iOff</name><operator>+</operator><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0x0D</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>recoverGetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iOff</name><operator>+</operator><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><literal type="number">0x05</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>eType</name><operator>==</operator><literal type="number">0x0D</literal><operator>)</operator></expr> ?</condition><then> <expr><name>n</name><operator>-</operator><literal type="number">35</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">64</literal><operator>/</operator><literal type="number">255</literal><operator>)</operator><operator>-</operator><literal type="number">23</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>M</name> <init>= <expr><operator>(</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">32</literal><operator>/</operator><literal type="number">255</literal><operator>)</operator><operator>-</operator><literal type="number">23</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>K</name> <init>= <expr><name>M</name><operator>+</operator><operator>(</operator><operator>(</operator><name>nPayload</name><operator>-</operator><name>M</name><operator>)</operator><operator>%</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;</operator><name>X</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>nPayload</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>K</name><operator>&lt;=</operator><name>X</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>K</name><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>M</name><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iOff</name><operator>+</operator><name>nByte</name><operator>&gt;</operator><name>n</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>iByte</name><operator>=</operator><name>iOff</name></expr>;</init> <condition><expr><name>iByte</name><operator>&lt;</operator><operator>(</operator><name>iOff</name><operator>+</operator><name>nByte</name><operator>)</operator></expr>;</condition> <incr><expr><name>iByte</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aUsed</name><index>[<expr><name>iByte</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iByte</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><name>nActual</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aUsed</name><index>[<expr><name>ii</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nActual</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>(</operator><name>nActual</name><operator>==</operator><name>nFrag</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsRead</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsWrite</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmMap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>volatile</specifier><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recoverVfsShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_io_methods</name></type> <name>recover_methods</name> <init>= <expr><block>{
  <expr><literal type="number">2</literal></expr>, <comment type="block">/* iVersion */</comment>
  <expr><name>recoverVfsClose</name></expr>,
  <expr><name>recoverVfsRead</name></expr>,
  <expr><name>recoverVfsWrite</name></expr>,
  <expr><name>recoverVfsTruncate</name></expr>,
  <expr><name>recoverVfsSync</name></expr>,
  <expr><name>recoverVfsFileSize</name></expr>,
  <expr><name>recoverVfsLock</name></expr>,
  <expr><name>recoverVfsUnlock</name></expr>,
  <expr><name>recoverVfsCheckReservedLock</name></expr>,
  <expr><name>recoverVfsFileControl</name></expr>,
  <expr><name>recoverVfsSectorSize</name></expr>,
  <expr><name>recoverVfsDeviceCharacteristics</name></expr>,
  <expr><name>recoverVfsShmMap</name></expr>,
  <expr><name>recoverVfsShmLock</name></expr>,
  <expr><name>recoverVfsShmBarrier</name></expr>,
  <expr><name>recoverVfsShmUnmap</name></expr>,
  <expr><name>recoverVfsFetch</name></expr>,
  <expr><name>recoverVfsUnfetch</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>!=</operator><operator>&amp;</operator><name>recover_methods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write value v to buffer a[] as a 16-bit big-endian unsigned integer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverPutU16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write value v to buffer a[] as a 32-bit big-endian unsigned integer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverPutU32</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Detect the page-size of the database opened by file-handle pFd by 
** searching the first part of the file for a well-formed SQLite b-tree 
** page. If parameter nReserve is non-zero, then as well as searching for
** a b-tree page with zero reserved bytes, this function searches for one
** with nReserve reserved bytes at the end of it.
**
** If successful, set variable p-&gt;detected_pgsz to the detected page-size
** in bytes and return SQLITE_OK. Or, if no error occurs but no valid page
** can be found, return SQLITE_OK but leave p-&gt;detected_pgsz set to 0. Or,
** if an error occurs (e.g. an IO or OOM error), then an SQLite error code
** is returned. The final value of p-&gt;detected_pgsz is undefined in this
** case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsDetectPagesize</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Recover handle */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,              <comment type="block">/* File-handle open on input database */</comment>
  <parameter><decl><type><name>u32</name></type> <name>nReserve</name></decl></parameter>,                   <comment type="block">/* Possible nReserve value */</comment>
  <parameter><decl><type><name>i64</name></type> <name>nSz</name></decl></parameter>                         <comment type="block">/* Size of database file in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMin</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMax</name> <init>= <expr><literal type="number">65536</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMaxBlk</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>pgsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aTmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>aPg</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>*</operator><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aTmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aPg</name><index>[<expr><name>nMax</name></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>nBlk</name> <operator>=</operator> <operator>(</operator><name>nSz</name><operator>+</operator><name>nMax</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>nMax</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nBlk</name><operator>&gt;</operator><name>nMaxBlk</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBlk</name> <operator>=</operator> <name>nMaxBlk</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <do>do <block>{<block_content>
    <for>for<control>(<init><expr><name>iBlk</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iBlk</name><operator>&lt;</operator><name>nBlk</name></expr>;</condition> <incr><expr><name>iBlk</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nSz</name><operator>&gt;=</operator><operator>(</operator><operator>(</operator><name>iBlk</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nMax</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>nMax</name></expr> </then><else>: <expr><operator>(</operator><name>nSz</name> <operator>%</operator> <name>nMax</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iBlk</name><operator>*</operator><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>pgsz2</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>pgsz2</name><operator>=</operator><operator>(</operator><ternary><condition><expr><name>pgsz</name></expr> ?</condition><then> <expr><name>pgsz</name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name>nMin</name></expr></else></ternary><operator>)</operator></expr>;</init> <condition><expr><name>pgsz2</name><operator>&lt;=</operator><name>nMax</name></expr>;</condition> <incr><expr><name>pgsz2</name><operator>=</operator><name>pgsz2</name><operator>*</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>iOff</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iOff</name><operator>&lt;</operator><name>nMax</name></expr>;</condition> <incr><expr><name>iOff</name><operator>+=</operator><name>pgsz2</name></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>recoverIsValidPage</name><argument_list>(<argument><expr><name>aTmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aPg</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>pgsz2</name><operator>-</operator><name>nReserve</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <name>pgsz2</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pgsz</name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name> <operator>=</operator> <name>pgsz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nReserve</name></name> <operator>=</operator> <name>nReserve</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nReserve</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><literal type="number">1</literal></expr> )</condition>;</do>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name> <operator>=</operator> <name>pgsz</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xRead() method of the wrapper VFS. This is used to intercept calls
** to read page 1 of the input database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsRead</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><operator>&amp;</operator><name>recover_methods</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name><name>recover_g</name><operator>.</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">16</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iOff</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nByte</name><operator>&gt;=</operator><literal type="number">108</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Ensure that the database has a valid header file. The only fields
      ** that really matter to recovery are:
      **
      **   + Database page size (16-bits at offset 16)
      **   + Size of db in pages (32-bits at offset 28)
      **   + Database encoding (32-bits at offset 56)
      **
      ** Also preserved are:
      **
      **   + first freelist page (32-bits at offset 32)
      **   + size of freelist (32-bits at offset 36)
      **   + the wal-mode flags (16-bits at offset 18)
      **
      ** We also try to preserve the auto-vacuum, incr-value, user-version
      ** and application-id fields - all 32 bit quantities at offsets 
      ** 52, 60, 64 and 68. All other fields are set to known good values.
      **
      ** Byte offset 105 should also contain the page-size as a 16-bit 
      ** integer.
      */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>aPreserve</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><literal type="number">68</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aHdr</name><index>[<expr><literal type="number">108</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x51</literal></expr>, <expr><literal type="number">0x4c</literal></expr>, <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x66</literal></expr>, 
        <expr><literal type="number">0x6f</literal></expr>, <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x6d</literal></expr>, <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x33</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x40</literal></expr>, <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x20</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x04</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x2e</literal></expr>, <expr><literal type="number">0x5b</literal></expr>, <expr><literal type="number">0x30</literal></expr>,

        <expr><literal type="number">0x0D</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x00</literal></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aBuf</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>u32</name></type> <name>pgsz</name> <init>= <expr><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>nReserve</name> <init>= <expr><name><name>a</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>enc</name> <init>= <expr><call><name>recoverGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">56</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>dbsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>dbFileSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>recover_g</name><operator>.</operator><name>p</name></name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>pgsz</name><operator>==</operator><literal type="number">0x01</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbFileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>recoverVfsDetectPagesize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>nReserve</name></expr></argument>, <argument><expr><name>dbFileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nReserve</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>pgsz</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>dbsz</name> <operator>=</operator> <name>dbFileSize</name> <operator>/</operator> <name>pgsz</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>enc</name><operator>!=</operator><name>SQLITE_UTF8</name> <operator>&amp;&amp;</operator> <name>enc</name><operator>!=</operator><name>SQLITE_UTF16BE</name> <operator>&amp;&amp;</operator> <name>enc</name><operator>!=</operator><name>SQLITE_UTF16LE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pgsz</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aHdr</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aHdr</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">19</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverPutU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dbsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverPutU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">56</literal></expr>]</index></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">105</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pgsz</name><operator>-</operator><name>nReserve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pgsz</name><operator>==</operator><literal type="number">65536</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>recoverPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pgsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aHdr</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <operator>=</operator> <name>nReserve</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aPreserve</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aPreserve</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><name><name>aPreserve</name><index>[<expr><name>ii</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name><name>aPreserve</name><index>[<expr><name>ii</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>aHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aBuf</name><operator>)</operator><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></sizeof></expr>]</index></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>recover_methods</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Used to make sqlite3_io_methods wrapper methods less verbose.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_VFS_WRAPPER</name><parameter_list>(<parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro>                         \
  <cpp:value>int rc = SQLITE_OK;                                     \
  if( pFd-&gt;pMethods==&amp;recover_methods ){                  \
    pFd-&gt;pMethods = recover_g.pMethods;                   \
    rc = code;                                            \
    pFd-&gt;pMethods = &amp;recover_methods;                     \
  }else{                                                  \
    rc = code;                                            \
  }                                                       \
  return rc;</cpp:value></cpp:define>                                              

<comment type="block">/*
** Methods of the wrapper VFS. All methods except for xRead() and xClose()
** simply uninstall the sqlite3_io_methods wrapper, invoke the equivalent
** method on the lower level VFS, then reinstall the wrapper before returning.
** Those that return an integer value use the RECOVER_VFS_WRAPPER macro.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>pSize</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xCheckReservedLock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
    <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr> ?</condition><then>  <expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileControl</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>SQLITE_NOTFOUND</name></expr></else></ternary><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xDeviceCharacteristics</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmMap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pgsz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bExtend</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><name>pgsz</name></expr></argument>, <argument><expr><name>bExtend</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmLock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverVfsShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><operator>&amp;</operator><name>recover_methods</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name><name>recover_g</name><operator>.</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>recover_methods</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>deleteFlag</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFetch</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Install the VFS wrapper around the file-descriptor open on the input
** database for recover handle p. Mutex RECOVER_MUTEX_ID must be held
** when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverInstallWrapper</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>recover_g</name><operator>.</operator><name>pMethods</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverAssertMutexHeld</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFd</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>!=</operator><operator>&amp;</operator><name>recover_methods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFd</name> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iVersion</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_methods</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <name>iVersion</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>recover_methods</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Uninstall the VFS wrapper that was installed around the file-descriptor open
** on the input database for recover handle p. Mutex RECOVER_MUTEX_ID must be
** held when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverUninstallWrapper</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>recoverAssertMutexHeld</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>,<argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFd</name> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name><name>recover_g</name><operator>.</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function does the work of a single sqlite3_recover_step() call. It
** is guaranteed that the handle is not in an error state when this
** function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>RECOVER_STATE_INIT</name></expr>:</case>
      <comment type="block">/* This is the very first call to sqlite3_recover_step() on this object.
      */</comment>
      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema = on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverInstallWrapper</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Open the output database. And register required virtual tables and 
      ** user functions with the new handle. */</comment>
      <expr_stmt><expr><call><name>recoverOpenOutput</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Open transactions on both the input and output databases. */</comment>
      <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_RESET_CACHE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema = on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bCloseTransaction</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM sqlite_schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverTransferSettings</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverOpenRecovery</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverCacheSchema</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverUninstallWrapper</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverWriteSchema1</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_WRITING</name></expr>;</expr_stmt>
      <break>break;</break>
      
    <case>case <expr><name>RECOVER_STATE_WRITING</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>w1</name><operator>.</operator><name>pTbls</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverWriteDataInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverWriteDataStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverWriteDataCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_LOSTANDFOUND1</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_SCHEMA2</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>RECOVER_STATE_LOSTANDFOUND1</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverLostAndFound1Init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverLostAndFound1Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_LOSTANDFOUND2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>RECOVER_STATE_LOSTANDFOUND2</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverLostAndFound2Init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverLostAndFound2Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_LOSTANDFOUND3</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>RECOVER_STATE_LOSTANDFOUND3</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pInsert</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverLostAndFound3Init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverLostAndFound3Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_SCHEMA2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>RECOVER_STATE_SCHEMA2</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>recoverWriteSchema2</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_DONE</name></expr>;</expr_stmt>

      <comment type="block">/* If no error has occurred, commit the write transaction on the output
      ** database. Regardless of whether or not an error has occurred, make
      ** an attempt to end the read transaction on the input database.  */</comment>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema = off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_DONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverFinalCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block><empty_stmt>;</empty_stmt>

    <case>case <expr><name>RECOVER_STATE_DONE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>
    </block_content>}</block><empty_stmt>;</empty_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** This is a worker function that does the heavy lifting for both init
** functions:
**
**     sqlite3_recover_init()
**     sqlite3_recover_init_sql()
**
** All this function does is allocate space for the recover handle and
** take copies of the input parameters. All the real work is done within
** sqlite3_recover_run().
*/</comment>
<function><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>recoverInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>,               <comment type="block">/* Output URI for _recover_init() */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSql</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,<comment type="block">/* SQL callback for _recover_init_sql() */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSqlCtx</name></decl></parameter>                   <comment type="block">/* Context arg for _recover_init_sql() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="string">"main"</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <call><name>recoverStrlen</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nUri</name> <operator>=</operator> <call><name>recoverStrlen</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_recover</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nDb</name><operator>+</operator><literal type="number">1</literal> <operator>+</operator> <name>nUri</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>sqlite3_recover</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>dbIn</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pRet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>zUri</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>zDb</name><index>[<expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nUri</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zUri</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>zUri</name></name></expr></argument>, <argument><expr><name>zUri</name></expr></argument>, <argument><expr><name>nUri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>xSql</name></name> <operator>=</operator> <name>xSql</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pSqlCtx</name></name> <operator>=</operator> <name>pSqlCtx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>bRecoverRowid</name></name> <operator>=</operator> <name>RECOVER_ROWID_DEFAULT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a recovery handle that creates a new database containing
** the recovered data.
*/</comment>
<function><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>sqlite3_recover_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a recovery handle that returns recovered data in the
** form of SQL statements via a callback.
*/</comment>
<function><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>sqlite3_recover_init_sql</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSql</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSqlCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xSql</name></expr></argument>, <argument><expr><name>pSqlCtx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the handle error message, if any.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_recover_errmsg</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_NOMEM</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> </then><else>: <expr><literal type="string">"out of memory"</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the handle error code.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr> </then><else>: <expr><name>SQLITE_NOMEM</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure the handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_config</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>RECOVER_STATE_INIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">789</literal></expr>:</case>
        <comment type="block">/* This undocumented magic configuration option is used to set the
        ** name of the auxiliary database that is ATTACH-ed to the database
        ** connection and used to hold state information during the
        ** recovery process.  This option is for debugging use only and
        ** is subject to change or removal at any time. */</comment>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_RECOVER_LOST_AND_FOUND</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zArg</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>SQLITE_RECOVER_FREELIST_CORRUPT</name></expr>:</case>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bFreelistCorrupt</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_RECOVER_ROWIDS</name></expr>:</case>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bRecoverRowid</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_RECOVER_SLOWINDEXES</name></expr>:</case>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bSlowIndexes</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do a unit of work towards the recovery job. Return SQLITE_OK if
** no error has occurred but database recovery is not finished, SQLITE_DONE
** if database recovery has been successfully completed, or an SQLite
** error code if an error has occurred.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>recoverStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>RECOVER_STATE_DONE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do the configured recovery operation. Return SQLITE_OK if successful, or
** else an SQLite error code.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_run</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>sqlite3_recover_step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
  <return>return <expr><call><name>sqlite3_recover_errcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Free all resources associated with the recover handle passed as the only
** argument. The results of using a handle with any sqlite3_recover_**
** API function after it has been passed to this function are undefined.
**
** A copy of the value returned by the first call made to sqlite3_recover_run()
** on this handle is returned, or SQLITE_OK if sqlite3_recover_run() has
** not been called on this handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_finish</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>recoverFinalCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bCloseTransaction</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3_get_autocommit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>
</unit>
