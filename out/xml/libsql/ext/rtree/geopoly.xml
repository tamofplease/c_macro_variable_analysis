<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/rtree/geopoly.c"><comment type="block">/*
** 2018-05-25
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file implements an alternative R-Tree virtual table that
** uses polygons to express the boundaries of 2-dimensional objects.
**
** This file is #include-ed onto the end of "rtree.c" so that it has
** access to all of the R-Tree internals.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Enable -DGEOPOLY_ENABLE_DEBUG for debugging facilities */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEOPOLY_ENABLE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>geo_debug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GEODEBUG</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if(geo_debug)printf X</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GEODEBUG</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Character class routines */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>sqlite3Isdigit</name></cpp:ifdef>
   <comment type="block">/* Use the SQLite core versions if this routine is part of the
   ** SQLite amalgamation */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>sqlite3Isdigit(x)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isalnum</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>sqlite3Isalnum(x)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isxdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3Isxdigit(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
   <comment type="block">/* Use the standard library for separate compilation */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>  <comment type="block">/* amalgamator: keep */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>isdigit((unsigned char)(x))</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isalnum</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>isalnum((unsigned char)(x))</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isxdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isxdigit((unsigned char)(x))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JSON_NULL</name></cpp:ifndef>   <comment type="block">/* The following stuff repeats things found in json1 */</comment>
<comment type="block">/*
** Growing our own isspace() routine this way is twice as fast as
** the library isspace() function.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>geopolyIsSpace</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fast_isspace</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(geopolyIsSpace[(unsigned char)x])</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JSON NULL - back to original code */</comment>

<comment type="block">/* Compiler and version */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GCC_VERSION</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_INTRINSIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_VERSION</name></cpp:macro> <cpp:value>(__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_VERSION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MSVC_VERSION</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_INTRINSIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MSVC_VERSION</name></cpp:macro> <cpp:value>_MSC_VER</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MSVC_VERSION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Datatype for coordinates
*/</comment>
<typedef>typedef <type><name>float</name></type> <name>GeoCoord</name>;</typedef>

<comment type="block">/*
** Internal representation of a polygon.
**
** The polygon consists of a sequence of vertexes.  There is a line
** segment between each pair of vertexes, and one final segment from
** the last vertex back to the first.  (This differs from the GeoJSON
** standard in which the final vertex is a repeat of the first.)
**
** The polygon follows the right-hand rule.  The area to the right of
** each segment is "outside" and the area to the left is "inside".
**
** The on-disk representation consists of a 4-byte header followed by
** the values.  The 4-byte header is:
**
**      encoding    (1 byte)   0=big-endian, 1=little-endian
**      nvertex     (3 bytes)  Number of vertexes as a big-endian integer
**
** Enough space is allocated for 4 coordinates, to work around over-zealous
** warnings coming from some compiler (notably, clang). In reality, the size
** of each GeoPoly memory allocate is adjusted as necessary so that the
** GeoPoly.a[] array at the end is the appropriate size.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>GeoPoly</name></name></type> <name>GeoPoly</name>;</typedef>
<struct>struct <name>GeoPoly</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nVertex</name></decl>;</decl_stmt>          <comment type="block">/* Number of vertexes */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hdr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Header for on-disk representation */</comment>
  <decl_stmt><decl><type><name>GeoCoord</name></type> <name><name>a</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* 2*nVertex values. X (longitude) first, then Y */</comment>
}</block>;</struct>

<comment type="block">/* The size of a memory allocation needed for a GeoPoly object sufficient
** to hold N coordinate pairs.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEOPOLY_SZ</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(sizeof(GeoPoly) + sizeof(GeoCoord)*2*((N)-4))</cpp:value></cpp:define>

<comment type="block">/* Macros to access coordinates of a GeoPoly.
** We have to use these macros, rather than just say p-&gt;a[i] in order
** to silence (incorrect) UBSAN warnings if the array index is too large.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GeoX</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((GeoCoord*)(P)-&gt;a)[(I)*2])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GeoY</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((GeoCoord*)(P)-&gt;a)[(I)*2+1])</cpp:value></cpp:define>


<comment type="block">/*
** State of a parse of a GeoJSON input.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>GeoParse</name></name></type> <name>GeoParse</name>;</typedef>
<struct>struct <name>GeoParse</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>   <comment type="block">/* Unparsed input */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVertex</name></decl>;</decl_stmt>              <comment type="block">/* Number of vertexes in a[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>               <comment type="block">/* Space allocated to a[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>                 <comment type="block">/* Number of errors encountered */</comment>
  <decl_stmt><decl><type><name>GeoCoord</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>          <comment type="block">/* Array of vertexes.  From sqlite3_malloc64() */</comment>
}</block>;</struct>

<comment type="block">/* Do a 4-byte byte swap */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolySwab32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>t</name> <init>= <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Skip whitespace.  Return the next non-whitespace character. */</comment>
<function><type><specifier>static</specifier> <name>char</name></type> <name>geopolySkipSpace</name><parameter_list>(<parameter><decl><type><name>GeoParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse out a number.  Write the value into *pVal if pVal!=0.
** return non-zero on success and zero if the next token is not a number.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyParseNumber</name><parameter_list>(<parameter><decl><type><name>GeoParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>GeoCoord</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name>geopolySkipSpace</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seenDP</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seenE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init>;</init><condition>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>safe_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>seenDP</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>seenDP</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>seenE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>seenDP</name> <operator>=</operator> <name>seenE</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>c</name><argument_list type="generic">&lt;<argument><expr><literal type="char">'0'</literal> <operator>||</operator> <name>c</name></expr></argument>&gt;</argument_list></name><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifdef>
     <comment type="block">/* The sqlite3AtoF() routine is much much faster than atof(), if it
     ** is available */</comment>
     <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
     <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
     <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>GeoCoord</name><operator>)</operator><call><name>atof</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>+=</operator> <name>j</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the input is a well-formed JSON array of coordinates with at least
** four coordinates and where each coordinate is itself a two-value array,
** then convert the JSON into a GeoPoly object and return a pointer to
** that object.
**
** If any error occurs, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>GeoPoly</name> <modifier>*</modifier></type><name>geopolyParseJson</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoParse</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>geopolySkipSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>.</operator><name>z</name></name><operator>++</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>geopolySkipSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>s</name><operator>.</operator><name>z</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>&gt;=</operator><name><name>s</name><operator>.</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>GeoCoord</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>nAlloc</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GeoCoord</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>s</name><operator>.</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><call><name>geopolyParseNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ii</name><operator>&lt;=</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>a</name><index>[<expr><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>*</operator><literal type="number">2</literal><operator>+</operator><name>ii</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>ii</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>ii</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>geopolySkipSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>z</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">']'</literal> <operator>&amp;&amp;</operator> <name>ii</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        <goto>goto <name>parse_json_err</name>;</goto>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><call><name>geopolySkipSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">','</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>z</name></name><operator>++</operator></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><call><name>geopolySkipSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">']'</literal>
     <operator>&amp;&amp;</operator> <name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>&gt;=</operator><literal type="number">4</literal>
     <operator>&amp;&amp;</operator> <name><name>s</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name><name>s</name><operator>.</operator><name>a</name><index>[<expr><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>*</operator><literal type="number">2</literal><operator>-</operator><literal type="number">2</literal></expr>]</index></name>
     <operator>&amp;&amp;</operator> <name><name>s</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name><name>s</name><operator>.</operator><name>a</name><index>[<expr><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>*</operator><literal type="number">2</literal><operator>-</operator><literal type="number">1</literal></expr>]</index></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>.</operator><name>z</name></name><operator>++</operator><operator>,</operator> <call><name>geopolySkipSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Remove the redundant vertex at the end */</comment>
      <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><call><name>GEOPOLY_SZ</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>s</name><operator>.</operator><name>nVertex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_json_err</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>nVertex</name></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>nVertex</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GeoCoord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>nVertex</name></name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>pOut</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>.</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>parse_json_err</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a function parameter, try to interpret it as a polygon, either
** in the binary format or JSON text.  Compute a GeoPoly object and
** return a pointer to that object.  Or if the input is not a well-formed
** polygon, put an error message in sqlite3_context and return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>GeoPoly</name> <modifier>*</modifier></type><name>geopolyFuncParam</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,      <comment type="block">/* Context for error messages */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,        <comment type="block">/* The value to decode */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                    <comment type="block">/* Write error here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>nByte</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><operator>(</operator><literal type="number">4</literal><operator>+</operator><literal type="number">6</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GeoCoord</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nVertex</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nVertex</name> <operator>=</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">1</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>nVertex</name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GeoCoord</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nByte</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>nVertex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GeoCoord</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name> <operator>=</operator> <name>nVertex</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nVertex</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>geopolySwab32</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>geopolySwab32</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>p</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zJson</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zJson</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>geopolyParseJson</name><argument_list>(<argument><expr><name>zJson</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the geopoly_blob(X) function.
**
** If the input is a well-formed Geopoly BLOB or JSON string
** then return the BLOB representation of the polygon.  Otherwise
** return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyBlobFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, 
       <argument><expr><literal type="number">4</literal><operator>+</operator><literal type="number">8</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:     geopoly_json(X)
**
** Interpret X as a polygon and render it as a JSON array
** of coordinates.  Or, if X is not a valid polygon, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyJsonFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"["</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"[%!g,%!g],"</literal></expr></argument>, <argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"[%!g,%!g]]"</literal></expr></argument>, <argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:     geopoly_svg(X, ....)
**
** Interpret X as a polygon and render it as a SVG &lt;polyline&gt;.
** Additional arguments are added as attributes to the &lt;polyline&gt;.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolySvgFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>cSep</name> <init>= <expr><literal type="char">'\''</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"&lt;polyline points="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"%c%g,%g"</literal></expr></argument>, <argument><expr><name>cSep</name></expr></argument>, <argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cSep</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">" %g,%g'"</literal></expr></argument>, <argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>z</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"&gt;&lt;/polyline&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL Function:      geopoly_xform(poly, A, B, C, D, E, F)
**
** Transform and/or translate a polygon as follows:
**
**      x1 = A*x0 + B*y0 + E
**      y1 = C*x0 + D*y0 + F
**
** For a translation:
**
**      geopoly_xform(poly, 1, 0, 0, 1, x-offset, y-offset)
**
** Rotate by R around the point (0,0):
**
**      geopoly_xform(poly, cos(R), sin(R), -sin(R), cos(R), 0, 0)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyXformFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>A</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>B</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>C</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>D</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>E</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>F</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoCoord</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>x0</name></decl>, <decl><type ref="prev"/><name>y0</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>x0</name> <operator>=</operator> <call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>y0</name> <operator>=</operator> <call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x1</name> <operator>=</operator> <operator>(</operator><name>GeoCoord</name><operator>)</operator><operator>(</operator><name>A</name><operator>*</operator><name>x0</name> <operator>+</operator> <name>B</name><operator>*</operator><name>y0</name> <operator>+</operator> <name>E</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>y1</name> <operator>=</operator> <operator>(</operator><name>GeoCoord</name><operator>)</operator><operator>(</operator><name>C</name><operator>*</operator><name>x0</name> <operator>+</operator> <name>D</name><operator>*</operator><name>y0</name> <operator>+</operator> <name>F</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>y1</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, 
       <argument><expr><literal type="number">4</literal><operator>+</operator><literal type="number">8</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compute the area enclosed by the polygon.
**
** This routine can also be used to detect polygons that rotate in
** the wrong direction.  Polygons are suppose to be counter-clockwise (CCW).
** This routine returns a negative value for clockwise (CW) polygons.
*/</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>geopolyArea</name><parameter_list>(<parameter><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>rArea</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rArea</name> <operator>+=</operator> <operator>(</operator><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>           <comment type="block">/* (x0 - x1) */</comment>
              <operator>*</operator> <operator>(</operator><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>        <comment type="block">/* (y0 + y1) */</comment>
              <operator>*</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rArea</name> <operator>+=</operator> <operator>(</operator><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>                <comment type="block">/* (xN - x0) */</comment>
           <operator>*</operator> <operator>(</operator><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>              <comment type="block">/* (yN + y0) */</comment>
           <operator>*</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
  <return>return <expr><name>rArea</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the geopoly_area(X) function.
**
** If the input is a well-formed Geopoly BLOB then return the area
** enclosed by the polygon.  If the polygon circulates clockwise instead
** of counterclockwise (as it should) then return the negative of the
** enclosed area.  Otherwise return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyAreaFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>geopolyArea</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>            
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the geopoly_ccw(X) function.
**
** If the rotation of polygon X is clockwise (incorrect) instead of
** counter-clockwise (the correct winding order according to RFC7946)
** then reverse the order of the vertexes in polygon X.  
**
** In other words, this routine returns a CCW polygon regardless of the
** winding order of its input.
**
** Use this routine to sanitize historical inputs that that sometimes
** contain polygons that wind in the wrong direction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyCcwFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>geopolyArea</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>jj</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>jj</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>jj</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>GeoCoord</name></type> <name>t</name> <init>= <expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>jj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>jj</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>jj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>jj</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, 
       <argument><expr><literal type="number">4</literal><operator>+</operator><literal type="number">8</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>            
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEOPOLY_PI</name></cpp:macro> <cpp:value>3.1415926535897932385</cpp:value></cpp:define>

<comment type="block">/* Fast approximation for sine(X) for X between -0.5*pi and 2*pi
*/</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>geopolySine</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name><operator>&gt;=</operator><operator>-</operator><literal type="number">0.5</literal><operator>*</operator><name>GEOPOLY_PI</name> <operator>&amp;&amp;</operator> <name>r</name><operator>&lt;=</operator><literal type="number">2.0</literal><operator>*</operator><name>GEOPOLY_PI</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;=</operator><literal type="number">1.5</literal><operator>*</operator><name>GEOPOLY_PI</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>-=</operator> <literal type="number">2.0</literal><operator>*</operator><name>GEOPOLY_PI</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;=</operator><literal type="number">0.5</literal><operator>*</operator><name>GEOPOLY_PI</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><call><name>geopolySine</name><argument_list>(<argument><expr><name>r</name><operator>-</operator><name>GEOPOLY_PI</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>r2</name> <init>= <expr><name>r</name><operator>*</operator><name>r</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>r3</name> <init>= <expr><name>r2</name><operator>*</operator><name>r</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>r5</name> <init>= <expr><name>r3</name><operator>*</operator><name>r2</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><literal type="number">0.9996949</literal><operator>*</operator><name>r</name> <operator>-</operator> <literal type="number">0.1656700</literal><operator>*</operator><name>r3</name> <operator>+</operator> <literal type="number">0.0075134</literal><operator>*</operator><name>r5</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Function:   geopoly_regular(X,Y,R,N)
**
** Construct a simple, convex, regular polygon centered at X, Y
** with circumradius R and with N sides.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyRegularFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">3</literal> <operator>||</operator> <name>r</name><operator>&lt;=</operator><literal type="number">0.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1000</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GeoCoord</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>n</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>n</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>rAngle</name> <init>= <expr><literal type="number">2.0</literal><operator>*</operator><name>GEOPOLY_PI</name><operator>*</operator><name>i</name><operator>/</operator><name>n</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>x</name> <operator>-</operator> <name>r</name><operator>*</operator><call><name>geopolySine</name><argument_list>(<argument><expr><name>rAngle</name><operator>-</operator><literal type="number">0.5</literal><operator>*</operator><name>GEOPOLY_PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>y</name> <operator>+</operator> <name>r</name><operator>*</operator><call><name>geopolySine</name><argument_list>(<argument><expr><name>rAngle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>+</operator><literal type="number">8</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If pPoly is a polygon, compute its bounding box. Then:
**
**    (1) if aCoord!=0 store the bounding box in aCoord, returning NULL
**    (2) otherwise, compute a GeoPoly for the bounding box and return the
**        new GeoPoly
**
** If pPoly is NULL but aCoord is not NULL, then compute a new GeoPoly from
** the bounding box in aCoord and return a pointer to that GeoPoly.
*/</comment>
<function><type><specifier>static</specifier> <name>GeoPoly</name> <modifier>*</modifier></type><name>geopolyBBox</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,   <comment type="block">/* For recording the error */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pPoly</name></decl></parameter>,       <comment type="block">/* The polygon */</comment>
  <parameter><decl><type><name>RtreeCoord</name> <modifier>*</modifier></type><name>aCoord</name></decl></parameter>,         <comment type="block">/* Results here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                    <comment type="block">/* Error code here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>mnX</name></decl>, <decl><type ref="prev"/><name>mxX</name></decl>, <decl><type ref="prev"/><name>mnY</name></decl>, <decl><type ref="prev"/><name>mxY</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPoly</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>aCoord</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>mnX</name> <operator>=</operator> <name><name>aCoord</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mxX</name> <operator>=</operator> <name><name>aCoord</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mnY</name> <operator>=</operator> <name><name>aCoord</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mxY</name> <operator>=</operator> <name><name>aCoord</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
    <goto>goto <name>geopolyBboxFill</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pPoly</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>mnX</name> <operator>=</operator> <name>mxX</name> <operator>=</operator> <call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mnY</name> <operator>=</operator> <name>mxY</name> <operator>=</operator> <call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><name>mnX</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mnX</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if<condition>( <expr><name>r</name><operator>&gt;</operator><name>mxX</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxX</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>GeoY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><name>mnY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mnY</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if<condition>( <expr><name>r</name><operator>&gt;</operator><name>mxY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxY</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>aCoord</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <label><name>geopolyBboxFill</name>:</label>
      <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>GEOPOLY_SZ</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>context</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>nVertex</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>ii</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ii</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mnX</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mnY</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mxX</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mnY</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mxX</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mxY</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mnX</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>mxY</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <name>mnX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <name>mxX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <name>mnY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <name>mxY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aCoord</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aCoord</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCoord</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the geopoly_bbox(X) SQL function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyBBoxFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>geopolyBBox</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, 
       <argument><expr><literal type="number">4</literal><operator>+</operator><literal type="number">8</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** State vector for the geopoly_group_bbox() aggregate function.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>GeoBBox</name></name></type> <name>GeoBBox</name>;</typedef>
<struct>struct <name>GeoBBox</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>isInit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCoord</name></type> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
** Implementation of the geopoly_group_bbox(X) aggregate SQL function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyBBoxStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeCoord</name></type> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>geopolyBBox</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>GeoBBox</name> <modifier>*</modifier></type><name>pBBox</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pBBox</name> <operator>=</operator> <operator>(</operator><name>GeoBBox</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pBBox</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBBox</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBBox</name><operator>-&gt;</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBBox</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBBox</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCoord</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>&lt;</operator> <name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>&gt;</operator> <name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>&lt;</operator> <name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>f</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>&gt;</operator> <name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>f</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBBox</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyBBoxFinal</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoBBox</name> <modifier>*</modifier></type><name>pBBox</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pBBox</name> <operator>=</operator> <operator>(</operator><name>GeoBBox</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBBox</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>geopolyBBox</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pBBox</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, 
       <argument><expr><literal type="number">4</literal><operator>+</operator><literal type="number">8</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Determine if point (x0,y0) is beneath line segment (x1,y1)-&gt;(x2,y2).
** Returns:
**
**    +2  x0,y0 is on the line segement
**
**    +1  x0,y0 is beneath line segment
**
**    0   x0,y0 is not on or beneath the line segment or the line segment
**        is vertical and x0,y0 is not on the line segment
**
** The left-most coordinate min(x1,x2) is not considered to be part of
** the line segment for the purposes of this analysis.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pointBeneathLine</name><parameter_list>(
  <parameter><decl><type><name>double</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y0</name></decl></parameter>,
  <parameter><decl><type><name>double</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y1</name></decl></parameter>,
  <parameter><decl><type><name>double</name></type> <name>x2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x0</name><operator>==</operator><name>x1</name> <operator>&amp;&amp;</operator> <name>y0</name><operator>==</operator><name>y1</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x1</name><operator>&lt;</operator><name>x2</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>x0</name><operator>&lt;=</operator><name>x1</name> <operator>||</operator> <name>x0</name><operator>&gt;</operator><name>x2</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x1</name><operator>&gt;</operator><name>x2</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>x0</name><operator>&lt;=</operator><name>x2</name> <operator>||</operator> <name>x0</name><operator>&gt;</operator><name>x1</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Vertical line segment */</comment>
    <if_stmt><if>if<condition>( <expr><name>x0</name><operator>!=</operator><name>x1</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>y0</name><operator>&lt;</operator><name>y1</name> <operator>&amp;&amp;</operator> <name>y0</name><operator>&lt;</operator><name>y2</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>y0</name><operator>&gt;</operator><name>y1</name> <operator>&amp;&amp;</operator> <name>y0</name><operator>&gt;</operator><name>y2</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>y</name> <operator>=</operator> <name>y1</name> <operator>+</operator> <operator>(</operator><name>y2</name><operator>-</operator><name>y1</name><operator>)</operator><operator>*</operator><operator>(</operator><name>x0</name><operator>-</operator><name>x1</name><operator>)</operator><operator>/</operator><operator>(</operator><name>x2</name><operator>-</operator><name>x1</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>y0</name><operator>==</operator><name>y</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>y0</name><operator>&lt;</operator><name>y</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:    geopoly_contains_point(P,X,Y)
**
** Return +2 if point X,Y is within polygon P.
** Return +1 if point X,Y is on the polygon boundary.
** Return 0 if point X,Y is outside the polygon
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyContainsPointFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>x0</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>y0</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nVertex</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>pointBeneathLine</name><argument_list>(<argument><expr><name>x0</name></expr></argument>,<argument><expr><name>y0</name></expr></argument>,<argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cnt</name> <operator>+=</operator> <name>v</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>pointBeneathLine</name><argument_list>(<argument><expr><name>x0</name></expr></argument>,<argument><expr><name>y0</name></expr></argument>,<argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>GeoX</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,  <argument><expr><call><name>GeoY</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><operator>(</operator><name>v</name><operator>+</operator><name>cnt</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>geopolyOverlap</name><parameter_list>(<parameter><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** SQL function:    geopoly_within(P1,P2)
**
** Return +2 if P1 and P2 are the same polygon
** Return +1 if P2 is contained within P1
** Return 0 if any part of P2 is on the outside of P1
**
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyWithinFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p1</name> <operator>&amp;&amp;</operator> <name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>geopolyOverlap</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><ternary><condition><expr><name>x</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><name>x</name><operator>==</operator><literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Objects used by the overlap algorihm. */</comment>
<typedef>typedef <type><name><name>struct</name> <name>GeoEvent</name></name></type> <name>GeoEvent</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>GeoSegment</name></name></type> <name>GeoSegment</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>GeoOverlap</name></name></type> <name>GeoOverlap</name>;</typedef>
<struct>struct <name>GeoEvent</name> <block>{
  <decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>              <comment type="block">/* X coordinate at which event occurs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>             <comment type="block">/* 0 for ADD, 1 for REMOVE */</comment>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>      <comment type="block">/* The segment to be added or removed */</comment>
  <decl_stmt><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>       <comment type="block">/* Next event in the sorted list */</comment>
}</block>;</struct>
<struct>struct <name>GeoSegment</name> <block>{
  <decl_stmt><decl><type><name>double</name></type> <name>C</name></decl>, <decl><type ref="prev"/><name>B</name></decl>;</decl_stmt>           <comment type="block">/* y = C*x + B */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>;</decl_stmt>              <comment type="block">/* Current y value */</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>y0</name></decl>;</decl_stmt>              <comment type="block">/* Initial y value */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>side</name></decl>;</decl_stmt>    <comment type="block">/* 1 for p1, 2 for p2 */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name></decl>;</decl_stmt>      <comment type="block">/* Which segment within the side */</comment>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>     <comment type="block">/* Next segment in a list sorted by y */</comment>
}</block>;</struct>
<struct>struct <name>GeoOverlap</name> <block>{
  <decl_stmt><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>aEvent</name></decl>;</decl_stmt>          <comment type="block">/* Array of all events */</comment>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>aSegment</name></decl>;</decl_stmt>      <comment type="block">/* Array of all segments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nEvent</name></decl>;</decl_stmt>                <comment type="block">/* Number of events */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSegment</name></decl>;</decl_stmt>              <comment type="block">/* Number of segments */</comment>
}</block>;</struct>

<comment type="block">/*
** Add a single segment and its associated events.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyAddOneSegment</name><parameter_list>(
  <parameter><decl><type><name>GeoOverlap</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>GeoCoord</name></type> <name>x0</name></decl></parameter>,
  <parameter><decl><type><name>GeoCoord</name></type> <name>y0</name></decl></parameter>,
  <parameter><decl><type><name>GeoCoord</name></type> <name>x1</name></decl></parameter>,
  <parameter><decl><type><name>GeoCoord</name></type> <name>y1</name></decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>side</name></decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>pEvent</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x0</name><operator>==</operator><name>x1</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Ignore vertical segments */</comment>
  <if_stmt><if>if<condition>( <expr><name>x0</name><operator>&gt;</operator><name>x1</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>GeoCoord</name></type> <name>t</name> <init>= <expr><name>x0</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>x0</name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>x1</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name>y0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y0</name> <operator>=</operator> <name>y1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y1</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aSegment</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nSegment</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSegment</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <operator>(</operator><name>y1</name><operator>-</operator><name>y0</name><operator>)</operator><operator>/</operator><operator>(</operator><name>x1</name><operator>-</operator><name>x0</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <name>y1</name> <operator>-</operator> <name>x1</name><operator>*</operator><name><name>pSeg</name><operator>-&gt;</operator><name>C</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>y0</name></name> <operator>=</operator> <name>y0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>side</name></name> <operator>=</operator> <name>side</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aEvent</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nEvent</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nEvent</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pEvent</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>x0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pEvent</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pEvent</name><operator>-&gt;</operator><name>pSeg</name></name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aEvent</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nEvent</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nEvent</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pEvent</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pEvent</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pEvent</name><operator>-&gt;</operator><name>pSeg</name></name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>
</block_content>}</block></function>
  


<comment type="block">/*
** Insert all segments and events for polygon pPoly.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyAddSegments</name><parameter_list>(
  <parameter><decl><type><name>GeoOverlap</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,          <comment type="block">/* Add segments to this Overlap object */</comment>
  <parameter><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>pPoly</name></decl></parameter>,         <comment type="block">/* Take all segments from this polygon */</comment>
  <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>side</name></decl></parameter>      <comment type="block">/* The side of pPoly */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoCoord</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>pPoly</name><operator>-&gt;</operator><name>nVertex</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>&amp;</operator><call><name>GeoX</name><argument_list>(<argument><expr><name>pPoly</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>geopolyAddOneSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>&amp;</operator><call><name>GeoX</name><argument_list>(<argument><expr><name>pPoly</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>geopolyAddOneSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPoly</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPoly</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Merge two lists of sorted events by X coordinate
*/</comment>
<function><type><specifier>static</specifier> <name>GeoEvent</name> <modifier>*</modifier></type><name>geopolyEventMerge</name><parameter_list>(<parameter><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoEvent</name></type> <name>head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>head</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLast</name> <operator>=</operator> <operator>&amp;</operator><name>head</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pRight</name> <operator>&amp;&amp;</operator> <name>pLeft</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>x</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLast</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLast</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>pLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <ternary><condition><expr><name>pRight</name></expr> ?</condition><then> <expr><name>pRight</name></expr> </then><else>: <expr><name>pLeft</name></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><name><name>head</name><operator>.</operator><name>pNext</name></name></expr>;</return>  
</block_content>}</block></function>

<comment type="block">/*
** Sort an array of nEvent event objects into a list.
*/</comment>
<function><type><specifier>static</specifier> <name>GeoEvent</name> <modifier>*</modifier></type><name>geopolySortEventsByX</name><parameter_list>(<parameter><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>aEvent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nEvent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nEvent</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>aEvent</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>mx</name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>geopolyEventMerge</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name>mx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mx</name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>geopolyEventMerge</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Merge two lists of sorted segments by Y, and then by C.
*/</comment>
<function><type><specifier>static</specifier> <name>GeoSegment</name> <modifier>*</modifier></type><name>geopolySegmentMerge</name><parameter_list>(<parameter><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoSegment</name></type> <name>head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>head</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLast</name> <operator>=</operator> <operator>&amp;</operator><name>head</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pRight</name> <operator>&amp;&amp;</operator> <name>pLeft</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><name><name>pRight</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>y</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>==</operator><literal type="number">0.0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>C</name></name> <operator>-</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>C</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLast</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLast</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>pLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <ternary><condition><expr><name>pRight</name></expr> ?</condition><then> <expr><name>pRight</name></expr> </then><else>: <expr><name>pLeft</name></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><name><name>head</name><operator>.</operator><name>pNext</name></name></expr>;</return>  
</block_content>}</block></function>

<comment type="block">/*
** Sort a list of GeoSegments in order of increasing Y and in the event of
** a tie, increasing C (slope).
*/</comment>
<function><type><specifier>static</specifier> <name>GeoSegment</name> <modifier>*</modifier></type><name>geopolySortSegmentsByYAndC</name><parameter_list>(<parameter><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mx</name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>geopolySegmentMerge</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>mx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mx</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>geopolySegmentMerge</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Determine the overlap between two polygons
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyOverlap</name><parameter_list>(<parameter><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nVertex</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>nVertex</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>nVertex</name></name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoOverlap</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoEvent</name> <modifier>*</modifier></type><name>pThisEvent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>rX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needSort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pActive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>aOverlap</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GeoEvent</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nVertex</name><operator>*</operator><literal type="number">2</literal> 
           <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GeoSegment</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nVertex</name> 
           <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GeoOverlap</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aEvent</name></name> <operator>=</operator> <operator>(</operator><name>GeoEvent</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aSegment</name></name> <operator>=</operator> <operator>(</operator><name>GeoSegment</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aEvent</name><index>[<expr><name>nVertex</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nEvent</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nSegment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>geopolyAddSegments</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>geopolyAddSegments</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pThisEvent</name> <operator>=</operator> <call><name>geopolySortEventsByX</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aEvent</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nEvent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rX</name> <operator>=</operator> <ternary><condition><expr><name>pThisEvent</name> <operator>&amp;&amp;</operator> <name><name>pThisEvent</name><operator>-&gt;</operator><name>x</name></name><operator>==</operator><literal type="number">0.0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.0</literal></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aOverlap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aOverlap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pThisEvent</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pThisEvent</name><operator>-&gt;</operator><name>x</name></name><operator>!=</operator><name>rX</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>GeoSegment</name> <modifier>*</modifier></type><name>pPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GEODEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Distinct X: %g\n"</literal><operator>,</operator> <name><name>pThisEvent</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rX</name> <operator>=</operator> <name><name>pThisEvent</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>needSort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>GEODEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SORT\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pActive</name> <operator>=</operator> <call><name>geopolySortSegmentsByYAndC</name><argument_list>(<argument><expr><name>pActive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>needSort</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>pSeg</name><operator>=</operator><name>pActive</name></expr>;</init> <condition><expr><name>pSeg</name></expr>;</condition> <incr><expr><name>pSeg</name><operator>=</operator><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pPrev</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pPrev</name><operator>-&gt;</operator><name>y</name></name><operator>!=</operator><name><name>pSeg</name><operator>-&gt;</operator><name>y</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>GEODEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MASK: %d\n"</literal><operator>,</operator> <name>iMask</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aOverlap</name><index>[<expr><name>iMask</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iMask</name> <operator>^=</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>side</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pSeg</name><operator>=</operator><name>pActive</name></expr>;</init> <condition><expr><name>pSeg</name></expr>;</condition> <incr><expr><name>pSeg</name><operator>=</operator><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>C</name></name><operator>*</operator><name>rX</name> <operator>+</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>B</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GEODEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Segment %d.%d %g-&gt;%g\n"</literal><operator>,</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>side</name></name><operator>,</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>idx</name></name><operator>,</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>y</name></name><operator>,</operator> <name>y</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pPrev</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pPrev</name><operator>-&gt;</operator><name>y</name></name><operator>&gt;</operator><name><name>pSeg</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>side</name></name><operator>!=</operator><name><name>pSeg</name><operator>-&gt;</operator><name>side</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GEODEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Crossing: %d.%d and %d.%d\n"</literal><operator>,</operator>
                    <name><name>pPrev</name><operator>-&gt;</operator><name>side</name></name><operator>,</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>idx</name></name><operator>,</operator>
                    <name><name>pSeg</name><operator>-&gt;</operator><name>side</name></name><operator>,</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>idx</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>geopolyOverlapDone</name>;</goto>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPrev</name><operator>-&gt;</operator><name>y</name></name><operator>!=</operator><name><name>pSeg</name><operator>-&gt;</operator><name>y</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>GEODEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MASK: %d\n"</literal><operator>,</operator> <name>iMask</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aOverlap</name><index>[<expr><name>iMask</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iMask</name> <operator>^=</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>side</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GEODEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%s %d.%d C=%g B=%g\n"</literal><operator>,</operator>
      <ternary><condition><expr><name><name>pThisEvent</name><operator>-&gt;</operator><name>eType</name></name></expr> ?</condition><then> <expr><literal type="string">"RM "</literal></expr> </then><else>: <expr><literal type="string">"ADD"</literal></expr></else></ternary><operator>,</operator>
      <name><name>pThisEvent</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>side</name></name><operator>,</operator> <name><name>pThisEvent</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>idx</name></name><operator>,</operator>
      <name><name>pThisEvent</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>C</name></name><operator>,</operator>
      <name><name>pThisEvent</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>B</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pThisEvent</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Add a segment */</comment>
      <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <name><name>pThisEvent</name><operator>-&gt;</operator><name>pSeg</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>y0</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pActive</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pActive</name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>needSort</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Remove a segment */</comment>
      <if_stmt><if>if<condition>( <expr><name>pActive</name><operator>==</operator><name><name>pThisEvent</name><operator>-&gt;</operator><name>pSeg</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pActive</name> <operator>=</operator> <ternary><condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pActive</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>pActive</name><operator>-&gt;</operator><name>pNext</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>pSeg</name><operator>=</operator><name>pActive</name></expr>;</init> <condition><expr><name>pSeg</name></expr>;</condition> <incr><expr><name>pSeg</name><operator>=</operator><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><name><name>pThisEvent</name><operator>-&gt;</operator><name>pSeg</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <ternary><condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>pSeg</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pNext</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pThisEvent</name> <operator>=</operator> <name><name>pThisEvent</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>aOverlap</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>aOverlap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aOverlap</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>aOverlap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aOverlap</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>aOverlap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aOverlap</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>geopolyOverlapDone</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:    geopoly_overlap(P1,P2)
**
** Determine whether or not P1 and P2 overlap. Return value:
**
**   0     The two polygons are disjoint
**   1     They overlap
**   2     P1 is completely contained within P2
**   3     P2 is completely contained within P1
**   4     P1 and P2 are the same polygon
**   NULL  Either P1 or P2 or both are not valid polygons
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyOverlapFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>geopolyFuncParam</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p1</name> <operator>&amp;&amp;</operator> <name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>geopolyOverlap</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Enable or disable debugging output
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geopolyDebugFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEOPOLY_ENABLE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>geo_debug</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* 
** This function is the implementation of both the xConnect and xCreate
** methods of the geopoly virtual table.
**
**   argv[0]   -&gt; module name
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[...] -&gt; column names...
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                        <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,                         <comment type="block">/* One of the RTREE_COORD_* constants */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,   <comment type="block">/* Parameters to CREATE TABLE statement */</comment>
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,              <comment type="block">/* OUT: New virtual table */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>,                       <comment type="block">/* OUT: Error message, if any */</comment>
  <parameter><decl><type><name>int</name></type> <name>isCreate</name></decl></parameter>                        <comment type="block">/* True for xCreate, false for xConnect */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nDb</name></decl>;</decl_stmt>              <comment type="block">/* Length of string argv[1] */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nName</name></decl>;</decl_stmt>            <comment type="block">/* Length of string argv[2] */</comment>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_CONSTRAINT_SUPPORT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate the sqlite3_vtab structure */</comment>
  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRtree</name> <operator>=</operator> <operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Rtree</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nDb</name><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRtree</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Rtree</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nDb</name><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pModule</name></name> <operator>=</operator> <operator>&amp;</operator><name>rtreeModule</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pRtree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name><index>[<expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name> <operator>=</operator> <name>RTREE_COORD_REAL32</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Create/Connect to the underlying relational database schema. If
  ** that is successful, call sqlite3_declare_vtab() to configure
  ** the r-tree table schema.
  */</comment>
  <expr_stmt><expr><name>pSql</name> <operator>=</operator> <call><name>sqlite3_str_new</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x(_shape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>         <comment type="block">/* Add one for _shape */</comment>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nAuxNotNull</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* The _shape column is always not-null */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>geopolyInit_fail</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>

  <comment type="block">/* Figure out the node size to use. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getNodeSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>isCreate</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>geopolyInit_fail</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeSqlInit</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>geopolyInit_fail</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name> <operator>*</operator><operator>)</operator><name>pRtree</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>geopolyInit_fail</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppVtab</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBusy</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
** GEOPOLY virtual table module xCreate method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyCreate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>geopolyInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** GEOPOLY virtual table module xConnect method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>geopolyInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
** GEOPOLY virtual table module xFilter method.
**
** Query plans:
**
**      1         rowid lookup
**      2         search for objects overlapping the same bounding box
**                that contains polygon argv[0]
**      3         search for objects overlapping the same bounding box
**                that contains polygon argv[0]
**      4         full table scan
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>,     <comment type="block">/* The cursor to initialize */</comment>
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>,                           <comment type="block">/* Query plan */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,                   <comment type="block">/* Not Used */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>        <comment type="block">/* Parameters to the query plan */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name><name>pVtabCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>rtreeReference</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the cursor to the same state as rtreeOpen() leaves it in. */</comment>
  <expr_stmt><expr><call><name>resetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iStrategy</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Special case - lookup by rowid. */</comment>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeaf</name></decl>;</decl_stmt>        <comment type="block">/* Leaf on which the required cell resides */</comment>
    <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>     <comment type="block">/* Search point for the leaf */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findLeafNode</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pLeaf</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>rtreeSearchPointNew</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>RTREE_ZERO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Always returns pCsr-&gt;sPoint */</comment>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pLeaf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>iNode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eWithin</name></name> <operator>=</operator> <name>PARTLY_WITHIN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeRowidIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iCell</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"PUSH-F1:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>atEOF</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Normal case - r-tree scan. Set up the RtreeCursor.aConstraint array 
    ** with the configured constraints. 
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>idxNum</name><operator>&lt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeCoord</name></type> <name><name>bbox</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>geopolyBBox</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bbox</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>geopoly_filter_end</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeConstraint</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nConstraint</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeConstraint</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>anQueue</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Overlap query */</comment>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'D'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'D'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Within query */</comment>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'D'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'D'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name><name>bbox</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>rtreeSearchPointNew</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>RTREE_ZERO</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>geopoly_filter_end</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eWithin</name></name> <operator>=</operator> <name>PARTLY_WITHIN</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bPoint</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"PUSH-Fm:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeStepToLeaf</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>geopoly_filter_end</name>:</label>
  <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rtree virtual table module xBestIndex method. There are three
** table scan strategies to choose from (in order from most to 
** least desirable):
**
**   idxNum     idxStr        Strategy
**   ------------------------------------------------
**     1        "rowid"       Direct lookup by rowid.
**     2        "rtree"       R-tree overlap query using geopoly_overlap()
**     3        "rtree"       R-tree within query using geopoly_within()
**     4        "fullscan"    full-table scan.
**   ------------------------------------------------
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowidTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFuncTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>  )</condition><block>{<block_content>
      <expr_stmt><expr><name>iRowidTerm</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>&gt;=</operator><name>SQLITE_INDEX_CONSTRAINT_FUNCTION</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* p-&gt;op==SQLITE_INDEX_CONSTRAINT_FUNCTION for geopoly_overlap()
      ** p-&gt;op==(SQLITE_INDEX_CONTRAINT_FUNCTION+1) for geopoly_within().
      ** See geopolyFindFunction() */</comment>
      <expr_stmt><expr><name>iFuncTerm</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxNum</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>-</operator> <name>SQLITE_INDEX_CONSTRAINT_FUNCTION</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>iRowidTerm</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="string">"rowid"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iRowidTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iRowidTerm</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">30.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>=</operator> <name>SQLITE_INDEX_SCAN_UNIQUE</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFuncTerm</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="string">"rtree"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iFuncTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iFuncTerm</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">300.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="string">"fullscan"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">3000000.0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">100000</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
** GEOPOLY virtual table module xColumn method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>rtreeSearchPointFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><call><name>rtreeNodeOfFirstSearchPoint</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_vtab_nochange</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;=</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>bAuxValid</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v3</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zReadAuxSql</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
          <argument><expr><call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bAuxValid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The xUpdate method for GEOPOLY module virtual tables.
**
** For DELETE:
**
**     argv[0] = the rowid to be deleted
**
** For INSERT:
**
**     argv[0] = SQL NULL
**     argv[1] = rowid to insert, or an SQL NULL to select automatically
**     argv[2] = _shape column
**     argv[3] = first application-defined column....
**
** For UPDATE:
**
**     argv[0] = rowid to modify.  Never NULL
**     argv[1] = rowid after the change.  Never NULL
**     argv[2] = new value for _shape
**     argv[3] = new value for first application-defined column....
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyUpdate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>                 <comment type="block">/* New cell to insert if nData&gt;1 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>oldRowid</name></decl>;</decl_stmt>                   <comment type="block">/* The old rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>oldRowidValid</name></decl>;</decl_stmt>              <comment type="block">/* True if oldRowid is valid */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>newRowid</name></decl>;</decl_stmt>                   <comment type="block">/* The new rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>newRowidValid</name></decl>;</decl_stmt>              <comment type="block">/* True if newRowid is valid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>coordChange</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Change in coordinates */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Unable to write to the btree while another cursor is reading from it,
    ** since the write might do a rebalance which would disrupt the read
    ** cursor. */</comment>
    <return>return <expr><name>SQLITE_LOCKED_VTAB</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>rtreeReference</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nData</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>oldRowidValid</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name>oldRowid</name> <operator>=</operator> <ternary><condition><expr><name>oldRowidValid</name></expr> ?</condition><then> <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>newRowidValid</name> <operator>=</operator> <name>nData</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>newRowid</name> <operator>=</operator> <ternary><condition><expr><name>newRowidValid</name></expr> ?</condition><then> <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name> <operator>=</operator> <name>newRowid</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&gt;</operator><literal type="number">1</literal>                                 <comment type="block">/* not a DELETE */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>oldRowidValid</name>                         <comment type="block">/* INSERT */</comment>
        <operator>||</operator> <operator>!</operator><call><name>sqlite3_value_nochange</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call>  <comment type="block">/* UPDATE _shape */</comment>
        <operator>||</operator> <name>oldRowid</name><operator>!=</operator><name>newRowid</name><operator>)</operator></expr>                <comment type="block">/* Rowid change */</comment>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>geopolyBBox</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>aCoord</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator>
          <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"_shape does not contain a valid polygon"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>geopoly_update_end</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>coordChange</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* If a rowid value was supplied, check if it is already present in 
    ** the table. If so, the constraint has failed. */</comment>
    <if_stmt><if>if<condition>( <expr><name>newRowidValid</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>oldRowidValid</name> <operator>||</operator> <name>oldRowid</name><operator>!=</operator><name>newRowid</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>steprc</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>steprc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><name>steprc</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_vtab_on_conflict</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_REPLACE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeDeleteRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeConstraintError</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If aData[0] is not an SQL NULL value, it is the rowid of a
  ** record to delete from the r-tree table. The following block does
  ** just that.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nData</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>coordChange</name> <operator>&amp;&amp;</operator> <name>oldRowidValid</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeDeleteRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>oldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the aData[] array contains more than one element, elements
  ** (aData[2]..aData[argc-1]) contain a new record to insert into
  ** the r-tree structure.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>coordChange</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Insert the new record into the r-tree */</comment>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeaf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>newRowidValid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeNewRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ChooseLeaf</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iReinsertHeight</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Change the data */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteAux</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nChange</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_nochange</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>GeoPoly</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TEXT</name>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>=</operator> <call><name>geopolyFuncParam</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>+</operator><literal type="number">8</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nVertex</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nChange</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nData</name><operator>-</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>nChange</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><name>jj</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>aData</name><index>[<expr><name>jj</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nChange</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>geopoly_update_end</name>:</label>
  <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Report that geopoly_overlap() is an overloaded function suitable
** for use in xBestIndex.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>geopolyFindFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>pxFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"geopoly_overlap"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>geopolyOverlapFunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppArg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_INDEX_CONSTRAINT_FUNCTION</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"geopoly_within"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>geopolyWithinFunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppArg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_INDEX_CONSTRAINT_FUNCTION</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>geopolyModule</name> <init>= <expr><block>{
  <expr><literal type="number">3</literal></expr>,                          <comment type="block">/* iVersion */</comment>
  <expr><name>geopolyCreate</name></expr>,              <comment type="block">/* xCreate - create a table */</comment>
  <expr><name>geopolyConnect</name></expr>,             <comment type="block">/* xConnect - connect to an existing table */</comment>
  <expr><name>geopolyBestIndex</name></expr>,           <comment type="block">/* xBestIndex - Determine search strategy */</comment>
  <expr><name>rtreeDisconnect</name></expr>,            <comment type="block">/* xDisconnect - Disconnect from a table */</comment>
  <expr><name>rtreeDestroy</name></expr>,               <comment type="block">/* xDestroy - Drop a table */</comment>
  <expr><name>rtreeOpen</name></expr>,                  <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>rtreeClose</name></expr>,                 <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>geopolyFilter</name></expr>,              <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>rtreeNext</name></expr>,                  <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>rtreeEof</name></expr>,                   <comment type="block">/* xEof */</comment>
  <expr><name>geopolyColumn</name></expr>,              <comment type="block">/* xColumn - read data */</comment>
  <expr><name>rtreeRowid</name></expr>,                 <comment type="block">/* xRowid - read data */</comment>
  <expr><name>geopolyUpdate</name></expr>,              <comment type="block">/* xUpdate - write data */</comment>
  <expr><name>rtreeBeginTransaction</name></expr>,      <comment type="block">/* xBegin - begin transaction */</comment>
  <expr><name>rtreeEndTransaction</name></expr>,        <comment type="block">/* xSync - sync transaction */</comment>
  <expr><name>rtreeEndTransaction</name></expr>,        <comment type="block">/* xCommit - commit transaction */</comment>
  <expr><name>rtreeEndTransaction</name></expr>,        <comment type="block">/* xRollback - rollback transaction */</comment>
  <expr><name>geopolyFindFunction</name></expr>,        <comment type="block">/* xFindFunction - function overloading */</comment>
  <expr><name>rtreeRename</name></expr>,                <comment type="block">/* xRename - rename the table */</comment>
  <expr><name>rtreeSavepoint</name></expr>,             <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* xRollbackTo */</comment>
  <expr><name>rtreeShadowName</name></expr>             <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3_geopoly_init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>nArg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bPure</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aFunc</name><index>[]</index></name> <init>= <expr><block>{
     <expr><block>{ <expr><name>geopolyAreaFunc</name></expr>,          <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_area"</literal></expr>             }</block></expr>,
     <expr><block>{ <expr><name>geopolyBlobFunc</name></expr>,          <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_blob"</literal></expr>             }</block></expr>,
     <expr><block>{ <expr><name>geopolyJsonFunc</name></expr>,          <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_json"</literal></expr>             }</block></expr>,
     <expr><block>{ <expr><name>geopolySvgFunc</name></expr>,          <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_svg"</literal></expr>              }</block></expr>,
     <expr><block>{ <expr><name>geopolyWithinFunc</name></expr>,        <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_within"</literal></expr>           }</block></expr>,
     <expr><block>{ <expr><name>geopolyContainsPointFunc</name></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_contains_point"</literal></expr>   }</block></expr>,
     <expr><block>{ <expr><name>geopolyOverlapFunc</name></expr>,       <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_overlap"</literal></expr>          }</block></expr>,
     <expr><block>{ <expr><name>geopolyDebugFunc</name></expr>,         <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,    <expr><literal type="string">"geopoly_debug"</literal></expr>            }</block></expr>,
     <expr><block>{ <expr><name>geopolyBBoxFunc</name></expr>,          <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_bbox"</literal></expr>             }</block></expr>,
     <expr><block>{ <expr><name>geopolyXformFunc</name></expr>,         <expr><literal type="number">7</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_xform"</literal></expr>            }</block></expr>,
     <expr><block>{ <expr><name>geopolyRegularFunc</name></expr>,       <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_regular"</literal></expr>          }</block></expr>,
     <expr><block>{ <expr><name>geopolyCcwFunc</name></expr>,           <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,    <expr><literal type="string">"geopoly_ccw"</literal></expr>              }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aAgg</name><index>[]</index></name> <init>= <expr><block>{
     <expr><block>{ <expr><name>geopolyBBoxStep</name></expr>, <expr><name>geopolyBBoxFinal</name></expr>, <expr><literal type="string">"geopoly_group_bbox"</literal></expr>    }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFunc</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>enc</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bPure</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name><operator>|</operator><name>SQLITE_INNOCUOUS</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DIRECTONLY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>,
                                 <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aAgg</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aAgg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aAgg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
              <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name><operator>|</operator><name>SQLITE_INNOCUOUS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
              <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aAgg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xStep</name></expr></argument>, <argument><expr><name><name>aAgg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"geopoly"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>geopolyModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
