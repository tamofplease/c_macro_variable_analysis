<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/session/sqlite3session.c">
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_PREUPDATE_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>SessionTable</name></name></type> <name>SessionTable</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>SessionChange</name></name></type> <name>SessionChange</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>SessionBuffer</name></name></type> <name>SessionBuffer</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>SessionInput</name></name></type> <name>SessionInput</name>;</typedef>

<comment type="block">/*
** Minimum chunk size used by streaming versions of functions.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SESSIONS_STRM_CHUNK_SIZE</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SESSIONS_STRM_CHUNK_SIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SESSIONS_STRM_CHUNK_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sessions_strm_chunk_size</name> <init>= <expr><name>SESSIONS_STRM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><name><name>struct</name> <name>SessionHook</name></name></type> <name>SessionHook</name>;</typedef>
<struct>struct <name>SessionHook</name> <block>{
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOld</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xNew</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCount</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xDepth</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>

<comment type="block">/*
** Session handle structure.
*/</comment>
<struct>struct <name>sqlite3_session</name> <block>{
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle session is attached to */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                      <comment type="block">/* Name of database session is attached to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bEnableSize</name></decl>;</decl_stmt>                <comment type="block">/* True if changeset_size() enabled */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bEnable</name></decl>;</decl_stmt>                    <comment type="block">/* True if currently recording */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIndirect</name></decl>;</decl_stmt>                  <comment type="block">/* True if all changes are indirect */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bAutoAttach</name></decl>;</decl_stmt>                <comment type="block">/* True to auto-attach tables */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Non-zero if an error has occurred */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pFilterCtx</name></decl>;</decl_stmt>               <comment type="block">/* First argument to pass to xTableFilter */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xTableFilter</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>i64</name></type> <name>nMalloc</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes of data allocated */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nMaxChangesetSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pZeroBlob</name></decl>;</decl_stmt>       <comment type="block">/* Value containing X'' */</comment>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>         <comment type="block">/* Next session object on same db. */</comment>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTable</name></decl>;</decl_stmt>           <comment type="block">/* List of attached tables */</comment>
  <decl_stmt><decl><type><name>SessionHook</name></type> <name>hook</name></decl>;</decl_stmt>               <comment type="block">/* APIs to grab new and old data with */</comment>
}</block>;</struct>

<comment type="block">/*
** Instances of this structure are used to build strings or binary records.
*/</comment>
<struct>struct <name>SessionBuffer</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl>;</decl_stmt>                       <comment type="block">/* Pointer to changeset buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name></decl>;</decl_stmt>                       <comment type="block">/* Size of buffer aBuf */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>                     <comment type="block">/* Size of allocation containing aBuf */</comment>
}</block>;</struct>

<comment type="block">/*
** An object of this type is used internally as an abstraction for 
** input data. Input data may be supplied either as a single large buffer
** (e.g. sqlite3changeset_start()) or using a stream function (e.g.
**  sqlite3changeset_start_strm()).
*/</comment>
<struct>struct <name>SessionInput</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bNoDiscard</name></decl>;</decl_stmt>                 <comment type="block">/* If true, do not discard in InputBuffer() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name></decl>;</decl_stmt>                   <comment type="block">/* Offset in aData[] of current change */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iNext</name></decl>;</decl_stmt>                      <comment type="block">/* Offset in aData[] of next change */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                      <comment type="block">/* Pointer to buffer containing changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes in aData */</comment>

  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf</name></decl>;</decl_stmt>              <comment type="block">/* Current read buffer */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>        <comment type="block">/* Input stream call (or NULL) */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>                                <comment type="block">/* First argument to xInput */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bEof</name></decl>;</decl_stmt>                       <comment type="block">/* Set to true after xInput finished */</comment>
}</block>;</struct>

<comment type="block">/*
** Structure for changeset iterators.
*/</comment>
<struct>struct <name>sqlite3_changeset_iter</name> <block>{
  <decl_stmt><decl><type><name>SessionInput</name></type> <name>in</name></decl>;</decl_stmt>                <comment type="block">/* Input buffer or stream */</comment>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>tblhdr</name></decl>;</decl_stmt>           <comment type="block">/* Buffer to hold apValue/zTab/abPK/ */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPatchset</name></decl>;</decl_stmt>                  <comment type="block">/* True if this is a patchset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bInvert</name></decl>;</decl_stmt>                    <comment type="block">/* True to invert changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSkipEmpty</name></decl>;</decl_stmt>                 <comment type="block">/* Skip noop UPDATE changes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Iterator error code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pConflict</name></decl>;</decl_stmt>        <comment type="block">/* Points to conflicting row, if any */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>                     <comment type="block">/* Current table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in zTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                         <comment type="block">/* Current operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIndirect</name></decl>;</decl_stmt>                  <comment type="block">/* True if current change was indirect */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl>;</decl_stmt>                       <comment type="block">/* Primary key array */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apValue</name></decl>;</decl_stmt>        <comment type="block">/* old.* and new.* values */</comment>
}</block>;</struct>

<comment type="block">/*
** Each session object maintains a set of the following structures, one
** for each table the session object is monitoring. The structures are
** stored in a linked list starting at sqlite3_session.pTable.
**
** The keys of the SessionTable.aChange[] hash table are all rows that have
** been modified in any way since the session object was attached to the
** table.
**
** The data associated with each hash-table entry is a structure containing
** a subset of the initial values that the modified row contained at the
** start of the session. Or no initial values if the row was inserted.
*/</comment>
<struct>struct <name>SessionTable</name> <block>{
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                    <comment type="block">/* Local name of table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in table zName */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bStat1</name></decl>;</decl_stmt>                     <comment type="block">/* True if this is sqlite_stat1 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl>;</decl_stmt>             <comment type="block">/* Column names */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl>;</decl_stmt>                       <comment type="block">/* Array of primary key flags */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>                     <comment type="block">/* Total number of entries in hash table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChange</name></decl>;</decl_stmt>                    <comment type="block">/* Size of apChange[] array */</comment>
  <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier><modifier>*</modifier></type><name>apChange</name></decl>;</decl_stmt>       <comment type="block">/* Hash table buckets */</comment>
}</block>;</struct>

<comment type="block">/* 
** RECORD FORMAT:
**
** The following record format is similar to (but not compatible with) that 
** used in SQLite database files. This format is used as part of the 
** change-set binary format, and so must be architecture independent.
**
** Unlike the SQLite database record format, each field is self-contained -
** there is no separation of header and data. Each field begins with a
** single byte describing its type, as follows:
**
**       0x00: Undefined value.
**       0x01: Integer value.
**       0x02: Real value.
**       0x03: Text value.
**       0x04: Blob value.
**       0x05: SQL NULL value.
**
** Note that the above match the definitions of SQLITE_INTEGER, SQLITE_TEXT
** and so on in sqlite3.h. For undefined and NULL values, the field consists
** only of the single type byte. For other types of values, the type byte
** is followed by:
**
**   Text values:
**     A varint containing the number of bytes in the value (encoded using
**     UTF-8). Followed by a buffer containing the UTF-8 representation
**     of the text value. There is no nul terminator.
**
**   Blob values:
**     A varint containing the number of bytes in the value, followed by
**     a buffer containing the value itself.
**
**   Integer values:
**     An 8-byte big-endian integer value.
**
**   Real values:
**     An 8-byte big-endian IEEE 754-2008 real value.
**
** Varint values are encoded in the same way as varints in the SQLite 
** record format.
**
** CHANGESET FORMAT:
**
** A changeset is a collection of DELETE, UPDATE and INSERT operations on
** one or more tables. Operations on a single table are grouped together,
** but may occur in any order (i.e. deletes, updates and inserts are all
** mixed together).
**
** Each group of changes begins with a table header:
**
**   1 byte: Constant 0x54 (capital 'T')
**   Varint: Number of columns in the table.
**   nCol bytes: 0x01 for PK columns, 0x00 otherwise.
**   N bytes: Unqualified table name (encoded using UTF-8). Nul-terminated.
**
** Followed by one or more changes to the table.
**
**   1 byte: Either SQLITE_INSERT (0x12), UPDATE (0x17) or DELETE (0x09).
**   1 byte: The "indirect-change" flag.
**   old.* record: (delete and update only)
**   new.* record: (insert and update only)
**
** The "old.*" and "new.*" records, if present, are N field records in the
** format described above under "RECORD FORMAT", where N is the number of
** columns in the table. The i'th field of each record is associated with
** the i'th column of the table, counting from left to right in the order
** in which columns were declared in the CREATE TABLE statement.
**
** The new.* record that is part of each INSERT change contains the values
** that make up the new row. Similarly, the old.* record that is part of each
** DELETE change contains the values that made up the row that was deleted 
** from the database. In the changeset format, the records that are part
** of INSERT or DELETE changes never contain any undefined (type byte 0x00)
** fields.
**
** Within the old.* record associated with an UPDATE change, all fields
** associated with table columns that are not PRIMARY KEY columns and are
** not modified by the UPDATE change are set to "undefined". Other fields
** are set to the values that made up the row before the UPDATE that the
** change records took place. Within the new.* record, fields associated 
** with table columns modified by the UPDATE change contain the new 
** values. Fields associated with table columns that are not modified
** are set to "undefined".
**
** PATCHSET FORMAT:
**
** A patchset is also a collection of changes. It is similar to a changeset,
** but leaves undefined those fields that are not useful if no conflict
** resolution is required when applying the changeset.
**
** Each group of changes begins with a table header:
**
**   1 byte: Constant 0x50 (capital 'P')
**   Varint: Number of columns in the table.
**   nCol bytes: 0x01 for PK columns, 0x00 otherwise.
**   N bytes: Unqualified table name (encoded using UTF-8). Nul-terminated.
**
** Followed by one or more changes to the table.
**
**   1 byte: Either SQLITE_INSERT (0x12), UPDATE (0x17) or DELETE (0x09).
**   1 byte: The "indirect-change" flag.
**   single record: (PK fields for DELETE, PK and modified fields for UPDATE,
**                   full record for INSERT).
**
** As in the changeset format, each field of the single record that is part
** of a patchset change is associated with the correspondingly positioned
** table column, counting from left to right within the CREATE TABLE 
** statement.
**
** For a DELETE change, all fields within the record except those associated
** with PRIMARY KEY columns are omitted. The PRIMARY KEY fields contain the
** values identifying the row to delete.
**
** For an UPDATE change, all fields except those associated with PRIMARY KEY
** columns and columns that are modified by the UPDATE are set to "undefined".
** PRIMARY KEY fields contain the values identifying the table row to update,
** and fields associated with modified columns contain the new column values.
**
** The records associated with INSERT changes are in the same format as for
** changesets. It is not possible for a record associated with an INSERT
** change to contain a field set to "undefined".
**
** REBASE BLOB FORMAT:
**
** A rebase blob may be output by sqlite3changeset_apply_v2() and its 
** streaming equivalent for use with the sqlite3_rebaser APIs to rebase
** existing changesets. A rebase blob contains one entry for each conflict
** resolved using either the OMIT or REPLACE strategies within the apply_v2()
** call.
**
** The format used for a rebase blob is very similar to that used for
** changesets. All entries related to a single table are grouped together.
**
** Each group of entries begins with a table header in changeset format:
**
**   1 byte: Constant 0x54 (capital 'T')
**   Varint: Number of columns in the table.
**   nCol bytes: 0x01 for PK columns, 0x00 otherwise.
**   N bytes: Unqualified table name (encoded using UTF-8). Nul-terminated.
**
** Followed by one or more entries associated with the table.
**
**   1 byte: Either SQLITE_INSERT (0x12), DELETE (0x09).
**   1 byte: Flag. 0x01 for REPLACE, 0x00 for OMIT.
**   record: (in the record format defined above).
**
** In a rebase blob, the first field is set to SQLITE_INSERT if the change
** that caused the conflict was an INSERT or UPDATE, or to SQLITE_DELETE if
** it was a DELETE. The second field is set to 0x01 if the conflict 
** resolution strategy was REPLACE, or 0x00 if it was OMIT.
**
** If the change that caused the conflict was a DELETE, then the single
** record is a copy of the old.* record from the original changeset. If it
** was an INSERT, then the single record is a copy of the new.* record. If
** the conflicting change was an UPDATE, then the single record is a copy
** of the new.* record with the PK fields filled in based on the original
** old.* record.
*/</comment>

<comment type="block">/*
** For each row modified during a session, there exists a single instance of
** this structure stored in a SessionTable.aChange[] hash table.
*/</comment>
<struct>struct <name>SessionChange</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>                          <comment type="block">/* One of UPDATE, DELETE, INSERT */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bIndirect</name></decl>;</decl_stmt>                   <comment type="block">/* True if this change is "indirect" */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxSize</name></decl>;</decl_stmt>                   <comment type="block">/* Max size of eventual changeset record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRecord</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes in buffer aRecord[] */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRecord</name></decl>;</decl_stmt>                    <comment type="block">/* Buffer containing old.* record */</comment>
  <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* For hash-table collisions */</comment>
}</block>;</struct>

<comment type="block">/*
** Write a varint with value iVal into the buffer at aBuf. Return the 
** number of bytes written.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionVarintPut</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>putVarint32</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes required to store value iVal as a varint.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionVarintLen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read a varint value from aBuf[] into *piVal. Return the number of 
** bytes read.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionVarintGet</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>getVarint32</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><operator>*</operator><name>piVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Load an unaligned and unsigned 32-bit integer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SESSION_UINT32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((u32)(x)[0]&lt;&lt;24)|((x)[1]&lt;&lt;16)|((x)[2]&lt;&lt;8)|(x)[3])</cpp:value></cpp:define>

<comment type="block">/*
** Read a 64-bit big-endian integer value from buffer aRec[]. Return
** the value read.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>sessionGetI64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><call><name>SESSION_UINT32</name><argument_list>(<argument><expr><name>aRec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>y</name> <init>= <expr><call><name>SESSION_UINT32</name><argument_list>(<argument><expr><name>aRec</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>y</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write a 64-bit big-endian integer value to the buffer aBuf[].
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionPutI64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">56</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">48</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">40</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to serialize the contents of value pValue (see
** comment titled "RECORD FORMAT" above).
**
** If it is non-NULL, the serialized form of the value is written to 
** buffer aBuf. *pnWrite is set to the number of bytes written before
** returning. Or, if aBuf is NULL, the only thing this function does is
** set *pnWrite.
**
** If no error occurs, SQLITE_OK is returned. Or, if an OOM error occurs
** within a call to sqlite3_value_text() (may fail if the db is utf-16)) 
** SQLITE_NOMEM is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionSerializeValue</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>,                       <comment type="block">/* If non-NULL, write serialized value here */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>,          <comment type="block">/* Value to serialize */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>          <comment type="block">/* IN/OUT: Increment by bytes written */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Size of serialized value in bytes */</comment>

  <if_stmt><if>if<condition>( <expr><name>pValue</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                    <comment type="block">/* Value type (SQLITE_NULL, TEXT etc.) */</comment>
  
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
    <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_NULL</name></expr>:</case> 
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
  
      <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> 
      <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>aBuf</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* TODO: SQLite does something special to deal with mixed-endian
          ** floating point values (e.g. ARM7). This code probably should
          ** too.  */</comment>
          <decl_stmt><decl><type><name>u64</name></type> <name>i</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>u64</name><operator>)</operator><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u64</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sessionPutI64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt> 
        <break>break;</break>
  
      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nVarint</name></decl>;</decl_stmt>
  
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator> <name>n</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nVarint</name> <operator>=</operator> <call><name>sessionVarintLen</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
        <if_stmt><if>if<condition>( <expr><name>aBuf</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sessionVarintPut</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>nVarint</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
  
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>nVarint</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pnWrite</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a pointer to a buffer nByte bytes in size. If
** pSession is not NULL, increase the sqlite3_session.nMalloc variable
** by the number of bytes allocated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>sessionMalloc64</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSession</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>nMalloc</name></name> <operator>+=</operator> <call><name>sqlite3_msize</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free buffer pFree, which must have been allocated by an earlier
** call to sessionMalloc64(). If pSession is not NULL, decrease the
** sqlite3_session.nMalloc counter by the number of bytes freed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionFree</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pFree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pSession</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>nMalloc</name></name> <operator>-=</operator> <call><name>sqlite3_msize</name><argument_list>(<argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This macro is used to calculate hash key values for data structures. In
** order to use this macro, the entire data structure must be represented
** as a series of unsigned integers. In order to calculate a hash-key value
** for a data structure represented as three such integers, the macro may
** then be used as follows:
**
**    int hash_key_value;
**    hash_key_value = HASH_APPEND(0, &lt;value 1&gt;);
**    hash_key_value = HASH_APPEND(hash_key_value, &lt;value 2&gt;);
**    hash_key_value = HASH_APPEND(hash_key_value, &lt;value 3&gt;);
**
** In practice, the data structures this macro is used for are the primary
** key values of modified rows.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_APPEND</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((hash) &lt;&lt; 3) ^ (hash) ^ (unsigned int)(add)</cpp:value></cpp:define>

<comment type="block">/*
** Append the hash of the 64-bit integer passed as the second argument to the
** hash-key value passed as the first. Return the new hash-key value.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>sessionHashAppendI64</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>HASH_APPEND</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>HASH_APPEND</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFFFFFFFF</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append the hash of the blob passed via the second and third arguments to 
** the hash-key value passed as the first. Return the new hash-key value.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>sessionHashAppendBlob</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>HASH_APPEND</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append the hash of the data type passed as the second argument to the
** hash-key value passed as the first. Return the new hash-key value.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>sessionHashAppendType</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>HASH_APPEND</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called from within a pre-update callback.
** It calculates a hash based on the primary key values of the old.* or 
** new.* row currently available and, assuming no error occurs, writes it to
** *piHash before returning. If the primary key contains one or more NULL
** values, *pbNullPK is set to true before returning.
**
** If an error occurs, an SQLite error code is returned and the final values
** of *piHash asn *pbNullPK are undefined. Otherwise, SQLITE_OK is returned
** and the output variables are set as described above.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionPreupdateHash</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object that owns pTab */</comment>
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Session table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>bNew</name></decl></parameter>,                       <comment type="block">/* True to hash the new.* PK */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piHash</name></decl></parameter>,                    <comment type="block">/* OUT: Hash value */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbNullPK</name></decl></parameter>                   <comment type="block">/* OUT: True if there are NULL values in PK */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Hash value to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through columns */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbNullPK</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xCount</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>bNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>sessionHashAppendType</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>rVal</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iVal</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rVal</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rVal</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>sessionHashAppendI64</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>z</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator> <name>n</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>sessionHashAppendBlob</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>bStat1</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pbNullPK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>piHash</name> <operator>=</operator> <operator>(</operator><name>h</name> <operator>%</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The buffer that the argument points to contains a serialized SQL value.
** Return the number of bytes of space occupied by the value (including
** the type byte).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionSerialLen</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><operator>*</operator><name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>e</name><operator>==</operator><literal type="number">0xFF</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>e</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">9</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sessionVarintGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Based on the primary key values stored in change aRecord, calculate a
** hash key. Assume the has table has nBucket buckets. The hash keys
** calculated by this function are compatible with those calculated by
** sessionPreupdateHash().
**
** The bPkOnly argument is non-zero if the record at aRecord[] is from
** a patchset DELETE. In this case the non-PK fields are omitted entirely.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>sessionChangeHash</name><parameter_list>(
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPkOnly</name></decl></parameter>,                    <comment type="block">/* Record consists of PK fields only */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRecord</name></decl></parameter>,                    <comment type="block">/* Change record */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBucket</name></decl></parameter>                     <comment type="block">/* Assume this many buckets in hash table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Value to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through columns */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>aRecord</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Used to iterate through change record */</comment>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><operator>*</operator><name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isPK</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>bPkOnly</name> <operator>&amp;&amp;</operator> <name>isPK</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* It is not possible for eType to be SQLITE_NULL here. The session 
    ** module does not record changes for rows with NULL values stored in
    ** primary key columns. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name> 
         <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name> 
         <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_NULL</name> <operator>||</operator> <name>eType</name><operator>==</operator><literal type="number">0</literal></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>isPK</name> <operator>||</operator> <operator>(</operator><name>eType</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><name>SQLITE_NULL</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>isPK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>sessionHashAppendType</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>sessionHashAppendI64</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>sessionGetI64</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt> 
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>sessionHashAppendBlob</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>(</operator><name>h</name> <operator>%</operator> <name>nBucket</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Arguments aLeft and aRight are pointers to change records for table pTab.
** This function returns true if the two records apply to the same row (i.e.
** have the same values stored in the primary key columns), or false 
** otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangeEqual</name><parameter_list>(
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Table used for PK definition */</comment>
  <parameter><decl><type><name>int</name></type> <name>bLeftPkOnly</name></decl></parameter>,                <comment type="block">/* True if aLeft[] contains PK fields only */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aLeft</name></decl></parameter>,                      <comment type="block">/* Change record */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRightPkOnly</name></decl></parameter>,               <comment type="block">/* True if aRight[] contains PK fields only */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRight</name></decl></parameter>                      <comment type="block">/* Change record */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><name>aLeft</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Cursor to iterate through aLeft */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><name>aRight</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Cursor to iterate through aRight */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Used to iterate through table columns */</comment>

  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>iCol</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n1</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>n1</name><operator>!=</operator><name>n2</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>a1</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bLeftPkOnly</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a1</name> <operator>+=</operator> <call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bRightPkOnly</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a2</name> <operator>+=</operator> <call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Arguments aLeft and aRight both point to buffers containing change
** records with nCol columns. This function "merges" the two records into
** a single records which is written to the buffer at *paOut. *paOut is
** then set to point to one byte after the last byte written before 
** returning.
**
** The merging of records is done as follows: For each column, if the 
** aRight record contains a value for the column, copy the value from
** their. Otherwise, if aLeft contains a value, copy it. If neither
** record contains a value for a given column, then neither does the
** output record.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionMergeRecord</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paOut</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aLeft</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><name>aLeft</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Cursor used to iterate through aLeft */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><name>aRight</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Cursor used to iterate through aRight */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name> <init>= <expr><operator>*</operator><name>paOut</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Output cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Used to iterate from 0 to nCol */</comment>

  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n1</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>a2</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aOut</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aOut</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>a1</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a2</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>paOut</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is a helper function used by sessionMergeUpdate().
**
** When this function is called, both *paOne and *paTwo point to a value 
** within a change record. Before it returns, both have been advanced so 
** as to point to the next value in the record.
**
** If, when this function is called, *paTwo points to a valid value (i.e.
** *paTwo[0] is not 0x00 - the "no value" placeholder), a copy of the *paTwo
** pointer is returned and *pnVal is set to the number of bytes in the 
** serialized value. Otherwise, a copy of *paOne is returned and *pnVal
** set to the number of bytes in the value at *paOne. If *paOne points
** to the "no value" placeholder, *pnVal is set to 1. In other words:
**
**   if( *paTwo is valid ) return *paTwo;
**   return *paOne;
**
*/</comment>
<function><type><specifier>static</specifier> <name>u8</name> <modifier>*</modifier></type><name>sessionMergeValue</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paOne</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Left-hand buffer pointer */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paTwo</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Right-hand buffer pointer */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>                      <comment type="block">/* OUT: Bytes in returned value */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><operator>*</operator><name>paOne</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><operator>*</operator><name>paTwo</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>a1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>a2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>a2</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name>a2</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>paTwo</name> <operator>=</operator> <operator>&amp;</operator><name><name>a2</name><index>[<expr><name>n2</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name>a1</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>paOne</name> <operator>=</operator> <operator>&amp;</operator><name><name>a1</name><index>[<expr><name>n1</name></expr>]</index></name></expr>;</expr_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used by changeset_concat() to merge two UPDATE changes
** on the same row.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionMergeUpdate</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paOut</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Pointer to output buffer */</comment>
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Table change pertains to */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,                  <comment type="block">/* True if records are patchset records */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOldRecord1</name></decl></parameter>,                <comment type="block">/* old.* record for first change */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOldRecord2</name></decl></parameter>,                <comment type="block">/* old.* record for second change */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNewRecord1</name></decl></parameter>,                <comment type="block">/* new.* record for first change */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNewRecord2</name></decl></parameter>                 <comment type="block">/* new.* record for second change */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld1</name> <init>= <expr><name>aOldRecord1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld2</name> <init>= <expr><name>aOldRecord2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew1</name> <init>= <expr><name>aNewRecord1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew2</name> <init>= <expr><name>aNewRecord2</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name> <init>= <expr><operator>*</operator><name>paOut</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>bPatchset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bRequired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aOldRecord1</name> <operator>&amp;&amp;</operator> <name>aNewRecord1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write the old.* vector first. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nOld</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>aOld</name> <operator>=</operator> <call><name>sessionMergeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aOld1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aOld2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sessionMergeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aNew1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aNew2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name>nOld</name><operator>!=</operator><name>nNew</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>aOld</name></expr></argument>, <argument><expr><name>aNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bRequired</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>aOld</name></expr></argument>, <argument><expr><name>nOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aOut</name> <operator>+=</operator> <name>nOld</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>aOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bRequired</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write the new.* vector */</comment>
  <expr_stmt><expr><name>aOld1</name> <operator>=</operator> <name>aOldRecord1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOld2</name> <operator>=</operator> <name>aOldRecord2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aNew1</name> <operator>=</operator> <name>aNewRecord1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aNew2</name> <operator>=</operator> <name>aNewRecord2</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>aOld</name> <operator>=</operator> <call><name>sessionMergeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aOld1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aOld2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sessionMergeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aNew1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aNew2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bPatchset</name><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><name>nOld</name><operator>==</operator><name>nNew</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>aOld</name></expr></argument>, <argument><expr><name>aNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>aOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>aNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aOut</name> <operator>+=</operator> <name>nNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>paOut</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only called from within a pre-update-hook callback.
** It determines if the current pre-update-hook change affects the same row
** as the change stored in argument pChange. If so, it returns true. Otherwise
** if the pre-update-hook does not affect the same row as pChange, it returns
** false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionPreupdateEqual</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object that owns SessionTable */</comment>
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Table associated with change */</comment>
  <parameter><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pChange</name></decl></parameter>,         <comment type="block">/* Change to compare to */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>                          <comment type="block">/* Current pre-update operation */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Used to iterate through columns */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>pChange</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Cursor used to scan change record */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>SQLITE_INSERT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>SQLITE_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>iCol</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>        <comment type="block">/* Value returned by preupdate_new/old */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                     <comment type="block">/* Error code from preupdate_new/old */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><operator>*</operator><name>a</name><operator>++</operator></expr></init></decl>;</decl_stmt>           <comment type="block">/* Type of value from change record */</comment>

      <comment type="block">/* The following calls to preupdate_new() and preupdate_old() can not
      ** fail. This is because they cache their return values, and by the
      ** time control flows to here they have already been called once from
      ** within sessionPreupdateHash(). The first two asserts below verify
      ** this (that the method has already been called). */</comment>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* assert( db-&gt;pPreUpdate-&gt;pNewUnpacked || db-&gt;pPreUpdate-&gt;aNew ); */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* assert( db-&gt;pPreUpdate-&gt;pUnpacked ); */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>!=</operator><name>eType</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* A SessionChange object never has a NULL value in a PK column */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name>
           <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name>    <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> <init>= <expr><call><name>sessionGetI64</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>!=</operator><name>iVal</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>rVal</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iVal</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rVal</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>!=</operator><name>rVal</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>!=</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If required, grow the hash table used to store changes on table pTab 
** (part of the session pSession). If a fatal OOM error occurs, set the
** session object to failed and return SQLITE_ERROR. Otherwise, return
** SQLITE_OK.
**
** It is possible that a non-fatal OOM error occurs in this function. In
** that case the hash-table does not grow, but SQLITE_OK is returned anyway.
** Growing the hash table in this case is a performance optimization only,
** it is not required for correct operation.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionGrowHash</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* For memory accounting. May be NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>, 
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nEntry</name></name><operator>&gt;=</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNew</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name></expr> ?</condition><then> <expr><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name></expr> </then><else>: <expr><literal type="number">128</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>SessionChange</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>sessionMalloc64</name><argument_list>(
        <argument><expr><name>pSession</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nNew</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>apNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>apNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bPkOnly</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name>bPatchset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><call><name>sessionChangeHash</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>bPkOnly</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>sessionFree</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function queries the database for the names of the columns of table
** zThis, in schema zDb.
**
** Otherwise, if they are not NULL, variable *pnCol is set to the number
** of columns in the database table and variable *pzTab is set to point to a
** nul-terminated copy of the table name. *pazCol (if not NULL) is set to
** point to an array of pointers to column names. And *pabPK (again, if not
** NULL) is set to point to an array of booleans - true if the corresponding
** column is part of the primary key.
**
** For example, if the table is declared as:
**
**     CREATE TABLE tbl1(w, x, y, z, PRIMARY KEY(w, z));
**
** Then the four output variables are populated as follows:
**
**     *pnCol  = 4
**     *pzTab  = "tbl1"
**     *pazCol = {"w", "x", "y", "z"}
**     *pabPK  = {1, 0, 0, 1}
**
** All returned buffers are part of the same single allocation, which must
** be freed using sqlite3_free() by the caller
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionTableInfo</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* For memory accounting. May be NULL */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of attached database (e.g. "main") */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zThis</name></decl></parameter>,              <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCol</name></decl></parameter>,                     <comment type="block">/* OUT: number of columns */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzTab</name></decl></parameter>,             <comment type="block">/* OUT: Copy of zThis */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>pazCol</name></decl></parameter>,           <comment type="block">/* OUT: Array of column names for table */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>pabPK</name></decl></parameter>                      <comment type="block">/* OUT: Array of booleans - true for PK col */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPragma</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDbCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nThis</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pazCol</name> <operator>&amp;&amp;</operator> <name>pabPK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nThis</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nThis</name><operator>==</operator><literal type="number">12</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>, <argument><expr><name>zThis</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zThis</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* For sqlite_stat1, pretend that (tbl,idx) is the PRIMARY KEY. */</comment>
      <expr_stmt><expr><name>zPragma</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT 0, 'tbl',  '', 0, '', 1     UNION ALL "</literal>
          <literal type="string">"SELECT 1, 'idx',  '', 0, '', 2     UNION ALL "</literal>
          <literal type="string">"SELECT 2, 'stat', '', 0, '', 0"</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zPragma</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pazCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pabPK</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pzTab</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zPragma</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA '%q'.table_info('%q')"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zPragma</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pazCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pabPK</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pzTab</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zPragma</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPragma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pazCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pabPK</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pzTab</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>nThis</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDbCol</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>nDbCol</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pAlloc</name> <operator>=</operator> <call><name>sessionMalloc64</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pAlloc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>azCol</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>pAlloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pAlloc</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>nDbCol</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>abPK</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pAlloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pAlloc</name> <operator>=</operator> <operator>&amp;</operator><name><name>abPK</name><index>[<expr><name>nDbCol</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pzTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pAlloc</name></expr></argument>, <argument><expr><name>zThis</name></expr></argument>, <argument><expr><name>nThis</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzTab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pAlloc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pAlloc</name> <operator>+=</operator> <name>nThis</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pAlloc</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pAlloc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pAlloc</name> <operator>+=</operator> <name>nName</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If successful, populate the output variables. Otherwise, zero them and
  ** free any allocation made. An error code will be returned in this case.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pazCol</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>azCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pabPK</name> <operator>=</operator> <name>abPK</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <name>nDbCol</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pazCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pabPK</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pzTab</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sessionFree</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only called from within a pre-update handler for a
** write to table pTab, part of session pSession. If this is the first
** write to this table, initalize the SessionTable.nCol, azCol[] and
** abPK[] arrays accordingly.
**
** If an error occurs, an error code is stored in sqlite3_session.rc and
** non-zero returned. Or, if no error occurs but the table has no primary
** key, sqlite3_session.rc is left set to SQLITE_OK and non-zero returned to
** indicate that updates on this table should be ignored. SessionTable.abPK 
** is set to NULL in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionInitTable</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>azCol</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sessionTableInfo</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, 
        <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>azCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abPK</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name> <operator>=</operator> <name>abPK</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bStat1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>bEnableSize</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>nMaxChangesetSize</name></name> <operator>+=</operator> <operator>(</operator>
          <literal type="number">1</literal> <operator>+</operator> <call><name>sessionVarintLen</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal>
        <operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Versions of the four methods in object SessionHook for use with the
** sqlite_stat1 table. The purpose of this is to substitute a zero-length
** blob each time a NULL value is read from the "idx" column of the
** sqlite_stat1 table.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>SessionStat1Ctx</name></name></type> <name>SessionStat1Ctx</name>;</typedef>
<struct>struct <name>SessionStat1Ctx</name> <block>{
  <decl_stmt><decl><type><name>SessionHook</name></type> <name>hook</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionStat1Old</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionStat1Ctx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SessionStat1Ctx</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSession</name><operator>-&gt;</operator><name>pZeroBlob</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionStat1New</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionStat1Ctx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SessionStat1Ctx</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSession</name><operator>-&gt;</operator><name>pZeroBlob</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionStat1Count</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionStat1Ctx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SessionStat1Ctx</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xCount</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionStat1Depth</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionStat1Ctx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SessionStat1Ctx</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xDepth</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionUpdateMaxSize</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object pTab is attached to */</comment>
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Table that change applies to */</comment>
  <parameter><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pC</name></decl></parameter>               <comment type="block">/* Update pC-&gt;nMaxSize */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nNew</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionSerializeValue</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nNew</name> <operator>+=</operator> <name><name>pC</name><operator>-&gt;</operator><name>nRecord</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_preupdate_blobwrite</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nNew</name> <operator>+=</operator> <name><name>pC</name><operator>-&gt;</operator><name>nRecord</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name><name>pC</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bChanged</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>*</operator><name>pCsr</name><operator>++</operator></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
          <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
        <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name> <init>= <expr><call><name>sessionGetI64</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>!=</operator><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <decl_stmt><decl><type><name>double</name></type> <name>dVal</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <operator>(</operator><name>dVal</name><operator>!=</operator><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>nOld</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>

        <default>default:</default> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>nOld</name> <operator>=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>nOld</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nOld</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> 
           <operator>&amp;&amp;</operator> <name>nByte</name><operator>==</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>nByte</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>

      <if_stmt><if>if<condition>( <expr><name>bChanged</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>ii</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>bChanged</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nNew</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>nOld</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionSerializeValue</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>ii</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nNew</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>nOld</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nNew</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&gt;</operator><name><name>pC</name><operator>-&gt;</operator><name>nMaxSize</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nIncr</name> <init>= <expr><name>nNew</name> <operator>-</operator> <name><name>pC</name><operator>-&gt;</operator><name>nMaxSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nMaxSize</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>nMaxChangesetSize</name></name> <operator>+=</operator> <name>nIncr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only called from with a pre-update-hook reporting a 
** change on table pTab (attached to session pSession). The type of change
** (UPDATE, INSERT, DELETE) is specified by the first argument.
**
** Unless one is already present or an error occurs, an entry is added
** to the changed-rows hash table associated with table pTab.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionPreupdateOneChange</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                         <comment type="block">/* One of SQLITE_UPDATE, INSERT, DELETE */</comment>
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object pTab is attached to */</comment>
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>              <comment type="block">/* Table that change applies to */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>bNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionStat1Ctx</name></type> <name>stat1</name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Load table details if required */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sessionInitTable</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Check the number of columns in this xPreUpdate call matches the 
  ** number of columns in the table.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xCount</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Grow the hash table if required */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sessionGrowHash</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bStat1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>stat1</name><operator>.</operator><name>hook</name></name> <operator>=</operator> <name><name>pSession</name><operator>-&gt;</operator><name>hook</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat1</name><operator>.</operator><name>pSession</name></name> <operator>=</operator> <name>pSession</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>stat1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name> <operator>=</operator> <name>sessionStat1New</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name> <operator>=</operator> <name>sessionStat1Old</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xCount</name></name> <operator>=</operator> <name>sessionStat1Count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xDepth</name></name> <operator>=</operator> <name>sessionStat1Depth</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>pZeroBlob</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>error_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>pZeroBlob</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Calculate the hash-key for this change. If the primary key of the row
  ** includes a NULL value, exit early. Such changes are ignored by the
  ** session module. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionPreupdateHash</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bNull</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Search the hash table for an existing record for this row. */</comment>
    <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pC</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>pC</name></expr>;</condition> <incr><expr><name>pC</name><operator>=</operator><name><name>pC</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sessionPreupdateEqual</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>pC</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Create a new change object containing all the old values (if
      ** this is an SQLITE_UPDATE or SQLITE_DELETE), or just the PK
      ** values (if this is an INSERT). */</comment>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>    <comment type="block">/* Number of bytes to allocate */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                  <comment type="block">/* Used to iterate through columns */</comment>
  
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nEntry</name></name><operator>++</operator></expr>;</expr_stmt>
  
      <comment type="block">/* Figure out how large an allocation is required */</comment>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
          <macro><name>TESTONLY</name><argument_list>(<argument>int trc =</argument> )</argument_list></macro> <expr_stmt><expr><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>trc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <macro><name>TESTONLY</name><argument_list>(<argument>int trc =</argument> )</argument_list></macro> <expr_stmt><expr><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>trc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* This may fail if SQLite value p contains a utf-16 string that must
        ** be converted to utf-8 and an OOM error occurs while doing so. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionSerializeValue</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></for>
  
      <comment type="block">/* Allocate the change object */</comment>
      <expr_stmt><expr><name>pC</name> <operator>=</operator> <operator>(</operator><name>SessionChange</name> <operator>*</operator><operator>)</operator><call><name>sessionMalloc64</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pC</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>error_out</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRecord</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pC</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
  
      <comment type="block">/* Populate the change object. None of the preupdate_old(),
      ** preupdate_new() or SerializeValue() calls below may fail as all
      ** required values and encodings have already been cached in memory.
      ** It is not possible for an OOM to occur in this block. */</comment>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sessionSerializeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pC</name><operator>-&gt;</operator><name>aRecord</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <comment type="block">/* Add the change to the hash-table */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>||</operator> <call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xDepth</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>pC</name></expr>;</expr_stmt>

    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>bIndirect</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the existing change is considered "indirect", but this current
      ** change is "direct", mark the change object as direct. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xDepth</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>pSession</name><operator>-&gt;</operator><name>bIndirect</name></name><operator>==</operator><literal type="number">0</literal></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>bEnableSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionUpdateMaxSize</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* If an error has occurred, mark the session object as failed. */</comment>
 <label><name>error_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bStat1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name></name> <operator>=</operator> <name><name>stat1</name><operator>.</operator><name>hook</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionFindTable</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTab</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

  <comment type="block">/* Search for an existing table */</comment>
  <for>for<control>(<init><expr><name>pRet</name><operator>=</operator><name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</init> <condition><expr><name>pRet</name></expr>;</condition> <incr><expr><name>pRet</name><operator>=</operator><name><name>pRet</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>pRet</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSession</name><operator>-&gt;</operator><name>bAutoAttach</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is a table-filter configured, invoke it. If it returns 0,
    ** do not automatically add the new table. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>xTableFilter</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>||</operator> <call><name><name>pSession</name><operator>-&gt;</operator><name>xTableFilter</name></name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>pFilterCtx</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3session_attach</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</expr_stmt>
        <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pRet</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>pRet</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRet</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pRet</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppTab</name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The 'pre-update' hook registered by this module with SQLite databases.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>xPreUpdate</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* Copy of third arg to preupdate_hook() */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                         <comment type="block">/* SQLITE_UPDATE, DELETE or INSERT */</comment>
  <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Database name */</comment>
  <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iKey1</name></decl></parameter>,            <comment type="block">/* Rowid of row about to be deleted/updated */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iKey2</name></decl></parameter>             <comment type="block">/* New rowid value (for a rowid UPDATE) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pSession</name><operator>=</operator><operator>(</operator><name>sqlite3_session</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr>;</init> <condition><expr><name>pSession</name></expr>;</condition> <incr><expr><name>pSession</name><operator>=</operator><name><name>pSession</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>

    <comment type="block">/* If this session is attached to a different database ("main", "temp" 
    ** etc.), or if it is not currently enabled, there is nothing to do. Skip 
    ** to the next session object attached to this database. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>bEnable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sessionFindTable</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionPreupdateOneChange</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sessionPreupdateOneChange</name><argument_list>(<argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** The pre-update hook implementations.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionPreupdateOld</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_preupdate_old</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>, <argument><expr><name>ppVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionPreupdateNew</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_preupdate_new</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>, <argument><expr><name>ppVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionPreupdateCount</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_preupdate_count</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionPreupdateDepth</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_preupdate_depth</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Install the pre-update hooks on the session object passed as the only
** argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionPreupdateHooks</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name> <operator>=</operator> <name>sessionPreupdateOld</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name> <operator>=</operator> <name>sessionPreupdateNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xCount</name></name> <operator>=</operator> <name>sessionPreupdateCount</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xDepth</name></name> <operator>=</operator> <name>sessionPreupdateDepth</name></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>SessionDiffCtx</name></name></type> <name>SessionDiffCtx</name>;</typedef>
<struct>struct <name>SessionDiffCtx</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOldOff</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** The diff hook implementations.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionDiffOld</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionDiffCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SessionDiffCtx</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iVal</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nOldOff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionDiffNew</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionDiffCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SessionDiffCtx</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionDiffCount</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionDiffCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SessionDiffCtx</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nOldOff</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nOldOff</name></name></expr> </then><else>: <expr><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionDiffDepth</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Install the diff hooks on the session object passed as the only
** argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionDiffHooks</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,
  <parameter><decl><type><name>SessionDiffCtx</name> <modifier>*</modifier></type><name>pDiffCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pDiffCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xOld</name></name> <operator>=</operator> <name>sessionDiffOld</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xNew</name></name> <operator>=</operator> <name>sessionDiffNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xCount</name></name> <operator>=</operator> <name>sessionDiffCount</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>xDepth</name></name> <operator>=</operator> <name>sessionDiffDepth</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionExprComparePK</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb2</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z%s\"%w\".\"%w\".\"%w\"=\"%w\".\"%w\".\"%w\""</literal></expr></argument>,
          <argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zDb1</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zDb2</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionExprCompareOther</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb2</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bHave</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bHave</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"%z%s\"%w\".\"%w\".\"%w\" IS NOT \"%w\".\"%w\".\"%w\""</literal></expr></argument>,
          <argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zDb1</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zDb2</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" OR "</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>bHave</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zRet</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionSelectFindNew</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb1</name></decl></parameter>,      <comment type="block">/* Pick rows in this db only */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb2</name></decl></parameter>,      <comment type="block">/* But not in this one */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name></decl></parameter>,      <comment type="block">/* Table name */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zExpr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">"SELECT * FROM \"%w\".\"%w\" WHERE NOT EXISTS ("</literal>
      <literal type="string">"  SELECT 1 FROM \"%w\".\"%w\" WHERE %s"</literal>
      <literal type="string">")"</literal></expr></argument>,
      <argument><expr><name>zDb1</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>zDb2</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionDiffFindNew</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb2</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zExpr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStmt</name> <init>= <expr><call><name>sessionSelectFindNew</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>zDb1</name></expr></argument>, <argument><expr><name>zDb2</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,<argument><expr><name>zExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SessionDiffCtx</name> <modifier>*</modifier></type><name>pDiffCtx</name> <init>= <expr><operator>(</operator><name>SessionDiffCtx</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pDiffCtx</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDiffCtx</name><operator>-&gt;</operator><name>nOldOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sessionPreupdateOneChange</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionDiffFindModified</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, 
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zExpr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExpr2</name> <init>= <expr><call><name>sessionExprCompareOther</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>,
      <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>azCol</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zExpr2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStmt</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"SELECT * FROM \"%w\".\"%w\", \"%w\".\"%w\" WHERE %s AND (%z)"</literal></expr></argument>,
        <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>, <argument><expr><name>zExpr2</name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SessionDiffCtx</name> <modifier>*</modifier></type><name>pDiffCtx</name> <init>= <expr><operator>(</operator><name>SessionDiffCtx</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>hook</name><operator>.</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pDiffCtx</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDiffCtx</name><operator>-&gt;</operator><name>nOldOff</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sessionPreupdateOneChange</name><argument_list>(<argument><expr><name>SQLITE_UPDATE</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3session_diff</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>pSession</name><operator>-&gt;</operator><name>zDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionDiffCtx</name></type> <name>d</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionDiffHooks</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pzErrMsg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTo</name></decl>;</decl_stmt>            <comment type="block">/* Table zTbl */</comment>

    <comment type="block">/* Locate and if necessary initialize the target table object */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionFindTable</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>diff_out</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sessionInitTable</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt>
      <goto>goto <name>diff_out</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check the table schemas match */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bHasPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bMismatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                   <comment type="block">/* Columns in zFrom.zTbl */</comment>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionTableInfo</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>azCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><name>nCol</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bMismatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bMismatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bMismatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bHasPk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bMismatch</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pzErrMsg</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"table schemas do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bHasPk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Ignore tables with no primary keys */</comment>
        <goto>goto <name>diff_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zExpr</name> <operator>=</operator> <call><name>sessionExprComparePK</name><argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, 
          <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>azCol</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find new rows */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionDiffFindNew</name><argument_list>(<argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find old rows */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionDiffFindNew</name><argument_list>(<argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find modified rows */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionDiffFindModified</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>diff_out</name>:</label>
  <expr_stmt><expr><call><name>sessionPreupdateHooks</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a session object. This session object will record changes to
** database zDb attached to connection db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_create</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of db (e.g. "main") */</comment>
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSession</name></decl></parameter>     <comment type="block">/* OUT: New session object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>          <comment type="block">/* Newly allocated session object */</comment>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>          <comment type="block">/* Session object already attached to db */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Length of zDb in bytes */</comment>

  <comment type="block">/* Zero the output value in case an error occurs. */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppSession</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Allocate and populate the new session object. */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>sqlite3_session</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_session</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nDb</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_session</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bEnable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionPreupdateHooks</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add the new session object to the linked list of session objects 
  ** attached to database handle $db. Do this under the cover of the db
  ** handle mutex.  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> <operator>=</operator> <operator>(</operator><name>sqlite3_session</name><operator>*</operator><operator>)</operator><call><name>sqlite3_preupdate_hook</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>xPreUpdate</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pOld</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppSession</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the list of table objects passed as the first argument. The contents
** of the changed-rows hash tables are also deleted.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionDeleteTable</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pNextChange</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNextChange</name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pNextChange</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionFree</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sessionFree</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>azCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* cast works around VC++ bug */</comment>
    <expr_stmt><expr><call><name>sessionFree</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionFree</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Delete a session object previously allocated using sqlite3session_create().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3session_delete</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pHead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

  <comment type="block">/* Unlink the session from the linked list of sessions attached to the
  ** database handle. Hold the db mutex while doing so.  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pHead</name> <operator>=</operator> <operator>(</operator><name>sqlite3_session</name><operator>*</operator><operator>)</operator><call><name>sqlite3_preupdate_hook</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name>pHead</name></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>==</operator><name>pSession</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pHead</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_preupdate_hook</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>xPreUpdate</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pHead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>pZeroBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Delete all attached table objects. And the contents of their 
  ** associated hash-tables. */</comment>
  <expr_stmt><expr><call><name>sessionDeleteTable</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assert that all allocations have been freed and then free the 
  ** session object itself. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>nMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set a table filter on a Session Object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3session_table_filter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, 
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xFilter</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* First argument passed to xFilter */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>bAutoAttach</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>pFilterCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>xTableFilter</name></name> <operator>=</operator> <name>xFilter</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attach a table to a session. All subsequent changes made to the table
** while the session object is enabled will be recorded.
**
** Only tables that have a PRIMARY KEY defined may be attached. It does
** not matter if the PRIMARY KEY is an "INTEGER PRIMARY KEY" (rowid alias)
** or not.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_attach</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>               <comment type="block">/* Table name */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>bAutoAttach</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>           <comment type="block">/* New table object (if required) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes in string zName */</comment>

    <comment type="block">/* First search for an existing entry. If one is found, this call is
    ** a no-op. Return early. */</comment>
    <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Allocate new SessionTable object. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionTable</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <operator>(</operator><name>SessionTable</name><operator>*</operator><operator>)</operator><call><name>sessionMalloc64</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Populate the new SessionTable object and link it into the list.
        ** The new object must be linked onto the end of the list, not 
        ** simply added to the start of it in order to ensure that tables
        ** appear in the correct order when a changeset or patchset is
        ** eventually generated. */</comment>
        <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTab</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTab</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ppTab</name><operator>=</operator><operator>&amp;</operator><name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ppTab</name></expr>;</condition> <incr><expr><name>ppTab</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>ppTab</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
        <expr_stmt><expr><operator>*</operator><name>ppTab</name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Ensure that there is room in the buffer to append nByte bytes of data.
** If not, use sqlite3_realloc() to grow the buffer so that there is.
**
** If successful, return zero. Otherwise, if an OOM condition is encountered,
** set *pRc to SQLITE_NOMEM and return non-zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionBufferGrow</name><parameter_list>(<parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SESSION_MAX_BUFFER_SZ</name></cpp:macro> <cpp:value>(0x7FFFFF00 - 1)</cpp:value></cpp:define> 
  <decl_stmt><decl><type><name>i64</name></type> <name>nReq</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <name>nByte</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nReq</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>nNew</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> </then><else>: <expr><literal type="number">128</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content>
      <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>nNew</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nReq</name></expr> )</condition>;</do>

    <comment type="block">/* The value of SESSION_MAX_BUFFER_SZ is copied from the implementation
    ** of sqlite3_realloc64(). Allocations greater than this size in bytes
    ** always fail. It is used here to ensure that this routine can always
    ** allocate up to this limit - instead of up to the largest power of
    ** two smaller than the limit.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&gt;</operator><name>SESSION_MAX_BUFFER_SZ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>SESSION_MAX_BUFFER_SZ</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nReq</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>aNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aBuf</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><operator>*</operator><name>pRc</name><operator>!=</operator><name>SQLITE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append the value passed as the second argument to the buffer passed
** as the first.
**
** This function is a no-op if *pRc is non-zero when it is called.
** Otherwise, if an error occurs, *pRc is set to an SQLite error code
** before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendValue</name><parameter_list>(<parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionSerializeValue</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionSerializeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is 
** called. Otherwise, append a single byte to the buffer. 
**
** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendByte</name><parameter_list>(<parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is 
** called. Otherwise, append a single varint to the buffer. 
**
** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendVarint</name><parameter_list>(<parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <call><name>sessionVarintPut</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is 
** called. Otherwise, append a blob of data to the buffer. 
**
** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendBlob</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nBlob</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <name>nBlob</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is 
** called. Otherwise, append a string to the buffer. All bytes in the string
** up to (but not including) the nul-terminator are written to the buffer.
**
** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendStr</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nStr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><name>nStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <name>nStr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is 
** called. Otherwise, append the string representation of integer iVal
** to the buffer. No nul-terminator is written.
**
** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendInteger</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Buffer to append to */</comment>
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>,                       <comment type="block">/* Value to write the string rep. of */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aBuf</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is 
** called. Otherwise, append the string zStr enclosed in quotes (") and
** with any embedded quote characters escaped to the buffer. No 
** nul-terminator byte is written.
**
** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendIdent</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Buffer to a append to */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>,               <comment type="block">/* String to quote, escape and append */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nStr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zStr</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>zIn</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zIn</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zIn</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>zOut</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aBuf</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is
** called. Otherwse, it appends the serialized version of the value stored
** in column iCol of the row that SQL statement pStmt currently points
** to to the buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendCol</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Buffer to append to */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,            <comment type="block">/* Handle pointing to row containing value */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Column to read value from */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>eType</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aBuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sessionPutI64</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_BLOB</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>z</name> <operator>||</operator> <operator>(</operator><name>eType</name><operator>==</operator><name>SQLITE_BLOB</name> <operator>&amp;&amp;</operator> <name>nByte</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sessionAppendVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
**
** This function appends an update change to the buffer (see the comments 
** under "CHANGESET FORMAT" at the top of the file). An update change 
** consists of:
**
**   1 byte:  SQLITE_UPDATE (0x17)
**   n bytes: old.* record (see RECORD FORMAT)
**   m bytes: new.* record (see RECORD FORMAT)
**
** The SessionChange object passed as the third argument contains the
** values that were stored in the row when the session began (the old.*
** values). The statement handle passed as the second argument points
** at the current version of the row (the new.* values).
**
** If all of the old.* values are equal to their corresponding new.* value
** (i.e. nothing has changed), then no data at all is appended to the buffer.
**
** Otherwise, the old.* record contains all primary key values and the 
** original values of any fields that have been modified. The new.* record 
** contains the new values of only those fields that have been modified.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionAppendUpdate</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,            <comment type="block">/* Buffer to append to */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,                  <comment type="block">/* True for "patchset", 0 for "changeset" */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,            <comment type="block">/* Statement handle pointing at new row */</comment>
  <parameter><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Object containing old values */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>                        <comment type="block">/* Boolean array - true for PK columns */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf2</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* Buffer to accumulate new.* record in */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bNoop</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Set to zero if any values are modified */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRewind</name> <init>= <expr><name><name>pBuf</name><operator>-&gt;</operator><name>nBuf</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Set to zero if any values are modified */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Used to iterate through columns */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Used to iterate through old.* values */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>abPK</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>SQLITE_UPDATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bChanged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nAdvance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><operator>*</operator><name>pCsr</name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
        <expr_stmt><expr><name>nAdvance</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
      <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>nAdvance</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name> <init>= <expr><call><name>sessionGetI64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>==</operator><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>double</name></type> <name>dVal</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>dVal</name><operator>==</operator><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nHdr</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nAdvance</name> <operator>=</operator> <name>nHdr</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> 
         <operator>&amp;&amp;</operator> <name>n</name><operator>==</operator><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> 
         <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><index>[<expr><name>nHdr</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block>
    </block_content>}</block></switch>

    <comment type="block">/* If at least one field has been modified, this is not a no-op. */</comment>
    <if_stmt><if>if<condition>( <expr><name>bChanged</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bNoop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Add a field to the old.* record. This is omitted if this modules is
    ** currently generating a patchset. */</comment>
    <if_stmt><if>if<condition>( <expr><name>bPatchset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bChanged</name> <operator>||</operator> <name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>nAdvance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add a field to the new.* record. Or the only record if currently
    ** generating a patchset.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>bChanged</name> <operator>||</operator> <operator>(</operator><name>bPatchset</name> <operator>&amp;&amp;</operator> <name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sessionAppendCol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf2</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>nAdvance</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>bNoop</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>nRewind</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>buf2</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>buf2</name><operator>.</operator><name>nBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>buf2</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append a DELETE change to the buffer passed as the first argument. Use
** the changeset format if argument bPatchset is zero, or the patchset
** format otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionAppendDelete</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,            <comment type="block">/* Buffer to append to */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,                  <comment type="block">/* True for "patchset", 0 for "changeset" */</comment>
  <parameter><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Object containing old values */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                       <comment type="block">/* Number of columns in table */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>                        <comment type="block">/* Boolean array - true for PK columns */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>bPatchset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRecord</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pStart</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><operator>*</operator><name>a</name><operator>++</operator></expr></init></decl>;</decl_stmt>

      <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case>
        <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
        <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
          <expr_stmt><expr><name>a</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
          <break>break;</break>

        <default>default:</default> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
      <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>a</name><operator>-</operator><name>pStart</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>a</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aRecord</name></name><operator>)</operator><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nRecord</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Formulate and prepare a SELECT statement to retrieve a row from table
** zTab in database zDb based on its primary key. i.e.
**
**   SELECT * FROM zDb.zTab WHERE pk1 = ? AND pk2 = ? AND ...
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionSelectStmt</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Database name */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                       <comment type="block">/* Number of columns in table */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>,             <comment type="block">/* Names of table columns */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>,                       <comment type="block">/* PRIMARY KEY  array */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>           <comment type="block">/* OUT: Prepared SELECT statement */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSql</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"SELECT tbl, ?2, stat FROM %Q.sqlite_stat1 WHERE tbl IS ?1 AND "</literal>
        <literal type="string">"idx IS (CASE WHEN ?2=X'' THEN NULL ELSE ?2 END)"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS ?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendInteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSql</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>nSql</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Bind the PRIMARY KEY values from the change passed in argument pChange
** to the SELECT statement passed as the first argument. The SELECT statement
** is as prepared by function sessionSelectStmt().
**
** Return SQLITE_OK if all PK values are successfully bound, or an SQLite
** error code (e.g. SQLITE_NOMEM) otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionSelectBind</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,          <comment type="block">/* SELECT from sessionSelectStmt() */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                       <comment type="block">/* Number of columns in table */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>,                       <comment type="block">/* PRIMARY KEY array */</comment>
  <parameter><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pChange</name></decl></parameter>          <comment type="block">/* Change structure */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>pChange</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><operator>*</operator><name>a</name><operator>++</operator></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>
      <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> <init>= <expr><call><name>sessionGetI64</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>rVal</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> <init>= <expr><call><name>sessionGetI64</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_double</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is set to other than SQLITE_OK when it
** is called. Otherwise, append a serialized table header (part of the binary 
** changeset format) to buffer *pBuf. If an error occurs, set *pRc to an
** SQLite error code before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendTableHdr</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,            <comment type="block">/* Append header to this buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,                  <comment type="block">/* Use the patchset format if true */</comment>
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Table object to append header for */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* Write a table header */</comment>
  <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bPatchset</name></expr> ?</condition><then> <expr><literal type="char">'P'</literal></expr> </then><else>: <expr><literal type="char">'T'</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendVarint</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate either a changeset (if argument bPatchset is zero) or a patchset
** (if it is non-zero) based on the current contents of the session object
** passed as the first argument.
**
** If no error occurs, SQLITE_OK is returned and the new changeset/patchset
** stored in output variables *pnChangeset and *ppChangeset. Or, if an error
** occurs, an SQLite error code is returned and both output variables set 
** to 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionGenerateChangeset</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,                  <comment type="block">/* True for patchset, false for changeset */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,                     <comment type="block">/* First argument for xOutput */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnChangeset</name></decl></parameter>,               <comment type="block">/* OUT: Size of buffer at *ppChangeset */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppChangeset</name></decl></parameter>              <comment type="block">/* OUT: Buffer containing changeset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Source database handle */</comment>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>             <comment type="block">/* Used to iterate through attached tables */</comment>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>    <comment type="block">/* Buffer in which to accumlate changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xOutput</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pnChangeset</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ppChangeset</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xOutput</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pnChangeset</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ppChangeset</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Zero the output variables in case an error occurs. If this session
  ** object is already in the error state (sqlite3_session.rc != SQLITE_OK),
  ** this call will be a no-op.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>xOutput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pnChangeset</name><operator>!=</operator><literal type="number">0</literal>  <operator>&amp;&amp;</operator> <name>ppChangeset</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnChangeset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppChangeset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pSession</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT changeset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of columns in table */</comment>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Primary key array */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Table columns */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Used to iterate through hash buckets */</comment>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* SELECT statement to query table pTab */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nRewind</name> <init>= <expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Initial size of write buffer */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nNoop</name></decl>;</decl_stmt>                  <comment type="block">/* Size of buffer after writing tbl header */</comment>

      <comment type="block">/* Check the table schema is still Ok. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionTableInfo</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>azCol</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>abPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><name>nCol</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>abPK</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Write a table header */</comment>
      <expr_stmt><expr><call><name>sessionAppendTableHdr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>bPatchset</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Build and compile a statement to execute: */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionSelectStmt</name><argument_list>(
            <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>nNoop</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>         <comment type="block">/* Used to iterate through changes */</comment>

        <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionSelectBind</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <expr_stmt><expr><call><name>sessionAppendCol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></for>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>abPK</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Because sessionSelectStmt() returned ok */</comment>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionAppendUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>bPatchset</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionAppendDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>bPatchset</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* If the buffer is now larger than sessions_strm_chunk_size, pass
          ** its contents to the xOutput() callback. */</comment>
          <if_stmt><if>if<condition>( <expr><name>xOutput</name> 
           <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name> 
           <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>nBuf</name></name><operator>&gt;</operator><name>nNoop</name> 
           <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>nBuf</name></name><operator>&gt;</operator><name>sessions_strm_chunk_size</name></expr> 
          )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nNoop</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        </block_content>}</block></for>
      </block_content>}</block></for>

      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name><operator>==</operator><name>nNoop</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name> <operator>=</operator> <name>nRewind</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* cast works around VC++ bug */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>xOutput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnChangeset</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppChangeset</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"RELEASE changeset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Obtain a changeset object containing all changes recorded by the 
** session object passed as the first argument.
**
** It is the responsibility of the caller to eventually free the buffer 
** using sqlite3_free().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_changeset</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnChangeset</name></decl></parameter>,               <comment type="block">/* OUT: Size of buffer at *ppChangeset */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppChangeset</name></decl></parameter>              <comment type="block">/* OUT: Buffer containing changeset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pnChangeset</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>ppChangeset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionGenerateChangeset</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pnChangeset</name></expr></argument>,<argument><expr><name>ppChangeset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name> <operator>||</operator> <name>pnChangeset</name><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <name><name>pSession</name><operator>-&gt;</operator><name>bEnableSize</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>pnChangeset</name><operator>&lt;=</operator><name><name>pSession</name><operator>-&gt;</operator><name>nMaxChangesetSize</name></name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Streaming version of sqlite3session_changeset().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_changeset_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>xOutput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sessionGenerateChangeset</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xOutput</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Streaming version of sqlite3session_patchset().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_patchset_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>xOutput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sessionGenerateChangeset</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>xOutput</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Obtain a patchset object containing all changes recorded by the 
** session object passed as the first argument.
**
** It is the responsibility of the caller to eventually free the buffer 
** using sqlite3_free().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_patchset</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>,      <comment type="block">/* Session object */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnPatchset</name></decl></parameter>,                <comment type="block">/* OUT: Size of buffer at *ppChangeset */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPatchset</name></decl></parameter>               <comment type="block">/* OUT: Buffer containing changeset */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pnPatchset</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>ppPatchset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sessionGenerateChangeset</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pnPatchset</name></expr></argument>, <argument><expr><name>ppPatchset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Enable or disable the session object passed as the first argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_enable</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bEnable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bEnable</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>bEnable</name></name> <operator>=</operator> <name>bEnable</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>pSession</name><operator>-&gt;</operator><name>bEnable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Enable or disable the session object passed as the first argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_indirect</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bIndirect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bIndirect</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>=</operator> <name>bIndirect</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>pSession</name><operator>-&gt;</operator><name>bIndirect</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if there have been no changes to monitored tables recorded
** by the session object passed as the only argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_isempty</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</init> <condition><expr><name>pTab</name> <operator>&amp;&amp;</operator> <name>ret</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nEntry</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name>ret</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the amount of heap memory in use.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3session_memory_used</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pSession</name><operator>-&gt;</operator><name>nMalloc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure the session object passed as the first argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_object_config</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_SESSION_OBJCONFIG_SIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iArg</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iArg</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>pTable</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>bEnableSize</name></name> <operator>=</operator> <operator>(</operator><name>iArg</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name><name>pSession</name><operator>-&gt;</operator><name>bEnableSize</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
  </block_content>}</block></switch>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the maximum size of sqlite3session_changeset() output.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3session_changeset_size</name><parameter_list>(<parameter><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pSession</name><operator>-&gt;</operator><name>nMaxChangesetSize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do the work for either sqlite3changeset_start() or start_strm().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetStart</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,    <comment type="block">/* OUT: Changeset iterator handle */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nChangeset</name></decl></parameter>,                 <comment type="block">/* Size of buffer pChangeset in bytes */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pChangeset</name></decl></parameter>,               <comment type="block">/* Pointer to buffer containing changeset */</comment>
  <parameter><decl><type><name>int</name></type> <name>bInvert</name></decl></parameter>,                    <comment type="block">/* True to invert changeset */</comment>
  <parameter><decl><type><name>int</name></type> <name>bSkipEmpty</name></decl></parameter>                  <comment type="block">/* True to skip empty UPDATE changes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>   <comment type="block">/* Iterator to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes to allocate for iterator */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xInput</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pChangeset</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nChangeset</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Zero the output variable in case an error occurs. */</comment>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Allocate and initialize the iterator structure. */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_changeset_iter</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>sqlite3_changeset_iter</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRet</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_changeset_iter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pChangeset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <name>nChangeset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>xInput</name></name> <operator>=</operator> <name>xInput</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pIn</name></name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>bEof</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>xInput</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>bInvert</name></name> <operator>=</operator> <name>bInvert</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>bSkipEmpty</name></name> <operator>=</operator> <name>bSkipEmpty</name></expr>;</expr_stmt>

  <comment type="block">/* Populate the output variable and return success. */</comment>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create an iterator used to iterate through the contents of a changeset.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_start</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,    <comment type="block">/* OUT: Changeset iterator handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nChangeset</name></decl></parameter>,                 <comment type="block">/* Size of buffer pChangeset in bytes */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pChangeset</name></decl></parameter>                <comment type="block">/* Pointer to buffer containing changeset */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sessionChangesetStart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nChangeset</name></expr></argument>, <argument><expr><name>pChangeset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3changeset_start_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,    <comment type="block">/* OUT: Changeset iterator handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nChangeset</name></decl></parameter>,                 <comment type="block">/* Size of buffer pChangeset in bytes */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pChangeset</name></decl></parameter>,               <comment type="block">/* Pointer to buffer containing changeset */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bInvert</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_CHANGESETSTART_INVERT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sessionChangesetStart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nChangeset</name></expr></argument>, <argument><expr><name>pChangeset</name></expr></argument>, <argument><expr><name>bInvert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Streaming version of sqlite3changeset_start().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_start_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,    <comment type="block">/* OUT: Changeset iterator handle */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sessionChangesetStart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>xInput</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3changeset_start_v2_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,    <comment type="block">/* OUT: Changeset iterator handle */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bInvert</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_CHANGESETSTART_INVERT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sessionChangesetStart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>xInput</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bInvert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the SessionInput object passed as the only argument is a streaming
** object and the buffer is full, discard some data to free up space.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionDiscardData</name><parameter_list>(<parameter><decl><type><name>SessionInput</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>xInput</name></name> <operator>&amp;&amp;</operator> <name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name><operator>&gt;=</operator><name>sessions_strm_chunk_size</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nMove</name> <init>= <expr><name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>nBuf</name></name> <operator>-</operator> <name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMove</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nMove</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>aBuf</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>nBuf</name></name> <operator>-=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Ensure that there are at least nByte bytes available in the buffer. Or,
** if there are not nByte bytes remaining in the input, that all available
** data is in the buffer.
**
** Return an SQLite error code if an error occurs, or SQLITE_OK otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionInputBuffer</name><parameter_list>(<parameter><decl><type><name>SessionInput</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>xInput</name></name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><operator>!</operator><name><name>pIn</name><operator>-&gt;</operator><name>bEof</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name><operator>+</operator><name>nByte</name><operator>)</operator><operator>&gt;=</operator><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><name>sessions_strm_chunk_size</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>bNoDiscard</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sessionDiscardData</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pIn</name><operator>-&gt;</operator><name>xInput</name></name><argument_list>(<argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>pIn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>aBuf</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>nBuf</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>nBuf</name></name> <operator>+=</operator> <name>nNew</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When this function is called, *ppRec points to the start of a record
** that contains nCol values. This function advances the pointer *ppRec
** until it points to the byte immediately following that record.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionSkipRecord</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRec</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Record pointer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>                        <comment type="block">/* Number of values in record */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name> <init>= <expr><operator>*</operator><name>ppRec</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><operator>*</operator><name>aRec</name><operator>++</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>aRec</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aRec</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aRec</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>ppRec</name> <operator>=</operator> <name>aRec</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function sets the value of the sqlite3_value object passed as the
** first argument to a copy of the string or blob held in the aData[] 
** buffer. SQLITE_OK is returned if successful, or SQLITE_NOMEM if an OOM
** error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionValueSetStr</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,            <comment type="block">/* Set the value of this object */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>,                      <comment type="block">/* Buffer containing string or blob data */</comment>
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,                      <comment type="block">/* Size of buffer aData[] in bytes */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>                          <comment type="block">/* String encoding (0 for blobs) */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* In theory this code could just pass SQLITE_TRANSIENT as the final
  ** argument to sqlite3ValueSetStr() and have the copy created 
  ** automatically. But doing so makes it difficult to detect any OOM
  ** error. Hence the code to create the copy externally. */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aCopy</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nData</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aCopy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aCopy</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>aCopy</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deserialize a single record from a buffer in memory. See "RECORD FORMAT"
** for details.
**
** When this function is called, *paChange points to the start of the record
** to deserialize. Assuming no error occurs, *paChange is set to point to
** one byte after the end of the same record before this function returns.
** If the argument abPK is NULL, then the record contains nCol values. Or,
** if abPK is other than NULL, then the record contains only the PK fields
** (in other words, it is a patchset DELETE record).
**
** If successful, each element of the apOut[] array (allocated by the caller)
** is set to point to an sqlite3_value object containing the value read
** from the corresponding position in the record. If that value is not
** included in the record (i.e. because the record is part of an UPDATE change
** and the field was not modified), the corresponding element of apOut[] is
** set to NULL.
**
** It is the responsibility of the caller to free all sqlite_value structures
** using sqlite3_free().
**
** If an error occurs, an SQLite error code (e.g. SQLITE_NOMEM) is returned.
** The apOut[] array may have been partially populated in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionReadRecord</name><parameter_list>(
  <parameter><decl><type><name>SessionInput</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,              <comment type="block">/* Input data */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                       <comment type="block">/* Number of values in record */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>,                       <comment type="block">/* Array of primary key flags, or NULL */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apOut</name></decl></parameter>,          <comment type="block">/* Write values to this array */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbEmpty</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbEmpty</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>pbEmpty</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pbEmpty</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbEmpty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Type of value (SQLITE_NULL, TEXT etc.) */</comment>
    <if_stmt><if>if<condition>( <expr><name>abPK</name> <operator>&amp;&amp;</operator> <name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name><operator>&gt;=</operator><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>eType</name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apOut</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pbEmpty</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbEmpty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>apOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>apOut</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aVal</name> <init>= <expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>nByte</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nByte</name></expr></argument>&gt;</argument_list></name><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name><operator>-</operator><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> ?</condition><then> <expr><name>SQLITE_UTF8</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionValueSetStr</name><argument_list>(<argument><expr><name><name>apOut</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>,<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name> <init>= <expr><call><name>sessionGetI64</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name><name>apOut</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeMemSetDouble</name><argument_list>(<argument><expr><name><name>apOut</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The input pointer currently points to the second byte of a table-header.
** Specifically, to the following:
**
**   + number of columns in table (varint)
**   + array of PK flags (1 byte per column),
**   + table name (nul terminated).
**
** This function ensures that all of the above is present in the input 
** buffer (i.e. that it can be accessed without any calls to xInput()).
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error code.
** The input pointer is not moved.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetBufferTblhdr</name><parameter_list>(<parameter><decl><type><name>SessionInput</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nRead</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+</operator> <name>nRead</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The hard upper limit for the number of columns in an SQLite
    ** database table is, according to sqliteLimit.h, 32676. So 
    ** consider any table-header that purports to have more than 65536 
    ** columns to be corrupt. This is convenient because otherwise, 
    ** if the (nCol&gt;65536) condition below were omitted, a sufficiently 
    ** large value for nCol may cause nRead to wrap around and become 
    ** negative. Leading to a crash. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>nCol</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nCol</name></expr></argument>&gt;</argument_list></name><literal type="number">65536</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nRead</name><operator>+</operator><name>nCol</name><operator>+</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRead</name> <operator>+=</operator> <name>nCol</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><operator>(</operator><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+</operator> <name>nRead</name><operator>)</operator><operator>&lt;</operator><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name> <operator>&amp;&amp;</operator> <name><name>pIn</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+</operator> <name>nRead</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRead</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+</operator> <name>nRead</name><operator>)</operator><operator>&lt;</operator><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nRead</name> <operator>+</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>pnByte</name> <operator>=</operator> <name>nRead</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The input pointer currently points to the first byte of the first field
** of a record consisting of nCol columns. This function ensures the entire
** record is buffered. It does not move the input pointer.
**
** If successful, SQLITE_OK is returned and *pnByte is set to the size of
** the record in bytes. Otherwise, an SQLite error code is returned. The
** final value of *pnByte is undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetBufferRecord</name><parameter_list>(
  <parameter><decl><type><name>SessionInput</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,              <comment type="block">/* Input data */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                       <comment type="block">/* Number of columns in record */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnByte</name></decl></parameter>                     <comment type="block">/* OUT: Size of record in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nByte</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+</operator> <name>nByte</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pIn</name><operator>-&gt;</operator><name>iNext</name></name><operator>+</operator><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pnByte</name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The input pointer currently points to the second byte of a table-header.
** Specifically, to the following:
**
**   + number of columns in table (varint)
**   + array of PK flags (1 byte per column),
**   + table name (nul terminated).
**
** This function decodes the table-header and populates the p-&gt;nCol, 
** p-&gt;zTab and p-&gt;abPK[] variables accordingly. The p-&gt;apValue[] array is 
** also allocated or resized according to the new value of p-&gt;nCol. The
** input pointer is left pointing to the byte following the table header.
**
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error code
** is returned and the final values of the various fields enumerated above
** are undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetReadTblhdr</name><parameter_list>(<parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetBufferTblhdr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nVarint</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nVarint</name> <operator>=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nCopy</name> <operator>-=</operator> <name>nVarint</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name> <operator>+=</operator> <name>nVarint</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCol</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tblhdr</name><operator>.</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tblhdr</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>iPK</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>tblhdr</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tblhdr</name><operator>.</operator><name>aBuf</name><index>[<expr><name>iPK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>tblhdr</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zTab</name></name> <operator>=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the changeset iterator to the next change. The differences between
** this function and sessionChangesetNext() are that
**
**   * If pbEmpty is not NULL and the change is a no-op UPDATE (an UPDATE
**     that modifies no columns), this function sets (*pbEmpty) to 1.
**
**   * If the iterator is configured to skip no-op UPDATEs,
**     sessionChangesetNext() does that. This function does not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetNextOne</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,      <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paRec</name></decl></parameter>,                     <comment type="block">/* If non-NULL, store record pointer here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRec</name></decl></parameter>,                     <comment type="block">/* If non-NULL, store size of record here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbNew</name></decl></parameter>,                     <comment type="block">/* If non-NULL, true if new table */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbEmpty</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>paRec</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pnRec</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>paRec</name> <operator>&amp;&amp;</operator> <name>pnRec</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbEmpty</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>pbEmpty</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the iterator is in the error-state, return immediately. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Free the current contents of p-&gt;apValue[], if any. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the buffer contains at least 10 bytes of input data, or all
  ** remaining data if there are less than 10 bytes available. This is
  ** sufficient either for the 'T' or 'P' byte and the varint that follows
  ** it, or for the two single byte values otherwise. */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* If the iterator is already at the end of the changeset, return DONE. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sessionDiscardData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iCurrent</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>op</name><operator>==</operator><literal type="char">'T'</literal> <operator>||</operator> <name>op</name><operator>==</operator><literal type="char">'P'</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pbNew</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbNew</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name> <operator>=</operator> <operator>(</operator><name>op</name><operator>==</operator><literal type="char">'P'</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sessionChangesetReadTblhdr</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iCurrent</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>nData</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_DONE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zTab</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bInvert</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first record in the changeset is not a table header. Must be a
    ** corrupt changeset. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>paRec</name></expr> )</condition><block>{<block_content> 
    <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>                     <comment type="block">/* Number of values to buffer */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCol</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nVal</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sessionChangesetBufferRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>pnRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>paRec</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name> <operator>+=</operator> <operator>*</operator><name>pnRec</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apOld</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bInvert</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bInvert</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If this is an UPDATE or DELETE, read the old.* record. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INSERT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sessionReadRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><name>apOld</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is an INSERT or UPDATE, read the new.* record. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sessionReadRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>apNew</name></expr></argument>, <argument><expr><name>pbEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>bInvert</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If this is an UPDATE that is part of a patchset, then all PK and
      ** modified fields are present in the new.* record. The old.* record
      ** is currently completely empty. This block shifts the PK fields from
      ** new.* to old.*, to accommodate the code that reads these arrays.  */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bInvert</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INSERT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SQLITE_DELETE</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SQLITE_INSERT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_ROW</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the changeset iterator to the next change.
**
** If both paRec and pnRec are NULL, then this function works like the public
** API sqlite3changeset_next(). If SQLITE_ROW is returned, then the
** sqlite3changeset_new() and old() APIs may be used to query for values.
**
** Otherwise, if paRec and pnRec are not NULL, then a pointer to the change
** record is written to *paRec before returning and the number of bytes in
** the record to *pnRec.
**
** Either way, this function returns SQLITE_ROW if the iterator is 
** successfully advanced to the next change in the changeset, an SQLite 
** error code if an error occurs, or SQLITE_DONE if there are no further 
** changes in the changeset.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetNext</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,      <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paRec</name></decl></parameter>,                     <comment type="block">/* If non-NULL, store record pointer here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRec</name></decl></parameter>,                     <comment type="block">/* If non-NULL, store size of record here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbNew</name></decl></parameter>                      <comment type="block">/* If non-NULL, true if new table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bEmpty</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>bEmpty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetNextOne</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>paRec</name></expr></argument>, <argument><expr><name>pnRec</name></expr></argument>, <argument><expr><name>pbNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bSkipEmpty</name></name> <operator>&amp;&amp;</operator> <name>bEmpty</name></expr>)</condition>;</do>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance an iterator created by sqlite3changeset_start() to the next
** change in the changeset. This function may return SQLITE_ROW, SQLITE_DONE
** or SQLITE_CORRUPT.
**
** This function may not be called on iterators passed to a conflict handler
** callback by changeset_apply().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_next</name><parameter_list>(<parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sessionChangesetNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following function extracts information on the current change
** from a changeset iterator. It may only be called after changeset_next()
** has returned SQLITE_ROW.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_op</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Iterator handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzTab</name></decl></parameter>,             <comment type="block">/* OUT: Pointer to table name */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCol</name></decl></parameter>,                     <comment type="block">/* OUT: Number of columns in table */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>,                       <comment type="block">/* OUT: SQLITE_INSERT, DELETE or UPDATE */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbIndirect</name></decl></parameter>                 <comment type="block">/* OUT: True if change is indirect */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pOp</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzTab</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>zTab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pbIndirect</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbIndirect</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>bIndirect</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return information regarding the PRIMARY KEY and number of columns in
** the database table affected by the change that pIter currently points
** to. This function may only be called after changeset_next() returns
** SQLITE_ROW.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_pk</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Iterator object */</comment>
  <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pabPK</name></decl></parameter>,          <comment type="block">/* OUT: Array of boolean - true for PK cols */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCol</name></decl></parameter>                      <comment type="block">/* OUT: Number of entries in output array */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pabPK</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>abPK</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnCol</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called while the iterator is pointing to an
** SQLITE_UPDATE or SQLITE_DELETE change (see sqlite3changeset_op()).
** Otherwise, SQLITE_MISUSE is returned.
**
** It sets *ppValue to point to an sqlite3_value structure containing the
** iVal'th value in the old.* record. Or, if that particular value is not
** included in the record (because the change is an UPDATE and the field
** was not modified and is not a PK column), set *ppValue to NULL.
**
** If value iVal is out-of-range, SQLITE_RANGE is returned and *ppValue is
** not modified. Otherwise, SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_old</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>,                       <comment type="block">/* Index of old.* value to retrieve */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppValue</name></decl></parameter>         <comment type="block">/* OUT: Old value (or NULL pointer) */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iVal</name><operator>&gt;=</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_RANGE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppValue</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>iVal</name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called while the iterator is pointing to an
** SQLITE_UPDATE or SQLITE_INSERT change (see sqlite3changeset_op()).
** Otherwise, SQLITE_MISUSE is returned.
**
** It sets *ppValue to point to an sqlite3_value structure containing the
** iVal'th value in the new.* record. Or, if that particular value is not
** included in the record (because the change is an UPDATE and the field
** was not modified), set *ppValue to NULL.
**
** If value iVal is out-of-range, SQLITE_RANGE is returned and *ppValue is
** not modified. Otherwise, SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_new</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>,                       <comment type="block">/* Index of new.* value to retrieve */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppValue</name></decl></parameter>         <comment type="block">/* OUT: New value (or NULL pointer) */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iVal</name><operator>&gt;=</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_RANGE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppValue</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><name>iVal</name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following two macros are used internally. They are similar to the
** sqlite3changeset_new() and sqlite3changeset_old() functions, except that
** they omit all error checking and return a pointer to the requested value.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sessionChangesetNew</name><parameter_list>(<parameter><type><name>pIter</name></type></parameter>, <parameter><type><name>iVal</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pIter)-&gt;apValue[(pIter)-&gt;nCol+(iVal)]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sessionChangesetOld</name><parameter_list>(<parameter><type><name>pIter</name></type></parameter>, <parameter><type><name>iVal</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pIter)-&gt;apValue[(iVal)]</cpp:value></cpp:define>

<comment type="block">/*
** This function may only be called with a changeset iterator that has been
** passed to an SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT 
** conflict-handler function. Otherwise, SQLITE_MISUSE is returned.
**
** If successful, *ppValue is set to point to an sqlite3_value structure
** containing the iVal'th value of the conflicting record.
**
** If value iVal is out-of-range or some other error occurs, an SQLite error
** code is returned. Otherwise, SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_conflict</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>,                       <comment type="block">/* Index of conflict record value to fetch */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppValue</name></decl></parameter>         <comment type="block">/* OUT: Value from conflicting row */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIter</name><operator>-&gt;</operator><name>pConflict</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iVal</name><operator>&gt;=</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_RANGE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppValue</name> <operator>=</operator> <call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>pConflict</name></name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called with an iterator passed to an
** SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case
** it sets the output variable to the total number of known foreign key
** violations in the destination database and returns SQLITE_OK.
**
** In all other cases this function returns SQLITE_MISUSE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_fk_conflicts</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>                      <comment type="block">/* OUT: Number of FK violations */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>pConflict</name></name> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>apValue</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Finalize an iterator allocated with sqlite3changeset_start().
**
** This function may not be called on iterators passed to a conflict handler
** callback by changeset_apply().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_finalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Used to iterate through p-&gt;apValue[] */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name></name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apValue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>tblhdr</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetInvert</name><parameter_list>(
  <parameter><decl><type><name>SessionInput</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>,           <comment type="block">/* Input changeset */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnInverted</name></decl></parameter>,                <comment type="block">/* OUT: Number of bytes in output changeset */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppInverted</name></decl></parameter>               <comment type="block">/* OUT: Inverse of pChangeset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return value */</comment>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>sOut</name></decl>;</decl_stmt>             <comment type="block">/* Output buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of cols in current table */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* PK array for current table */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Space for values for UPDATE inversion */</comment>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>sPK</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* PK array for current table */</comment>

  <comment type="block">/* Initialize the output buffer */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Zero the output variables in case an error occurs. */</comment>
  <if_stmt><if>if<condition>( <expr><name>ppInverted</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppInverted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnInverted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>

    <comment type="block">/* Test for EOF. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sessionInputBuffer</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished_invert</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name><operator>&gt;=</operator><name><name>pInput</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr>;</expr_stmt>

    <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="char">'T'</literal></expr>:</case> <block>{<block_content>
        <comment type="block">/* A 'table' record consists of:
        **
        **   * A constant 'T' character,
        **   * Number of columns in said table (a varint),
        **   * An array of nCol bytes (sPK),
        **   * A nul-terminated table name.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nVar</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sessionChangesetBufferTblhdr</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
          <goto>goto <name>finished_invert</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nVar</name> <operator>=</operator> <call><name>sessionVarintGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sPK</name><operator>.</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sPK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInput</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name><operator>+</operator><name>nVar</name></expr>]</index></name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInput</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished_invert</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>apVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>apVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>abPK</name> <operator>=</operator> <name><name>sPK</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>SQLITE_INSERT</name></expr>:</case>
      <case>case <expr><name>SQLITE_DELETE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bIndirect</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eType2</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>eType</name><operator>==</operator><name>SQLITE_DELETE</name></expr> ?</condition><then> <expr><name>SQLITE_INSERT</name></expr> </then><else>: <expr><name>SQLITE_DELETE</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetBufferRecord</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>eType2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>bIndirect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInput</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished_invert</name>;</goto></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>SQLITE_UPDATE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>apVal</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>apVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>apVal</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            <goto>goto <name>finished_invert</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>apVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Write the header for the new UPDATE change. Same as the original. */</comment>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Read the old.* and new.* records for the update change. */</comment>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>iNext</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionReadRecord</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionReadRecord</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apVal</name><index>[<expr><name>nCol</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Write the new old.* record. Consists of the PK columns from the
        ** original old.* record, and the other values from the original
        ** new.* record. */</comment>
        <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><name><name>apVal</name><index>[<expr><name>iCol</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>abPK</name><index>[<expr><name>iCol</name></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>nCol</name></expr></else></ternary><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sessionAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Write the new new.* record. Consists of a copy of all values
        ** from the original old.* record, except for the PK columns, which
        ** are set to "undefined". */</comment>
        <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>abPK</name><index>[<expr><name>iCol</name></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>apVal</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sessionAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name><operator>*</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>apVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>finished_invert</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>
      </block_content>}</block>

      <default>default:</default>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>finished_invert</name>;</goto>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>xOutput</name> <operator>&amp;&amp;</operator> <name><name>sOut</name><operator>.</operator><name>nBuf</name></name><operator>&gt;=</operator><name>sessions_strm_chunk_size</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished_invert</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnInverted</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>ppInverted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnInverted</name> <operator>=</operator> <name><name>sOut</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppInverted</name> <operator>=</operator> <name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>xOutput</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>finished_invert</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>apVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sPK</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Invert a changeset object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_invert</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nChangeset</name></decl></parameter>,                 <comment type="block">/* Number of bytes in input */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pChangeset</name></decl></parameter>,         <comment type="block">/* Input changeset */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnInverted</name></decl></parameter>,                <comment type="block">/* OUT: Number of bytes in output changeset */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppInverted</name></decl></parameter>               <comment type="block">/* OUT: Inverse of pChangeset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionInput</name></type> <name>sInput</name></decl>;</decl_stmt>

  <comment type="block">/* Set up the input stream */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sInput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionInput</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sInput</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <name>nChangeset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sInput</name><operator>.</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pChangeset</name></expr>;</expr_stmt>

  <return>return <expr><call><name>sessionChangesetInvert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sInput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pnInverted</name></expr></argument>, <argument><expr><name>ppInverted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Streaming version of sqlite3changeset_invert().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_invert_strm</name><parameter_list>(
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionInput</name></type> <name>sInput</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Set up the input stream */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sInput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionInput</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sInput</name><operator>.</operator><name>xInput</name></name> <operator>=</operator> <name>xInput</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sInput</name><operator>.</operator><name>pIn</name></name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetInvert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sInput</name></expr></argument>, <argument><expr><name>xOutput</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sInput</name><operator>.</operator><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><name><name>struct</name> <name>SessionUpdate</name></name></type> <name>SessionUpdate</name>;</typedef>
<struct>struct <name>SessionUpdate</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aMask</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionUpdate</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>SessionApplyCtx</name></name></type> <name>SessionApplyCtx</name>;</typedef>
<struct>struct <name>SessionApplyCtx</name> <block>{
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDelete</name></decl>;</decl_stmt>          <comment type="block">/* DELETE statement */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name></decl>;</decl_stmt>          <comment type="block">/* INSERT statement */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name></decl>;</decl_stmt>          <comment type="block">/* SELECT statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Size of azCol[] and abPK[] arrays */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl>;</decl_stmt>             <comment type="block">/* Array of column names */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl>;</decl_stmt>                       <comment type="block">/* Boolean array - true if column is in PK */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aUpdateMask</name></decl>;</decl_stmt>               <comment type="block">/* Used by sessionUpdateFind */</comment>
  <decl_stmt><decl><type><name>SessionUpdate</name> <modifier>*</modifier></type><name>pUp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bStat1</name></decl>;</decl_stmt>                     <comment type="block">/* True if table is sqlite_stat1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDeferConstraints</name></decl>;</decl_stmt>          <comment type="block">/* True to defer constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bInvertConstraints</name></decl>;</decl_stmt>         <comment type="block">/* Invert when iterating constraints buffer */</comment>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>constraints</name></decl>;</decl_stmt>      <comment type="block">/* Deferred constraints are stored here */</comment>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>rebase</name></decl>;</decl_stmt>           <comment type="block">/* Rebase information (if any) here */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bRebaseStarted</name></decl>;</decl_stmt>              <comment type="block">/* If table header is already in rebase */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bRebase</name></decl>;</decl_stmt>                     <comment type="block">/* True to collect rebase information */</comment>
}</block>;</struct>

<comment type="block">/* Number of prepared UPDATE statements to cache. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SESSION_UPDATE_CACHE_SZ</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<comment type="block">/*
** Find a prepared UPDATE statement suitable for the UPDATE step currently
** being visited by the iterator. The UPDATE is of the form:
**
**   UPDATE tbl SET col = ?, col2 = ? WHERE pk1 IS ? AND pk2 IS ?
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionUpdateFind</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionUpdate</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nU32</name> <init>= <expr><operator>(</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">33</literal><operator>)</operator><operator>/</operator><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nU32</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nU32</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sessionChangesetNew</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name><index>[<expr><name>ii</name><operator>/</operator><literal type="number">32</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ii</name><operator>%</operator><literal type="number">32</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bPatchset</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name><index>[<expr><name>nCol</name><operator>/</operator><literal type="number">32</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>nCol</name><operator>%</operator><literal type="number">32</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nUp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SessionUpdate</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nUp</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>aMask</name></name></expr></argument>, <argument><expr><name>nU32</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pUp</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pUp</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pUp</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pUp</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>nUp</name><operator>&gt;=</operator><name>SESSION_UPDATE_CACHE_SZ</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pUp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionUpdate</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nU32</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bStat1</name> <init>= <expr><operator>(</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pUp</name> <operator>=</operator> <operator>(</operator><name>SessionUpdate</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pUp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pUp</name><operator>-&gt;</operator><name>aMask</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pUp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>aMask</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name></expr></argument>, <argument><expr><name>nU32</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE main."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SET "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Create the assignments part of the UPDATE */</comment>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>ii</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sessionChangesetNew</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = ?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sessionAppendInteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ii</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Create the WHERE clause part of the UPDATE */</comment>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><name>bPatchset</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sessionChangesetOld</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>bStat1</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, 
                  <argument><expr><literal type="string">"idx IS CASE "</literal>
                  <literal type="string">"WHEN length(?4)=0 AND typeof(?4)='blob' THEN NULL "</literal>
                  <literal type="string">"ELSE ?4 END "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS ?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendInteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ii</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pUp</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pUp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pUp</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pUp</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator><operator>==</operator><operator>(</operator><name>pUp</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name><name>pUp</name><operator>-&gt;</operator><name>pStmt</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all cached UPDATE statements.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionUpdateFree</name><parameter_list>(<parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionUpdate</name> <modifier>*</modifier></type><name>pUp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionUpdate</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pUp</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</init> <condition><expr><name>pUp</name></expr>;</condition> <incr><expr><name>pUp</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pUp</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aUpdateMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Formulate a statement to DELETE a row from database db. Assuming a table
** structure like this:
**
**     CREATE TABLE x(a, b, c, d, PRIMARY KEY(a, c));
**
** The DELETE statement looks like this:
**
**     DELETE FROM x WHERE a = :1 AND c = :3 AND (:5 OR b IS :2 AND d IS :4)
**
** Variable :5 (nCol+1) is a boolean. It should be set to 0 if we require
** matching b and d values, or 1 otherwise. The second case comes up if the
** conflict handler is invoked with NOTFOUND and returns CHANGESET_REPLACE.
**
** If successful, SQLITE_OK is returned and SessionApplyCtx.pDelete is left
** pointing to the prepared version of the SQL statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionDeleteRow</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>              <comment type="block">/* Session changeset-apply context */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM main."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nPk</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = ?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendInteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>nPk</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AND (?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionAppendInteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OR "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS ?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendInteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"AND "</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Formulate and prepare an SQL statement to query table zTab by primary
** key. Assuming the following table structure:
**
**     CREATE TABLE x(a, b, c, d, PRIMARY KEY(a, c));
**
** The SELECT statement looks like this:
**
**     SELECT * FROM x WHERE a = ?1 AND c = ?3
**
** If successful, SQLITE_OK is returned and SessionApplyCtx.pSelect is left
** pointing to the prepared version of the SQL statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionSelectRow</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>              <comment type="block">/* Session changeset-apply context */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sessionSelectStmt</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Formulate and prepare an INSERT statement to add a record to table zTab.
** For example:
**
**     INSERT INTO main."zTab" VALUES(?1, ?2, ?3 ...);
**
** If successful, SQLITE_OK is returned and SessionApplyCtx.pInsert is left
** pointing to the prepared version of the SQL statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionInsertRow</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>              <comment type="block">/* Session changeset-apply context */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO main."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sessionAppendIdent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") VALUES(?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", ?"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sessionAppendStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionPrepare</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Prepare statements for applying changes to the sqlite_stat1 table.
** These are similar to those created by sessionSelectRow(),
** sessionInsertRow(), sessionUpdateRow() and sessionDeleteRow() for 
** other tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionStat1Sql</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sessionSelectRow</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionPrepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>,
        <argument><expr><literal type="string">"INSERT INTO main.sqlite_stat1 VALUES(?1, "</literal>
        <literal type="string">"CASE WHEN length(?2)=0 AND typeof(?2)='blob' THEN NULL ELSE ?2 END, "</literal>
        <literal type="string">"?3)"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionPrepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>,
        <argument><expr><literal type="string">"DELETE FROM main.sqlite_stat1 WHERE tbl=?1 AND idx IS "</literal>
        <literal type="string">"CASE WHEN length(?2)=0 AND typeof(?2)='blob' THEN NULL ELSE ?2 END "</literal>
        <literal type="string">"AND (?4 OR stat IS ?3)"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A wrapper around sqlite3_bind_value() that detects an extra problem. 
** See comments in the body of this function for details.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionBindValue</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,            <comment type="block">/* Statement to bind value to */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,                          <comment type="block">/* Parameter number to bind to */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>             <comment type="block">/* Value to bind */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block">/* COVERAGE: The (pVal-&gt;z==0) branch is never true using current versions
  ** of SQLite. If a malloc fails in an sqlite3_value_xxx() function, either
  ** the (pVal-&gt;z) variable remains as it was or the type of the value is
  ** set to SQLITE_NULL.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_BLOB</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pVal</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* This condition occurs when an earlier OOM in a call to
    ** sqlite3_value_text() or sqlite3_value_blob() (perhaps from within
    ** a conflict-handler) has zeroed the pVal-&gt;z pointer. Return NOMEM. */</comment>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Iterator pIter must point to an SQLITE_INSERT entry. This function 
** transfers new.* values from the current iterator entry to statement
** pStmt. The table being inserted into has nCol columns.
**
** New.* value $i from the iterator is bound to variable ($i+1) of 
** statement pStmt. If parameter abPK is NULL, all values from 0 to (nCol-1)
** are transfered to the statement. Otherwise, if abPK is not NULL, it points
** to an array nCol elements in size. In this case only those values for 
** which abPK[$i] is true are read from the iterator and bound to the 
** statement.
**
** An SQLite error code is returned if an error occurs. Otherwise, SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionBindRow</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Iterator to read values from */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xValue</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                       <comment type="block">/* Number of columns */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>,                       <comment type="block">/* If not NULL, bind only if true */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>             <comment type="block">/* Bind values to this statement */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Neither sqlite3changeset_old or sqlite3changeset_new can fail if the
  ** argument iterator points to a suitable entry. Make sure that xValue 
  ** is one of these to guarantee that it is safe to ignore the return 
  ** in the code below. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xValue</name><operator>==</operator><name>sqlite3changeset_old</name> <operator>||</operator> <name>xValue</name><operator>==</operator><name>sqlite3changeset_new</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>abPK</name> <operator>||</operator> <name><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>xValue</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* The value in the changeset was "undefined". This indicates a
        ** corrupt changeset blob.  */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionBindValue</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQL statement pSelect is as generated by the sessionSelectRow() function.
** This function binds the primary key values from the change that changeset
** iterator pIter points to to the SELECT and attempts to seek to the table
** entry. If a row is found, the SELECT statement left pointing at the row 
** and SQLITE_ROW is returned. Otherwise, if no row is found and no error
** has occured, the statement is reset and SQLITE_OK is returned. If an
** error occurs, the statement is reset and an SQLite error code is returned.
**
** If this function returns SQLITE_ROW, the caller must eventually reset() 
** statement pSelect. If any other value is returned, the statement does
** not require a reset().
**
** If the iterator currently points to an INSERT record, bind values from the
** new.* record to the SELECT statement. Or, if it points to a DELETE or
** UPDATE, bind values from the old.* record. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionSeekToRow</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl></parameter>,                       <comment type="block">/* Primary key flags array */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>           <comment type="block">/* SELECT statement from sessionSelectRow() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                         <comment type="block">/* Changset operation (SQLITE_UPDATE etc.) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDummy</name></decl>;</decl_stmt>             <comment type="block">/* Unused */</comment>

  <expr_stmt><expr><call><name>sqlite3changeset_op</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionBindRow</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, 
      <argument><expr><ternary><condition><expr><name>op</name><operator>==</operator><name>SQLITE_INSERT</name></expr> ?</condition><then> <expr><name>sqlite3changeset_new</name></expr> </then><else>: <expr><name>sqlite3changeset_old</name></expr></else></ternary></expr></argument>,
      <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called from within sqlite3changeset_apply_v2() when
** a conflict is encountered and resolved using conflict resolution
** mode eType (either SQLITE_CHANGESET_OMIT or SQLITE_CHANGESET_REPLACE)..
** It adds a conflict resolution record to the buffer in 
** SessionApplyCtx.rebase, which will eventually be returned to the caller
** of apply_v2() as the "rebase" buffer.
**
** Return SQLITE_OK if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionRebaseAdd</name><parameter_list>(
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Apply context */</comment>
  <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>,                      <comment type="block">/* Conflict resolution (OMIT or REPLACE) */</comment>
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>   <comment type="block">/* Iterator pointing at current change */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRebase</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eOp</name> <init>= <expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRebaseStarted</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Append a table-header to the rebase buffer */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><name><name>pIter</name><operator>-&gt;</operator><name>zTab</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rebase</name></name></expr></argument>, <argument><expr><literal type="char">'T'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rebase</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rebase</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rebase</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zTab</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bRebaseStarted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_CHANGESET_REPLACE</name><operator>||</operator><name>eType</name><operator>==</operator><name>SQLITE_CHANGESET_OMIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SQLITE_INSERT</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SQLITE_UPDATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rebase</name></name></expr></argument>, 
        <argument><expr><operator>(</operator><ternary><condition><expr><name>eOp</name><operator>==</operator><name>SQLITE_DELETE</name></expr> ?</condition><then> <expr><name>SQLITE_DELETE</name></expr> </then><else>: <expr><name>SQLITE_INSERT</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rebase</name></name></expr></argument>, <argument><expr><operator>(</operator><name>eType</name><operator>==</operator><name>SQLITE_CHANGESET_REPLACE</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>||</operator> <operator>(</operator><name>eOp</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3changeset_old</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3changeset_new</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sessionAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rebase</name></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the conflict handler for the change that the changeset iterator
** currently points to.
**
** Argument eType must be either CHANGESET_DATA or CHANGESET_CONFLICT.
** If argument pbReplace is NULL, then the type of conflict handler invoked
** depends solely on eType, as follows:
**
**    eType value                 Value passed to xConflict
**    -------------------------------------------------
**    CHANGESET_DATA              CHANGESET_NOTFOUND
**    CHANGESET_CONFLICT          CHANGESET_CONSTRAINT
**
** Or, if pbReplace is not NULL, then an attempt is made to find an existing
** record with the same primary key as the record about to be deleted, updated
** or inserted. If such a record can be found, it is available to the conflict
** handler as the "conflicting" record. In this case the type of conflict
** handler invoked is as follows:
**
**    eType value         PK Record found?   Value passed to xConflict
**    ----------------------------------------------------------------
**    CHANGESET_DATA      Yes                CHANGESET_DATA
**    CHANGESET_DATA      No                 CHANGESET_NOTFOUND
**    CHANGESET_CONFLICT  Yes                CHANGESET_CONFLICT
**    CHANGESET_CONFLICT  No                 CHANGESET_CONSTRAINT
**
** If pbReplace is not NULL, and a record with a matching PK is found, and
** the conflict handler function returns SQLITE_CHANGESET_REPLACE, *pbReplace
** is set to non-zero before returning SQLITE_OK.
**
** If the conflict handler returns SQLITE_CHANGESET_ABORT, SQLITE_ABORT is
** returned. Or, if the conflict handler returns an invalid value, 
** SQLITE_MISUSE. If the conflict handler returns SQLITE_CHANGESET_OMIT,
** this function returns SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionConflictHandler</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>,                      <comment type="block">/* Either CHANGESET_DATA or CONFLICT */</comment>
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* changeset_apply() context */</comment>
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_changeset_iter</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* First argument for conflict handler */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbReplace</name></decl></parameter>                  <comment type="block">/* OUT: Set to true if PK row is found */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Value returned by conflict handler */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDummy</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3changeset_op</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_CHANGESET_CONFLICT</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_CHANGESET_DATA</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHANGESET_CONFLICT</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>SQLITE_CHANGESET_CONSTRAINT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHANGESET_DATA</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>SQLITE_CHANGESET_NOTFOUND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Bind the new.* PRIMARY KEY values to the SELECT statement. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pbReplace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionSeekToRow</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* There exists another row with the new.* primary key. */</comment>
    <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>pConflict</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>xConflict</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>pConflict</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bDeferConstraints</name></name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>SQLITE_CHANGESET_CONFLICT</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Instead of invoking the conflict handler, append the change blob
      ** to the SessionApplyCtx.constraints buffer. */</comment>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBlob</name> <init>= <expr><operator>&amp;</operator><name><name>pIter</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>aData</name><index>[<expr><name><name>pIter</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iCurrent</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><name><name>pIter</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iNext</name></name> <operator>-</operator> <name><name>pIter</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>iCurrent</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* No other row with the new.* primary key. */</comment>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>xConflict</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>eType</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><name>SQLITE_CHANGESET_REPLACE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_CHANGESET_REPLACE</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbReplace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pbReplace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_CHANGESET_OMIT</name></expr>:</case>
        <break>break;</break>

      <case>case <expr><name>SQLITE_CHANGESET_ABORT</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ABORT</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionRebaseAdd</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to apply the change that the iterator passed as the first argument
** currently points to to the database. If a conflict is encountered, invoke
** the conflict handler callback.
**
** If argument pbRetry is NULL, then ignore any CHANGESET_DATA conflict. If
** one is encountered, update or delete the row with the matching primary key
** instead. Or, if pbRetry is not NULL and a CHANGESET_DATA conflict occurs,
** invoke the conflict handler. If it returns CHANGESET_REPLACE, set *pbRetry
** to true before returning. In this case the caller will invoke this function
** again, this time with pbRetry set to NULL.
**
** If argument pbReplace is NULL and a CHANGESET_CONFLICT conflict is 
** encountered invoke the conflict handler with CHANGESET_CONSTRAINT instead.
** Or, if pbReplace is not NULL, invoke it with CHANGESET_CONFLICT. If such
** an invocation returns SQLITE_CHANGESET_REPLACE, set *pbReplace to true
** before retrying. In this case the caller attempts to remove the conflicting
** row before invoking this function again, this time with pbReplace set 
** to NULL.
**
** If any conflict handler returns SQLITE_CHANGESET_ABORT, this function
** returns SQLITE_ABORT. Otherwise, if no error occurs, SQLITE_OK is 
** returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionApplyOneOp</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator */</comment>
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* changeset_apply() context */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* First argument for the conflict handler */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbReplace</name></decl></parameter>,                 <comment type="block">/* OUT: True to remove PK row and retry */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbRetry</name></decl></parameter>                    <comment type="block">/* OUT: True to retry. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pInsert</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azCol</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pbReplace</name> <operator>||</operator> <operator>*</operator><name>pbReplace</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3changeset_op</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Bind values to the DELETE statement. If conflict handling is required,
    ** bind values for all columns and set bound variable (nCol+1) to true.
    ** Or, if conflict handling is not required, bind just the PK column
    ** values and, if it exists, set (nCol+1) to false. Conflict handling
    ** is not required if:
    **
    **   * this is a patchset, or
    **   * (pbRetry==0), or
    **   * all columns of the table are PK columns (in this case there is
    **     no (nCol+1) variable to bind to).
    */</comment>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionBindRow</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>sqlite3changeset_old</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_bind_parameter_count</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><name>nCol</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>, <argument><expr><name>nCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>pbRetry</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>abPK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_changes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionConflictHandler</name><argument_list>(
          <argument><expr><name>SQLITE_CHANGESET_DATA</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pbRetry</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionConflictHandler</name><argument_list>(
          <argument><expr><name>SQLITE_CHANGESET_CONFLICT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bPatchset</name> <init>= <expr><operator>(</operator><name>pbRetry</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionUpdateFind</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>bPatchset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Bind values to the UPDATE statement. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pOld</name> <init>= <expr><call><name>sessionChangesetOld</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sessionChangesetNew</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><name>bPatchset</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pOld</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionBindValue</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionBindValue</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Attempt the UPDATE. In the case of a NOTFOUND or DATA conflict,
    ** the result will be SQLITE_OK with 0 rows modified. */</comment>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_changes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* A NOTFOUND or DATA error. Search the table to see if it contains
      ** a row with a matching primary key. If so, this is a DATA conflict.
      ** Otherwise, if there is no primary key match, it is a NOTFOUND. */</comment>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionConflictHandler</name><argument_list>(
          <argument><expr><name>SQLITE_CHANGESET_DATA</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pbRetry</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This is always a CONSTRAINT conflict. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionConflictHandler</name><argument_list>(
          <argument><expr><name>SQLITE_CHANGESET_CONFLICT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>SQLITE_INSERT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bStat1</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Check if there is a conflicting row. For sqlite_stat1, this needs
      ** to be done using a SELECT, as there is no PRIMARY KEY in the 
      ** database schema to throw an exception if a duplicate is inserted.  */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionSeekToRow</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionBindRow</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>sqlite3changeset_new</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionConflictHandler</name><argument_list>(
          <argument><expr><name>SQLITE_CHANGESET_CONFLICT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pbReplace</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to apply the change that the iterator passed as the first argument
** currently points to to the database. If a conflict is encountered, invoke
** the conflict handler callback.
**
** The difference between this function and sessionApplyOne() is that this
** function handles the case where the conflict-handler is invoked and 
** returns SQLITE_CHANGESET_REPLACE - indicating that the change should be
** retried in some manner.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionApplyOneWithRetry</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Apply change to "main" db of this handle */</comment>
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset iterator to read change from */</comment>
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>pApply</name></decl></parameter>,        <comment type="block">/* Apply context */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_changeset_iter</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* First argument passed to xConflict */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bReplace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bRetry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionApplyOneOp</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>pApply</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bReplace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bRetry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the bRetry flag is set, the change has not been applied due to an
    ** SQLITE_CHANGESET_DATA problem (i.e. this is an UPDATE or DELETE and
    ** a row with the correct PK is present in the db, but one or more other
    ** fields do not contain the expected values) and the conflict handler 
    ** returned SQLITE_CHANGESET_REPLACE. In this case retry the operation,
    ** but pass NULL as the final argument so that sessionApplyOneOp() ignores
    ** the SQLITE_CHANGESET_DATA problem.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>bRetry</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionApplyOneOp</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>pApply</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

    <comment type="block">/* If the bReplace flag is set, the change is an INSERT that has not
    ** been performed because the database already contains a row with the
    ** specified primary key and the conflict handler returned
    ** SQLITE_CHANGESET_REPLACE. In this case remove the conflicting row
    ** before reattempting the INSERT.  */</comment>
    <if type="elseif">else if<condition>( <expr><name>bReplace</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INSERT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT replace_op"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionBindRow</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, 
            <argument><expr><name>sqlite3changeset_new</name></expr></argument>, <argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>, <argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionApplyOneOp</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>pApply</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"RELEASE replace_op"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Retry the changes accumulated in the pApply-&gt;constraints buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionRetryConstraints</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><name>SessionApplyCtx</name> <modifier>*</modifier></type><name>pApply</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_changeset_iter</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* First argument passed to xConflict */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name><name>pApply</name><operator>-&gt;</operator><name>constraints</name><operator>.</operator><name>nBuf</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>cons</name> <init>= <expr><name><name>pApply</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pApply</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetStart</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name>pIter2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>cons</name><operator>.</operator><name>nBuf</name></name></expr></argument>, <argument><expr><name><name>cons</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>bInvertConstraints</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>nByte</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><name><name>pApply</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pIter2</name><operator>-&gt;</operator><name>bPatchset</name></name> <operator>=</operator> <name>bPatchset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIter2</name><operator>-&gt;</operator><name>zTab</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zTab</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIter2</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name><name>pApply</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIter2</name><operator>-&gt;</operator><name>abPK</name></name> <operator>=</operator> <name><name>pApply</name><operator>-&gt;</operator><name>abPK</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pIter2</name><operator>-&gt;</operator><name>tblhdr</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIter2</name><operator>-&gt;</operator><name>apValue</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>pIter2</name><operator>-&gt;</operator><name>tblhdr</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pIter2</name><operator>-&gt;</operator><name>apValue</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3changeset_next</name><argument_list>(<argument><expr><name>pIter2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionApplyOneWithRetry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIter2</name></expr></argument>, <argument><expr><name>pApply</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pApply</name><operator>-&gt;</operator><name>bDeferConstraints</name></name> <operator>||</operator> <name><name>pApply</name><operator>-&gt;</operator><name>constraints</name><operator>.</operator><name>nBuf</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>cons</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pApply</name><operator>-&gt;</operator><name>constraints</name><operator>.</operator><name>nBuf</name></name><operator>&gt;=</operator><name><name>cons</name><operator>.</operator><name>nBuf</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* No progress was made on the last round. */</comment>
      <expr_stmt><expr><name><name>pApply</name><operator>-&gt;</operator><name>bDeferConstraints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument pIter is a changeset iterator that has been initialized, but
** not yet passed to sqlite3changeset_next(). This function applies the 
** changeset to the main database attached to handle "db". The supplied
** conflict handler callback is invoked to resolve any conflicts encountered
** while applying the change.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetApply</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Apply change to "main" db of this handle */</comment>
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Changeset to apply */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xFilter</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>              <comment type="block">/* Table name */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of fifth arg to _apply() */</comment>
    <parameter><decl><type><name>int</name></type> <name>eConflict</name></decl></parameter>,                <comment type="block">/* DATA, MISSING, CONFLICT, CONSTRAINT */</comment>
    <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>     <comment type="block">/* Handle describing change and conflict */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* First argument passed to xConflict */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRebase</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRebase</name></decl></parameter>, <comment type="block">/* OUT: Rebase information */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>                       <comment type="block">/* SESSION_APPLY_XXX flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>schemaMismatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Name of current table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Result of sqlite3Strlen30(zTab) */</comment>
  <decl_stmt><decl><type><name>SessionApplyCtx</name></type> <name>sApply</name></decl>;</decl_stmt>         <comment type="block">/* changeset_apply() context object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPatchset</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xConflict</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>bNoDiscard</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sApply</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>bRebase</name></name> <operator>=</operator> <operator>(</operator><name>ppRebase</name> <operator>&amp;&amp;</operator> <name>pnRebase</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>bInvertConstraints</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_CHANGESETAPPLY_INVERT</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_CHANGESETAPPLY_NOSAVEPOINT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT changeset_apply"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA defer_foreign_keys = 1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3changeset_next</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>sqlite3changeset_op</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>nTab</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionRetryConstraints</name><argument_list>(
          <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>sessionUpdateFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>sApply</name><operator>.</operator><name>azCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* cast works around VC++ bug */</comment>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>sApply</name><operator>.</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>sApply</name><operator>.</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>sApply</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>pDelete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>pInsert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>nCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>azCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>abPK</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>bStat1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>bDeferConstraints</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>bRebaseStarted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sApply</name><operator>.</operator><name>constraints</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If an xFilter() callback was specified, invoke it now. If the 
      ** xFilter callback returns zero, skip this table. If it returns
      ** non-zero, proceed. */</comment>
      <expr_stmt><expr><name>schemaMismatch</name> <operator>=</operator> <operator>(</operator><name>xFilter</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>xFilter</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>schemaMismatch</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zTab</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nTab</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>azCol</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>zTab</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nMinCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>sqlite3changeset_pk</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abPK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionTableInfo</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, 
            <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sApply</name><operator>.</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sApply</name><operator>.</operator><name>azCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sApply</name><operator>.</operator><name>abPK</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sApply</name><operator>.</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>sApply</name><operator>.</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMinCol</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
  
        <if_stmt><if>if<condition>( <expr><name><name>sApply</name><operator>.</operator><name>nCol</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>schemaMismatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_SCHEMA</name></expr></argument>, 
              <argument><expr><literal type="string">"sqlite3changeset_apply(): no such table: %s"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><name><name>sApply</name><operator>.</operator><name>nCol</name></name><operator>&lt;</operator><name>nCol</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>schemaMismatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_SCHEMA</name></expr></argument>, 
              <argument><expr><literal type="string">"sqlite3changeset_apply(): table %s has %d columns, "</literal>
              <literal type="string">"expected %d or more"</literal></expr></argument>, 
              <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>sApply</name><operator>.</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><name>nCol</name><operator>&lt;</operator><name>nMinCol</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>sApply</name><operator>.</operator><name>abPK</name></name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>schemaMismatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_SCHEMA</name></expr></argument>, <argument><expr><literal type="string">"sqlite3changeset_apply(): "</literal>
              <literal type="string">"primary key mismatch for table %s"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block>{<block_content>
          <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sessionStat1Sql</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>)</argument_list></call> <operator>)</operator></expr> )</condition><block>{<block_content>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>bStat1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sessionSelectRow</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>)</argument_list></call><operator>)</operator>
             <operator>||</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sessionDeleteRow</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>)</argument_list></call><operator>)</operator>
             <operator>||</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sessionInsertRow</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
            )</condition><block>{<block_content>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>bStat1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>nTab</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If there is a schema mismatch on the current table, proceed to the
    ** next change. A log message has already been issued. */</comment>
    <if_stmt><if>if<condition>( <expr><name>schemaMismatch</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionApplyOneWithRetry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name>bPatchset</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionRetryConstraints</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>bPatchset</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nFk</name></decl>, <decl><type ref="prev"/><name>notUsed</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_DEFERRED_FKS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nFk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>notUsed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nFk</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>SQLITE_CHANGESET_ABORT</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_changeset_iter</name></type> <name>sIter</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sIter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>nCol</name></name> <operator>=</operator> <name>nFk</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>xConflict</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>SQLITE_CHANGESET_FOREIGN_KEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>!=</operator><name>SQLITE_CHANGESET_OMIT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA defer_foreign_keys = 0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_CHANGESETAPPLY_NOSAVEPOINT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"RELEASE changeset_apply"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO changeset_apply"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"RELEASE changeset_apply"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sApply</name><operator>.</operator><name>bRebase</name></name> <operator>||</operator> <name><name>sApply</name><operator>.</operator><name>rebase</name><operator>.</operator><name>nBuf</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bPatchset</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sApply</name><operator>.</operator><name>bRebase</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppRebase</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>sApply</name><operator>.</operator><name>rebase</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnRebase</name> <operator>=</operator> <name><name>sApply</name><operator>.</operator><name>rebase</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sApply</name><operator>.</operator><name>rebase</name><operator>.</operator><name>aBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sessionUpdateFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sApply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>sApply</name><operator>.</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>sApply</name><operator>.</operator><name>pDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>sApply</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>sApply</name><operator>.</operator><name>azCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* cast works around VC++ bug */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>sApply</name><operator>.</operator><name>constraints</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>sApply</name><operator>.</operator><name>rebase</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_db_mutex</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Apply the changeset passed via pChangeset/nChangeset to the main 
** database attached to handle "db".
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_apply_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Apply change to "main" db of this handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nChangeset</name></decl></parameter>,                 <comment type="block">/* Size of changeset in bytes */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pChangeset</name></decl></parameter>,               <comment type="block">/* Changeset blob */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xFilter</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>              <comment type="block">/* Table name */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><name>int</name></type> <name>eConflict</name></decl></parameter>,                <comment type="block">/* DATA, MISSING, CONFLICT, CONSTRAINT */</comment>
    <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>     <comment type="block">/* Handle describing change and conflict */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* First argument passed to xConflict */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRebase</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRebase</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>  <comment type="block">/* Iterator to skip through changeset */</comment>  
  <decl_stmt><decl><type><name>int</name></type> <name>bInv</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_CHANGESETAPPLY_INVERT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sessionChangesetStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nChangeset</name></expr></argument>, <argument><expr><name>pChangeset</name></expr></argument>, <argument><expr><name>bInv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetApply</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xFilter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>ppRebase</name></expr></argument>, <argument><expr><name>pnRebase</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Apply the changeset passed via pChangeset/nChangeset to the main database
** attached to handle "db". Invoke the supplied conflict handler callback
** to resolve any conflicts encountered while applying the change.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_apply</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Apply change to "main" db of this handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nChangeset</name></decl></parameter>,                 <comment type="block">/* Size of changeset in bytes */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pChangeset</name></decl></parameter>,               <comment type="block">/* Changeset blob */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xFilter</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>              <comment type="block">/* Table name */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of fifth arg to _apply() */</comment>
    <parameter><decl><type><name>int</name></type> <name>eConflict</name></decl></parameter>,                <comment type="block">/* DATA, MISSING, CONFLICT, CONSTRAINT */</comment>
    <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>     <comment type="block">/* Handle describing change and conflict */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* First argument passed to xConflict */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3changeset_apply_v2</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>, <argument><expr><name>nChangeset</name></expr></argument>, <argument><expr><name>pChangeset</name></expr></argument>, <argument><expr><name>xFilter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Apply the changeset passed via xInput/pIn to the main database
** attached to handle "db". Invoke the supplied conflict handler callback
** to resolve any conflicts encountered while applying the change.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_apply_v2_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Apply change to "main" db of this handle */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Input function */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,                                          <comment type="block">/* First arg for xInput */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xFilter</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>              <comment type="block">/* Table name */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><name>int</name></type> <name>eConflict</name></decl></parameter>,                <comment type="block">/* DATA, MISSING, CONFLICT, CONSTRAINT */</comment>
    <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>     <comment type="block">/* Handle describing change and conflict */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* First argument passed to xConflict */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRebase</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRebase</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>  <comment type="block">/* Iterator to skip through changeset */</comment>  
  <decl_stmt><decl><type><name>int</name></type> <name>bInverse</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_CHANGESETAPPLY_INVERT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sessionChangesetStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><name>xInput</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bInverse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetApply</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xFilter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>ppRebase</name></expr></argument>, <argument><expr><name>pnRebase</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3changeset_apply_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Apply change to "main" db of this handle */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Input function */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,                                          <comment type="block">/* First arg for xInput */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xFilter</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>              <comment type="block">/* Table name */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xConflict</name>)<parameter_list>(
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                   <comment type="block">/* Copy of sixth arg to _apply() */</comment>
    <parameter><decl><type><name>int</name></type> <name>eConflict</name></decl></parameter>,                <comment type="block">/* DATA, MISSING, CONFLICT, CONSTRAINT */</comment>
    <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>     <comment type="block">/* Handle describing change and conflict */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* First argument passed to xConflict */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3changeset_apply_v2_strm</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>, <argument><expr><name>xInput</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>xFilter</name></expr></argument>, <argument><expr><name>xConflict</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** sqlite3_changegroup handle.
*/</comment>
<struct>struct <name>sqlite3_changegroup</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Error code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPatch</name></decl>;</decl_stmt>                     <comment type="block">/* True to accumulate patchsets */</comment>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>            <comment type="block">/* List of tables in current patch */</comment>
}</block>;</struct>

<comment type="block">/*
** This function is called to merge two changes to the same row together as
** part of an sqlite3changeset_concat() operation. A new change object is
** allocated and a pointer to it stored in *ppNew.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangeMerge</name><parameter_list>(
  <parameter><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* Table structure */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRebase</name></decl></parameter>,                    <comment type="block">/* True for a rebase hash-table */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPatchset</name></decl></parameter>,                  <comment type="block">/* True for patchsets */</comment>
  <parameter><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pExist</name></decl></parameter>,          <comment type="block">/* Existing change */</comment>
  <parameter><decl><type><name>int</name></type> <name>op2</name></decl></parameter>,                        <comment type="block">/* Second change operation */</comment>
  <parameter><decl><type><name>int</name></type> <name>bIndirect</name></decl></parameter>,                  <comment type="block">/* True if second change is indirect */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name></decl></parameter>,                       <comment type="block">/* Second change record */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRec</name></decl></parameter>,                       <comment type="block">/* Number of bytes in aRec */</comment>
  <parameter><decl><type><name>SessionChange</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNew</name></decl></parameter>           <comment type="block">/* OUT: Merged change */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pExist</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>SessionChange</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>=</operator> <name>bIndirect</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bIndirect</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bRebase</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>=</operator> <name>nRec</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pIn</name> <init>= <expr><name>aRec</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>nIn</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>pIn</name> <operator>+=</operator> <name>nIn</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>=</operator> <name>pOut</name> <operator>-</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bRebase</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExist</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name><name>pExist</name><operator>-&gt;</operator><name>bIndirect</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppNew</name> <operator>=</operator> <name>pExist</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><name>nRec</name> <operator>+</operator> <name><name>pExist</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>SessionChange</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><name><name>pExist</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><name>aRec</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>=</operator> <name>bIndirect</name> <operator>||</operator> <name><name>pExist</name><operator>-&gt;</operator><name>bIndirect</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>n1</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>*</operator><name>a1</name><operator>==</operator><literal type="number">0xFF</literal> <operator>||</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bIndirect</name><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>a2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>a1</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>a2</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>=</operator> <name>pOut</name> <operator>-</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pExist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>op1</name> <init>= <expr><name><name>pExist</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* 
    **   op1=INSERT, op2=INSERT      -&gt;      Unsupported. Discard op2.
    **   op1=INSERT, op2=UPDATE      -&gt;      INSERT.
    **   op1=INSERT, op2=DELETE      -&gt;      (none)
    **
    **   op1=UPDATE, op2=INSERT      -&gt;      Unsupported. Discard op2.
    **   op1=UPDATE, op2=UPDATE      -&gt;      UPDATE.
    **   op1=UPDATE, op2=DELETE      -&gt;      DELETE.
    **
    **   op1=DELETE, op2=INSERT      -&gt;      UPDATE.
    **   op1=DELETE, op2=UPDATE      -&gt;      Unsupported. Discard op2.
    **   op1=DELETE, op2=DELETE      -&gt;      Unsupported. Discard op2.
    */</comment>   
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op1</name><operator>==</operator><name>SQLITE_INSERT</name> <operator>&amp;&amp;</operator> <name>op2</name><operator>==</operator><name>SQLITE_INSERT</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>op1</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name>op2</name><operator>==</operator><name>SQLITE_INSERT</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>op1</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name>op2</name><operator>==</operator><name>SQLITE_UPDATE</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>op1</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name>op2</name><operator>==</operator><name>SQLITE_DELETE</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name>pExist</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op1</name><operator>==</operator><name>SQLITE_INSERT</name> <operator>&amp;&amp;</operator> <name>op2</name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pExist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aExist</name> <init>= <expr><name><name>pExist</name><operator>-&gt;</operator><name>aRecord</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aCsr</name></decl>;</decl_stmt>

      <comment type="block">/* Allocate a new SessionChange object. Ensure that the aRecord[]
      ** buffer of the new object is large enough to hold any record that
      ** may be generated by combining the input records.  */</comment>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pExist</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>+</operator> <name>nRec</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>SessionChange</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pExist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bIndirect</name></name> <operator>=</operator> <operator>(</operator><name>bIndirect</name> <operator>&amp;&amp;</operator> <name><name>pExist</name><operator>-&gt;</operator><name>bIndirect</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>aCsr</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>op1</name><operator>==</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>             <comment type="block">/* INSERT + UPDATE */</comment>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><name>aRec</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op2</name><operator>==</operator><name>SQLITE_UPDATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SQLITE_INSERT</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bPatchset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sessionSkipRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a1</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sessionMergeRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aCsr</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>aExist</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op1</name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>       <comment type="block">/* DELETE + INSERT */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op2</name><operator>==</operator><name>SQLITE_INSERT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SQLITE_UPDATE</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bPatchset</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aCsr</name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>aCsr</name> <operator>+=</operator> <name>nRec</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sessionMergeUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aCsr</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>bPatchset</name></expr></argument>, <argument><expr><name>aExist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>aRec</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op2</name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>       <comment type="block">/* UPDATE + UPDATE */</comment>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><name>aExist</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><name>aRec</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op1</name><operator>==</operator><name>SQLITE_UPDATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bPatchset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sessionSkipRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a1</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sessionSkipRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a2</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SQLITE_UPDATE</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sessionMergeUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aCsr</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>bPatchset</name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>aExist</name></expr></argument>,<argument><expr><name>a1</name></expr></argument>,<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>                                <comment type="block">/* UPDATE + DELETE */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op1</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name>op2</name><operator>==</operator><name>SQLITE_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SQLITE_DELETE</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bPatchset</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aCsr</name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>aCsr</name> <operator>+=</operator> <name>nRec</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sessionMergeRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aCsr</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>aExist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRecord</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>aCsr</name> <operator>-</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aRecord</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pExist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppNew</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add all changes in the changeset traversed by the iterator passed as
** the first argument to the changegroup hash tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangesetToHash</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,   <comment type="block">/* Iterator to read from */</comment>
  <parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>,       <comment type="block">/* Changegroup object to add changeset to */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRebase</name></decl></parameter>                      <comment type="block">/* True if hash table is for rebasing */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sessionChangesetNext</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bIndirect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pChange</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pExist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pGrp</name><operator>-&gt;</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pGrp</name><operator>-&gt;</operator><name>bPatch</name></name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>!=</operator><name><name>pGrp</name><operator>-&gt;</operator><name>bPatch</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3changeset_op</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIndirect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Search the list for a matching table */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>abPK</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>sqlite3changeset_pk</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abPK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pTab</name> <operator>=</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>nNew</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTab</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionTable</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nCol</name> <operator>+</operator> <name>nNew</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SessionTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTab</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>nNew</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The new object must be linked on to the end of the list, not
        ** simply added to the start of it. This is to ensure that the
        ** tables within the output of sqlite3changegroup_output() are in 
        ** the right order.  */</comment>
        <for>for<control>(<init><expr><name>ppTab</name><operator>=</operator><operator>&amp;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ppTab</name></expr>;</condition> <incr><expr><name>ppTab</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>ppTab</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
        <expr_stmt><expr><operator>*</operator><name>ppTab</name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><name>nCol</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name>abPK</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>sessionGrowHash</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>sessionChangeHash</name><argument_list>(
        <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>(</operator><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>SQLITE_DELETE</name><operator>)</operator></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Search for existing entry. If found, remove it from the hash table. 
    ** Code below may link it back in.
    */</comment>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bPkOnly1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bPkOnly2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bPkOnly1</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bPkOnly2</name> <operator>=</operator> <name>op</name><operator>==</operator><name>SQLITE_DELETE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sessionChangeEqual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>bPkOnly1</name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name>bPkOnly2</name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pExist</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nEntry</name></name><operator>--</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangeMerge</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>bRebase</name></expr></argument>, 
        <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr></argument>, <argument><expr><name>pExist</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>bIndirect</name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChange</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pChange</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>pChange</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nEntry</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Serialize a changeset (or patchset) based on all changesets (or patchsets)
** added to the changegroup object passed as the first argument.
**
** If xOutput is not NULL, then the changeset/patchset is returned to the
** user via one or more calls to xOutput, as with the other streaming
** interfaces. 
**
** Or, if xOutput is NULL, then (*ppOut) is populated with a pointer to a
** buffer containing the output changeset before this function returns. In
** this case (*pnOut) is set to the size of the output buffer in bytes. It
** is the responsibility of the caller to free the output buffer using
** sqlite3_free() when it is no longer required.
**
** If successful, SQLITE_OK is returned. Or, if an error occurs, an SQLite
** error code. If an error occurs and xOutput is NULL, (*ppOut) and (*pnOut)
** are both set to 0 before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionChangegroupOutput</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>buf</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xOutput</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>ppOut</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pnOut</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create the serialized output changeset based on the contents of the
  ** hash tables attached to the SessionTable objects in list p-&gt;pList. 
  */</comment>
  <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>pGrp</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nEntry</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sessionAppendTableHdr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>pGrp</name><operator>-&gt;</operator><name>bPatch</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRecord</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>xOutput</name> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>nBuf</name></name><operator>&gt;=</operator><name>sessions_strm_chunk_size</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>xOutput</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ppOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pnOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new, empty, sqlite3_changegroup.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changegroup_new</name><parameter_list>(<parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>         <comment type="block">/* New object */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>sqlite3_changegroup</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_changegroup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_changegroup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add the changeset currently stored in buffer pData, size nData bytes,
** to changeset-group p.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changegroup_add</name><parameter_list>(<parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>  <comment type="block">/* Iterator opened on pData/nData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changeset_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetToHash</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>pGrp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Obtain a buffer containing a changeset representing the concatenation
** of all changesets added to the group so far.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changegroup_output</name><parameter_list>(
    <parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>,
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sessionChangegroupOutput</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pnData</name></expr></argument>, <argument><expr><name>ppData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Streaming versions of changegroup_add().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changegroup_add_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>  <comment type="block">/* Iterator opened on pData/nData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changeset_start_strm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><name>xInput</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetToHash</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>pGrp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Streaming versions of changegroup_output().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changegroup_output_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sessionChangegroupOutput</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><name>xOutput</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a changegroup object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3changegroup_delete</name><parameter_list>(<parameter><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pGrp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sessionDeleteTable</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pGrp</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Combine two changesets together.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_concat</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,                      <comment type="block">/* Number of bytes in lhs input */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,                    <comment type="block">/* Lhs input changeset */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRight</name></decl></parameter>                      <comment type="block">/* Number of bytes in rhs input */</comment>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,                   <comment type="block">/* Rhs input changeset */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,                     <comment type="block">/* OUT: Number of bytes in output changeset */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>                    <comment type="block">/* OUT: changeset (left &lt;concat&gt; right) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pGrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_add</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_add</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_output</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3changegroup_delete</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Streaming version of sqlite3changeset_concat().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3changeset_concat_strm</name><parameter_list>(
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInputA</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pInA</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInputB</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pInB</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changegroup</name> <modifier>*</modifier></type><name>pGrp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pGrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_add_strm</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><name>xInputA</name></expr></argument>, <argument><expr><name>pInA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_add_strm</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><name>xInputB</name></expr></argument>, <argument><expr><name>pInB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changegroup_output_strm</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><name>xOutput</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3changegroup_delete</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Changeset rebaser handle.
*/</comment>
<struct>struct <name>sqlite3_rebaser</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_changegroup</name></type> <name>grp</name></decl>;</decl_stmt>        <comment type="block">/* Hash table */</comment>
}</block>;</struct>

<comment type="block">/*
** Buffers a1 and a2 must both contain a sessions module record nCol
** fields in size. This function appends an nCol sessions module 
** record to buffer pBuf that is a copy of a1, except that for
** each field that is undefined in a1[], swap in the field from a2[].
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendRecordMerge</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,            <comment type="block">/* Buffer to append to */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                       <comment type="block">/* Number of columns in each record */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n1</name></decl></parameter>,                 <comment type="block">/* Record 1 */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n2</name></decl></parameter>,                 <comment type="block">/* Record 2 */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: error code */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>n1</name><operator>+</operator><name>n2</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><operator>&amp;</operator><name><name>pBuf</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>pBuf</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nn1</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nn2</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>a1</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>a1</name><operator>==</operator><literal type="number">0xFF</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>nn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>nn2</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>nn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>nn1</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>a1</name> <operator>+=</operator> <name>nn1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>+=</operator> <name>nn2</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>pOut</name><operator>-</operator><name><name>pBuf</name><operator>-&gt;</operator><name>aBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBuf</name><operator>-&gt;</operator><name>nBuf</name></name><operator>&lt;=</operator><name><name>pBuf</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when rebasing a local UPDATE change against one 
** or more remote UPDATE changes. The aRec/nRec buffer contains the current
** old.* and new.* records for the change. The rebase buffer (a single
** record) is in aChange/nChange. The rebased change is appended to buffer
** pBuf.
**
** Rebasing the UPDATE involves: 
**
**   * Removing any changes to fields for which the corresponding field
**     in the rebase buffer is set to "replaced" (type 0xFF). If this
**     means the UPDATE change updates no fields, nothing is appended
**     to the output buffer.
**
**   * For each field modified by the local change for which the 
**     corresponding field in the rebase buffer is not "undefined" (0x00)
**     or "replaced" (0xFF), the old.* value is replaced by the value
**     in the rebase buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sessionAppendPartialUpdate</name><parameter_list>(
  <parameter><decl><type><name>SessionBuffer</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,            <comment type="block">/* Append record here */</comment>
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Iterator pointed at local change */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRec</name></decl></parameter>,             <comment type="block">/* Local change */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aChange</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nChange</name></decl></parameter>,       <comment type="block">/* Record to rebase against */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Return Code */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sessionBufferGrow</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>nRec</name><operator>+</operator><name>nChange</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><operator>&amp;</operator><name><name>pBuf</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name><name>pBuf</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><name>aRec</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><name>aChange</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <name>SQLITE_UPDATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>bIndirect</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n1</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>a2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIter</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>a1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bData</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>a2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0xFF</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bData</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>a1</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>bData</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>a2</name> <operator>=</operator> <name>aChange</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n1</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sessionSerialLen</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>abPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>a2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0xFF</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pOut</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>a1</name> <operator>+=</operator> <name>n1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a2</name> <operator>+=</operator> <name>n2</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <operator>(</operator><name>pOut</name> <operator>-</operator> <name><name>pBuf</name><operator>-&gt;</operator><name>aBuf</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** pIter is configured to iterate through a changeset. This function rebases 
** that changeset according to the current configuration of the rebaser 
** object passed as the first argument. If no error occurs and argument xOutput
** is not NULL, then the changeset is returned to the caller by invoking
** xOutput zero or more times and SQLITE_OK returned. Or, if xOutput is NULL,
** then (*ppOut) is set to point to a buffer containing the rebased changeset
** before this function returns. In this case (*pnOut) is set to the size of
** the buffer in bytes.  It is the responsibility of the caller to eventually
** free the (*ppOut) buffer using sqlite3_free(). 
**
** If an error occurs, an SQLite error code is returned. If ppOut and
** pnOut are not NULL, then the two output parameters are set to 0 before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sessionRebase</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_rebaser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Rebaser hash table */</comment>
  <parameter><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,  <comment type="block">/* Input data */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,                     <comment type="block">/* Context for xOutput callback */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,                     <comment type="block">/* OUT: Number of bytes in output changeset */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>                    <comment type="block">/* OUT: Inverse of pChangeset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SessionBuffer</name></type> <name>sOut</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sessionChangesetNext</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bNew</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SessionChange</name> <modifier>*</modifier></type><name>pChange</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>bNew</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><name><name>pIter</name><operator>-&gt;</operator><name>zTab</name></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>grp</name><operator>.</operator><name>pList</name></name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>bNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* A patchset may not be rebased */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Append a table header to the output for this new table */</comment>
      <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pIter</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> ?</condition><then> <expr><literal type="char">'P'</literal></expr> </then><else>: <expr><literal type="char">'T'</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>abPK</name></name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>,<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pIter</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pTab</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><call><name>sessionChangeHash</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <for>for<control>(<init><expr><name>pChange</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>apChange</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>pChange</name></expr>;</condition> <incr><expr><name>pChange</name><operator>=</operator><name><name>pChange</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sessionChangeEqual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pChange</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name> <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INSERT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>SQLITE_INSERT</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>bIndirect</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>SQLITE_UPDATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>nRecord</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <case>case <expr><name>SQLITE_UPDATE</name></expr>:</case>
          <expr_stmt><expr><name>bDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>bIndirect</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name>aRec</name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>sessionSkipRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sessionAppendRecordMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>,
                  <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>nRec</name><operator>-</operator><operator>(</operator><name>pCsr</name><operator>-</operator><name>aRec</name><operator>)</operator></expr></argument>, 
                  <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>nRecord</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sessionAppendPartialUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>,
                <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>nRecord</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <break>break;</break>

        <default>default:</default>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>bDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INSERT</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sessionAppendRecordMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>,
                <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>aRecord</name></name></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>nRecord</name></name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>bIndirect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sessionAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><name>aRec</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>xOutput</name> <operator>&amp;&amp;</operator> <name><name>sOut</name><operator>.</operator><name>nBuf</name></name><operator>&gt;</operator><name>sessions_strm_chunk_size</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sOut</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>xOutput</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xOutput</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr></argument>, <argument><expr><name><name>sOut</name><operator>.</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ppOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name><name>sOut</name><operator>.</operator><name>nBuf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sOut</name><operator>.</operator><name>aBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Create a new rebaser object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3rebaser_create</name><parameter_list>(<parameter><decl><type><name>sqlite3_rebaser</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_rebaser</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_rebaser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_rebaser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppNew</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Call this one or more times to configure a rebaser.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3rebaser_configure</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_rebaser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nRebase</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRebase</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Iterator opened on pData/nData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                              <comment type="block">/* Return code */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3changeset_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><name>nRebase</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pRebase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionChangesetToHash</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>grp</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rebase a changeset according to current rebaser configuration 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3rebaser_rebase</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_rebaser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter> 
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Iterator to skip through input */</comment>  
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3changeset_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionRebase</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rebase a changeset according to current rebaser configuration 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3rebaser_rebase_strm</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_rebaser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xInput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xOutput</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_changeset_iter</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Iterator to skip through input */</comment>  
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3changeset_start_strm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><name>xInput</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sessionRebase</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>xOutput</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3changeset_finalize</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Destroy a rebaser object 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3rebaser_delete</name><parameter_list>(<parameter><decl><type><name>sqlite3_rebaser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sessionDeleteTable</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>grp</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Global configuration
*/</comment>
<function><type><name>int</name></type> <name>sqlite3session_config</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_SESSION_CONFIG_STRMSIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pInt</name> <init>= <expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pInt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>sessions_strm_chunk_size</name> <operator>=</operator> <operator>*</operator><name>pInt</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pInt</name> <operator>=</operator> <name>sessions_strm_chunk_size</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_SESSION &amp;&amp; SQLITE_ENABLE_PREUPDATE_HOOK */</comment>
</unit>
