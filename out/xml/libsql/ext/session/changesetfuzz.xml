<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/session/changesetfuzz.c"><comment type="block">/*
** 2018-11-01
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement the "changesetfuzz" command 
** line utility for fuzzing changeset blobs without corrupting them.
*/</comment>


<comment type="block" format="doxygen">/************************************************************************
** USAGE:
**
** This program may be invoked in two ways:
**
**   changesetfuzz INPUT
**   changesetfuzz INPUT SEED N
**
** Argument INPUT must be the name of a file containing a binary changeset.
** In the first form above, this program outputs a human-readable version
** of the same changeset. This is chiefly for debugging.
**
** As well as changesets, this program can also dump and fuzz patchsets.
** The term "changeset" is used for both patchsets and changesets from this
** point on.
**
** In the second form, arguments SEED and N must both be integers. In this
** case, this program writes N binary changesets to disk. Each output
** changeset is a slightly modified - "fuzzed" - version of the input. 
** The output changesets are written to files name "INPUT-$n", where $n is 
** an integer between 0 and N-1, inclusive. Output changesets are always
** well-formed. Parameter SEED is used to seed the PRNG - any two 
** invocations of this program with the same SEED and input changeset create
** the same N output changesets.
**
** The ways in which an input changeset may be fuzzed are as follows:
**
**   1. Any two values within the changeset may be exchanged.
**
**   2. Any TEXT, BLOB, INTEGER or REAL value within the changeset 
**      may have a single bit of its content flipped.
**
**   3. Any value within a changeset may be replaced by a pseudo-randomly
**      generated value.
**
** The above operations never set a PRIMARY KEY column to NULL. Nor do they
** set any value to "undefined", or replace any "undefined" value with
** another. Any such operation risks producing a changeset that is not 
** well-formed.
**
**   4. A single change may be duplicated.
**
**   5. A single change may be removed, so long as this does not mean that
**      there are zero changes following a table-header within the changeset.
**
**   6. A single change may have its type (INSERT, DELETE, UPDATE) changed.
**      If an INSERT is changed to a DELETE (or vice versa), the type is
**      simply changed - no other modifications are required. If an INSERT
**      or DELETE is changed to an UPDATE, then the single record is duplicated
**      (as both the old.* and new.* records of the new UPDATE change). If an
**      UPDATE is changed to a DELETE or INSERT, the new.* record is discarded
**      and any "undefined" fields replaced with pseudo-randomly generated
**      values.
**
**   7. An UPDATE change that modifies N table columns may be modified so
**      that it updates N-1 columns, so long as (N&gt;1).
**
**   8. The "indirect" flag may be toggled for any change.
**
** Entire group of changes may also be operated on:
**
**   9. Duplicate an existing group.
**
**  10. Remove an existing group.
**
**  11. The positions of two groups may be exchanged.
**
** There are also schema changes:
**
**  12. A non-PK column may be added to a table. In this case a NULL 
**      value is appended to all records.
**
**  13. A PK column may be added to a table. In this case a non-NULL 
**      value is appended to all INSERT, DELETE and UPDATE old.* records.
**      An "undefined" is appended to new.* UPDATE records.
**
**  14. A column may be removed from a table, provided that it is not the
**      only PRIMARY KEY column in the table. In this case the corresponding
**      field is removed from all records. In cases where this leaves an UPDATE
**      with no non-PK, non-undefined fields, the entire change is removed.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_VALUE_SUB</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* Replace one value with a copy of another */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_VALUE_MOD</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* Modify content by 1 bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_VALUE_RND</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>    <comment type="block">/* Replace with pseudo-random value */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_CHANGE_DUP</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>    <comment type="block">/* Duplicate an existing change */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_CHANGE_DEL</name></cpp:macro>      <cpp:value>5</cpp:value></cpp:define>    <comment type="block">/* Completely remove one change */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_CHANGE_TYPE</name></cpp:macro>     <cpp:value>6</cpp:value></cpp:define>    <comment type="block">/* Change the type of one change */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_CHANGE_FIELD</name></cpp:macro>    <cpp:value>7</cpp:value></cpp:define>    <comment type="block">/* Change an UPDATE to modify fewer columns */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_CHANGE_INDIRECT</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>    <comment type="block">/* Toggle the "indirect" flag of a change */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_GROUP_DUP</name></cpp:macro>       <cpp:value>9</cpp:value></cpp:define>    <comment type="block">/* Duplicate a change group */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_GROUP_DEL</name></cpp:macro>      <cpp:value>10</cpp:value></cpp:define>    <comment type="block">/* Delete an entire change group */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_GROUP_SWAP</name></cpp:macro>     <cpp:value>11</cpp:value></cpp:define>    <comment type="block">/* Exchange the position of two groups */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_COLUMN_ADD</name></cpp:macro>     <cpp:value>12</cpp:value></cpp:define>     <comment type="block">/* Add column to table definition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_COLUMN_ADDPK</name></cpp:macro>   <cpp:value>13</cpp:value></cpp:define>     <comment type="block">/* Add PK column to table definition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZ_COLUMN_DEL</name></cpp:macro>     <cpp:value>14</cpp:value></cpp:define>     <comment type="block">/* Remove column from table definition */</comment>



<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<typedef>typedef <type><name>sqlite3_uint64</name></type> <name>u64</name>;</typedef>
<typedef>typedef <type><name>sqlite3_int64</name></type> <name>i64</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>

<comment type="block">/*
** Show a usage message on stderr then quit.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: %s FILENAME ?SEED N?\n"</literal></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Read the content of a disk file into an in-memory buffer
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzReadFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pSz</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot open \"%s\" for reading\n"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><ternary><condition><expr><name>sz</name></expr> ?</condition><then> <expr><name>sz</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot allocate %d to hold content of \"%s\"\n"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>fread</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot read all %d bytes of \"%s\"\n"</literal></expr></argument>,
              <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSz</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppBuf</name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Write the contents of buffer pBuf, size nBuf bytes, into file zFilename
** on disk. zFilename, if it already exists, is clobbered.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzWriteFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot open \"%s\" for writing\n"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fwrite</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot write to \"%s\"\n"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzCorrupt</name><parameter_list>()</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************************************************************************
** The following block is a copy of the implementation of SQLite function
** sqlite3_randomness. This version has two important differences:
**
**   1. It always uses the same seed. So the sequence of random data output
**      is the same for every run of the program.
**
**   2. It is not threadsafe.
*/</comment>
<struct><specifier>static</specifier> struct <name>sqlite3PrngType</name> <block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>             <comment type="block">/* State variables */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>s</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>           <comment type="block">/* State variables */</comment>
}</block> <decl><name>sqlite3Prng</name> <init>= <expr><block>{
    <expr><literal type="number">0xAF</literal></expr>, <expr><literal type="number">0x28</literal></expr>,
  <expr><block>{
    <expr><literal type="number">0x71</literal></expr>, <expr><literal type="number">0xF5</literal></expr>, <expr><literal type="number">0xB4</literal></expr>, <expr><literal type="number">0x6E</literal></expr>, <expr><literal type="number">0x80</literal></expr>, <expr><literal type="number">0xAB</literal></expr>, <expr><literal type="number">0x1D</literal></expr>, <expr><literal type="number">0xB8</literal></expr>, 
    <expr><literal type="number">0xFB</literal></expr>, <expr><literal type="number">0xB7</literal></expr>, <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0xBF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x2D</literal></expr>, <expr><literal type="number">0x14</literal></expr>, 
    <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0xE3</literal></expr>, <expr><literal type="number">0x78</literal></expr>, <expr><literal type="number">0x76</literal></expr>, <expr><literal type="number">0xB0</literal></expr>, <expr><literal type="number">0x2C</literal></expr>, <expr><literal type="number">0x0A</literal></expr>, 
    <expr><literal type="number">0x8E</literal></expr>, <expr><literal type="number">0x23</literal></expr>, <expr><literal type="number">0xEE</literal></expr>, <expr><literal type="number">0xDF</literal></expr>, <expr><literal type="number">0xE0</literal></expr>, <expr><literal type="number">0x9A</literal></expr>, <expr><literal type="number">0x2F</literal></expr>, <expr><literal type="number">0x67</literal></expr>, 
    <expr><literal type="number">0xE1</literal></expr>, <expr><literal type="number">0xBE</literal></expr>, <expr><literal type="number">0x0E</literal></expr>, <expr><literal type="number">0xA7</literal></expr>, <expr><literal type="number">0x08</literal></expr>, <expr><literal type="number">0x97</literal></expr>, <expr><literal type="number">0xEB</literal></expr>, <expr><literal type="number">0x77</literal></expr>, 
    <expr><literal type="number">0x78</literal></expr>, <expr><literal type="number">0xBA</literal></expr>, <expr><literal type="number">0x9D</literal></expr>, <expr><literal type="number">0xCA</literal></expr>, <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x4C</literal></expr>, <expr><literal type="number">0x60</literal></expr>, <expr><literal type="number">0x9A</literal></expr>, 
    <expr><literal type="number">0xF6</literal></expr>, <expr><literal type="number">0xBD</literal></expr>, <expr><literal type="number">0xDA</literal></expr>, <expr><literal type="number">0x7F</literal></expr>, <expr><literal type="number">0xBC</literal></expr>, <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x58</literal></expr>, <expr><literal type="number">0x52</literal></expr>, 
    <expr><literal type="number">0xE5</literal></expr>, <expr><literal type="number">0xCD</literal></expr>, <expr><literal type="number">0x83</literal></expr>, <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x23</literal></expr>, <expr><literal type="number">0x52</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x6D</literal></expr>, 
    <expr><literal type="number">0xEF</literal></expr>, <expr><literal type="number">0x0F</literal></expr>, <expr><literal type="number">0x82</literal></expr>, <expr><literal type="number">0x29</literal></expr>, <expr><literal type="number">0xA0</literal></expr>, <expr><literal type="number">0x83</literal></expr>, <expr><literal type="number">0x3F</literal></expr>, <expr><literal type="number">0x7D</literal></expr>, 
    <expr><literal type="number">0xA4</literal></expr>, <expr><literal type="number">0x88</literal></expr>, <expr><literal type="number">0x31</literal></expr>, <expr><literal type="number">0xE7</literal></expr>, <expr><literal type="number">0x88</literal></expr>, <expr><literal type="number">0x92</literal></expr>, <expr><literal type="number">0x3B</literal></expr>, <expr><literal type="number">0x9B</literal></expr>, 
    <expr><literal type="number">0x3B</literal></expr>, <expr><literal type="number">0x2C</literal></expr>, <expr><literal type="number">0xC2</literal></expr>, <expr><literal type="number">0x4C</literal></expr>, <expr><literal type="number">0x71</literal></expr>, <expr><literal type="number">0xA2</literal></expr>, <expr><literal type="number">0xB0</literal></expr>, <expr><literal type="number">0xEA</literal></expr>, 
    <expr><literal type="number">0x36</literal></expr>, <expr><literal type="number">0xD0</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xF1</literal></expr>, <expr><literal type="number">0xD3</literal></expr>, <expr><literal type="number">0x39</literal></expr>, <expr><literal type="number">0x17</literal></expr>, <expr><literal type="number">0x5D</literal></expr>, 
    <expr><literal type="number">0x2A</literal></expr>, <expr><literal type="number">0x7A</literal></expr>, <expr><literal type="number">0xE4</literal></expr>, <expr><literal type="number">0xAD</literal></expr>, <expr><literal type="number">0xE1</literal></expr>, <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0xCE</literal></expr>, <expr><literal type="number">0x0F</literal></expr>, 
    <expr><literal type="number">0x9C</literal></expr>, <expr><literal type="number">0xD9</literal></expr>, <expr><literal type="number">0xF5</literal></expr>, <expr><literal type="number">0xED</literal></expr>, <expr><literal type="number">0xB0</literal></expr>, <expr><literal type="number">0x22</literal></expr>, <expr><literal type="number">0x5E</literal></expr>, <expr><literal type="number">0x62</literal></expr>, 
    <expr><literal type="number">0x97</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0xA3</literal></expr>, <expr><literal type="number">0x8C</literal></expr>, <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x80</literal></expr>, <expr><literal type="number">0xFC</literal></expr>, <expr><literal type="number">0x88</literal></expr>, 
    <expr><literal type="number">0x14</literal></expr>, <expr><literal type="number">0x0B</literal></expr>, <expr><literal type="number">0x15</literal></expr>, <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x0F</literal></expr>, <expr><literal type="number">0xC7</literal></expr>, <expr><literal type="number">0x40</literal></expr>, <expr><literal type="number">0xD4</literal></expr>, 
    <expr><literal type="number">0xF1</literal></expr>, <expr><literal type="number">0xF9</literal></expr>, <expr><literal type="number">0x0E</literal></expr>, <expr><literal type="number">0x1A</literal></expr>, <expr><literal type="number">0xCE</literal></expr>, <expr><literal type="number">0xB9</literal></expr>, <expr><literal type="number">0x1E</literal></expr>, <expr><literal type="number">0xA1</literal></expr>, 
    <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x8E</literal></expr>, <expr><literal type="number">0xD7</literal></expr>, <expr><literal type="number">0x78</literal></expr>, <expr><literal type="number">0x39</literal></expr>, <expr><literal type="number">0xCD</literal></expr>, <expr><literal type="number">0xF4</literal></expr>, <expr><literal type="number">0x5D</literal></expr>, 
    <expr><literal type="number">0x2A</literal></expr>, <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x26</literal></expr>, <expr><literal type="number">0x34</literal></expr>, <expr><literal type="number">0xF2</literal></expr>, <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x0B</literal></expr>, <expr><literal type="number">0xA0</literal></expr>, 
    <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x51</literal></expr>, <expr><literal type="number">0x2C</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0xA3</literal></expr>, <expr><literal type="number">0xA7</literal></expr>, <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x13</literal></expr>, 
    <expr><literal type="number">0xE8</literal></expr>, <expr><literal type="number">0x98</literal></expr>, <expr><literal type="number">0x2B</literal></expr>, <expr><literal type="number">0xD2</literal></expr>, <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0xF8</literal></expr>, <expr><literal type="number">0xEE</literal></expr>, <expr><literal type="number">0x91</literal></expr>, 
    <expr><literal type="number">0x7D</literal></expr>, <expr><literal type="number">0xE7</literal></expr>, <expr><literal type="number">0xE3</literal></expr>, <expr><literal type="number">0xDA</literal></expr>, <expr><literal type="number">0xD5</literal></expr>, <expr><literal type="number">0xBB</literal></expr>, <expr><literal type="number">0xC0</literal></expr>, <expr><literal type="number">0x92</literal></expr>, 
    <expr><literal type="number">0x9D</literal></expr>, <expr><literal type="number">0x98</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x2C</literal></expr>, <expr><literal type="number">0xF9</literal></expr>, <expr><literal type="number">0xB9</literal></expr>, <expr><literal type="number">0xA0</literal></expr>, <expr><literal type="number">0xEB</literal></expr>, 
    <expr><literal type="number">0xCF</literal></expr>, <expr><literal type="number">0x32</literal></expr>, <expr><literal type="number">0xFA</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0xA5</literal></expr>, <expr><literal type="number">0x1D</literal></expr>, <expr><literal type="number">0x9A</literal></expr>, 
    <expr><literal type="number">0x76</literal></expr>, <expr><literal type="number">0x86</literal></expr>, <expr><literal type="number">0x3F</literal></expr>, <expr><literal type="number">0x40</literal></expr>, <expr><literal type="number">0xD4</literal></expr>, <expr><literal type="number">0x89</literal></expr>, <expr><literal type="number">0x8F</literal></expr>, <expr><literal type="number">0x9C</literal></expr>, 
    <expr><literal type="number">0xE2</literal></expr>, <expr><literal type="number">0xE3</literal></expr>, <expr><literal type="number">0x11</literal></expr>, <expr><literal type="number">0x31</literal></expr>, <expr><literal type="number">0x37</literal></expr>, <expr><literal type="number">0xB2</literal></expr>, <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x28</literal></expr>, 
    <expr><literal type="number">0x35</literal></expr>, <expr><literal type="number">0xC0</literal></expr>, <expr><literal type="number">0x99</literal></expr>, <expr><literal type="number">0xB6</literal></expr>, <expr><literal type="number">0xD0</literal></expr>, <expr><literal type="number">0xBC</literal></expr>, <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x35</literal></expr>, 
    <expr><literal type="number">0xF7</literal></expr>, <expr><literal type="number">0x83</literal></expr>, <expr><literal type="number">0x5B</literal></expr>, <expr><literal type="number">0xD7</literal></expr>, <expr><literal type="number">0x37</literal></expr>, <expr><literal type="number">0x1A</literal></expr>, <expr><literal type="number">0x2B</literal></expr>, <expr><literal type="number">0x18</literal></expr>, 
    <expr><literal type="number">0xA6</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x8D</literal></expr>, <expr><literal type="number">0x7C</literal></expr>, <expr><literal type="number">0x81</literal></expr>, <expr><literal type="number">0xA8</literal></expr>, <expr><literal type="number">0xFC</literal></expr>, <expr><literal type="number">0x9E</literal></expr>, 
    <expr><literal type="number">0xC4</literal></expr>, <expr><literal type="number">0xEC</literal></expr>, <expr><literal type="number">0x80</literal></expr>, <expr><literal type="number">0xD0</literal></expr>, <expr><literal type="number">0x98</literal></expr>, <expr><literal type="number">0xA7</literal></expr>, <expr><literal type="number">0x76</literal></expr>, <expr><literal type="number">0xCC</literal></expr>, 
    <expr><literal type="number">0x9C</literal></expr>, <expr><literal type="number">0x2F</literal></expr>, <expr><literal type="number">0x7B</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x8E</literal></expr>, <expr><literal type="number">0x0E</literal></expr>, <expr><literal type="number">0xBB</literal></expr>, <expr><literal type="number">0x90</literal></expr>, 
    <expr><literal type="number">0xAE</literal></expr>, <expr><literal type="number">0x13</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0xF5</literal></expr>, <expr><literal type="number">0x1C</literal></expr>, <expr><literal type="number">0x4E</literal></expr>, <expr><literal type="number">0x52</literal></expr>, <expr><literal type="number">0xF7</literal></expr>
  }</block></expr>
}</block></expr></init></decl>;</struct>

<comment type="block">/* 
** Generate and return single random byte 
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>fuzzRandomByte</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name><name>sqlite3Prng</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>j</name></name> <operator>+=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name><name>sqlite3Prng</name><operator>.</operator><name>i</name></name></expr>]</index></name> <operator>=</operator> <name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name><name>sqlite3Prng</name><operator>.</operator><name>j</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name><name>sqlite3Prng</name><operator>.</operator><name>j</name></name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>+=</operator> <name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name><name>sqlite3Prng</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name>t</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return N random bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzRandomBlob</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBuf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>fuzzRandomByte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Return a random integer between 0 and nRange (not inclusive).
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>fuzzRandomInt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nRange</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRange</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fuzzRandomBlob</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>ret</name> <operator>%</operator> <name>nRange</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>u64</name></type> <name>fuzzRandomU64</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fuzzRandomBlob</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzRandomSeed</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iSeed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">4</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^=</operator> <operator>(</operator><operator>(</operator><name>iSeed</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <operator>(</operator><operator>(</operator><name>iSeed</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <operator>(</operator><operator>(</operator><name>iSeed</name> <operator>&gt;&gt;</operator>  <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3Prng</name><operator>.</operator><name>s</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <operator>(</operator><operator>(</operator><name>iSeed</name> <operator>&gt;&gt;</operator>  <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<comment type="block">/*
** End of code for generating pseudo-random values.
*************************************************************************/</comment>

<typedef>typedef <type><name><name>struct</name> <name>FuzzChangeset</name></name></type> <name>FuzzChangeset</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>FuzzChangesetGroup</name></name></type> <name>FuzzChangesetGroup</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>FuzzChange</name></name></type> <name>FuzzChange</name>;</typedef>

<comment type="block">/* 
** Object containing partially parsed changeset.
*/</comment>
<struct>struct <name>FuzzChangeset</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bPatchset</name></decl>;</decl_stmt>                  <comment type="block">/* True for a patchset */</comment>
  <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier><modifier>*</modifier></type><name>apGroup</name></decl>;</decl_stmt>   <comment type="block">/* Array of groups in changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nGroup</name></decl>;</decl_stmt>                     <comment type="block">/* Number of items in list pGroup */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl>;</decl_stmt>                     <comment type="block">/* Array of all values in changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>                       <comment type="block">/* Number of used slots in apVal[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChange</name></decl>;</decl_stmt>                    <comment type="block">/* Number of changes in changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nUpdate</name></decl>;</decl_stmt>                    <comment type="block">/* Number of UPDATE changes in changeset */</comment>
}</block>;</struct>

<comment type="block">/* 
** There is one object of this type for each change-group (table header)
** in the input changeset.
*/</comment>
<struct>struct <name>FuzzChangesetGroup</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>               <comment type="block">/* Name of table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in table */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aPK</name></decl>;</decl_stmt>                        <comment type="block">/* PK array for this table */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aChange</name></decl>;</decl_stmt>                    <comment type="block">/* Buffer containing array of changes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szChange</name></decl>;</decl_stmt>                   <comment type="block">/* Size of buffer aChange[] in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChange</name></decl>;</decl_stmt>                    <comment type="block">/* Number of changes in buffer aChange[] */</comment>
}</block>;</struct>

<comment type="block">/*
** Description of a fuzz change to be applied to a changeset.
*/</comment>
<struct>struct <name>FuzzChange</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                      <comment type="block">/* One of the FUZZ_* constants above */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iChange</name></decl>;</decl_stmt>                    <comment type="block">/* Change or UPDATE to modify */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iGroup</name></decl>;</decl_stmt>                     <comment type="block">/* Group to modify */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDelete</name></decl>;</decl_stmt>                    <comment type="block">/* Field to remove (FUZZ_COLUMN_DEL) */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSub1</name></decl>;</decl_stmt>                      <comment type="block">/* Replace this value with pSub2 */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSub2</name></decl>;</decl_stmt>                      <comment type="block">/* And this one with pSub1 */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aSub</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>                   <comment type="block">/* Buffer for substitute value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name></decl>;</decl_stmt>                   <comment type="block">/* Current change number */</comment>
}</block>;</struct>

<comment type="block">/*
** Allocate and return nByte bytes of zeroed memory.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>fuzzMalloc</name><parameter_list>(<parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the buffer indicated by the first argument. This function is used
** to free buffers allocated by fuzzMalloc().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Argument p points to a buffer containing an SQLite varint that, assuming the
** input is not corrupt, may be between 0 and 0x7FFFFFFF, inclusive. Before
** returning, this function sets (*pnVal) to the value of that varint, and
** returns the number of bytes of space that it takes up.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzGetVarint</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>(</operator><name>nVal</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nVal</name></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write value nVal into the buffer indicated by argument p as an SQLite
** varint. nVal is guaranteed to be between 0 and (2^21-1), inclusive.
** Return the number of bytes written to buffer p.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzPutVarint</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nVal</name><operator>&lt;</operator><literal type="number">2097152</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&lt;</operator><literal type="number">128</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nVal</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&lt;</operator><literal type="number">16384</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nVal</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>nVal</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nVal</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nVal</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>nVal</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read a 64-bit big-endian integer value from buffer aRec[]. Return
** the value read.
*/</comment>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>fuzzGetI64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator>
      <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">56</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">48</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">40</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aRec</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">0</literal><operator>)</operator>
  <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write value iVal to buffer aRec[] as an unsigned 64-bit big-endian integer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzPutU64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRec</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>&gt;&gt;</operator><literal type="number">56</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>&gt;&gt;</operator><literal type="number">48</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>&gt;&gt;</operator><literal type="number">40</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRec</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iVal</name><operator>)</operator>     <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Parse a single table-header from the input. Allocate a new change-group
** object with the results. Return SQLITE_OK if successful, or an error code
** otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzParseHeader</name><parameter_list>(
  <parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Changeset parse object */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppHdr</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Iterator */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,                       <comment type="block">/* 1 byte past EOF */</comment>
  <parameter><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppGrp</name></decl></parameter>      <comment type="block">/* OUT: New change-group object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>cHdr</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> ?</condition><then> <expr><literal type="char">'P'</literal></expr> </then><else>: <expr><literal type="char">'T'</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEnd</name><operator>&gt;</operator><operator>(</operator><operator>*</operator><name>ppHdr</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pGrp</name> <operator>=</operator> <operator>(</operator><name>FuzzChangesetGroup</name><operator>*</operator><operator>)</operator><call><name>fuzzMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuzzChangesetGroup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pGrp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppHdr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><name>cHdr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzCorrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>fuzzGetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGrp</name><operator>-&gt;</operator><name>zTab</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>p</name><operator>&gt;=</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzCorrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppHdr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fuzzFree</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGrp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppGrp</name> <operator>=</operator> <name>pGrp</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument p points to a buffer containing a single changeset-record value. 
** This function attempts to determine the size of the value in bytes. If
** successful, it sets (*pSz) to the size and returns SQLITE_OK. Or, if the
** buffer does not contain a valid value, SQLITE_CORRUPT is returned and
** the final value of (*pSz) is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzChangeSize</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pSz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0x00</literal></expr>:</case>                    <comment type="block">/* undefined */</comment>
    <case>case <expr><literal type="number">0x05</literal></expr>:</case>                    <comment type="block">/* null */</comment>
      <expr_stmt><expr><operator>*</operator><name>pSz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><literal type="number">0x01</literal></expr>:</case>                    <comment type="block">/* integer */</comment>
    <case>case <expr><literal type="number">0x02</literal></expr>:</case>                    <comment type="block">/* real */</comment>
      <expr_stmt><expr><operator>*</operator><name>pSz</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><literal type="number">0x03</literal></expr>:</case>                    <comment type="block">/* text */</comment>
    <case>case <expr><literal type="number">0x04</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* blob */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nTxt</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>fuzzGetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pSz</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>sz</name> <operator>+</operator> <name>nTxt</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <return>return <expr><call><name>fuzzCorrupt</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When this function is called, (*ppRec) points to the start of a 
** record in a changeset being parsed. This function adds entries
** to the pParse-&gt;apVal[] array for all values and advances (*ppRec) 
** to one byte past the end of the record. Argument pEnd points to
** one byte past the end of the input changeset.
**
** Argument bPkOnly is true if the record being parsed is part of
** a DELETE record in a patchset. In this case, all non-primary-key
** fields have been omitted from the record.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzParseRecord</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRec</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Iterator */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,                       <comment type="block">/* One byte after end of input data */</comment>
  <parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Changeset parse context */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPkOnly</name></decl></parameter>                     <comment type="block">/* True if non-PK fields omitted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppRec</name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bPkOnly</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name><operator>&gt;=</operator><name>pEnd</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name></expr> ?</condition><then> <expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>apVal</name></name></expr></argument>, <argument><expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u8</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>apNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>apVal</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzCorrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppRec</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parse the array of changes starting at (*ppData) and add entries for
** all values to the pParse-&gt;apVal[] array. Argument pEnd points to one byte
** past the end of the input changeset. If successful, set (*ppData) to point
** to one byte past the end of the change array and return SQLITE_OK.
** Otherwise, return an SQLite error code. The final value of (*ppData) is
** undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzParseChanges</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>, <parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>cHdr</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> ?</condition><then> <expr><literal type="char">'P'</literal></expr> </then><else>: <expr><literal type="char">'T'</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppData</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pGrp</name><operator>-&gt;</operator><name>aChange</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;</operator><name>pEnd</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><name>cHdr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>eOp</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>bIndirect</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nUpdate</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzParseRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOp</name><operator>!=</operator><name>SQLITE_INSERT</name> <operator>&amp;&amp;</operator> <name>eOp</name><operator>!=</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzCorrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bPkOnly</name> <init>= <expr><operator>(</operator><name>eOp</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzParseRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>bPkOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pGrp</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>pGrp</name><operator>-&gt;</operator><name>szChange</name></name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aChange</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parse the changeset stored in buffer pChangeset (nChangeset bytes in
** size). If successful, write the results into (*pParse) and return
** SQLITE_OK. Or, if an error occurs, return an SQLite error code. The
** final state of (*pParse) is undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzParseChangeset</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pChangeset</name></decl></parameter>,                 <comment type="block">/* Buffer containing changeset */</comment>
  <parameter><decl><type><name>int</name></type> <name>nChangeset</name></decl></parameter>,                 <comment type="block">/* Size of buffer in bytes */</comment>
  <parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>           <comment type="block">/* OUT: Results of parse */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pChangeset</name><index>[<expr><name>nChangeset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pChangeset</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuzzChangeset</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nChangeset</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name> <operator>=</operator> <operator>(</operator><name><name>pChangeset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'P'</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Read a table-header from the changeset */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzParseHeader</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pGrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator><operator>==</operator><operator>(</operator><name>pGrp</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the table-header was successfully parsed, add the new change-group
    ** to the array and parse the associated changes. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name> <init>= <expr><operator>(</operator><name>FuzzChangesetGroup</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(
          <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuzzChangesetGroup</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>
      )</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>apNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>apNew</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name></expr>]</index></name> <operator>=</operator> <name>pGrp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzParseChanges</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When this function is called, (*ppRec) points to the first byte of
** a record that is part of change-group pGrp. This function attempts
** to output a human-readable version of the record to stdout and advance
** (*ppRec) to point to the first byte past the end of the record before
** returning. If successful, SQLITE_OK is returned. Otherwise, an SQLite
** error code.
**
** If parameter bPkOnly is non-zero, then all non-primary-key fields have
** been omitted from the record. This occurs for records that are part
** of DELETE changes in patchsets.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzPrintRecord</name><parameter_list>(<parameter><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bPKOnly</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppRec</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPre</name> <init>= <expr><literal type="string">" ("</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bPKOnly</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><name>p</name><operator>++</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
      <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="number">0x00</literal></expr>:</case>                    <comment type="block">/* undefined */</comment>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%sn/a"</literal></expr></argument>, <argument><expr><name>zPre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><literal type="number">0x01</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* integer */</comment>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>fuzzGetI64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%lld"</literal></expr></argument>, <argument><expr><name>zPre</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>

        <case>case <expr><literal type="number">0x02</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* real */</comment>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>fVal</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>fuzzGetI64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%f"</literal></expr></argument>, <argument><expr><name>zPre</name></expr></argument>, <argument><expr><name>fVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>

        <case>case <expr><literal type="number">0x03</literal></expr>:</case>                    <comment type="block">/* text */</comment>
        <case>case <expr><literal type="number">0x04</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* blob */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nTxt</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>fuzzGetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>zPre</name></expr></argument>, <argument><expr><ternary><condition><expr><name>eType</name><operator>==</operator><literal type="number">0x03</literal></expr> ?</condition><then> <expr><literal type="string">"'"</literal></expr> </then><else>: <expr><literal type="string">"X'"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTxt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0x03</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <decl_stmt><decl><type><name>char</name></type> <name><name>aHex</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, <expr><literal type="char">'6'</literal></expr>, <expr><literal type="char">'7'</literal></expr>,
                               <expr><literal type="char">'8'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, <expr><literal type="char">'A'</literal></expr>, <expr><literal type="char">'B'</literal></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><literal type="char">'D'</literal></expr>, <expr><literal type="char">'E'</literal></expr>, <expr><literal type="char">'F'</literal></expr>
              }</block></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>aHex</name><index>[ <expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;&gt;</operator><literal type="number">4</literal></expr> ]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>aHex</name><index>[ <expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr> ]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nTxt</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>

        <case>case <expr><literal type="number">0x05</literal></expr>:</case>                    <comment type="block">/* null */</comment>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%sNULL"</literal></expr></argument>, <argument><expr><name>zPre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
      <expr_stmt><expr><name>zPre</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppRec</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print a human-readable version of the table-header and all changes in the
** change-group passed as the second argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzPrintGroup</name><parameter_list>(<parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <comment type="block">/* The table header */</comment>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"TABLE:  %s nCol=%d aPK="</literal></expr></argument>, <argument><expr><name><name>pGrp</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The array of changes */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aChange</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>bIndirect</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (ind=%d):"</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>eType</name><operator>==</operator><name>SQLITE_INSERT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"INSERT"</literal></expr> </then><else>:
        <expr><operator>(</operator><ternary><condition><expr><name>eType</name><operator>==</operator><name>SQLITE_DELETE</name></expr> ?</condition><then> <expr><literal type="string">"DELETE"</literal></expr> </then><else>: <expr><literal type="string">"UPDATE"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>,
        <argument><expr><name>bIndirect</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fuzzPrintRecord</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fuzzPrintRecord</name><argument_list>(<argument><expr><name>pGrp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Initialize the object passed as the second parameter with details
** of the change that will be attempted (type of change, to which part of the
** changeset it applies etc.). If successful, return SQLITE_OK. Or, if an
** error occurs, return an SQLite error code. 
**
** If a negative value is returned, then the selected change would have
** produced a non-well-formed changeset. In this case the caller should
** call this function again.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzSelectChange</name><parameter_list>(<parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>FuzzChange</name> <modifier>*</modifier></type><name>pChange</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iSub</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pChange</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuzzChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name>FUZZ_COLUMN_DEL</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_SUB</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_MOD</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_RND</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_DUP</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_DEL</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_TYPE</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_FIELD</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_INDIRECT</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_GROUP_DUP</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_GROUP_DEL</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_GROUP_SWAP</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_ADD</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_ADDPK</name>
       <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_DEL</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>iGroup</name></name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>iChange</name></name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_FIELD</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nUpdate</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>iChange</name></name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nUpdate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>iDelete</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_DEL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name><name>pChange</name><operator>-&gt;</operator><name>iGroup</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>iDelete</name></name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pChange</name><operator>-&gt;</operator><name>iDelete</name></name><operator>!=</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_GROUP_SWAP</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iGrp</name> <init>= <expr><name><name>pChange</name><operator>-&gt;</operator><name>iGroup</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><name>iGrp</name><operator>==</operator><name><name>pChange</name><operator>-&gt;</operator><name>iGroup</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iGrp</name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>pGrp</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name><name>pChange</name><operator>-&gt;</operator><name>iGroup</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name><name>pChange</name><operator>-&gt;</operator><name>iGroup</name></name></expr>]</index></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name>iGrp</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name>iGrp</name></expr>]</index></name> <operator>=</operator> <name>pGrp</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_SUB</name> 
   <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_MOD</name> 
   <operator>||</operator> <name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_RND</name></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>iSub</name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>pSub1</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><name>iSub</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_SUB</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iSub</name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>pSub2</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><name>iSub</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>pSub2</name></name> <operator>=</operator> <name><name>pChange</name><operator>-&gt;</operator><name>aSub</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_RND</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><call><name>fuzzRandomInt</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="number">0x01</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* integer */</comment>
          <decl_stmt><decl><type><name>u64</name></type> <name>iVal</name> <init>= <expr><call><name>fuzzRandomU64</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>fuzzPutU64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>

        <case>case <expr><literal type="number">0x02</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* real */</comment>
          <decl_stmt><decl><type><name>u64</name></type> <name>iVal1</name> <init>= <expr><call><name>fuzzRandomU64</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u64</name></type> <name>iVal2</name> <init>= <expr><call><name>fuzzRandomU64</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name>iVal1</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>iVal2</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iVal1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iVal1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fuzzPutU64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iVal1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>

        <case>case <expr><literal type="number">0x03</literal></expr>:</case>                    <comment type="block">/* text */</comment>
        <case>case <expr><literal type="number">0x04</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* blob */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><call><name>fuzzRandomInt</name><argument_list>(<argument><expr><literal type="number">48</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fuzzRandomBlob</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x03</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nByte</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7F</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_VALUE_MOD</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>pSub1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name></name></expr></argument>, <argument><expr><name><name>pChange</name><operator>-&gt;</operator><name>pSub1</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="number">0x01</literal></expr>:</case>
        <case>case <expr><literal type="number">0x02</literal></expr>:</case>
          <expr_stmt><expr><name>iMod</name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><literal type="number">0x03</literal></expr>:</case>                    <comment type="block">/* text */</comment>
        <case>case <expr><literal type="number">0x04</literal></expr>:</case> <block>{<block_content>                  <comment type="block">/* blob */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <call><name>fuzzGetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iMod</name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>iFirst</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>

      <if_stmt><if>if<condition>( <expr><name>iMod</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>mask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><literal type="number">8</literal> <operator>-</operator> <operator>(</operator><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x03</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pChange</name><operator>-&gt;</operator><name>aSub</name><index>[<expr><name>iMod</name></expr>]</index></name> <operator>^=</operator> <name>mask</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Copy a single change from the input to the output changeset, making
** any modifications specified by (*pFuzz).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzCopyChange</name><parameter_list>(
  <parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iGrp</name></decl></parameter>,
  <parameter><decl><type><name>FuzzChange</name> <modifier>*</modifier></type><name>pFuzz</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>             <comment type="block">/* IN/OUT: Input and output pointers */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bPS</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name>iGrp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><operator>*</operator><name>ppOut</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><name>p</name><operator>++</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>eType</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bPS</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iUndef</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUpdate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>u8</name></type> <name>eNew</name> <init>= <expr><name>eType</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>iCurrent</name></name><operator>==</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>iChange</name></name> <operator>&amp;&amp;</operator> <name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_TYPE</name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_INSERT</name></expr>:</case>
        <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>SQLITE_DELETE</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>SQLITE_DELETE</name></expr>:</case>
        <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>SQLITE_UPDATE</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>SQLITE_UPDATE</name></expr>:</case>
        <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>SQLITE_INSERT</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>iCurrent</name></name><operator>==</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>iChange</name></name> 
   <operator>&amp;&amp;</operator> <name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_FIELD</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>SQLITE_UPDATE</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nDef</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nDef</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nDef</name> <operator>=</operator> <call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name>nDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <name>p</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>nDef</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iUndef</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nDef</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Copy the change type and indirect flag. If the fuzz mode is
  ** FUZZ_CHANGE_INDIRECT, and the current change is the one selected for
  ** fuzzing, invert the indirect flag.  */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>eNew</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_INDIRECT</name> <operator>&amp;&amp;</operator> <name><name>pFuzz</name><operator>-&gt;</operator><name>iCurrent</name></name><operator>==</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>iChange</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>!</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <for>for<control>(<init><expr><name>iRec</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iRec</name><operator>&lt;</operator><name>nRec</name></expr>;</condition> <incr><expr><name>iRec</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Copy the next record from the output to the input.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If this is a patchset, and the input is a DELETE, then the only
      ** fields present are the PK fields. So, if this is not a PK, skip to 
      ** the next column. If the current fuzz is FUZZ_CHANGE_TYPE, then
      ** write a randomly selected value to the output.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>bPS</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><name>eNew</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eNew</name><operator>==</operator><name>SQLITE_UPDATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <do>do <block>{<block_content>
            <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block>while<condition>( <expr><name><name>pCopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x00</literal></expr> )</condition>;</do>
          <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>pCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>pSub1</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <name><name>pFuzz</name><operator>-&gt;</operator><name>pSub2</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>p</name><operator>==</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>pSub2</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <name><name>pFuzz</name><operator>-&gt;</operator><name>pSub1</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>==</operator><name>iUndef</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><literal type="string">"\0"</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pCopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x00</literal> <operator>&amp;&amp;</operator> <name>eNew</name><operator>!=</operator><name>eType</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name>iRec</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name><name>pCopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x00</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x00</literal> <operator>&amp;&amp;</operator> <name><name>pCopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0x00</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x05</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>iGroup</name></name><operator>!=</operator><name>iGrp</name> <operator>||</operator> <name>i</name><operator>!=</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>iDelete</name></name><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>eNew</name><operator>==</operator><name>eType</name> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_UPDATE</name> <operator>||</operator> <name>iRec</name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>eNew</name><operator>==</operator><name>eType</name> <operator>||</operator> <name>eNew</name><operator>!=</operator><name>SQLITE_DELETE</name> <operator>||</operator> <operator>!</operator><name>bPS</name> <operator>||</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>pCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nUpdate</name> <operator>+=</operator> <operator>(</operator><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0x00</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>iGrp</name><operator>==</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>iGroup</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_ADD</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bPS</name> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_DELETE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x05</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_ADDPK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iRec</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>szNew</name></decl>;</decl_stmt>
          <do>do <block>{<block_content>
            <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><call><name>fuzzRandomInt</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block>while<condition>( <expr><name><name>pNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x00</literal> <operator>||</operator> <name><name>pNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x05</literal></expr> )</condition>;</do>
          <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>szNew</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>iCurrent</name></name><operator>==</operator><name><name>pFuzz</name><operator>-&gt;</operator><name>iChange</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_DUP</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><name>pOut</name> <operator>-</operator> <operator>(</operator><operator>*</operator><name>ppOut</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>*</operator><name>ppOut</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_CHANGE_DEL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>*</operator><name>ppOut</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eNew</name><operator>!=</operator><name>eType</name> <operator>&amp;&amp;</operator> <name>eNew</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bPS</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><operator>*</operator><name>ppOut</name><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><name>pCsr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><literal type="string">"\0"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>pCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fuzzChangeSize</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If a column is being deleted from this group, and this change was an 
  ** UPDATE, and there are now no non-PK, non-undefined columns in the 
  ** change, remove it altogether. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_DEL</name> <operator>&amp;&amp;</operator> <name><name>pFuzz</name><operator>-&gt;</operator><name>iGroup</name></name><operator>==</operator><name>iGrp</name> 
   <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>&amp;&amp;</operator> <name>nUpdate</name><operator>==</operator><literal type="number">0</literal></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>*</operator><name>ppOut</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFuzz</name><operator>-&gt;</operator><name>iCurrent</name></name> <operator>+=</operator> <operator>(</operator><name>eType</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>||</operator> <name><name>pFuzz</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>FUZZ_CHANGE_FIELD</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Fuzz the changeset parsed into object pParse and write the results 
** to file zOut on disk. Argument pBuf points to a buffer that is guaranteed
** to be large enough to hold the fuzzed changeset.
**
** Return SQLITE_OK if successful, or an SQLite error code if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzDoOneFuzz</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>,               <comment type="block">/* Filename to write modified changeset to */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,                       <comment type="block">/* Buffer to use for modified changeset */</comment>
  <parameter><decl><type><name>FuzzChangeset</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>           <comment type="block">/* Parse of input changeset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuzzChange</name></type> <name>change</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iGrp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name>pBuf</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzSelectChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iGrp</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iGrp</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name></expr>;</condition> <incr><expr><name>iGrp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>FuzzChangesetGroup</name> <modifier>*</modifier></type><name>pGrp</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>apGroup</name><index>[<expr><name>iGrp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nTab</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>pGrp</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nRep</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If this is the group to delete for a FUZZ_GROUP_DEL change, jump to
      ** the next group. Unless this is the only group in the changeset - in
      ** that case this change cannot be applied.
      **
      ** Or, if this is a FUZZ_GROUP_DUP, set nRep to 2 to output two
      ** copies of the group. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>change</name><operator>.</operator><name>iGroup</name></name><operator>==</operator><name>iGrp</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>change</name><operator>.</operator><name>eType</name></name><operator>==</operator><name>FUZZ_GROUP_DEL</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nGroup</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><name><name>change</name><operator>.</operator><name>eType</name></name><operator>==</operator><name>FUZZ_GROUP_DUP</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nRep</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nRep</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSaved</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pGrp</name><operator>-&gt;</operator><name>aChange</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iPKDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>iGrp</name><operator>==</operator><name><name>change</name><operator>.</operator><name>iGroup</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>change</name><operator>.</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_ADD</name> 
           <operator>||</operator> <name><name>change</name><operator>.</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_ADDPK</name></expr> 
          )</condition><block>{<block_content>
            <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>change</name><operator>.</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_DEL</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nCol</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>iPKDel</name> <operator>=</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name><name>change</name><operator>.</operator><name>iDelete</name></name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Output a table header */</comment>
        <expr_stmt><expr><name>pOut</name><operator>++</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>bPatchset</name></name></expr> ?</condition><then> <expr><literal type="char">'P'</literal></expr> </then><else>: <expr><literal type="char">'T'</literal></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <call><name>fuzzPutVarint</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iGrp</name><operator>!=</operator><name><name>change</name><operator>.</operator><name>iGroup</name></name> <operator>||</operator> <name>i</name><operator>!=</operator><name><name>change</name><operator>.</operator><name>iDelete</name></name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>u8</name></type> <name>v</name> <init>= <expr><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>iPKDel</name> <operator>&amp;&amp;</operator> <name>v</name><operator>&gt;</operator><name>iPKDel</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&gt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>change</name><operator>.</operator><name>eType</name></name><operator>==</operator><name>FUZZ_COLUMN_ADD</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>u8</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><name>max</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>pGrp</name><operator>-&gt;</operator><name>aPK</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>pOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>max</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pGrp</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><name>nTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOut</name> <operator>+=</operator> <name>nTab</name></expr>;</expr_stmt>

        <comment type="block">/* Output the change array. */</comment>
        <expr_stmt><expr><name>pSaved</name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pGrp</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzCopyChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iGrp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>change</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>==</operator><name>pSaved</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fuzzWriteFile</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pOut</name><operator>-</operator><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRepeat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of output files */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSeed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Value of PRNG seed */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl>;</decl_stmt>             <comment type="block">/* Name of input file */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pChangeset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Input changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChangeset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Size of input changeset in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Current output file */</comment>
  <decl_stmt><decl><type><name>FuzzChangeset</name></type> <name>changeset</name></decl>;</decl_stmt>        <comment type="block">/* Partially parsed changeset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>!=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>argc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zInput</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fuzzReadFile</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nChangeset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChangeset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzParseChangeset</name><argument_list>(<argument><expr><name>pChangeset</name></expr></argument>, <argument><expr><name>nChangeset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>changeset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>changeset</name><operator>.</operator><name>nGroup</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>fuzzPrintGroup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>changeset</name></expr></argument>, <argument><expr><name><name>changeset</name><operator>.</operator><name>apGroup</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>fuzzMalloc</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nChangeset</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iSeed</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nRepeat</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fuzzRandomSeed</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>iSeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nRepeat</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s-%d"</literal></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzDoOneFuzz</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>changeset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fuzzFree</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"error while processing changeset: %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
