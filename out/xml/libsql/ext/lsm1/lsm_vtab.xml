<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/lsm1/lsm_vtab.c"><comment type="block">/*
** 2015-11-16
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file implements a virtual table for SQLite3 around the LSM
** storage engine from SQLite4.
**
** USAGE
**
**   CREATE VIRTUAL TABLE demo USING lsm1(filename,key,keytype,value1,...);
**
** The filename parameter is the name of the LSM database file, which is
** separate and distinct from the SQLite3 database file.
**
** The keytype must be one of: UINT, TEXT, BLOB.  All keys must be of that
** one type.  "UINT" means unsigned integer.  The values may be of any
** SQLite datatype: BLOB, TEXT, INTEGER, FLOAT, or NULL.
**
** The virtual table contains read-only hidden columns:
**
**     lsm1_key       A BLOB which is the raw LSM key.  If the "keytype"
**                    is BLOB or TEXT then this column is exactly the
**                    same as the key.  For the UINT keytype, this column
**                    will be a variable-length integer encoding of the key.
**
**     lsm1_value     A BLOB which is the raw LSM value.  All of the value
**                    columns are packed into this BLOB using the encoding
**                    described below.
**
** Attempts to write values into the lsm1_key and lsm1_value columns are
** silently ignored.
**
** EXAMPLE
**
** The virtual table declared this way:
**
**    CREATE VIRTUAL TABLE demo2 USING lsm1('x.lsm',id,UINT,a,b,c,d);
**
** Results in a new virtual table named "demo2" that acts as if it has
** the following schema:
**
**    CREATE TABLE demo2(
**      id UINT PRIMARY KEY ON CONFLICT REPLACE,
**      a ANY,
**      b ANY,
**      c ANY,
**      d ANY,
**      lsm1_key BLOB HIDDEN,
**      lsm1_value BLOB HIDDEN
**    ) WITHOUT ROWID;
**
** 
**
** INTERNALS
**
** The key encoding for BLOB and TEXT is just a copy of the blob or text.
** UTF-8 is used for text.  The key encoding for UINT is the variable-length
** integer format at https://sqlite.org/src4/doc/trunk/www/varint.wiki.
**
** The values are encoded as a single blob (since that is what lsm stores as
** its content).  There is a "type integer" followed by "content" for each
** value, alternating back and forth.  The content might be empty.
**
**    TYPE1  CONTENT1  TYPE2  CONTENT2  TYPE3  CONTENT3 ....
**
** Each "type integer" is encoded as a variable-length integer in the
** format of the link above.  Let the type integer be T.  The actual
** datatype is an integer 0-5 equal to T%6.  Values 1 through 5 correspond
** to SQLITE_INTEGER through SQLITE_NULL.  The size of the content in bytes
** is T/6.  Type value 0 means that the value is an integer whose actual
** values is T/6 and there is no content.  The type-value-0 integer format
** only works for integers in the range of 0 through 40.
**
** There is no content for NULL or type-0 integers.  For BLOB and TEXT
** values, the content is the blob data or the UTF-8 text data.  For
** non-negative integers X, the content is a variable-length integer X*2.
** For negative integers Y, the content is varaible-length integer (1-Y)*2+1.
** For FLOAT values, the content is the IEEE754 floating point value in
** native byte-order.  This means that FLOAT values will be corrupted when
** database file is moved between big-endian and little-endian machines.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Forward declaration of subclasses of virtual table objects */</comment>
<typedef>typedef <type><name><name>struct</name> <name>lsm1_vtab</name></name></type> <name>lsm1_vtab</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>lsm1_cursor</name></name></type> <name>lsm1_cursor</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>lsm1_vblob</name></name></type> <name>lsm1_vblob</name>;</typedef>

<comment type="block">/* Primitive types */</comment>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>
<typedef>typedef <type><name>sqlite3_uint64</name></type> <name>u64</name>;</typedef>

<comment type="block">/* An open connection to an LSM table */</comment>
<struct>struct <name>lsm1_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>          <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                <comment type="block">/* Open connection to the LSM table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>keyType</name></decl>;</decl_stmt>                 <comment type="block">/* SQLITE_BLOB, _TEXT, or _INTEGER */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nVal</name></decl>;</decl_stmt>                   <comment type="block">/* Number of value columns */</comment>
}</block>;</struct>


<comment type="block">/* lsm1_cursor is a subclass of sqlite3_vtab_cursor which will
** serve as the underlying representation of a cursor that scans
** over rows of the result
*/</comment>
<struct>struct <name>lsm1_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pLsmCur</name></decl>;</decl_stmt>       <comment type="block">/* The LSM cursor */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isDesc</name></decl>;</decl_stmt>                 <comment type="block">/* 0: scan forward.  1: scan reverse */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>atEof</name></decl>;</decl_stmt>                  <comment type="block">/* True if the scan is complete */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bUnique</name></decl>;</decl_stmt>                <comment type="block">/* True if no more than one row of output */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>                 <comment type="block">/* Content of the current row */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nData</name></decl>;</decl_stmt>                 <comment type="block">/* Number of bytes in the current row */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aeType</name></decl>;</decl_stmt>                <comment type="block">/* Types for all column values */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aiOfst</name></decl>;</decl_stmt>               <comment type="block">/* Offsets to the various fields */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aiLen</name></decl>;</decl_stmt>                <comment type="block">/* Length of each field */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pKey2</name></decl>;</decl_stmt>                 <comment type="block">/* Loop termination key, or NULL */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nKey2</name></decl>;</decl_stmt>                 <comment type="block">/* Length of the loop termination key */</comment>
}</block>;</struct>

<comment type="block">/* An extensible buffer object.
**
** Content can be appended.  Space to hold new content is automatically
** allocated.
*/</comment>
<struct>struct <name>lsm1_vblob</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>             <comment type="block">/* Space to hold content, from sqlite3_malloc64() */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>n</name></decl>;</decl_stmt>             <comment type="block">/* Bytes of space used */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nAlloc</name></decl>;</decl_stmt>        <comment type="block">/* Bytes of space allocated */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>errNoMem</name></decl>;</decl_stmt>       <comment type="block">/* True if a memory allocation error has been seen */</comment>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LSM1_NOINLINE</name></cpp:macro>  <cpp:value>__attribute__((noinline))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1310</literal></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LSM1_NOINLINE</name></cpp:macro>  <cpp:value>__declspec(noinline)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LSM1_NOINLINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Increase the available space in the vblob object so that it can hold
** at least N more bytes.  Return the number of errors.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1VblobEnlarge</name><parameter_list>(<parameter><decl><type><name>lsm1_vblob</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><name>N</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errNoMem</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>+=</operator> <name>N</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> </then><else>: <expr><name>N</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errNoMem</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <call><name>sqlite3_msize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append N bytes to a vblob after first enlarging it */</comment>
<function><type><specifier>static</specifier> <name>LSM1_NOINLINE</name> <name>void</name></type> <name>lsm1VblobEnlargeAndAppend</name><parameter_list>(
  <parameter><decl><type><name>lsm1_vblob</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,
  <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><name>N</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>lsm1VblobEnlarge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append N bytes to a vblob */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsm1VblobAppend</name><parameter_list>(<parameter><decl><type><name>lsm1_vblob</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>+</operator><name>N</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm1VblobEnlargeAndAppend</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* append text to a vblob */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsm1VblobAppendText</name><parameter_list>(<parameter><decl><type><name>lsm1_vblob</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>lsm1VblobAppend</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Dequote the string */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsm1Dequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>cQuote</name> <init>= <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>cQuote</name><operator>!=</operator><literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name>cQuote</name><operator>!=</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">2</literal> <operator>||</operator> <name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>cQuote</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>cQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** The lsm1Connect() method is invoked to create a new
** lsm1_vtab that describes the virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Connect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>keyType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm1_vblob</name></type> <name>sql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azTypes</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"UINT"</literal></expr>,         <expr><literal type="string">"TEXT"</literal></expr>,     <expr><literal type="string">"BLOB"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aeTypes</name><index>[]</index></name> <init>=    <expr><block>{ <expr><name>SQLITE_INTEGER</name></expr>, <expr><name>SQLITE_TEXT</name></expr>, <expr><name>SQLITE_BLOB</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azArgName</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"key"</literal></expr>, <expr><literal type="string">"key type"</literal></expr>, <expr><literal type="string">"value1"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azArgName</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azArgName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><name>i</name><operator>+</operator><literal type="number">4</literal> <operator>||</operator> <name><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s (%r) argument missing"</literal></expr></argument>,
                               <argument><expr><name><name>azArgName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azTypes</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>azTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>keyType</name> <operator>=</operator> <name><name>aeTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>keyType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"key type should be INT, TEXT, or BLOB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><operator>*</operator><name>ppVtab</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>keyType</name></name> <operator>=</operator> <name>keyType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"lsm_new failed with error code %d"</literal></expr></argument>,  <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>connect_failed</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm1Dequote</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_open</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"lsm_open failed with %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>connect_failed</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" PRIMARY KEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">6</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lsm1VblobAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, 
      <argument><expr><literal type="string">", lsm1_command HIDDEN"</literal>
      <literal type="string">", lsm1_key HIDDEN"</literal>
      <literal type="string">", lsm1_value HIDDEN) WITHOUT ROWID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm1VblobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sql</name><operator>.</operator><name>errNoMem</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>connect_failed</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>sql</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>connect_failed</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>pDb</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsm_close</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for lsm1_cursor objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Disconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsm_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new lsm1_cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Open</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof>
                 <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nVal</name></name><operator>*</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiOfst</name></name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiLen</name></name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiOfst</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiLen</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aiOfst</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aeType</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aiLen</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_open</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for a lsm1_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Close</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lsm1_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm_csr_close</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Advance a lsm1_cursor to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Next</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lsm1_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>bUnique</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>atEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_prev</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_next</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsm_csr_valid</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>atEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>atEof</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>nVal</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_key</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>len</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>nVal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>nVal</name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>atEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Eof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lsm1_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>atEof</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rowids are not supported by the underlying virtual table.  So always
** return 0 for the rowid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Rowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Type prefixes on LSM keys
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSM1_TYPE_NEGATIVE</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSM1_TYPE_POSITIVE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSM1_TYPE_TEXT</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSM1_TYPE_BLOB</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
** Write a 32-bit unsigned integer as 4 big-endian bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>varintWrite32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>y</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write a varint into z[].  The buffer z[] must be at least 9 characters
** long to accommodate the largest possible varint.  Return the number of
** bytes of z[] used.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1PutVarint64</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>sqlite3_uint64</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>w</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">240</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">2287</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">240</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>/</operator><literal type="number">256</literal> <operator>+</operator> <literal type="number">241</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>%</operator><literal type="number">256</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">67823</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">2288</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">249</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>/</operator><literal type="number">256</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>%</operator><literal type="number">256</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">3</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>w</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>y</name><operator>&lt;=</operator><literal type="number">16777215</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">250</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>y</name><operator>)</operator></expr>;</expr_stmt>
      <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">251</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>varintWrite32</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>w</name><operator>&lt;=</operator><literal type="number">255</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">252</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>varintWrite32</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">6</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>w</name><operator>&lt;=</operator><literal type="number">65535</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">253</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>w</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>varintWrite32</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">7</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>w</name><operator>&lt;=</operator><literal type="number">16777215</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">254</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>w</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>w</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>varintWrite32</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">8</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>varintWrite32</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>varintWrite32</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">5</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">9</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append non-negative integer x as a variable-length integer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsm1VblobAppendVarint</name><parameter_list>(<parameter><decl><type><name>lsm1_vblob</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_uint64</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>+</operator><literal type="number">9</literal><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>lsm1VblobEnlarge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>lsm1PutVarint64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Decode the varint in the first n bytes z[].  Write the integer value
** into *pResult and return the number of bytes in the varint.
**
** If the decode fails because there are not enough bytes in z[] then
** return 0;
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1GetVarint64</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_uint64</name> <modifier>*</modifier></type><name>pResult</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="number">240</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="number">248</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="number">241</literal><operator>)</operator><operator>*</operator><literal type="number">256</literal> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">240</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="number">246</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">249</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <literal type="number">2288</literal> <operator>+</operator> <literal type="number">256</literal><operator>*</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">3</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">250</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">251</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">252</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>x</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">6</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">253</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>x</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">7</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">254</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>x</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">8</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>x</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>+</operator>
               <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">9</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Encoded a signed integer as a varint.  Numbers close to zero uses fewer
** bytes than numbers far away from zero.  However, the result is not in
** lexicographical order.
**
** Encoding:  Non-negative integer X is encoding as an unsigned
** varint X*2.  Negative integer Y is encoding as an unsigned
** varint (1-Y)*2 + 1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1PutSignedVarint64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
    <return>return <expr><call><name>lsm1PutVarint64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>u</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>v</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><call><name>lsm1PutVarint64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>u</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Decoded a signed varint. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1GetSignedVarint64</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pResult</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lsm1GetVarint64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>u</name><operator>&amp;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>u</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>u</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Read the value part of the key-value pair and decode it into columns.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1DecodeValues</name><parameter_list>(<parameter><decl><type><name>lsm1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>v</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zData</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_value</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>lsm1GetVarint64</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nData</name></name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aeType</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>eType</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>%</operator><literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiOfst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>v</name><operator>/</operator><literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiLen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content> 
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiOfst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>+=</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>aiLen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>v</name><operator>/</operator><literal type="number">6</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nVal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the lsm1_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Column</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lsm1_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The key column */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>lsm_csr_key</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>keyType</name></name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>keyType</name></name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>v1</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsm1GetVarint64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>&gt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nVal</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nVal</name></name><operator>+</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>  <comment type="block">/* lsm1_key */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>lsm_csr_key</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nVal</name></name><operator>+</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>  <comment type="block">/* lsm1_value */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>lsm_csr_value</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>lsm1DecodeValues</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* The i-th value column (where leftmost is 1) */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>nData</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>zData</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zData</name></name> <operator>+</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aiOfst</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aiLen</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aeType</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* in-line integer */</comment>
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aiOfst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsm1GetSignedVarint64</name><argument_list>(<argument><expr><name>zData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>v</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nData</name><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
         <comment type="block">/* A NULL.  Do nothing */</comment>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parameter "pValue" contains an SQL value that is to be used as
** a key in an LSM table.  The type of the key is determined by
** "keyType".  Extract the raw bytes used for the key in LSM1.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsm1KeyFromValue</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>keyType</name></decl></parameter>,                 <comment type="block">/* The key type */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>,       <comment type="block">/* The key value */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,                    <comment type="block">/* Storage space for a generated key */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppKey</name></decl></parameter>,            <comment type="block">/* OUT: the bytes of the key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>                   <comment type="block">/* OUT: size of the key */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>keyType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>keyType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <call><name>lsm1PutVarint64</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Move to the first row to return.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Filter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>lsm1_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seekType</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>keyType</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>keyType</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aKey1</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>atEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&lt;</operator><literal type="number">99</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm1KeyFromValue</name><argument_list>(<argument><expr><name>keyType</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aKey1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>( <expr><name>idxNum</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>   <comment type="block">/* key==argv[0] */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>seekType</name> <operator>=</operator> <name>LSM_SEEK_EQ</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bUnique</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* key&gt;=argv[0] AND key&lt;=argv[1] */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aKey</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><name>seekType</name> <operator>=</operator> <name>LSM_SEEK_GE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bUnique</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>keyType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name> <operator>=</operator> <call><name>lsm1PutVarint64</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>keyType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nKey2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* key&gt;=argv[0] */</comment>
      <expr_stmt><expr><name>seekType</name> <operator>=</operator> <name>LSM_SEEK_GE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bUnique</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* key&lt;=argv[0] */</comment>
      <expr_stmt><expr><name>seekType</name> <operator>=</operator> <name>LSM_SEEK_LE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bUnique</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content> <comment type="block">/* full table scan */</comment>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bUnique</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_seek</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>seekType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_first</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsm_csr_valid</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pLsmCur</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>atEof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Only comparisons against the key are allowed.  The idxNum defines
** which comparisons are available:
**
**     0        key==?1
**     1        key&gt;=?1 AND key&lt;=?2
**     2        key&gt;?1 or key&gt;=?1
**     3        key&lt;?1 or key&lt;=?1
**    99        Full table scan only
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1BestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop over constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name> <init>= <expr><literal type="number">99</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* The query plan */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Number of arguments to xFilter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>argIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Index of the key== constraint, or -1 if none */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx2</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* The index of the second key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>omit1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>omit2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>argIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iIdx2</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>idxNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>omit1</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr>:</case>
      <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">99</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>argIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>idxNum</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>omit1</name> <operator>=</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iIdx2</name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>omit2</name> <operator>=</operator> <name>omit1</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>argIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>idxNum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>omit1</name> <operator>=</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr>:</case>
      <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">99</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>argIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>idxNum</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>omit1</name> <operator>=</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iIdx2</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>idxNum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>omit1</name> <operator>=</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>argIdx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>argIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>nArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>argIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <name>omit1</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iIdx2</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iIdx2</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>nArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iIdx2</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <name>omit2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxNum</name><operator>&lt;</operator><literal type="number">99</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">5000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">5000</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Full table scan */</comment>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">2147483647</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">2147483647</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xUpdate method is normally used for INSERT, REPLACE, UPDATE, and
** DELETE.  But this virtual table only supports INSERT and REPLACE.
** DELETE is accomplished by inserting a record with a value of NULL.
** UPDATE is achieved by using REPLACE.
*/</comment>
<function><type><name>int</name></type> <name>lsm1Update</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>, <decl><type ref="prev"/><name>nKey2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pKey</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pKey2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>aKey</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>pSpace</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm1_vblob</name></type> <name>val</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* DELETE the record whose key is argv[0] */</comment>
    <expr_stmt><expr><call><name>lsm1KeyFromValue</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>keyType</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_delete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* An UPDATE */</comment>
    <expr_stmt><expr><call><name>lsm1KeyFromValue</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>keyType</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm1KeyFromValue</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>keyType</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>!=</operator><name>nKey2</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The UPDATE changes the PRIMARY KEY value.  DELETE the old key */</comment>
      <expr_stmt><expr><call><name>lsm_delete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through into the INSERT case to complete the UPDATE */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* "INSERT INTO tab(lsm1_command) VALUES('....')" is used to implement
  ** special commands.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lsm1KeyFromValue</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>keyType</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">3</literal><operator>+</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>lsm1VblobAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>SQLITE_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>v</name><operator>&lt;=</operator><literal type="number">240</literal><operator>/</operator><literal type="number">6</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>lsm1VblobAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>v</name><operator>*</operator><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>lsm1PutSignedVarint64</name><argument_list>(<argument><expr><name>pSpace</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>lsm1VblobAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>SQLITE_INTEGER</name> <operator>+</operator> <name>n</name><operator>*</operator><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsm1VblobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsm1VblobAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>SQLITE_FLOAT</name> <operator>+</operator> <literal type="number">8</literal><operator>*</operator><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsm1VblobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsm1VblobAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>n</name><operator>*</operator><literal type="number">6</literal> <operator>+</operator> <name>SQLITE_BLOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsm1VblobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsm1VblobAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>n</name><operator>*</operator><literal type="number">6</literal> <operator>+</operator> <name>SQLITE_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsm1VblobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>val</name><operator>.</operator><name>errNoMem</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_insert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name><name>val</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>val</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>      

<comment type="block">/* Begin a transaction
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Begin</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>lsm_begin</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Phase 1 of a transaction commit.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Sync</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Commit a transaction
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Commit</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>lsm_commit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Rollback a transaction
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm1Rollback</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>lsm1_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>lsm_rollback</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This following structure defines all the methods for the 
** generate_lsm1 virtual table.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>lsm1Module</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* iVersion */</comment>
  <expr><name>lsm1Connect</name></expr>,             <comment type="block">/* xCreate */</comment>
  <expr><name>lsm1Connect</name></expr>,             <comment type="block">/* xConnect */</comment>
  <expr><name>lsm1BestIndex</name></expr>,           <comment type="block">/* xBestIndex */</comment>
  <expr><name>lsm1Disconnect</name></expr>,          <comment type="block">/* xDisconnect */</comment>
  <expr><name>lsm1Disconnect</name></expr>,          <comment type="block">/* xDestroy */</comment>
  <expr><name>lsm1Open</name></expr>,                <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>lsm1Close</name></expr>,               <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>lsm1Filter</name></expr>,              <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>lsm1Next</name></expr>,                <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>lsm1Eof</name></expr>,                 <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>lsm1Column</name></expr>,              <comment type="block">/* xColumn - read data */</comment>
  <expr><name>lsm1Rowid</name></expr>,               <comment type="block">/* xRowid - read data */</comment>
  <expr><name>lsm1Update</name></expr>,              <comment type="block">/* xUpdate */</comment>
  <expr><name>lsm1Begin</name></expr>,               <comment type="block">/* xBegin */</comment>
  <expr><name>lsm1Sync</name></expr>,                <comment type="block">/* xSync */</comment>
  <expr><name>lsm1Commit</name></expr>,              <comment type="block">/* xCommit */</comment>
  <expr><name>lsm1Rollback</name></expr>,            <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xRename */</comment>
}</block></expr></init></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_lsm_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"lsm1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsm1Module</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
