<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/lsm1/lsm_sorted.c"><comment type="block">/*
** 2011-08-14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** PAGE FORMAT:
**
**   The maximum page size is 65536 bytes.
**
**   Since all records are equal to or larger than 2 bytes in size, and 
**   some space within the page is consumed by the page footer, there must
**   be less than 2^15 records on each page.
**
**   Each page ends with a footer that describes the pages contents. This
**   footer serves as similar purpose to the page header in an SQLite database.
**   A footer is used instead of a header because it makes it easier to
**   populate a new page based on a sorted list of key/value pairs.
**
**   The footer consists of the following values (starting at the end of
**   the page and continuing backwards towards the start). All values are
**   stored as unsigned big-endian integers.
**
**     * Number of records on page (2 bytes).
**     * Flags field (2 bytes).
**     * Left-hand pointer value (8 bytes).
**     * The starting offset of each record (2 bytes per record).
**
**   Records may span pages. Unless it happens to be an exact fit, the part
**   of the final record that starts on page X that does not fit on page X
**   is stored at the start of page (X+1). This means there may be pages where
**   (N==0). And on most pages the first record that starts on the page will
**   not start at byte offset 0. For example:
**
**      aaaaa bbbbb ccc &lt;footer&gt;    cc eeeee fffff g &lt;footer&gt;    gggg....
**
** RECORD FORMAT:
** 
**   The first byte of the record is a flags byte. It is a combination
**   of the following flags (defined in lsmInt.h):
**
**       LSM_START_DELETE
**       LSM_END_DELETE 
**       LSM_POINT_DELETE
**       LSM_INSERT    
**       LSM_SEPARATOR
**       LSM_SYSTEMKEY
**
**   Immediately following the type byte is a pointer to the smallest key 
**   in the next file that is larger than the key in the current record. The 
**   pointer is encoded as a varint. When added to the 32-bit page number 
**   stored in the footer, it is the page number of the page that contains the
**   smallest key in the next sorted file that is larger than this key. 
**
**   Next is the number of bytes in the key, encoded as a varint.
**
**   If the LSM_INSERT flag is set, the number of bytes in the value, as
**   a varint, is next.
**
**   Finally, the blob of data containing the key, and for LSM_INSERT
**   records, the value as well.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_LSM_INT_H</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"lsmInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSM_LOG_STRUCTURE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSM_LOG_DATA</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/*
** Macros to help decode record types.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rtTopic</name><parameter_list>(<parameter><type><name>eType</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>((eType) &amp; LSM_SYSTEMKEY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rtIsDelete</name><parameter_list>(<parameter><type><name>eType</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(((eType) &amp; 0x0F)==LSM_POINT_DELETE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rtIsSeparator</name><parameter_list>(<parameter><type><name>eType</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((eType) &amp; LSM_SEPARATOR)!=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rtIsWrite</name><parameter_list>(<parameter><type><name>eType</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>(((eType) &amp; LSM_INSERT)!=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rtIsSystem</name><parameter_list>(<parameter><type><name>eType</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(((eType) &amp; LSM_SYSTEMKEY)!=0)</cpp:value></cpp:define>

<comment type="block">/*
** The following macros are used to access a page footer.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_NRECORD_OFFSET</name><parameter_list>(<parameter><type><name>pgsz</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>((pgsz) - 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_FLAGS_OFFSET</name><parameter_list>(<parameter><type><name>pgsz</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>((pgsz) - 2 - 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_POINTER_OFFSET</name><parameter_list>(<parameter><type><name>pgsz</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>((pgsz) - 2 - 2 - 8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_CELLPTR_OFFSET</name><parameter_list>(<parameter><type><name>pgsz</name></type></parameter>, <parameter><type><name>iCell</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pgsz) - 2 - 2 - 8 - 2 - (iCell)*2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_EOF</name><parameter_list>(<parameter><type><name>pgsz</name></type></parameter>, <parameter><type><name>nEntry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SEGMENT_CELLPTR_OFFSET(pgsz, nEntry-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_BTREE_FLAG</name></cpp:macro>     <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGFTR_SKIP_NEXT_FLAG</name></cpp:macro>   <cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGFTR_SKIP_THIS_FLAG</name></cpp:macro>   <cpp:value>0x0004</cpp:value></cpp:define>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>SegmentPtr</name></name></type> <name>SegmentPtr</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>LsmBlob</name></name></type> <name>LsmBlob</name>;</typedef>

<struct>struct <name>LsmBlob</name> <block>{
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** A SegmentPtr object may be used for one of two purposes:
**
**   * To iterate and/or seek within a single Segment (the combination of a 
**     main run and an optional sorted run).
**
**   * To iterate through the separators array of a segment.
*/</comment>
<struct>struct <name>SegmentPtr</name> <block>{
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>                <comment type="block">/* Level object segment is part of */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>                <comment type="block">/* Segment to access */</comment>

  <comment type="block">/* Current page. See segmentPtrLoadPage(). */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>                    <comment type="block">/* Current page */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>                    <comment type="block">/* Copy of page flags field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                    <comment type="block">/* Number of cells on pPg */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl>;</decl_stmt>                 <comment type="block">/* Base cascade pointer */</comment>

  <comment type="block">/* Current cell. See segmentPtrLoadCell() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>                    <comment type="block">/* Current record within page pPg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                    <comment type="block">/* Type of current record */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPgPtr</name></decl>;</decl_stmt>               <comment type="block">/* Cascade pointer offset */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>         <comment type="block">/* Key associated with current record */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>         <comment type="block">/* Current record value (eType==WRITE only) */</comment>

  <comment type="block">/* Blobs used to allocate buffers for pKey and pVal as required */</comment>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob2</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Used to iterate through the keys stored in a b-tree hierarchy from start
** to finish. Only First() and Next() operations are required.
**
**   btreeCursorNew()
**   btreeCursorFirst()
**   btreeCursorNext()
**   btreeCursorFree()
**   btreeCursorPosition()
**   btreeCursorRestore()
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>BtreePg</name></name></type> <name>BtreePg</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>BtreeCursor</name></name></type> <name>BtreeCursor</name>;</typedef>
<struct>struct <name>BtreePg</name> <block>{
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>BtreeCursor</name> <block>{
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>                  <comment type="block">/* Iterate through this segments btree */</comment>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl>;</decl_stmt>                <comment type="block">/* File system to read pages from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDepth</name></decl>;</decl_stmt>                     <comment type="block">/* Allocated size of aPg[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPg</name></decl>;</decl_stmt>                        <comment type="block">/* Current entry in aPg[]. -1 -&gt; EOF. */</comment>
  <decl_stmt><decl><type><name>BtreePg</name> <modifier>*</modifier></type><name>aPg</name></decl>;</decl_stmt>                   <comment type="block">/* Pages from root to current location */</comment>

  <comment type="block">/* Cache of current entry. pKey==0 for EOF. */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl>;</decl_stmt>

  <comment type="block">/* Storage for key, if not local */</comment>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
** A cursor used for merged searches or iterations through up to one
** Tree structure and any number of sorted files.
**
**   lsmMCursorNew()
**   lsmMCursorSeek()
**   lsmMCursorNext()
**   lsmMCursorPrev()
**   lsmMCursorFirst()
**   lsmMCursorLast()
**   lsmMCursorKey()
**   lsmMCursorValue()
**   lsmMCursorValid()
**
** iFree:
**   This variable is only used by cursors providing input data for a
**   new top-level segment. Such cursors only ever iterate forwards, not
**   backwards.
*/</comment>
<struct>struct <name>MultiCursor</name> <block>{
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                    <comment type="block">/* Connection that owns this cursor */</comment>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>             <comment type="block">/* Next cursor owned by connection pDb */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                      <comment type="block">/* Mask of CURSOR_XXX flags */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                      <comment type="block">/* Cache of current key type */</comment>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>key</name></decl>;</decl_stmt>                    <comment type="block">/* Cache of current key (or NULL) */</comment>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>val</name></decl>;</decl_stmt>                    <comment type="block">/* Cache of current value */</comment>

  <comment type="block">/* All the component cursors: */</comment>
  <decl_stmt><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name><name>apTreeCsr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Up to two tree cursors */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFree</name></decl>;</decl_stmt>                      <comment type="block">/* Next element of free-list (-ve for eof) */</comment>
  <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>aPtr</name></decl>;</decl_stmt>               <comment type="block">/* Array of segment pointers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPtr</name></decl>;</decl_stmt>                       <comment type="block">/* Size of array aPtr[] */</comment>
  <decl_stmt><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pBtCsr</name></decl>;</decl_stmt>            <comment type="block">/* b-tree cursor (db writes only) */</comment>

  <comment type="block">/* Comparison results */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTree</name></decl>;</decl_stmt>                      <comment type="block">/* Size of aTree[] array */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aTree</name></decl>;</decl_stmt>                     <comment type="block">/* Array of comparison results */</comment>

  <comment type="block">/* Used by cursors flushing the in-memory tree only */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pSystemVal</name></decl>;</decl_stmt>               <comment type="block">/* Pointer to buffer to free */</comment>

  <comment type="block">/* Used by worker cursors only */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>pPrevMergePtr</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** The following constants are used to assign integers to each component
** cursor of a multi-cursor.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_DATA_TREE0</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>   <comment type="block">/* Current tree cursor (apTreeCsr[0]) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_DATA_TREE1</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>   <comment type="block">/* The "old" tree, if any (apTreeCsr[1]) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_DATA_SYSTEM</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>   <comment type="block">/* Free-list entries (new-toplevel only) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_DATA_SEGMENT</name></cpp:macro>   <cpp:value>3</cpp:value></cpp:define>   <comment type="block">/* First segment pointer (aPtr[0]) */</comment>

<comment type="block">/*
** CURSOR_IGNORE_DELETE
**   If set, this cursor will not visit SORTED_DELETE keys.
**
** CURSOR_FLUSH_FREELIST
**   This cursor is being used to create a new toplevel. It should also 
**   iterate through the contents of the in-memory free block list.
**
** CURSOR_IGNORE_SYSTEM
**   If set, this cursor ignores system keys.
**
** CURSOR_NEXT_OK
**   Set if it is Ok to call lsm_csr_next().
**
** CURSOR_PREV_OK
**   Set if it is Ok to call lsm_csr_prev().
**
** CURSOR_READ_SEPARATORS
**   Set if this cursor should visit the separator keys in segment 
**   aPtr[nPtr-1].
**
** CURSOR_SEEK_EQ
**   Cursor has undergone a successful lsm_csr_seek(LSM_SEEK_EQ) operation.
**   The key and value are stored in MultiCursor.key and MultiCursor.val
**   respectively.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_IGNORE_DELETE</name></cpp:macro>    <cpp:value>0x00000001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_FLUSH_FREELIST</name></cpp:macro>   <cpp:value>0x00000002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_IGNORE_SYSTEM</name></cpp:macro>    <cpp:value>0x00000010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_NEXT_OK</name></cpp:macro>          <cpp:value>0x00000020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_PREV_OK</name></cpp:macro>          <cpp:value>0x00000040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_READ_SEPARATORS</name></cpp:macro>  <cpp:value>0x00000080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_SEEK_EQ</name></cpp:macro>          <cpp:value>0x00000100</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>MergeWorker</name></name></type> <name>MergeWorker</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>Hierarchy</name></name></type> <name>Hierarchy</name>;</typedef>

<struct>struct <name>Hierarchy</name> <block>{
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>apHier</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nHier</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** aSave:
**   When mergeWorkerNextPage() is called to advance to the next page in
**   the output segment, if the bStore flag for an element of aSave[] is
**   true, it is cleared and the corresponding iPgno value is set to the 
**   page number of the page just completed.
**
**   aSave[0] is used to record the pointer value to be pushed into the
**   b-tree hierarchy. aSave[1] is used to save the page number of the
**   page containing the indirect key most recently written to the b-tree.
**   see mergeWorkerPushHierarchy() for details.
*/</comment>
<struct>struct <name>MergeWorker</name> <block>{
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>                  <comment type="block">/* Worker snapshot Level being merged */</comment>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>              <comment type="block">/* Cursor to read new segment contents from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFlush</name></decl>;</decl_stmt>                     <comment type="block">/* True if this is an in-memory tree flush */</comment>
  <decl_stmt><decl><type><name>Hierarchy</name></type> <name>hier</name></decl>;</decl_stmt>                 <comment type="block">/* B-tree hierarchy under construction */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>                    <comment type="block">/* Current output page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWork</name></decl>;</decl_stmt>                      <comment type="block">/* Number of calls to mergeWorkerNextPage() */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aGobble</name></decl>;</decl_stmt>               <comment type="block">/* Gobble point for each input segment */</comment>

  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iIndirect</name></decl>;</decl_stmt>
  <struct>struct <name>SavedPgno</name> <block>{
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPgno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bStore</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aSave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</struct>
}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG_EXPENSIVE</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>assertPointersOk</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>assertBtreeOk</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assertRunInOrder</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assertRunInOrder</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assertBtreeOk</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<struct>struct <name>FilePage</name> <block>{ <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt> }</block>;</struct>
<function><type><specifier>static</specifier> <name>u8</name> <modifier>*</modifier></type><name>fsPageData</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pnData</name> <operator>=</operator> <operator>(</operator><operator>(</operator>struct <name>FilePage</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>pPg</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>nData</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator>struct <name>FilePage</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>pPg</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>aData</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*UNUSED static u8 *fsPageDataPtr(Page *pPg){
  return ((struct FilePage *)(pPg))-&gt;aData;
}*/</comment>

<comment type="block">/*
** Write nVal as a 16-bit unsigned big-endian integer into buffer aOut.
*/</comment>
<function><type><name>void</name></type> <name>lsmPutU16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>nVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>nVal</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmPutU32</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>nVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name>    <operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmGetU16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>aOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>aOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>u32</name></type> <name>lsmGetU32</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>u64</name></type> <name>lsmGetU64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator>
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> 
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>aOut</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmPutU64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>nVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">56</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">48</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">40</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name><operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nVal</name>    <operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedBlobGrow</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pEnv</name></name><operator>==</operator><name>pEnv</name> <operator>||</operator> <operator>(</operator><name><name>pBlob</name><operator>-&gt;</operator><name>pEnv</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&lt;</operator><name>nData</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>lsmReallocOrFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pEnv</name></name> <operator>=</operator> <name>pEnv</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedBlobSet</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sortedBlobGrow</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int sortedBlobCopy(LsmBlob *pDest, LsmBlob *pSrc){
  return sortedBlobSet(pDest, pSrc-&gt;pData, pSrc-&gt;nData);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sortedBlobFree</name><parameter_list>(<parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pEnv</name></name> <operator>||</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmBlob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedReadData</name><parameter_list>(
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,
  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iOff</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>,
  <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_NRECORD_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iEnd</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iEnd</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iOff</name><operator>+</operator><name>nByte</name><operator>&lt;=</operator><name>iEnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>nByte</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>iOff</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aDest</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure the blob is big enough to store the value being loaded. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobGrow</name><argument_list>(<argument><expr><call><name>lsmPageEnv</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aDest</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment the pointer pages ref-count. */</comment>
    <expr_stmt><expr><call><name>lsmFsPageRef</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

      <comment type="block">/* Copy data from pPg into the output buffer. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><call><name>LSM_MIN</name><argument_list>(<argument><expr><name>nRem</name></expr></argument>, <argument><expr><name>iEnd</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCopy</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aDest</name><index>[<expr><name>nByte</name><operator>-</operator><name>nRem</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRem</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>==</operator><name>iEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRem</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nRem</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>i</name> <operator>-=</operator> <name>iEnd</name></expr>;</expr_stmt>

      <comment type="block">/* Grab the next page in the segment */</comment>

      <do>do <block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>pNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_FLAGS_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SEGMENT_BTREE_FLAG</name></expr> )</condition>;</do>

      <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>nData</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iEnd</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iEnd</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pageGetNRec</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_NRECORD_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>pageGetPtr</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>LsmPgno</name><operator>)</operator><call><name>lsmGetU64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_POINTER_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pageGetFlags</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_FLAGS_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>u8</name> <modifier>*</modifier></type><name>pageGetCell</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_CELLPTR_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of cells on page pPg.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pageObjGetNRec</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><call><name>lsmFsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the decoded (possibly relative) pointer value stored in cell 
** iCell from page aData/nData.
*/</comment>
<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>pageGetRecordPtr</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRet</name></decl>;</decl_stmt>                   <comment type="block">/* Return value */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aCell</name></decl>;</decl_stmt>                      <comment type="block">/* Pointer to cell iCell */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCell</name><operator>&lt;</operator><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>iCell</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCell</name> <operator>=</operator> <call><name>pageGetCell</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmVarintGet64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>u8</name> <modifier>*</modifier></type><name>pageGetKey</name><parameter_list>(
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Segment pPg belongs to */</comment>
  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,                      <comment type="block">/* Page to read from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,                      <comment type="block">/* Index of cell on page to read */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piTopic</name></decl></parameter>,                   <comment type="block">/* OUT: Topic associated with this key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>,                     <comment type="block">/* OUT: Size of key in bytes */</comment>
  <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>                  <comment type="block">/* If required, use this for dynamic memory */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCell</name><operator>&lt;</operator><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>pageGetCell</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>*</operator><name>pKey</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKey</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKey</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>pnKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>rtIsWrite</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pKey</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>piTopic</name> <operator>=</operator> <call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sortedReadData</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pKey</name><operator>-</operator><name>aData</name></expr></argument>, <argument><expr><operator>*</operator><name>pnKey</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pKey</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pageGetKeyCopy</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>,                  <comment type="block">/* Environment handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Segment pPg belongs to */</comment>
  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,                      <comment type="block">/* Page to read from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,                      <comment type="block">/* Index of cell on page to read */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piTopic</name></decl></parameter>,                   <comment type="block">/* OUT: Topic associated with this key */</comment>
  <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>                  <comment type="block">/* If required, use this for dynamic memory */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aKey</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aKey</name> <operator>=</operator> <call><name>pageGetKey</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><name>piTopic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>aKey</name><operator>!=</operator><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name> <operator>||</operator> <name>nKey</name><operator>==</operator><name><name>pBlob</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>aKey</name><operator>!=</operator><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>pageGetBtreeRef</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRef</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aCell</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCell</name> <operator>=</operator> <call><name>pageGetCell</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aCell</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCell</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet64</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmVarintGet64</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iRef</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iRef</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETVARINT64</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i)=((u8*)(a))[0])&lt;=240?1:lsmVarintGet64((a), &amp;(i)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETVARINT32</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i)=((u8*)(a))[0])&lt;=240?1:lsmVarintGet32((a), &amp;(i)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pageGetBtreeKey</name><parameter_list>(
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Segment page pPg belongs to */</comment>
  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iKey</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piTopic</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>,
  <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SEGMENT_BTREE_FLAG</name> <operator>&amp;</operator> <call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iKey</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iKey</name><operator>&lt;</operator><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>aCell</name> <operator>=</operator> <call><name>pageGetCell</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>*</operator><name>aCell</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>GETVARINT64</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>*</operator><name>piPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRef</name></decl>;</decl_stmt>               <comment type="block">/* Page number of referenced page */</comment>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pRef</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>GETVARINT64</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><name>iRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><call><name>lsmPageFS</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iRef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pageGetKeyCopy</name><argument_list>(<argument><expr><call><name>lsmPageEnv</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pRef</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>GETVARINT32</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>*</operator><name>pnKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <name>aCell</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>piTopic</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piTopic</name> <operator>=</operator> <call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursorLoadKey</name><parameter_list>(<parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>dummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPg</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>.</operator><name>iCell</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>iCell</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>--</operator><name>iPg</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iCell</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pageGetBtreeKey</name><argument_list>(
        <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>,
        <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>.</operator><name>pPage</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name> <operator>|=</operator> <name>LSM_SEPARATOR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursorPtr</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&gt;=</operator><name>nCell</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetRecordPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursorNext</name><parameter_list>(<parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>BtreePg</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iCell</name></name><operator>&lt;=</operator><name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>iCell</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>iCell</name></name><operator>==</operator><name>nCell</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLoad</name></decl>;</decl_stmt>

    <comment type="block">/* Up to parent. */</comment>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>--</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>iCell</name></name><operator>&lt;</operator><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Read the key */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorLoadKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Unless the cursor is at EOF, descend to cell -1 (yes, negative one) of 
    ** the left-most most descendent. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>++</operator></expr>;</expr_stmt>

      <expr_stmt><expr><name>iLoad</name> <operator>=</operator> <call><name>btreeCursorPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <do>do <block>{<block_content>
        <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLoad</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name>iLoad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLoad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>pPage</name> <operator>=</operator> <name>pLoad</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pLoad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iLoad</name> <operator>=</operator> <call><name>btreeCursorPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>&lt;</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition>;</do>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorLoadKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>pPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <call><name>btreeCursorPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeCursorFree</name><parameter_list>(<parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><call><name>lsmFsEnv</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursorFirst</name><parameter_list>(<parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPg</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr></init></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>LSM_OK</name><operator>)</operator><operator>==</operator><operator>(</operator><name>pPg</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name> <operator>+</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name></name> <operator>=</operator> <operator>(</operator><name>BtreePg</name> <operator>*</operator><operator>)</operator><call><name>lsmReallocOrFreeRc</name><argument_list>(
            <argument><expr><call><name>lsmFsEnv</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtreePg</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtreePg</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name></expr>]</index></name><operator>.</operator><name>pPage</name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>iPg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetRecordPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition>;</do>
  <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorNext</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeCursorPosition</name><parameter_list>(<parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>MergeInput</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>btreeCursorSplitkey</name><parameter_list>(<parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>MergeInput</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <name>iCell</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedKeyCompare</name><parameter_list>(
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLhsTopic</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pLhsKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLhsKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iRhsTopic</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pRhsKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRhsKey</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>iLhsTopic</name> <operator>-</operator> <name>iRhsTopic</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>xCmp</name><argument_list>(<argument><expr><name>pLhsKey</name></expr></argument>, <argument><expr><name>nLhsKey</name></expr></argument>, <argument><expr><name>pRhsKey</name></expr></argument>, <argument><expr><name>nRhsKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursorRestore</name><parameter_list>(
  <parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>MergeInput</name> <modifier>*</modifier></type><name>p</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><call><name>lsmFsEnv</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>                    <comment type="block">/* Current cell number on leaf page */</comment>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLeaf</name></decl>;</decl_stmt>                <comment type="block">/* Page number of current leaf page */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nDepth</name></decl>;</decl_stmt>                   <comment type="block">/* Depth of b-tree structure */</comment>
    <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Decode the MergeInput structure */</comment>
    <expr_stmt><expr><name>iLeaf</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iPg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDepth</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>&amp;</operator> <literal type="number">0x00FF</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCell</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Allocate the BtreeCursor.aPg[] array */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name></name> <operator>=</operator> <operator>(</operator><name>BtreePg</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtreePg</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nDepth</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Populate the last entry of the aPg[] array */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>nDepth</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pPage</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <name>nDepth</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDepth</name></name> <operator>=</operator> <name>nDepth</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>=</operator> <name>iCell</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iLeaf</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Populate any other aPg[] array entries */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nDepth</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pSeek</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nSeek</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iTopicSeek</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iLoad</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>nDepth</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pPage</name></expr></init></decl>;</decl_stmt>
 
      <if_stmt><if>if<condition>( <expr><call><name>pageObjGetNRec</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* This can happen when pPg is the right-most leaf in the b-tree.
        ** In this case, set the iTopicSeek/pSeek/nSeek key to a value
        ** greater than any real key.  */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCell</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iTopicSeek</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pSeek</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSeek</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>LsmPgno</name></type> <name>dummy</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pageGetBtreeKey</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>,
            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopicSeek</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSeek</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSeek</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <do>do <block>{<block_content>
        <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg2</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iLoad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>pPg2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                  <comment type="block">/* Buffer containing page data */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                  <comment type="block">/* Size of aData[] in bytes */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>iMin</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iMax</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iCell2</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>iLoad</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iCell2</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
          <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name>iCell2</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>iMin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

          <while>while<condition>( <expr><name>iMax</name><operator>&gt;=</operator><name>iMin</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>iTry</name> <init>= <expr><operator>(</operator><name>iMin</name><operator>+</operator><name>iMax</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>         <comment type="block">/* Key for cell iTry */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>iTopic</name></decl>;</decl_stmt>                   <comment type="block">/* Topic for key pKeyT/nKeyT */</comment>
            <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl>;</decl_stmt>                 <comment type="block">/* Pointer for cell iTry */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>                      <comment type="block">/* (pSeek - pKeyT) */</comment>

            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pageGetBtreeKey</name><argument_list>(
                <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg2</name></expr></argument>, <argument><expr><name>iTry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(
                <argument><expr><name>xCmp</name></expr></argument>, <argument><expr><name>iTopicSeek</name></expr></argument>, <argument><expr><name>pSeek</name></expr></argument>, <argument><expr><name>nSeek</name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>iLoad</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>iPtr</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>iCell2</name> <operator>=</operator> <name>iTry</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name>iTry</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iTry</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></while>

          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>.</operator><name>pPage</name> <operator>=</operator> <name>pPg2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>iPg</name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>=</operator> <name>iCell2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iPg</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPg</name><operator>!=</operator><name>nDepth</name><operator>-</operator><literal type="number">1</literal> 
               <operator>||</operator> <call><name>lsmFsRedirectPage</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name></expr></argument>, <argument><expr><name>iLoad</name></expr></argument>)</argument_list></call><operator>==</operator><name>iLeaf</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>iPg</name><operator>&lt;</operator><operator>(</operator><name>nDepth</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Load the current key and pointer */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>BtreePg</name> <modifier>*</modifier></type><name>pBtreePg</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>pBtreePg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>pBtreePg</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <call><name>btreeCursorPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name><name>pBtreePg</name><operator>-&gt;</operator><name>iCell</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pBtreePg</name><operator>-&gt;</operator><name>iCell</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>LsmPgno</name></type> <name>dummy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pageGetBtreeKey</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>,
            <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pPage</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCell</name><operator>-</operator><literal type="number">1</literal></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name> <operator>|=</operator> <name>LSM_SEPARATOR</name></expr>;</expr_stmt>

      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorLoadKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>btreeCursorNew</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,
  <parameter><decl><type><name>BtreeCursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtreeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFS</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSeg</name></name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>segmentPtrSetPage</name><parameter_list>(<parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNext</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><call><name>fsPageData</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Load a new page into the SegmentPtr object pPtr.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrLoadPage</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,              <comment type="block">/* Load page into this SegmentPtr object */</comment>
  <parameter><decl><type><name>int</name></type> <name>iNew</name></decl></parameter>                       <comment type="block">/* Page number of new page */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* The new page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                        <comment type="block">/* Return Code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>pPg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>segmentPtrSetPage</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrReadData</name><parameter_list>(
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iOff</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>,
  <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sortedReadData</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>ppData</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrNextPage</name><parameter_list>(
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,              <comment type="block">/* Load page into this SegmentPtr object */</comment>
  <parameter><decl><type><name>int</name></type> <name>eDir</name></decl></parameter>                       <comment type="block">/* +1 for next(), -1 for prev() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>                   <comment type="block">/* New page to load */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                        <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eDir</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eDir</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name> <operator>||</operator> <name>eDir</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>, <argument><expr><name>eDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>pNext</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>segmentPtrSetPage</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrLoadCell</name><parameter_list>(
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,              <comment type="block">/* Load page into this SegmentPtr object */</comment>
  <parameter><decl><type><name>int</name></type> <name>iNew</name></decl></parameter>                       <comment type="block">/* Cell number of new cell */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to page data buffer */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>                     <comment type="block">/* Offset in aData[] to read from */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nPgsz</name></decl>;</decl_stmt>                    <comment type="block">/* Size of page (aData[]) in bytes */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iNew</name><operator>&lt;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPgsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_CELLPTR_OFFSET</name><argument_list>(<argument><expr><name>nPgsz</name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>GETVARINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>iPgPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>GETVARINT32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>rtIsWrite</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>GETVARINT32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrReadData</name><argument_list>(
        <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>blob1</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>rtIsWrite</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrReadData</name><argument_list>(
          <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iOff</name><operator>+</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>blob2</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Segment</name> <modifier>*</modifier></type><name>sortedSplitkeySegment</name><parameter_list>(<parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Merge</name> <modifier>*</modifier></type><name>pMerge</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MergeInput</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pMerge</name><operator>-&gt;</operator><name>splitkey</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPg</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name><operator>==</operator><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><operator>(</operator><name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>pSeg</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sortedSplitkey</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Environment handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Merge</name> <modifier>*</modifier></type><name>pMerge</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <call><name>sortedSplitkeySegment</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pMerge</name><operator>-&gt;</operator><name>splitkey</name><operator>.</operator><name>iPg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iTopic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>lsmFsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>LsmPgno</name></type> <name>dummy</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pageGetBtreeKey</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>,
          <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name><name>pMerge</name><operator>-&gt;</operator><name>splitkey</name><operator>.</operator><name>iCell</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>blob</name><operator>.</operator><name>pData</name></name><operator>!=</operator><name>pKey</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pageGetKeyCopy</name><argument_list>(
          <argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name><name>pMerge</name><operator>-&gt;</operator><name>splitkey</name><operator>.</operator><name>iCell</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iSplitTopic</name></name> <operator>=</operator> <name>iTopic</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pSplitKey</name></name> <operator>=</operator> <name><name>blob</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>nSplitKey</name></name> <operator>=</operator> <name><name>blob</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Reset a segment cursor. Also free its buffers if they are nThreshold
** bytes or larger in size.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>segmentPtrReset</name><parameter_list>(<parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nThreshold</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>blob1</name><operator>.</operator><name>nAlloc</name></name><operator>&gt;=</operator><name>nThreshold</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>blob1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>blob2</name><operator>.</operator><name>nAlloc</name></name><operator>&gt;=</operator><name>nThreshold</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>blob2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrIgnoreSeparators</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_READ_SEPARATORS</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
      <operator>||</operator> <operator>(</operator><name>pPtr</name><operator>!=</operator><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrAdvance</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eDir</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bReverse</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name></name></expr></init></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>                    <comment type="block">/* Number of new cell in page */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>svFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* SegmentPtr.eType before advance */</comment>

    <expr_stmt><expr><name>iCell</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iCell</name></name> <operator>+</operator> <name>eDir</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCell</name><operator>&lt;=</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name> <operator>&amp;&amp;</operator> <name>iCell</name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bReverse</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>!=</operator><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>svFlags</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>svFlags</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&gt;=</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name> <operator>||</operator> <name>iCell</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <do>do <block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrNextPage</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>eDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> 
           <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> 
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator> <operator>)</operator></expr> 
      )</condition>;</do>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <ternary><condition><expr><name>bReverse</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>svFlags</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>,
          <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,
          <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>iSplitTopic</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr></argument>
      )</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>svFlags</name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>LSM_START_DELETE</name> <operator>|</operator> <name>LSM_POINT_DELETE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name><name>pLvl</name><operator>-&gt;</operator><name>iSplitTopic</name></name></expr> ?</condition><then> <expr><name>LSM_SYSTEMKEY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block>while<condition>( <expr><name>pCsr</name> 
       <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> 
       <operator>&amp;&amp;</operator> <call><name>segmentPtrIgnoreSeparators</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <call><name>rtIsSeparator</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr>
  )</condition>;</do>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>segmentPtrEndPage</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bLast</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>bLast</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>lsmFsDbPageLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>segmentPtrSetPage</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Try to move the segment pointer passed as the second argument so that it
** points at either the first (bLast==0) or last (bLast==1) cell in the valid
** region of the segment defined by pPtr-&gt;iFirst and pPtr-&gt;iLast.
**
** Return LSM_OK if successful or an lsm error code if something goes
** wrong (IO error, OOM etc.).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrEnd</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bIgnore</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>segmentPtrEndPage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>bLast</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> 
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrNextPage</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bLast</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bLast</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bLast</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>!=</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>,
          <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,
          <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>iSplitTopic</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr></argument>
      )</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><name>bIgnore</name> <operator>=</operator> <call><name>segmentPtrIgnoreSeparators</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> <operator>&amp;&amp;</operator> <name>bIgnore</name> <operator>&amp;&amp;</operator> <call><name>rtIsSeparator</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>bLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  if( bLast &amp;&amp; rc==LSM_OK &amp;&amp; pPtr-&gt;pPg
   &amp;&amp; pPtr-&gt;pSeg==&amp;pLvl-&gt;lhs 
   &amp;&amp; pLvl-&gt;nRight &amp;&amp; (pPtr-&gt;eType &amp; LSM_START_DELETE)
  ){
    pPtr-&gt;iCell++;
    pPtr-&gt;eType = LSM_END_DELETE | (pLvl-&gt;iSplitTopic);
    pPtr-&gt;pKey = pLvl-&gt;pSplitKey;
    pPtr-&gt;nKey = pLvl-&gt;nSplitKey;
    pPtr-&gt;pVal = 0;
    pPtr-&gt;nVal = 0;
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>segmentPtrKey</name><parameter_list>(<parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* NOT USED */</comment>
static char *keyToString(lsm_env *pEnv, void *pKey, int nKey){
  int i;
  u8 *aKey = (u8 *)pKey;
  char *zRet = (char *)lsmMalloc(pEnv, nKey+1);

  for(i=0; i&lt;nKey; i++){
    zRet[i] = (char)(isalnum(aKey[i]) ? aKey[i] : '.');
  }
  zRet[nKey] = '\0';
  return zRet;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* NOT USED */</comment>
<comment type="block">/*
** Check that the page that pPtr currently has loaded is the correct page
** to search for key (pKey/nKey). If it is, return 1. Otherwise, an assert
** fails and this function does not return.
*/</comment>
static int assertKeyLocation(
  MultiCursor *pCsr, 
  SegmentPtr *pPtr, 
  void *pKey, int nKey
){
  lsm_env *pEnv = lsmFsEnv(pCsr-&gt;pDb-&gt;pFS);
  LsmBlob blob = {0, 0, 0};
  int eDir;
  int iTopic = 0;                 <comment type="block">/* TODO: Fix me */</comment>

  for(eDir=-1; eDir&lt;=1; eDir+=2){
    Page *pTest = pPtr-&gt;pPg;

    lsmFsPageRef(pTest);
    while( pTest ){
      Segment *pSeg = pPtr-&gt;pSeg;
      Page *pNext;

      int rc = lsmFsDbPageNext(pSeg, pTest, eDir, &amp;pNext);
      lsmFsPageRelease(pTest);
      if( rc ) return 1;
      pTest = pNext;

      if( pTest ){
        int nData;
        u8 *aData = fsPageData(pTest, &amp;nData);
        int nCell = pageGetNRec(aData, nData);
        int flags = pageGetFlags(aData, nData);
        if( nCell &amp;&amp; 0==(flags&amp;SEGMENT_BTREE_FLAG) ){
          int nPgKey;
          int iPgTopic;
          u8 *pPgKey;
          int res;
          int iCell;

          iCell = ((eDir &lt; 0) ? (nCell-1) : 0);
          pPgKey = pageGetKey(pSeg, pTest, iCell, &amp;iPgTopic, &amp;nPgKey, &amp;blob);
          res = iTopic - iPgTopic;
          if( res==0 ) res = pCsr-&gt;pDb-&gt;xCmp(pKey, nKey, pPgKey, nPgKey);
          if( (eDir==1 &amp;&amp; res&gt;0) || (eDir==-1 &amp;&amp; res&lt;0) ){
            <comment type="block">/* Taking this branch means something has gone wrong. */</comment>
            char *zMsg = lsmMallocPrintf(pEnv, "Key \"%s\" is not on page %d", 
                keyToString(pEnv, pKey, nKey), lsmFsPageNumber(pPtr-&gt;pPg)
            );
            fprintf(stderr, "%s\n", zMsg);
            assert( !"assertKeyLocation() failed" );
          }
          lsmFsPageRelease(pTest);
          pTest = 0;
        }
      }
    }
  }

  sortedBlobFree(&amp;blob);
  return 1;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>assertSeekResult</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eSeek</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>,
        <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>eSeek</name><operator>==</operator><name>LSM_SEEK_EQ</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eSeek</name><operator>==</operator><name>LSM_SEEK_LE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>res</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eSeek</name><operator>==</operator><name>LSM_SEEK_GE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>res</name><operator>&lt;=</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrSearchOversized</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,              <comment type="block">/* Cursor context */</comment>
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,               <comment type="block">/* Pointer to seek */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>,                     <comment type="block">/* Topic of key to search for */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>            <comment type="block">/* Key to seek to */</comment>
)</parameter_list><block>{<block_content>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></init>;</function_decl>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the OVERSIZED flag is set, then there is no pointer in the
  ** upper level to the next page in the segment that contains at least
  ** one key. So compare the largest key on the current page with the
  ** key being sought (pKey/nKey). If (pKey/nKey) is larger, advance
  ** to the next page in the segment that contains at least one key. 
  */</comment>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGFTR_SKIP_NEXT_FLAG</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pLastKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nLastKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLastTopic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>                      <comment type="block">/* Result of comparison */</comment>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

    <comment type="block">/* Load the last key on the current page. */</comment>
    <expr_stmt><expr><name>pLastKey</name> <operator>=</operator> <call><name>pageGetKey</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>,
        <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLastTopic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLastKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>blob1</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the loaded key is &gt;= than (pKey/nKey), break out of the loop.
    ** If (pKey/nKey) is present in this array, it must be on the current 
    ** page.  */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(
        <argument><expr><name>xCmp</name></expr></argument>, <argument><expr><name>iLastTopic</name></expr></argument>, <argument><expr><name>pLastKey</name></expr></argument>, <argument><expr><name>nLastKey</name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* Advance to the next page that contains at least one key. */</comment>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRef</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLoad</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLoad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name>pLoad</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>lsmFsPageData</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>pNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>segmentPtrSetPage</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This should probably be an LSM_CORRUPT error. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGFTR_SKIP_THIS_FLAG</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ptrFwdPointer</name><parameter_list>(
  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbFound</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><name>pPage</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name> <init>= <expr><name>iCell</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>lsmFsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> <init>= <expr><operator>*</operator><call><name>pageGetCell</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pbFound</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>piPtr</name> <operator>=</operator> <call><name>pageGetRecordPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>LSM_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>pPg</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition>;</do>
  <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pbFound</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedRhsFirst</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl></parameter>, <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>,
        <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>iSplitTopic</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr></argument>,
        <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called as part of a SEEK_GE op on a multi-cursor if the 
** FC pointer read from segment *pPtr comes from an entry with the 
** LSM_START_DELETE flag set. In this case the pointer value cannot be 
** trusted. Instead, the pointer that should be followed is that associated
** with the next entry in *pPtr that does not have LSM_START_DELETE set.
**
** Why the pointers can't be trusted:
**
**
**
** TODO: This is a stop-gap solution:
** 
**   At the moment, this function is called from within segmentPtrSeek(), 
**   as part of the initial lsmMCursorSeek() call. However, consider a 
**   database where the following has occurred:
**
**      1. A range delete removes keys 1..9999 using a range delete.
**      2. Keys 1 through 9999 are reinserted.
**      3. The levels containing the ops in 1. and 2. above are merged. Call
**         this level N. Level N contains FC pointers to level N+1.
**
**   Then, if the user attempts to query for (key&gt;=2 LIMIT 10), the 
**   lsmMCursorSeek() call will iterate through 9998 entries searching for a 
**   pointer down to the level N+1 that is never actually used. It would be
**   much better if the multi-cursor could do this lazily - only seek to the
**   level (N+1) page after the user has moved the cursor on level N passed
**   the big range-delete.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrFwdPointer</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,              <comment type="block">/* Multi-cursor pPtr belongs to */</comment>
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,               <comment type="block">/* Segment-pointer to extract FC ptr from */</comment>
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>                  <comment type="block">/* OUT: FC pointer value */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bFound</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name> <operator>||</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pNext</name><operator>==</operator><literal type="number">0</literal> 
        <operator>||</operator> <operator>(</operator><name><name>pNext</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iRoot</name></name><operator>)</operator>
        <operator>||</operator> <operator>(</operator><name><name>pNext</name><operator>-&gt;</operator><name>nRight</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iRoot</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
      <comment type="block">/* Do nothing. The pointer will not be used anyway. */</comment>
      <return>return <expr><name>LSM_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>LSM_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Search for a pointer within the current segment. */</comment>
  <expr_stmt><expr><call><name>lsmFsPageRef</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ptrFwdPointer</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bFound</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* This case happens when pPtr points to the left-hand-side of a segment
    ** currently undergoing an incremental merge. In this case, jump to the
    ** oldest segment in the right-hand-side of the same level and continue
    ** searching. But - do not consider any keys smaller than the levels
    ** split-key. */</comment>
    <decl_stmt><decl><type><name>SegmentPtr</name></type> <name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>!=</operator><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>LSM_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ptr</name><operator>.</operator><name>pLevel</name></name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ptr</name><operator>.</operator><name>pSeg</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ptr</name><operator>.</operator><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name><name>ptr</name><operator>.</operator><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedRhsFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>ptr</name><operator>.</operator><name>pLevel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ptrFwdPointer</name><argument_list>(<argument><expr><name><name>ptr</name><operator>.</operator><name>pPg</name></name></expr></argument>, <argument><expr><name><name>ptr</name><operator>.</operator><name>iCell</name></name></expr></argument>, <argument><expr><name><name>ptr</name><operator>.</operator><name>pSeg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ptr</name><operator>.</operator><name>pPg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piPtr</name> <operator>=</operator> <name>iOut</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentPtrSeek</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,              <comment type="block">/* Cursor context */</comment>
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,               <comment type="block">/* Pointer to seek */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>,                     <comment type="block">/* Key topic to seek to */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key to seek to */</comment>
  <parameter><decl><type><name>int</name></type> <name>eSeek</name></decl></parameter>,                      <comment type="block">/* Search bias - see above */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>,                     <comment type="block">/* OUT: FC pointer */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbStop</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></init>;</function_decl>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Result of comparison operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMax</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtrOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the current page contains an oversized entry, then there are no
  ** pointers to one or more of the subsequent pages in the sorted run.
  ** The following call ensures that the segment-ptr points to the correct 
  ** page in this case.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrSearchOversized</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iPtrOut</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iPtr</name></name></expr>;</expr_stmt>

  <comment type="block">/* Assert that this page is the right page of this segment for the key
  ** that we are searching for. Do this by loading page (iPg-1) and testing
  ** that pKey/nKey is greater than all keys on that page, and then by 
  ** loading (iPg+1) and testing that pKey/nKey is smaller than all
  ** the keys it houses.  
  **
  ** TODO: With range-deletes in the tree, the test described above may fail.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  assert( assertKeyLocation(pCsr, pPtr, pKey, nKey) );
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal> 
       <operator>||</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>nSize</name></name><operator>==</operator><literal type="number">1</literal> 
       <operator>||</operator> <call><name>lsmFsDbPageIsLast</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iMin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTry</name> <init>= <expr><operator>(</operator><name>iMin</name><operator>+</operator><name>iMax</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKeyT</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKeyT</name></decl>;</decl_stmt>       <comment type="block">/* Key for cell iTry */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iTopicT</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTry</name><operator>&lt;</operator><name>iMax</name> <operator>||</operator> <name>iMin</name><operator>==</operator><name>iMax</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iTry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>segmentPtrKey</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKeyT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKeyT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iTopicT</name> <operator>=</operator> <call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name>xCmp</name></expr></argument>, <argument><expr><name>iTopicT</name></expr></argument>, <argument><expr><name>pKeyT</name></expr></argument>, <argument><expr><name>nKeyT</name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iPtrOut</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>+</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iPgPtr</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iMin</name><operator>==</operator><name>iMax</name></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iMax</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><name>iTry</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iTry</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iMin</name><operator>==</operator><name>iMax</name> <operator>&amp;&amp;</operator> <name>iMin</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iMin</name><operator>&lt;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iPtrOut</name><operator>==</operator><operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>+</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iPgPtr</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <switch>switch<condition>( <expr><name>eSeek</name></expr> )</condition><block>{<block_content>
          <case>case <expr><name>LSM_SEEK_EQ</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator>
             <operator>||</operator> <operator>(</operator><name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator><operator>)</operator>
             <operator>||</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_POINT_DELETE</name><operator>)</operator><operator>)</operator></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>pbStop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_INSERT</name><operator>)</operator></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><operator>*</operator><name>pbStop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_SEEK_EQ</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>LSM_SEEK_LE</name></expr>:</case>
            <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
          <case>case <expr><name>LSM_SEEK_GE</name></expr>:</case> <block>{<block_content>
            <comment type="block">/* Figure out if we need to 'skip' the pointer forward or not */</comment>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator> 
             <operator>||</operator> <operator>(</operator><name>res</name><operator>&gt;</operator><literal type="number">0</literal>  <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator><operator>)</operator></expr> 
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrFwdPointer</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPtrOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
          </block_content>}</block>
        </block_content>}</block></switch>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the cursor seek has found a separator key, and this cursor is
    ** supposed to ignore separators keys, advance to the next entry.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name>
     <operator>&amp;&amp;</operator> <call><name>segmentPtrIgnoreSeparators</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <call><name>rtIsSeparator</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eSeek</name><operator>!=</operator><name>LSM_SEEK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>eSeek</name><operator>==</operator><name>LSM_SEEK_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <call><name>assertSeekResult</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>,<argument><expr><name>pPtr</name></expr></argument>,<argument><expr><name>iTopic</name></expr></argument>,<argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>nKey</name></expr></argument>,<argument><expr><name>eSeek</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>iPtrOut</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>seekInBtree</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,              <comment type="block">/* Multi-cursor object */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Seek within this segment */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key to seek to */</comment>
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aPg</name></decl></parameter>,                   <comment type="block">/* OUT: Page numbers */</comment>
  <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPg</name></decl></parameter>                     <comment type="block">/* OUT: Leaf (sorted-run) page reference */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>iPg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piFirst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>aPg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aPg</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iPg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>piFirst</name> <operator>=</operator> <operator>&amp;</operator><name><name>aPg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>pPg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                  <comment type="block">/* Buffer containing page data */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                  <comment type="block">/* Size of aData[] in bytes */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iMin</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iMax</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>iPg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>iMin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name>nRec</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>iMax</name><operator>&gt;=</operator><name>iMin</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iTry</name> <init>= <expr><operator>(</operator><name>iMin</name><operator>+</operator><name>iMax</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKeyT</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKeyT</name></decl>;</decl_stmt>       <comment type="block">/* Key for cell iTry */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>iTopicT</name></decl>;</decl_stmt>                  <comment type="block">/* Topic for key pKeyT/nKeyT */</comment>
        <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl>;</decl_stmt>                 <comment type="block">/* Pointer associated with cell iTry */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>                      <comment type="block">/* (pKey - pKeyT) */</comment>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pageGetBtreeKey</name><argument_list>(
            <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iTry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopicT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKeyT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKeyT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>piFirst</name> <operator>&amp;&amp;</operator> <name>pKeyT</name><operator>==</operator><name><name>blob</name><operator>.</operator><name>pData</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>piFirst</name> <operator>=</operator> <call><name>pageGetBtreeRef</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iTry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>piFirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(
            <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>iTopicT</name></expr></argument>, <argument><expr><name>pKeyT</name></expr></argument>, <argument><expr><name>nKeyT</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iPg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>iPtr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name>iTry</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iTry</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition>;</do>

  <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>LSM_OK</name><operator>)</operator><operator>==</operator><operator>(</operator><name>pPg</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ppPg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppPg</name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>seekInSegment</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iPg</name></decl></parameter>,                        <comment type="block">/* Page to search */</comment>
  <parameter><decl><type><name>int</name></type> <name>eSeek</name></decl></parameter>,                      <comment type="block">/* Search bias - see above */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>,                     <comment type="block">/* OUT: FC pointer */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbStop</name></decl></parameter>                     <comment type="block">/* OUT: Stop search flag */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name> <init>= <expr><name>iPg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>seekInBtree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>segmentPtrSetPage</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iPtr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadPage</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrSeek</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>eSeek</name></expr></argument>, <argument><expr><name>piPtr</name></expr></argument>, <argument><expr><name>pbStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Seek each segment pointer in the array of (pLvl-&gt;nRight+1) at aPtr[].
**
** pbStop:
**   This parameter is only significant if parameter eSeek is set to
**   LSM_SEEK_EQ. In this case, it is set to true before returning if
**   the seek operation is finished. This can happen in two ways:
**   
**     a) A key matching (pKey/nKey) is found, or
**     b) A point-delete or range-delete deleting the key is found.
**
**   In case (a), the multi-cursor CURSOR_SEEK_EQ flag is set and the pCsr-&gt;key
**   and pCsr-&gt;val blobs populated before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seekInLevel</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,              <comment type="block">/* Sorted cursor object to seek */</comment>
  <parameter><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>aPtr</name></decl></parameter>,               <comment type="block">/* Pointer to array of (nRhs+1) SPs */</comment>
  <parameter><decl><type><name>int</name></type> <name>eSeek</name></decl></parameter>,                      <comment type="block">/* Search bias - see above */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>,                     <comment type="block">/* Key topic to search for */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key to search for */</comment>
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piPgno</name></decl></parameter>,                <comment type="block">/* IN/OUT: fraction cascade pointer (or 0) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbStop</name></decl></parameter>                     <comment type="block">/* OUT: See above */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>aPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pLevel</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Level to seek within */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Pointer to return to caller */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Result of xCmp(pKey, split) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRhs</name> <init>= <expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Number of right-hand-side segments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bStop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If this is a composite level (one currently undergoing an incremental
  ** merge), figure out if the search key is larger or smaller than the
  ** levels split-key.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nRhs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, 
        <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>iSplitTopic</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If (res&lt;0), then key pKey/nKey is smaller than the split-key (or this
  ** is not a composite level and there is no split-key). Search the 
  ** left-hand-side of the level in this case.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nRhs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>piPgno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>seekInSegment</name><argument_list>(
        <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>, <argument><expr><name>eSeek</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bStop</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nRhs</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eSeek</name><operator>==</operator><name>LSM_SEEK_GE</name> <operator>&amp;&amp;</operator> <name><name>aPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nRhs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bHit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* True if at least one rhs is not EOF */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>piPgno</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><name>nRhs</name> <operator>&amp;&amp;</operator> <name>bStop</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>iOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>seekInSegment</name><argument_list>(
          <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>, <argument><expr><name>eSeek</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bStop</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name>iOut</name></expr>;</expr_stmt>

      <comment type="block">/* If the segment-pointer has settled on a key that is smaller than
      ** the splitkey, invalidate the segment-pointer.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, 
            <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, 
            <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>iSplitTopic</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>&amp;</operator> <name>LSM_START_DELETE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LSM_INSERT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bHit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>eSeek</name><operator>==</operator><name>LSM_SEEK_LE</name> <operator>&amp;&amp;</operator> <name>bHit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eSeek</name><operator>==</operator><name>LSM_SEEK_EQ</name> <operator>||</operator> <name>bStop</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piPgno</name> <operator>=</operator> <name>iOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pbStop</name> <operator>=</operator> <name>bStop</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>multiCursorGetKey</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>peType</name></decl></parameter>,                    <comment type="block">/* OUT: Key type (SORTED_WRITE etc.) */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppKey</name></decl></parameter>,                   <comment type="block">/* OUT: Pointer to buffer containing key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>                      <comment type="block">/* OUT: Size of *ppKey in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>( <expr><name>iKey</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>CURSOR_DATA_TREE0</name></expr>:</case>
    <case>case <expr><name>CURSOR_DATA_TREE1</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pTreeCsr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><name>iKey</name><operator>-</operator><name>CURSOR_DATA_TREE0</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmTreeCursorKey</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CURSOR_DATA_SYSTEM</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pWorker</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_FLUSH_FREELIST</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><name><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>&lt;</operator> <operator>(</operator><name>nEntry</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>FreelistEntry</name> <modifier>*</modifier></type><name>aEntry</name> <init>= <expr><name><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>aEntry</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>nEntry</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u32</name></type> <name>iKey2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>LSM_END_DELETE</name><operator>|</operator><name>LSM_SYSTEMKEY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>iKey2</name> <operator>=</operator> <name><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iId</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>LSM_INSERT</name><operator>|</operator><name>LSM_SYSTEMKEY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>iKey2</name> <operator>=</operator> <name><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name></expr>;</expr_stmt>

            <comment type="block">/* If the in-memory entry immediately before this one was a
             ** DELETE, and the block number is one greater than the current
             ** block number, mark this entry as an "end-delete-range". */</comment>
            <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>nEntry</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>aEntry</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iBlk</name><operator>==</operator><name>iKey2</name><operator>+</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>aEntry</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iId</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>eType</name> <operator>|=</operator> <name>LSM_END_DELETE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>LSM_START_DELETE</name><operator>|</operator><name>LSM_SYSTEMKEY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>iKey2</name> <operator>=</operator> <name><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

          <comment type="block">/* If the in-memory entry immediately after this one is a
          ** DELETE, and the block number is one less than the current
          ** key, mark this entry as an "start-delete-range".  */</comment>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aEntry</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iBlk</name><operator>==</operator><name>iKey2</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>aEntry</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iId</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>eType</name> <operator>|=</operator> <name>LSM_START_DELETE</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name>pKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pSystemVal</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nKey</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmPutU32</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><operator>~</operator><name>iKey2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name> <init>= <expr><name>iKey</name> <operator>-</operator> <name>CURSOR_DATA_SEGMENT</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPtr</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPtr</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name><operator>-&gt;</operator><name>pKey</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>eType</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iPtr</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pKey</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>eType</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>peType</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>peType</name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>ppKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <name>pKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedDbKeyCompare</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLhsFlags</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pLhsKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLhsKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iRhsFlags</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pRhsKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRhsKey</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></init>;</function_decl>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <comment type="block">/* Compare the keys, including the system flag. */</comment>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name>xCmp</name></expr></argument>, 
    <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>iLhsFlags</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pLhsKey</name></expr></argument>, <argument><expr><name>nLhsKey</name></expr></argument>,
    <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>iRhsFlags</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pRhsKey</name></expr></argument>, <argument><expr><name>nRhsKey</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a key has the LSM_START_DELETE flag set, but not the LSM_INSERT or
  ** LSM_POINT_DELETE flags, it is considered a delta larger. This prevents
  ** the beginning of an open-ended set from masking a database entry or
  ** delete at a lower level.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_IGNORE_DELETE</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>m</name> <init>= <expr><name>LSM_POINT_DELETE</name><operator>|</operator><name>LSM_INSERT</name><operator>|</operator><name>LSM_END_DELETE</name> <operator>|</operator><name>LSM_START_DELETE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iDel1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iDel2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>LSM_START_DELETE</name><operator>==</operator><operator>(</operator><name>iLhsFlags</name> <operator>&amp;</operator> <name>m</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iDel1</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>LSM_END_DELETE</name>  <operator>==</operator><operator>(</operator><name>iLhsFlags</name> <operator>&amp;</operator> <name>m</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iDel1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>LSM_START_DELETE</name><operator>==</operator><operator>(</operator><name>iRhsFlags</name> <operator>&amp;</operator> <name>m</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iDel2</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>LSM_END_DELETE</name>  <operator>==</operator><operator>(</operator><name>iRhsFlags</name> <operator>&amp;</operator> <name>m</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iDel2</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>iDel1</name> <operator>-</operator> <name>iDel2</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>multiCursorDoCompare</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iOut</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>eType1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey2</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>eType2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mul</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bReverse</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name> <operator>&amp;&amp;</operator> <name>iOut</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iOut</name><operator>&gt;=</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>i1</name> <operator>=</operator> <operator>(</operator><name>iOut</name> <operator>-</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i2</name> <operator>=</operator> <name>i1</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>i1</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>iOut</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i2</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>iOut</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pKey1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i2</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pKey2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i1</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <comment type="block">/* Compare the keys */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedDbKeyCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>,
        <argument><expr><name>eType1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>eType2</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>*</operator> <name>mul</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The two keys are identical. Normally, this means that the key from
      ** the newer run clobbers the old. However, if the newer key is a
      ** separator key, or a range-delete-boundary only, do not allow it
      ** to clobber an older entry.  */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nc1</name> <init>= <expr><operator>(</operator><name>eType1</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_INSERT</name><operator>|</operator><name>LSM_POINT_DELETE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nc2</name> <init>= <expr><operator>(</operator><name>eType2</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_INSERT</name><operator>|</operator><name>LSM_POINT_DELETE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>iRes</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nc1</name> <operator>&gt;</operator> <name>nc2</name><operator>)</operator></expr> ?</condition><then> <expr><name>i2</name></expr> </then><else>: <expr><name>i1</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i1</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i2</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name>iRes</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function advances segment pointer iPtr belonging to multi-cursor
** pCsr forward (bReverse==0) or backward (bReverse!=0).
**
** If the segment pointer points to a segment that is part of a composite
** level, then the following special case is handled.
**
**   * If iPtr is the lhs of a composite level, and the cursor is being
**     advanced forwards, and segment iPtr is at EOF, move all pointers
**     that correspond to rhs segments of the same level to the first
**     key in their respective data.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentCursorAdvance</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iPtr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bComposite</name></decl>;</decl_stmt>                 <comment type="block">/* True if pPtr is part of composite level */</comment>

  <comment type="block">/* Advance the segment-pointer object. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>bComposite</name> <operator>=</operator> <operator>(</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>&gt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bComposite</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bFix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>bReverse</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>bReverse</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pLhs</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name> <operator>-</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pLhs</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pPg</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bFix</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLhs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>bFix</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedRhsFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLvl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bFix</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>multiCursorDoCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  if( bComposite &amp;&amp; pPtr-&gt;pSeg==&amp;pLvl-&gt;lhs       <comment type="block">/* lhs of composite level */</comment>
   &amp;&amp; bReverse==0                                <comment type="block">/* csr advanced forwards */</comment>
   &amp;&amp; pPtr-&gt;pPg==0                               <comment type="block">/* segment at EOF */</comment>
  ){
    int i;
    for(i=0; rc==LSM_OK &amp;&amp; i&lt;pLvl-&gt;nRight; i++){
      rc = sortedRhsFirst(pCsr, pLvl, &amp;pCsr-&gt;aPtr[iPtr+1+i]);
    }
    for(i=pCsr-&gt;nTree-1; i&gt;0; i--){
      multiCursorDoCompare(pCsr, i, 0);
    }
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mcursorFreeComponents</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Close the tree cursor, if any. */</comment>
  <expr_stmt><expr><call><name>lsmTreeCursorDestroy</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmTreeCursorDestroy</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the segment pointers */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* And the b-tree cursor, if any */</comment>
  <expr_stmt><expr><call><name>btreeCursorFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free allocations */</comment>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSystemVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Zero fields */</comment>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSystemVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmMCursorFreeCache</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsrCache</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsrCache</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close the cursor passed as the first argument.
**
** If the bCache parameter is true, then shift the cursor to the pCsrCache
** list for possible reuse instead of actually deleting it.
*/</comment>
<function><type><name>void</name></type> <name>lsmMCursorClose</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>             <comment type="block">/* Iterator variable */</comment>

    <comment type="block">/* The cursor may or may not be currently part of the linked list 
    ** starting at lsm_db.pCsr. If it is, extract it.  */</comment>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pp</name><operator>==</operator><name>pCsr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>bCache</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Used to iterate through segment-pointers */</comment>

      <comment type="block">/* Release any page references held by this cursor. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>

      <comment type="block">/* Reset the tree cursors */</comment>
      <expr_stmt><expr><call><name>lsmTreeCursorReset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmTreeCursorReset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Add the cursor to the pCsrCache list */</comment>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsrCache</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsrCache</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Free the allocation used to cache the current key, if any. */</comment>
      <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Free the component cursors */</comment>
      <expr_stmt><expr><call><name>mcursorFreeComponents</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Free the cursor structure itself */</comment>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_OLD</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_BOTH</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
** Parameter eTree is one of TREE_OLD or TREE_BOTH.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorAddTree</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eTree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Add a tree cursor on the 'old' tree, if it exists. */</comment>
  <if_stmt><if>if<condition>( <expr><name>eTree</name><operator>!=</operator><name>TREE_NONE</name> 
   <operator>&amp;&amp;</operator> <call><name>lsmTreeHasOld</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> 
   <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldLog</name></name><operator>!=</operator><name><name>pSnap</name><operator>-&gt;</operator><name>iLogOff</name></name></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Add a tree cursor on the 'current' tree, if required. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>eTree</name><operator>==</operator><name>TREE_BOTH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorAddRhs</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRhs</name> <init>= <expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name> <operator>=</operator> <call><name>lsmMallocZero</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentPtr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nRhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name> <operator>=</operator> <name>nRhs</name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRhs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pLevel</name> <operator>=</operator> <name>pLvl</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>multiCursorAddOne</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name><operator>.</operator><name>pLevel</name> <operator>=</operator> <name>pLvl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name><operator>.</operator><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPtr</name><operator>++</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name><operator>.</operator><name>pLevel</name> <operator>=</operator> <name>pLvl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name><operator>.</operator><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPtr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name> <operator>&amp;&amp;</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sortedSplitkey</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>pLvl</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name> <operator>=</operator> <name>iPtr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorAddAll</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pLvl</name><operator>=</operator><name><name>pSnap</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</init> <condition><expr><name>pLvl</name></expr>;</condition> <incr><expr><name>pLvl</name><operator>=</operator><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* If the LEVEL_INCOMPLETE flag is set, then this function is being
    ** called (indirectly) from within a sortedNewToplevel() call to
    ** construct pLvl. In this case ignore pLvl - this cursor is going to
    ** be used to retrieve a freelist entry from the LSM, and the partially
    ** complete level may confuse it.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLvl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LEVEL_INCOMPLETE</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nPtr</name> <operator>+=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentPtr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pLvl</name><operator>=</operator><name><name>pSnap</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</init> <condition><expr><name>pLvl</name></expr>;</condition> <incr><expr><name>pLvl</name><operator>=</operator><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLvl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LEVEL_INCOMPLETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>multiCursorAddOne</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLvl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorInit</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAddAll</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pSnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAddTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pSnap</name></expr></argument>, <argument><expr><name>TREE_BOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><name>CURSOR_IGNORE_SYSTEM</name> <operator>|</operator> <name>CURSOR_IGNORE_DELETE</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MultiCursor</name> <modifier>*</modifier></type><name>multiCursorNew</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pCsr</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>lsmSortedRemap</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</init> <condition><expr><name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>btreeCursorLoadKey</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>iPtr</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPtr</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>iPtr</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name><operator>.</operator><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>multiCursorReadSeparators</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_READ_SEPARATORS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Have this cursor skip over SORTED_DELETE entries.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiCursorIgnoreDelete</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_IGNORE_DELETE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If the free-block list is not empty, then have this cursor visit a key
** with (a) the system bit set, and (b) the key "FREELIST" and (c) a value 
** blob containing the serialized free-block list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorVisitFreelist</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_FLUSH_FREELIST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSystemVal</name></name> <operator>=</operator> <call><name>lsmMallocRc</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a new database cursor.
**
** This method should only be called to allocate user cursors. As it may
** recycle a cursor from lsm_db.pCsrCache.
*/</comment>
<function><type><name>int</name></type> <name>lsmMCursorNew</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>             <comment type="block">/* OUT: Allocated cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsrCache</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bOld</name></decl>;</decl_stmt>                     <comment type="block">/* True if there is an old in-memory tree */</comment>

    <comment type="block">/* Remove a cursor from the pCsrCache list and add it to the open list. */</comment>
    <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsrCache</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsrCache</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>

    <comment type="block">/* The cursor can almost be used as is, except that the old in-memory
    ** tree cursor may be present and not required, or required and not
    ** present. Fix this if required.  */</comment>
    <expr_stmt><expr><name>bOld</name> <operator>=</operator> <operator>(</operator><call><name>lsmTreeHasOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldLog</name></name><operator>!=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iLogOff</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bOld</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmTreeCursorDestroy</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bOld</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name>CURSOR_IGNORE_SYSTEM</name> <operator>|</operator> <name>CURSOR_IGNORE_DELETE</name><operator>)</operator></expr>;</expr_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>multiCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorInit</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>LSM_OK</name><operator>)</operator><operator>==</operator><operator>(</operator><name>pCsr</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorGetVal</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>iVal</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>CURSOR_DATA_TREE0</name></expr>:</case>
    <case>case <expr><name>CURSOR_DATA_TREE1</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pTreeCsr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><name>iVal</name><operator>-</operator><name>CURSOR_DATA_TREE0</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmTreeCursorValue</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>, <argument><expr><name>ppVal</name></expr></argument>, <argument><expr><name>pnVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CURSOR_DATA_SYSTEM</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pWorker</name> 
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iEntry</name> <init>= <expr><name><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aVal</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pSystemVal</name></name><operator>)</operator><operator>)</operator><index>[<expr><literal type="number">4</literal></expr>]</index></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsmPutU64</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>, <argument><expr><name><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>aEntry</name><index>[<expr><name>iEntry</name></expr>]</index></name><operator>.</operator><name>iId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>aVal</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name> <init>= <expr><name>iVal</name><operator>-</operator><name>CURSOR_DATA_SEGMENT</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPtr</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pVal</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>ppVal</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pnVal</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorAdvance</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** This function is called by worker connections to walk the part of the
** free-list stored within the LSM data structure.
*/</comment>
<function><type><name>int</name></type> <name>lsmSortedWalkFreelist</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>,                   <comment type="block">/* True to iterate from largest to smallest */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>x</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>i64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,     <comment type="block">/* Callback function */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* First argument to pass to callback */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>              <comment type="block">/* Cursor used to read db */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bIncrMerge</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointDeserialize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name><operator>-&gt;</operator><name>aSnap1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pSnap</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>multiCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAddAll</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pSnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_IGNORE_DELETE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bReverse</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorLast</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorSeek</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LSM_SEEK_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsmMCursorValid</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rtIsSystem</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorValue</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nKey</name><operator>!=</operator><literal type="number">4</literal> <operator>||</operator> <name>nVal</name><operator>!=</operator><literal type="number">8</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>i64</name></type> <name>iSnap</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><call><name>lsmGetU32</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>iSnap</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>lsmGetU64</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>x</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><name>iSnap</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>!</operator><name>bReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSnap</name><operator>!=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFreeSnapshot</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pSnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmSortedLoadFreelist</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle (must be worker) */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>,                   <comment type="block">/* OUT: Blob containing LSM free-list */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>                      <comment type="block">/* OUT: Size of *ppVal blob in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>              <comment type="block">/* Cursor used to retreive free-list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppVal</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pnVal</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>multiCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAddAll</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_IGNORE_DELETE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorLast</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> 
     <operator>&amp;&amp;</operator> <call><name>rtIsWrite</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rtIsSystem</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name><operator>==</operator><literal type="number">8</literal> 
     <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><literal type="string">"FREELIST"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>         <comment type="block">/* Value read from database */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorValue</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <call><name>lsmMallocRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>ppVal</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>ppVal</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorAllocTree</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                    <comment type="block">/* Bytes of space to allocate */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nMin</name></decl>;</decl_stmt>                     <comment type="block">/* Total number of cursors being merged */</comment>

    <expr_stmt><expr><name>nMin</name> <operator>=</operator> <name>CURSOR_DATA_SEGMENT</name> <operator>+</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name> <operator>+</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>&lt;</operator><name>nMin</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>multiCursorCacheKey</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG_EXPENSIVE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assertCursorTree</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bRev</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_PREV_OK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aSave</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSave</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAllocTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>multiCursorDoCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSave</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name> 
        <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>aSave</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nSave</name></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name> <operator>=</operator> <name>aSave</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name> <operator>=</operator> <name>nSave</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>assertCursorTree</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mcursorLocationOk</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bDeleteOk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rdmask</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CURSOR_NEXT_OK</name><operator>|</operator><name>CURSOR_PREV_OK</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assertCursorTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rdmask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_NEXT_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>LSM_END_DELETE</name></expr> </then><else>: <expr><name>LSM_START_DELETE</name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* If the cursor does not currently point to an actual database key (i.e.
  ** it points to a delete key, or the start or end of a range-delete), and
  ** the CURSOR_IGNORE_DELETE flag is set, skip past this entry.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_IGNORE_DELETE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>bDeleteOk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_INSERT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the cursor points to a system key (free-list entry), and the
  ** CURSOR_IGNORE_SYSTEM flag is set, skip thie entry.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_IGNORE_SYSTEM</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <comment type="block">/* This block fires assert() statements to check one of the assumptions
  ** in the comment below - that if the lhs sub-cursor of a level undergoing
  ** a merge is valid, then all the rhs sub-cursors must be at EOF. 
  **
  ** Also assert that all rhs sub-cursors are either at EOF or point to
  ** a key that is not less than the level split-key.  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pPg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, 
            <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,
            <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>iSplitTopic</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nSplitKey</name></name></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Now check if this key has already been deleted by a range-delete. If 
  ** so, skip past it.
  **
  ** Assume, for the moment, that the tree contains no levels currently 
  ** undergoing incremental merge, and that this cursor is iterating forwards
  ** through the database keys. The cursor currently points to a key in
  ** level L. This key has already been deleted if any of the sub-cursors
  ** that point to levels newer than L (or to the in-memory tree) point to
  ** a key greater than the current key with the LSM_END_DELETE flag set.
  **
  ** Or, if the cursor is iterating backwards through data keys, if any
  ** such sub-cursor points to a key smaller than the current key with the
  ** LSM_START_DELETE flag set.
  **
  ** Why it works with levels undergoing a merge too:
  **
  ** When a cursor iterates forwards, the sub-cursors for the rhs of a 
  ** level are only activated once the lhs reaches EOF. So when iterating
  ** forwards, the keys visited are the same as if the level was completely
  ** merged.
  **
  ** If the cursor is iterating backwards, then the lhs sub-cursor is not 
  ** initialized until the last of the rhs sub-cursors has reached EOF.
  ** Additionally, if the START_DELETE flag is set on the last entry (in
  ** reverse order - so the entry with the smallest key) of a rhs sub-cursor,
  ** then a pseudo-key equal to the levels split-key with the END_DELETE
  ** flag set is visited by the sub-cursor.
  */</comment> 
  <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iKey</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>csrflags</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csrflags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rdmask</name> <operator>&amp;</operator> <name>csrflags</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>SD_ED</name> <init>= <expr><operator>(</operator><name>LSM_START_DELETE</name><operator>|</operator><name>LSM_END_DELETE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>csrflags</name> <operator>&amp;</operator> <name>SD_ED</name><operator>)</operator><operator>==</operator><name>SD_ED</name> 
       <operator>||</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_IGNORE_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>,
              <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr></argument>,
              <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>csrflags</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>
        )</argument_list></call></expr>)</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* The current cursor position is one this cursor should visit. Return 1. */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorSetupTree</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bRev</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAllocTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>multiCursorDoCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assertCursorTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>multiCursorCacheKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>mcursorLocationOk</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorEnd</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CURSOR_NEXT_OK</name> <operator>|</operator> <name>CURSOR_PREV_OK</name> <operator>|</operator> <name>CURSOR_SEEK_EQ</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>bLast</name></expr> ?</condition><then> <expr><name>CURSOR_PREV_OK</name></expr> </then><else>: <expr><name>CURSOR_NEXT_OK</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Position the two in-memory tree cursors */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorEnd</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>bLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iRhs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bHit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>bLast</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>iRhs</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iRhs</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr>;</condition> <incr><expr><name>iRhs</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><index>[<expr><name>iRhs</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><index>[<expr><name>iRhs</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pPg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bHit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>bHit</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bLhs</name> <init>= <expr><operator>(</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name> <operator>||</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>bLhs</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bHit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>iRhs</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iRhs</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr>;</condition> <incr><expr><name>iRhs</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>bHit</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPtr</name><index>[<expr><name>iRhs</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedRhsFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLvl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPtr</name><index>[<expr><name>iRhs</name><operator>+</operator><name>bLhs</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* And the b-tree cursor, if applicable */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bLast</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorFirst</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorSetupTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>bLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>mcursorSave</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iTree</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iTree</name><operator>==</operator><name>CURSOR_DATA_TREE0</name> <operator>||</operator> <name>iTree</name><operator>==</operator><name>CURSOR_DATA_TREE1</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>multiCursorCacheKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>mcursorFreeComponents</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mcursorRestore</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorInit</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorSeek</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, 
         <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmSaveCursors</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mcursorSave</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmRestoreCursors</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mcursorRestore</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorFirst</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>multiCursorEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorLast</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>multiCursorEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>lsm_db</name> <modifier>*</modifier></type><name>lsmMCursorDb</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmMCursorReset</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsmTreeCursorReset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmTreeCursorReset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>LSM_SEGMENTPTR_FREE_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treeCursorSeek</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,
  <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pTreeCsr</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>eSeek</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbStop</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTreeCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsmTreeCursorSeek</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>eSeek</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>LSM_SEEK_EQ</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>lsmTreeCursorFlags</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_POINT_DELETE</name><operator>)</operator><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pbStop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_INSERT</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>         <comment type="block">/* Key/value from tree-cursor */</comment>
          <expr_stmt><expr><operator>*</operator><name>pbStop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_SEEK_EQ</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorKey</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorValue</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>lsmTreeCursorReset</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>LSM_SEEK_GE</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      <default>default:</default>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmTreeCursorPrev</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Seek the cursor.
*/</comment>
<function><type><name>int</name></type> <name>lsmMCursorSeek</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>eSeek</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eESeek</name> <init>= <expr><name>eSeek</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Effective eSeek parameter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bStop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Set to true to halt search operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Used to iterate through pCsr-&gt;aPtr[] */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPgno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* FC pointer value */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iTopic</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iTopic</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eESeek</name><operator>==</operator><name>LSM_SEEK_LEFAST</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eESeek</name> <operator>=</operator> <name>LSM_SEEK_LE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eESeek</name><operator>==</operator><name>LSM_SEEK_EQ</name> <operator>||</operator> <name>eESeek</name><operator>==</operator><name>LSM_SEEK_LE</name> <operator>||</operator> <name>eESeek</name><operator>==</operator><name>LSM_SEEK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_FLUSH_FREELIST</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pLevel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CURSOR_NEXT_OK</name> <operator>|</operator> <name>CURSOR_PREV_OK</name> <operator>|</operator> <name>CURSOR_SEEK_EQ</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeCursorSeek</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>eESeek</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bStop</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeCursorSeek</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>eESeek</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Seek all segment pointers. */</comment>
  <for>for<control>(<init><expr><name>iPtr</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPtr</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bStop</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>iPtr</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pSeg</name></name><operator>==</operator><operator>&amp;</operator><name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>seekInLevel</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>eESeek</name></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPtr</name> <operator>+=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>eSeek</name><operator>!=</operator><name>LSM_SEEK_EQ</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAllocTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>multiCursorDoCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>eESeek</name><operator>==</operator><name>LSM_SEEK_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>eSeek</name><operator>==</operator><name>LSM_SEEK_GE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_NEXT_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>eSeek</name><operator>==</operator><name>LSM_SEEK_LE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_PREV_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>multiCursorCacheKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>eSeek</name><operator>!=</operator><name>LSM_SEEK_LEFAST</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>mcursorLocationOk</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <switch>switch<condition>( <expr><name>eESeek</name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>LSM_SEEK_EQ</name></expr>:</case>
          <expr_stmt><expr><call><name>lsmMCursorReset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>LSM_SEEK_GE</name></expr>:</case>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorNext</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorPrev</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorValid</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_SEEK_EQ</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iKey</name><operator>==</operator><name>CURSOR_DATA_TREE0</name> <operator>||</operator> <name>iKey</name><operator>==</operator><name>CURSOR_DATA_TREE1</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><name>iKey</name><operator>-</operator><name>CURSOR_DATA_TREE0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> 
      <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name>pKey</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mcursorAdvanceOk</name><parameter_list>(
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>                     <comment type="block">/* Pointer to buffer containing new key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>                       <comment type="block">/* Size of buffer pNew in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eNewType</name></decl>;</decl_stmt>                   <comment type="block">/* Type of new record */</comment>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Check the current key value. If it is not greater than (if bReverse==0)
  ** or less than (if bReverse!=0) the key currently cached in pCsr-&gt;key, 
  ** then the cursor has not yet been successfully advanced.  
  */</comment>
  <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eNewType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>typemask</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_IGNORE_DELETE</name><operator>)</operator></expr> ?</condition><then> <expr><operator>~</operator><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr> </then><else>: <expr><name>LSM_SYSTEMKEY</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sortedDbKeyCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>,
      <argument><expr><name>eNewType</name> <operator>&amp;</operator> <name>typemask</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>, 
      <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name> <operator>&amp;</operator> <name>typemask</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>bReverse</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>res</name><operator>&lt;=</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bReverse</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>res</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>multiCursorCacheKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>eNewType</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this cursor is configured to skip deleted keys, and the current
    ** cursor points to a SORTED_DELETE entry, then the cursor has not been 
    ** successfully advanced.  
    **
    ** Similarly, if the cursor is configured to skip system keys and the
    ** current cursor points to a system key, it has not yet been advanced.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>mcursorLocationOk</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flCsrAdvance</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_FLUSH_FREELIST</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>%</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FreelistEntry</name> <modifier>*</modifier></type><name>aEntry</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>aEntry</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>nEntry</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the current entry is a delete and the "end-delete" key will not
    ** be attached to the next entry, increment iFree by 1 only. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iId</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>aEntry</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iBlk</name><operator>!=</operator><name><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name><operator>--</operator></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>aEntry</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iId</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iFree</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiCursorAdvance</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>lsmMCursorValid</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iKey</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assertCursorTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this multi-cursor is advancing forwards, and the sub-cursor
      ** being advanced is the one that separator keys may be being read
      ** from, record the current absolute pointer value.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iKey</name><operator>==</operator><operator>(</operator><name>CURSOR_DATA_SEGMENT</name><operator>+</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name><operator>-&gt;</operator><name>iPtr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>&gt;</operator><literal type="number">0</literal>
               <operator>&amp;&amp;</operator> <name>iKey</name><operator>==</operator><operator>(</operator><name>CURSOR_DATA_SEGMENT</name><operator>+</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> 
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iKey</name><operator>-</operator><name>CURSOR_DATA_SEGMENT</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><operator>*</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iPtr</name></name><operator>+</operator><name><name>pPtr</name><operator>-&gt;</operator><name>iPgPtr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>iKey</name><operator>==</operator><name>CURSOR_DATA_TREE0</name> <operator>||</operator> <name>iKey</name><operator>==</operator><name>CURSOR_DATA_TREE1</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pTreeCsr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><name>iKey</name><operator>-</operator><name>CURSOR_DATA_TREE0</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>bReverse</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorPrev</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iKey</name><operator>==</operator><name>CURSOR_DATA_SYSTEM</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_FLUSH_FREELIST</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bReverse</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>flCsrAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iKey</name><operator>==</operator><operator>(</operator><name>CURSOR_DATA_SEGMENT</name><operator>+</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bReverse</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorNext</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentCursorAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iKey</name><operator>-</operator><name>CURSOR_DATA_SEGMENT</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><operator>(</operator><name>iKey</name><operator>+</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTree</name></name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><name>i</name><operator>/</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>multiCursorDoCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>assertCursorTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>while<condition>( <expr><call><name>mcursorAdvanceOk</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorNext</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_NEXT_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>multiCursorAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorPrev</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_PREV_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>multiCursorAdvance</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorKey</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_SEEK_EQ</name><operator>)</operator> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>iKey</name><operator>==</operator><name>CURSOR_DATA_TREE0</name> <operator>||</operator> <name>iKey</name><operator>==</operator><name>CURSOR_DATA_TREE1</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pTreeCsr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><name>iKey</name><operator>-</operator><name>CURSOR_DATA_TREE0</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lsmTreeCursorKey</name><argument_list>(<argument><expr><name>pTreeCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppKey</name></expr></argument>, <argument><expr><name>pnKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt> 
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the current key that cursor csr points to with pKey/nKey. Set
** *piRes to the result and return LSM_OK.
*/</comment>
<function><type><name>int</name></type> <name>lsm_csr_cmp</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>csr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>csr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pCsrkey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nCsrkey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsrkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCsrkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></init>;</function_decl>
    <expr_stmt><expr><operator>*</operator><name>piRes</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name>xCmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pCsrkey</name></expr></argument>, <argument><expr><name>nCsrkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorValue</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_SEEK_EQ</name><operator>)</operator> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>mcursorLocationOk</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_IGNORE_DELETE</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorGetVal</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVal</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmMCursorType</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>peType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>peType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Buffer aData[], size nData, is assumed to contain a valid b-tree 
** hierarchy page image. Return the offset in aData[] of the next free
** byte in the data area (where a new cell may be written if there is
** space).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerPageOffset</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_NRECORD_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iOff</name> <operator>=</operator> <call><name>lsmGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_CELLPTR_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nRec</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eType</name> <operator>=</operator> <name><name>aData</name><index>[<expr><name>iOff</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <name>eType</name><operator>==</operator><operator>(</operator><name>LSM_SYSTEMKEY</name><operator>|</operator><name>LSM_SEPARATOR</name><operator>)</operator> 
       <operator>||</operator> <name>eType</name><operator>==</operator><operator>(</operator><name>LSM_SEPARATOR</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>iOff</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>eType</name></expr> ?</condition><then> <expr><name>nKey</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Following a checkpoint operation, database pages that are part of the
** checkpointed state of the LSM are deemed read-only. This includes the
** right-most page of the b-tree hierarchy of any separators array under
** construction, and all pages between it and the b-tree root, inclusive.
** This is a problem, as when further pages are appended to the separators
** array, entries must be added to the indicated b-tree hierarchy pages.
**
** This function copies all such b-tree pages to new locations, so that
** they can be modified as required.
**
** The complication is that not all database pages are the same size - due
** to the way the file.c module works some (the first and last in each block)
** are 4 bytes smaller than the others.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerMoveHierarchy</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>,               <comment type="block">/* Merge worker */</comment>
  <parameter><decl><type><name>int</name></type> <name>bSep</name></decl></parameter>                        <comment type="block">/* True for separators run */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>apHier</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nHier</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>nHier</name></name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nHier</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSortedAppend</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a2</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>n2</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>a1</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n1</name><operator>==</operator><name>n2</name> <operator>||</operator> <name>n1</name><operator>+</operator><literal type="number">4</literal><operator>==</operator><name>n2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>n1</name><operator>==</operator><name>n2</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iEof1</name> <init>= <expr><call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>nEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iEof2</name> <init>= <expr><call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>n2</name></expr></argument>, <argument><expr><name>nEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>iEof2</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a1</name><index>[<expr><name>iEof1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a2</name><index>[<expr><name>iEof2</name></expr>]</index></name></expr></argument>, <argument><expr><name>n2</name> <operator>-</operator> <name>iEof2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
      assert( n1==n2 || n1+4==n2 || n2+4==n1 );
      if( n1&gt;=n2 ){
        <comment type="block">/* If n1 (size of the new page) is equal to or greater than n2 (the
        ** size of the old page), then copy the data into the new page. If
        ** n1==n2, this could be done with a single memcpy(). However, 
        ** since sometimes n1&gt;n2, the page content and footer must be copied 
        ** separately. */</comment>
        int nEntry = pageGetNRec(a2, n2);
        int iEof1 = SEGMENT_EOF(n1, nEntry);
        int iEof2 = SEGMENT_EOF(n2, nEntry);
        memcpy(a1, a2, iEof2);
        memcpy(&amp;a1[iEof1], &amp;a2[iEof2], n2 - iEof2);
        lsmFsPageRelease(apHier[i]);
        apHier[i] = pNew;
      }else{
        lsmPutU16(&amp;a1[SEGMENT_FLAGS_OFFSET(n1)], SEGMENT_BTREE_FLAG);
        lsmPutU16(&amp;a1[SEGMENT_NRECORD_OFFSET(n1)], 0);
        lsmPutU64(&amp;a1[SEGMENT_POINTER_OFFSET(n1)], 0);
        i = i - 1;
        lsmFsPageRelease(pNew);
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nHier</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmFsPageWritable</name><argument_list>(<argument><expr><name><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and populate the MergeWorker.apHier[] array.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerLoadHierarchy</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hierarchy</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
 
  <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMW</name><operator>-&gt;</operator><name>hier</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apHier</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>apHier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nHier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPg</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SEGMENT_BTREE_FLAG</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name> <init>= <expr><operator>(</operator><name>Page</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lsmRealloc</name><argument_list>(
            <argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>apHier</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nHier</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>apNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_NOMEM_BKPT</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>apHier</name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>apHier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apHier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nHier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nHier</name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>apHier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iPg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>while<condition>( <expr><literal type="number">1</literal></expr> )</condition>;</do>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>apHier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iPgno</name> <operator>=</operator> <call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nHier</name></name> <operator>=</operator> <name>nHier</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apHier</name></name> <operator>=</operator> <name>apHier</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerMoveHierarchy</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nHier</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>apHier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** B-tree pages use almost the same format as regular pages. The 
** differences are:
**
**   1. The record format is (usually, see below) as follows:
**
**         + Type byte (always SORTED_SEPARATOR or SORTED_SYSTEM_SEPARATOR),
**         + Absolute pointer value (varint),
**         + Number of bytes in key (varint),
**         + LsmBlob containing key data.
**
**   2. All pointer values are stored as absolute values (not offsets 
**      relative to the footer pointer value).
**
**   3. Each pointer that is part of a record points to a page that 
**      contains keys smaller than the records key (note: not "equal to or
**      smaller than - smaller than").
**
**   4. The pointer in the page footer of a b-tree page points to a page
**      that contains keys equal to or larger than the largest key on the
**      b-tree page.
**
** The reason for having the page footer pointer point to the right-child
** (instead of the left) is that doing things this way makes the 
** mergeWorkerMoveHierarchy() operation less complicated (since the pointers 
** that need to be updated are all stored as fixed-size integers within the 
** page footer, not varints in page records).
**
** Records may not span b-tree pages. If this function is called to add a
** record larger than (page-size / 4) bytes, then a pointer to the indexed
** array page that contains the main record is added to the b-tree instead.
** In this case the record format is:
**
**         + 0x00 byte (1 byte) 
**         + Absolute pointer value (varint),
**         + Absolute page number of page containing key (varint).
**
** See function seekInBtree() for the code that traverses b-tree pages.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerBtreeWrite</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>,
  <parameter><decl><type><name>u8</name></type> <name>eType</name></decl></parameter>,
  <parameter><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl></parameter>,
  <parameter><decl><type><name>LsmPgno</name></type> <name>iKeyPg</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Hierarchy</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pMW</name><operator>-&gt;</operator><name>hier</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLevel</name></decl>;</decl_stmt>                     <comment type="block">/* Level of b-tree hierachy to write to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                      <comment type="block">/* Size of aData[] in bytes */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                      <comment type="block">/* Page data for level iLevel */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>                       <comment type="block">/* Offset on b-tree page to write record to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>                       <comment type="block">/* Initial number of records on b-tree page */</comment>

  <comment type="block">/* iKeyPg should be zero for an ordinary b-tree key, or non-zero for an
  ** indirect key. The flags byte for an indirect key is 0x00.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>eType</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>iKeyPg</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The MergeWorker.apHier[] array contains the right-most leaf of the b-tree
  ** hierarchy, the root node, and all nodes that lie on the path between.
  ** apHier[0] is the right-most leaf and apHier[pMW-&gt;nHier-1] is the current
  ** root page.
  **
  ** This loop searches for a node with enough space to store the key on,
  ** starting with the leaf and iterating up towards the root. When the loop
  ** exits, the key may be written to apHier[iLevel].  */</comment>
  <for>for<control>(<init><expr><name>iLevel</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLevel</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nHier</name></name></expr>;</condition> <incr><expr><name>iLevel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                    <comment type="block">/* Number of free bytes required */</comment>

    <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nHier</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Extend the array and allocate a new root page. */</comment>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><name>Page</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lsmRealloc</name><argument_list>(
          <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apHier</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nHier</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apHier</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nFree</name></decl>;</decl_stmt>

      <comment type="block">/* If the key will fit on this page, break out of the loop here.
      ** The new entry will be written to page apHier[iLevel]. */</comment>
      <expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apHier</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmFsPageWritable</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>lsmVarintLen32</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iPtr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>lsmVarintLen32</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iKeyPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>lsmVarintLen32</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iPtr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>lsmVarintLen32</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nKey</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nFree</name> <operator>=</operator> <call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>mergeWorkerPageOffset</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><name>nFree</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* Otherwise, this page is full. Set the right-hand-child pointer
      ** to iPtr and release it.  */</comment>
      <expr_stmt><expr><call><name>lsmPutU64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_POINTER_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsPagePersist</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Allocate a new page for apHier[iLevel]. */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apHier</name><index>[<expr><name>iLevel</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSortedAppend</name><argument_list>(
          <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>apHier</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apHier</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_FLAGS_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>SEGMENT_BTREE_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_NRECORD_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nHier</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nHier</name></name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Write the key into page apHier[iLevel]. */</comment>
  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apHier</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iOff</name> <operator>=</operator> <call><name>mergeWorkerPageOffset</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_CELLPTR_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_NRECORD_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>nRec</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><name>iOff</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintPut32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintPut32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iKeyPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><name>iOff</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintPut32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintPut32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerBtreeIndirect</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMW</name><operator>-&gt;</operator><name>iIndirect</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iKeyPg</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iPgno</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerBtreeWrite</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>iIndirect</name></name></expr></argument>, <argument><expr><name>iKeyPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>iIndirect</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append the database key (iTopic/pKey/nKey) to the b-tree under 
** construction. This key has not yet been written to a segment page.
** The pointer that will accompany the new key in the b-tree - that
** points to the completed segment page that contains keys smaller than
** (pKey/nKey) is currently stored in pMW-&gt;aSave[0].iPgno.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerPushHierarchy</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>,               <comment type="block">/* Merge worker object */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTopic</name></decl></parameter>,                     <comment type="block">/* Topic value for this key */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,                     <comment type="block">/* Pointer to key buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>                        <comment type="block">/* Size of pKey buffer in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl>;</decl_stmt>                   <comment type="block">/* Pointer value to accompany pKey/nKey */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bStore</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bStore</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerBtreeIndirect</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Obtain the absolute pointer value to store along with the key in the
  ** page body. This pointer points to a page that contains keys that are
  ** smaller than pKey/nKey.  */</comment>
  <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iPgno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPtr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Determine if the indirect format should be used. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nKey</name><operator>*</operator><literal type="number">4</literal> <operator>&gt;</operator> <call><name>lsmFsPageSize</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>iIndirect</name></name> <operator>=</operator> <name>iPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bStore</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerBtreeWrite</name><argument_list>(
        <argument><expr><name>pMW</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>iTopic</name> <operator>|</operator> <name>LSM_SEPARATOR</name><operator>)</operator></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Ensure that the SortedRun.iRoot field is correct. */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerFinishHierarchy</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>                <comment type="block">/* Merge worker object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to loop through apHier[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl>;</decl_stmt>                   <comment type="block">/* New right-hand-child pointer value */</comment>

  <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iPgno</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>nHier</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                    <comment type="block">/* Size of aData[] in bytes */</comment>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Page data for pPg */</comment>

    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmPutU64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_POINTER_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsPagePersist</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>nHier</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iRoot</name></name> <operator>=</operator> <name>iPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>nHier</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerAddPadding</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>                <comment type="block">/* Merge worker object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lsmFsSortedPadding</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release all page references currently held by the merge-worker passed
** as the only argument. Unless an error has occurred, all pages have
** already been released.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mergeWorkerReleaseAll</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>nHier</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>apHier</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>nHier</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>keyszToSkip</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nPgsz</name></decl>;</decl_stmt>                <comment type="block">/* Nominal database page size */</comment>
  <expr_stmt><expr><name>nPgsz</name> <operator>=</operator> <call><name>lsmFsPageSize</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>LSM_MIN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>nKey</name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator> <operator>/</operator> <name>nPgsz</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release the reference to the current output page of merge-worker *pMW
** (reference pMW-&gt;pPage). Set the page number values in aSave[] as 
** required (see comments above struct MergeWorker for details).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerPersistAndRelease</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name> <operator>||</operator> <operator>(</operator><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bStore</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bStore</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Persist the page */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsPagePersist</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If required, save the page number. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bStore</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPgno</name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bStore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Release the completed output page. */</comment>
  <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance to the next page of an output run being populated by merge-worker
** pMW. The footer of the new page is initialized to indicate that it contains
** zero records. The flags field is cleared. The page footer pointer field
** is set to iFPtr.
**
** If successful, LSM_OK is returned. Otherwise, an error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerNextPage</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>,               <comment type="block">/* Merge worker object to append page to */</comment>
  <parameter><decl><type><name>LsmPgno</name></type> <name>iFPtr</name></decl></parameter>                   <comment type="block">/* Pointer value for footer of new page */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* New page appended to run */</comment>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Database handle */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSortedAppend</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name> <operator>||</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>xCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Data buffer belonging to page pNext */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                    <comment type="block">/* Size of aData[] in bytes */</comment>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerPersistAndRelease</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name><operator>-&gt;</operator><name>iOutputOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_NRECORD_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_FLAGS_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmPutU64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_POINTER_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>iFPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>nWork</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write a blob of data into an output segment being populated by a 
** merge-worker object. If argument bSep is true, write into the separators
** array. Otherwise, the main array.
**
** This function is used to write the blobs of data for keys and values.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerData</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>,               <comment type="block">/* Merge worker object */</comment>
  <parameter><decl><type><name>int</name></type> <name>bSep</name></decl></parameter>,                       <comment type="block">/* True to write to separators run */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFPtr</name></decl></parameter>,                      <comment type="block">/* Footer ptr for new pages */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aWrite</name></decl></parameter>,                     <comment type="block">/* Write data from this buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nWrite</name></decl></parameter>                      <comment type="block">/* Size of aWrite[] in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>nWrite</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Number of bytes still to write */</comment>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Merge</name> <modifier>*</modifier></type><name>pMerge</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes to copy */</comment>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to buffer of current output page */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                    <comment type="block">/* Size of aData[] in bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>                     <comment type="block">/* Number of records on current output page */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>                     <comment type="block">/* Offset in aData[] to write to */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmFsPageWritable</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
   
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>iOutputOff</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <call><name>LSM_MIN</name><argument_list>(<argument><expr><name>nRem</name></expr></argument>, <argument><expr><call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aWrite</name><index>[<expr><name>nWrite</name><operator>-</operator><name>nRem</name></expr>]</index></name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerNextPage</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><name>iFPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>iOutputOff</name></name> <operator>=</operator> <name>iOff</name> <operator>+</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The MergeWorker passed as the only argument is working to merge two or
** more existing segments together (not to flush an in-memory tree). It
** has not yet written the first key to the first page of the output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerFirstPage</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* First page of run pSeg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Pointer value read from footer of pPg */</comment>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iFPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSeg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Buffer for page pPg */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                    <comment type="block">/* Size of aData[] in bytes */</comment>
      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iFPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerNextPage</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><name>iFPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name> <operator>=</operator> <name>iFPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bStore</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerWrite</name><parameter_list>(
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>,               <comment type="block">/* Merge worker object to write into */</comment>
  <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>,                      <comment type="block">/* One of SORTED_SEPARATOR, WRITE or DELETE */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key value */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,           <comment type="block">/* Value value */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPtr</name></decl></parameter>                        <comment type="block">/* Absolute value of page pointer, or 0 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Merge</name> <modifier>*</modifier></type><name>pMerge</name></decl>;</decl_stmt>                  <comment type="block">/* Persistent part of level merge state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHdr</name></decl>;</decl_stmt>                       <comment type="block">/* Space required for this record header */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>                      <comment type="block">/* Page to write to */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                      <comment type="block">/* Data buffer for page pWriter-&gt;pPage */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of buffer aData[] in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of records on page pPg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Value of pointer in footer of pPg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Value of pointer written into record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Current write offset within page pPg */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>                  <comment type="block">/* Segment being written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* If != 0, flags value for page footer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFirst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* True for first key of output run */</comment>

  <expr_stmt><expr><name>pMerge</name> <operator>=</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr>;</expr_stmt>    
  <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerFirstPage</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bFirst</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iFPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iRPtr</name> <operator>=</operator> <name>iPtr</name> <operator>-</operator> <name>iFPtr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
     
  <comment type="block">/* Figure out how much space is required by the new record. The space
  ** required is divided into two sections: the header and the body. The
  ** header consists of the intial varint fields. The body are the blobs 
  ** of data that correspond to the key and value data. The entire header 
  ** must be stored on the page. The body may overflow onto the next and
  ** subsequent pages.
  **
  ** The header space is:
  **
  **     1) record type - 1 byte.
  **     2) Page-pointer-offset - 1 varint
  **     3) Key size - 1 varint
  **     4) Value size - 1 varint (only if LSM_INSERT flag is set)
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nHdr</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>lsmVarintLen32</name><argument_list>(<argument><expr><name>iRPtr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>lsmVarintLen32</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>rtIsWrite</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nHdr</name> <operator>+=</operator> <call><name>lsmVarintLen32</name><argument_list>(<argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If the entire header will not fit on page pPg, or if page pPg is 
    ** marked read-only, advance to the next page of the output run. */</comment>
    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>iOutputOff</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>iOff</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>pPg</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iOff</name><operator>+</operator><name>nHdr</name></expr></argument> &gt;</argument_list></name> <call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nRec</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iOff</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pPg</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Zero any free space on the page */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call><operator>-</operator><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iFPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRPtr</name> <operator>=</operator> <name>iPtr</name> <operator>-</operator> <name>iFPtr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerNextPage</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><name>iFPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this record header will be the first on the page, and the page is 
  ** not the very first in the entire run, add a copy of the key to the
  ** b-tree hierarchy.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nRec</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bFirst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMerge</name><operator>-&gt;</operator><name>nSkip</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pMerge</name><operator>-&gt;</operator><name>nSkip</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerPushHierarchy</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bStore</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bStore</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <call><name>keyszToSkip</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>nSkip</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>PGFTR_SKIP_THIS_FLAG</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pMerge</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PGFTR_SKIP_NEXT_FLAG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the output segment */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update the page footer. */</comment>
    <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_NRECORD_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>nRec</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_CELLPTR_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><call><name>SEGMENT_FLAGS_OFFSET</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Write the entry header into the current page. */</comment>
    <expr_stmt><expr><name><name>aData</name><index>[<expr><name>iOff</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eType</name></expr>;</expr_stmt>                                           <comment type="block">/* 1 */</comment>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintPut32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>iRPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                         <comment type="block">/* 2 */</comment>
    <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintPut32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                          <comment type="block">/* 3 */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>rtIsWrite</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>lsmVarintPut32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* 4 */</comment>
    <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>iOutputOff</name></name> <operator>=</operator> <name>iOff</name></expr>;</expr_stmt>

    <comment type="block">/* Write the key and data into the segment. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFPtr</name><operator>==</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerData</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iFPtr</name><operator>+</operator><name>iRPtr</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>rtIsWrite</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerData</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iFPtr</name><operator>+</operator><name>iRPtr</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Free all resources allocated by mergeWorkerInit().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mergeWorkerShutdown</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Unless the merge has finished, save the cursor position in the
  ** Merge.aInput[] array. See function mergeWorkerInit() for the 
  ** code to restore a cursor position based on aInput[].  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>pCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Merge</name> <modifier>*</modifier></type><name>pMerge</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>lsmMCursorValid</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bBtree</name> <init>= <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name></decl>;</decl_stmt>

      <comment type="block">/* pMerge-&gt;nInput==0 indicates that this is a FlushTree() operation. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name><operator>==</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>+</operator><name>bBtree</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name><operator>-</operator><name>bBtree</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPg</name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iCell</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCell</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>bBtree</name> <operator>&amp;&amp;</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>btreeCursorPosition</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Store the location of the split-key */</comment>
      <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>CURSOR_DATA_SEGMENT</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPtr</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>splitkey</name></name> <operator>=</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>iPtr</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>btreeCursorSplitkey</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMerge</name><operator>-&gt;</operator><name>splitkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Zero any free space left on the final page. This helps with
    ** compression if using a compression hook. And prevents valgrind
    ** from complaining about uninitialized byte passed to write(). */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><call><name>fsPageData</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><name><name>pMerge</name><operator>-&gt;</operator><name>iOutputOff</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iEof</name> <init>= <expr><call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iEof</name> <operator>-</operator> <name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>iOutputOff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Persist and release the output page. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerPersistAndRelease</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerBtreeIndirect</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerFinishHierarchy</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerAddPadding</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lsmFsFlushWaiting</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>mergeWorkerReleaseAll</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>aGobble</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aGobble</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The cursor passed as the first argument is being used as the input for
** a merge operation. When this function is called, *piFlags contains the
** database entry flags for the current entry. The entry about to be written
** to the output.
**
** Note that this function only has to work for cursors configured to 
** iterate forwards (not backwards).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mergeRangeDeletes</name><parameter_list>(<parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piFlags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><operator>*</operator><name>piFlags</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iKey</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_NEXT_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CURSOR_IGNORE_DELETE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The ignore-delete flag is set when the output of the merge will form
    ** the oldest level in the database. In this case there is no point in
    ** retaining any range-delete flags.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>LSM_POINT_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>f</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>LSM_START_DELETE</name><operator>|</operator><name>LSM_END_DELETE</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>CURSOR_DATA_SEGMENT</name> <operator>+</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>iKey</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>multiCursorGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>pKey</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sortedKeyCompare</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, 
              <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr></argument>,
              <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>&lt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_INSERT</name><operator>|</operator><name>LSM_POINT_DELETE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>eType</name> <operator>&amp;</operator> <name>LSM_INSERT</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>f</name> <operator>|=</operator> <name>LSM_INSERT</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
              </block_content>}</block></if>
              <if type="elseif">else if<condition>( <expr><name>eType</name> <operator>&amp;</operator> <name>LSM_POINT_DELETE</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>f</name> <operator>|=</operator> <name>LSM_POINT_DELETE</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>f</name> <operator>|=</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_END_DELETE</name><operator>|</operator><name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>iKey</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>eType</name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_INSERT</name><operator>|</operator><name>LSM_POINT_DELETE</name><operator>)</operator></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>f</name> <operator>|=</operator> <operator>(</operator><name>LSM_END_DELETE</name><operator>|</operator><name>LSM_START_DELETE</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>LSM_INSERT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>f</name> <operator>&amp;</operator> <name>LSM_POINT_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>f</name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>f</name> <operator>&amp;</operator> <name>LSM_POINT_DELETE</name> <operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piFlags</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerStep</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>            <comment type="block">/* Cursor to read input data from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                    <comment type="block">/* SORTED_SEPARATOR, WRITE or DELETE */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>         <comment type="block">/* Key */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</expr_stmt>

  <comment type="block">/* Pull the next record out of the source cursor. */</comment>
  <expr_stmt><expr><call><name>lsmMCursorKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eType</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>

  <comment type="block">/* Figure out if the output record may have a different pointer value
  ** than the previous. This is the case if the current key is identical to
  ** a key that appears in the lowest level run being merged. If so, set 
  ** iPtr to the absolute pointer value. If not, leave iPtr set to zero, 
  ** indicating that the output pointer value should be a copy of the pointer 
  ** value written with the previous key.  */</comment>
  <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name></expr> ?</condition><then> <expr><operator>*</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pBtCsr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBtCsr</name><operator>-&gt;</operator><name>pKey</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pBtCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>pBtCsr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pBtCsr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>res</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name><name>pBtCsr</name><operator>-&gt;</operator><name>iPtr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPtr</name><operator>-&gt;</operator><name>pPg</name></name>
     <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pPtr</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>iPtr</name></name><operator>+</operator><name><name>pPtr</name><operator>-&gt;</operator><name>iPgPtr</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>mergeRangeDeletes</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMW</name><operator>-&gt;</operator><name>aGobble</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iGobble</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>CURSOR_DATA_SEGMENT</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iGobble</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name> <operator>&amp;&amp;</operator> <name>iGobble</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pGobble</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iGobble</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pGobble</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGFTR_SKIP_THIS_FLAG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aGobble</name><index>[<expr><name>iGobble</name></expr>]</index></name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name><name>pGobble</name><operator>-&gt;</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is a separator key and we know that the output pointer has not
    ** changed, there is no point in writing an output record. Otherwise,
    ** proceed. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>rtIsSeparator</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iPtr</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* Write the record into the main run. */</comment>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorGetVal</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pVal</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBlobSet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pVal</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerWrite</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Advance the cursor to the next input record (assuming one exists). */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmMCursorValid</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorNext</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerDone</name><parameter_list>(<parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>lsmMCursorValid</name><argument_list>(<argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sortedFreeLevel</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSplitKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pMerge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sortedInvokeWorkHook</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorkCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedNewToplevel</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Connection handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>eTree</name></decl></parameter>,                      <comment type="block">/* One of the TREE_XXX constants */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>                    <comment type="block">/* OUT: Number of database pages written */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* The current top level */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>                    <comment type="block">/* The new level itself */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pLinked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Delete separators from this segment */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Delete this entire level */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of database pages written */</comment>
  <decl_stmt><decl><type><name>Freelist</name></type> <name>freelist</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>eTree</name><operator>!=</operator><name>TREE_NONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmCacheChunks</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFreelist</name></name> <operator>=</operator> <operator>&amp;</operator><name>freelist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>freelist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>freelist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate the new level structure to write to. */</comment>
  <expr_stmt><expr><name>pNext</name> <operator>=</operator> <call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>Level</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Level</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmDbSnapshotSetLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create a cursor to gather the data required by the new segment. The new
  ** segment contains everything in the tree and pointers to the next segment
  ** in the database (if any).  */</comment>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>multiCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorVisitFreelist</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAddTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>eTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>pNext</name> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>pMerge</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNext</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LEVEL_FREELIST_ONLY</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDel</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>multiCursorAddOne</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eTree</name><operator>!=</operator><name>TREE_NONE</name> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iRoot</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pLinked</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNext</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pLinked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this will be the only segment in the database, discard any delete
    ** markers present in the in-memory tree.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>pNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>multiCursorIgnoreDelete</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLeftPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Merge</name></type> <name>merge</name></decl>;</decl_stmt>                  <comment type="block">/* Merge object used to create new level */</comment>
    <decl_stmt><decl><type><name>MergeWorker</name></type> <name>mergeworker</name></decl>;</decl_stmt>      <comment type="block">/* MergeWorker object for the same purpose */</comment>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Merge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MergeWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pMerge</name></name> <operator>=</operator> <operator>&amp;</operator><name>merge</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LEVEL_INCOMPLETE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mergeworker</name><operator>.</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mergeworker</name><operator>.</operator><name>pLevel</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mergeworker</name><operator>.</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name> <operator>=</operator> <operator>&amp;</operator><name>iLeftPtr</name></expr>;</expr_stmt>

    <comment type="block">/* Mark the separators array for the new level as a "phantom". */</comment>
    <expr_stmt><expr><name><name>mergeworker</name><operator>.</operator><name>bFlush</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Do the work to create the new merged segment on disk */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>mergeWorkerDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>mergeWorkerShutdown</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>mergeworker</name><operator>.</operator><name>nWork</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pNew</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSortedFinish</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <name><name>mergeworker</name><operator>.</operator><name>nWork</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LEVEL_INCOMPLETE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eTree</name><operator>==</operator><name>TREE_NONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LEVEL_FREELIST_ONLY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pMerge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>pNew</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmDbSnapshotSetLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sortedFreeLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pLinked</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLinked</name><operator>-&gt;</operator><name>iRoot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pDel</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><name>pDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pDel</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsSortedDelete</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sortedFreeLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LSM_LOG_STRUCTURE</name></expr></cpp:if>
    <expr_stmt><expr><call><name>lsmSortedDumpStructure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>LSM_LOG_DATA</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"new-toplevel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>( <expr><name><name>freelist</name><operator>.</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Freelist</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freelist</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>freelist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>freelist</name><operator>.</operator><name>aEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assertBtreeOk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sortedInvokeWorkHook</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pnWrite</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <name>nWrite</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>nWrite</name></name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFreelist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>freelist</name><operator>.</operator><name>aEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The nMerge levels in the LSM beginning with pLevel consist of a
** left-hand-side segment only. Replace these levels with a single new
** level consisting of a new empty segment on the left-hand-side and the
** nMerge segments from the replaced levels on the right-hand-side.
**
** Also, allocate and populate a Merge object and set Level.pMerge to
** point to it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedMergeSetup</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,                  <comment type="block">/* First level to merge */</comment>
  <parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>,                     <comment type="block">/* Merge this many levels together */</comment>
  <parameter><decl><type><name>Level</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNew</name></decl></parameter>                   <comment type="block">/* New, merged, level */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>                    <comment type="block">/* New Level object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bUseNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* True to link in next separators */</comment>
  <decl_stmt><decl><type><name>Merge</name> <modifier>*</modifier></type><name>pMerge</name></decl>;</decl_stmt>                  <comment type="block">/* New Merge object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Bytes of space allocated at pMerge */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>iLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><name>pLevel</name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>iLevel</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLevel</name><operator>&lt;</operator><name>nMerge</name></expr>;</condition> <incr><expr><name>iLevel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Allocate the new Level object */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>Level</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Level</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aRhs</name></name> <operator>=</operator> <operator>(</operator><name>Segment</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, 
                                        <argument><expr><name>nMerge</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Segment</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Populate the new Level object */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Level following pNew */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bFreeOnly</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pTopLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pLevel</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRight</name></name> <operator>=</operator> <name>nMerge</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iAge</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iAge</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMerge</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LEVEL_FREELIST_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bFreeOnly</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sortedFreeLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>bFreeOnly</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LEVEL_FREELIST_ONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Replace the old levels with the new. */</comment>
    <expr_stmt><expr><name>pTopLevel</name> <operator>=</operator> <call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name>pTopLevel</name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pLevel</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmDbSnapshotSetLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>pTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Determine whether or not the next separators will be linked in */</comment>
    <if_stmt><if>if<condition>( <expr><name>pNext</name> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>pMerge</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iRoot</name></name> <operator>&amp;&amp;</operator> <name>pNext</name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>bFreeOnly</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pNext</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LEVEL_FREELIST_ONLY</name><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>bUseNext</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate the merge object */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Merge</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MergeInput</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nMerge</name> <operator>+</operator> <name>bUseNext</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMerge</name> <operator>=</operator> <operator>(</operator><name>Merge</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pMerge</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name></name> <operator>=</operator> <operator>(</operator><name>MergeInput</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pMerge</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name> <operator>=</operator> <name>nMerge</name> <operator>+</operator> <name>bUseNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pMerge</name></name> <operator>=</operator> <name>pMerge</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppNew</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeWorkerInit</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Db connection to do merge work */</comment>
  <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,                  <comment type="block">/* Level to work on merging */</comment>
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>                <comment type="block">/* Object to initialize */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Merge</name> <modifier>*</modifier></type><name>pMerge</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Persistent part of merge state */</comment>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Cursor opened for pMW */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Next level in LSM */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MergeWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name></name> <operator>=</operator> <name>pLevel</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aGobble</name></name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmPgno</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a multi-cursor to read the data to write to the new
  ** segment. The new segment contains:
  **
  **   1. Records from LHS of each of the nMerge levels being merged.
  **   2. Separators from either the last level being merged, or the
  **      separators attached to the LHS of the following level, or neither.
  **
  ** If the new level is the lowest (oldest) in the db, discard any
  ** delete keys. Key annihilation.
  */</comment>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>multiCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_NEXT_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorAddRhs</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name> <operator>&gt;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNext</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pNext</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>multiCursorReadSeparators</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>multiCursorIgnoreDelete</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name><operator>==</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>+</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>

  <comment type="block">/* Load the b-tree hierarchy into memory. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerLoadHierarchy</name><argument_list>(<argument><expr><name>pMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pMW</name><operator>-&gt;</operator><name>hier</name><operator>.</operator><name>nHier</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aSave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iPgno</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Position the cursor. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPrevMergePtr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pMerge</name><operator>-&gt;</operator><name>iCurrentPtr</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The output array is still empty. So position the cursor at the very 
      ** start of the input.  */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The output array is non-empty. Position the cursor based on the
      ** page/cell data saved in the Merge.aInput[] array.  */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>MergeInput</name> <modifier>*</modifier></type><name>pInput</name> <init>= <expr><operator>&amp;</operator><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pInput</name><operator>-&gt;</operator><name>iPg</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pPtr</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pPg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadPage</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pInput</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr> )</condition><block>{<block_content>
        <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></init>;</function_decl>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorRestore</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pBtCsr</name></name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMerge</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorSetupTree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CURSOR_NEXT_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedBtreeGobble</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Worker connection */</comment>
  <parameter><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,              <comment type="block">/* Multi-cursor being used for a merge */</comment>
  <parameter><decl><type><name>int</name></type> <name>iGobble</name></decl></parameter>                     <comment type="block">/* pCsr-&gt;aPtr[] entry to operate on */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>iGobble</name></expr>]</index></name><operator>.</operator><name>pSeg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aPg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nPg</name></decl>;</decl_stmt>

    <comment type="block">/* Seek from the root of the b-tree to the segment leaf that may contain
    ** a key equal to the one multi-cursor currently points to. Record the
    ** page number of each b-tree page and the leaf. The segment may be
    ** gobbled up to (but not including) the first of these page numbers.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aPg</name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmPgno</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>seekInBtree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, 
          <argument><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>nPg</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aPg</name><index>[<expr><name>nPg</name></expr>]</index></name></expr>;</condition> <incr><expr><name>nPg</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><call><name>lsmFsGobble</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><name>nPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument p points to a level of age N. Return the number of levels in
** the linked list starting at p that have age=N (always at least 1).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedCountLevels</name><parameter_list>(<parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iAge</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iAge</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>nRet</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iAge</name></name><operator>==</operator><name>iAge</name></expr> )</condition>;</do>
  <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedSelectLevel</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pTopLevel</name> <init>= <expr><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Output value */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pBest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Best level to work on found so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBest</name></decl>;</decl_stmt>                    <comment type="block">/* Number of segments merged at pBest */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pThis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* First in run of levels with age=iAge */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nThis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of levels starting at pThis */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMerge</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nBest</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nMerge</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find the longest contiguous run of levels not currently undergoing a 
  ** merge with the same age in the structure. Or the level being merged
  ** with the largest number of right-hand segments. Work on it. */</comment>
  <for>for<control>(<init><expr><name>pLevel</name><operator>=</operator><name>pTopLevel</name></expr>;</init> <condition><expr><name>pLevel</name></expr>;</condition> <incr><expr><name>pLevel</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pThis</name> <operator>&amp;&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iAge</name></name><operator>==</operator><name><name>pThis</name><operator>-&gt;</operator><name>iAge</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nThis</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nThis</name><operator>&gt;</operator><name>nBest</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iAge</name></name><operator>!=</operator><name><name>pThis</name><operator>-&gt;</operator><name>iAge</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sortedCountLevels</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>pThis</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nBest</name> <operator>=</operator> <name>nThis</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>&gt;</operator><name>nBest</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nBest</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>pLevel</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nThis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pThis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pThis</name> <operator>=</operator> <name>pLevel</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nThis</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>nThis</name><operator>&gt;</operator><name>nBest</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pThis</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>pThis</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nBest</name> <operator>=</operator> <name>nThis</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pBest</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nMerge</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nUsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pLevel</name><operator>=</operator><name>pTopLevel</name></expr>;</init> <condition><expr><name>pLevel</name></expr>;</condition> <incr><expr><name>pLevel</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LEVEL_FREELIST_ONLY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nFree</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nUsr</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nUsr</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>pTopLevel</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBest</name> <operator>=</operator> <name>nFree</name> <operator>+</operator> <name>nUsr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pBest</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pBest</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedMergeSetup</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pBest</name></expr></argument>, <argument><expr><name>nBest</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pBest</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedDbIsFull</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pTop</name> <init>= <expr><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>lsmDatabaseFull</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTop</name> <operator>&amp;&amp;</operator> <name><name>pTop</name><operator>-&gt;</operator><name>iAge</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTop</name><operator>-&gt;</operator><name>nRight</name></name> <operator>||</operator> <call><name>sortedCountLevels</name><argument_list>(<argument><expr><name>pTop</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>MoveBlockCtx</name></name></type> <name>MoveBlockCtx</name>;</typedef>
<struct>struct <name>MoveBlockCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iSeen</name></decl>;</decl_stmt>                      <comment type="block">/* Previous free block on list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFrom</name></decl>;</decl_stmt>                      <comment type="block">/* Total number of blocks in file */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>moveBlockCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MoveBlockCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MoveBlockCtx</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iFrom</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBlk</name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iSeen</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iSeen</name></name> <operator>=</operator> <name>iBlk</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iFrom</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iSeen</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to further compact a database for which all 
** of the content has already been merged into a single segment. If 
** possible, it moves the contents of a single block from the end of the
** file to a free-block that lies closer to the start of the file (allowing
** the file to be eventually truncated).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedMoveBlock</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFrom</name></decl>;</decl_stmt>                      <comment type="block">/* Block to move */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTo</name></decl>;</decl_stmt>                        <comment type="block">/* Destination to move block to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <decl_stmt><decl><type><name>MoveBlockCtx</name></type> <name>sCtx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name><operator>&lt;=</operator><name>LSM_MAX_BLOCK_REDIRECTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Check that the redirect array is not already full. If it is, return
  ** without moving any database content.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name><operator>&gt;=</operator><name>LSM_MAX_BLOCK_REDIRECTS</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Find the last block of content in the database file. Do this by 
  ** traversing the free-list in reverse (descending block number) order.
  ** The first block not on the free list is the one that will be moved.
  ** Since the db consists of a single segment, there is no ambiguity as
  ** to which segment the block belongs to.  */</comment>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>iSeen</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nBlock</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>iFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmWalkFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>moveBlockCb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>sCtx</name><operator>.</operator><name>iFrom</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iFrom</name> <operator>=</operator> <name><name>sCtx</name><operator>.</operator><name>iFrom</name></name></expr>;</expr_stmt>

  <comment type="block">/* Find the first free block in the database, ignoring block 1. Block
  ** 1 is tricky as it is smaller than the other blocks.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBlockAllocate</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name>iTo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTo</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iTo</name><operator>&lt;</operator><name>iFrom</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsMoveBlock</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>RedirectEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>LSM_MAX_BLOCK_REDIRECTS</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name></name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>

      <comment type="block">/* Check if the block just moved was already redirected. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iTo</name><operator>==</operator><name>iFrom</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Block iFrom was not already redirected. Add a new array entry. */</comment>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, 
            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>RedirectEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iFrom</name> <operator>=</operator> <name>iFrom</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iTo</name> <operator>=</operator> <name>iTo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Block iFrom was already redirected. Overwrite existing entry. */</comment>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iTo</name> <operator>=</operator> <name>iTo</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBlockFree</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <call><name>lsmFsBlockSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>lsmFsPageSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>pRedirect</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>redirect</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LSM_LOG_STRUCTURE</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>aBuf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><literal type="string">"move-block %d/%d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>LSM_MAX_BLOCK_REDIRECTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmSortedDumpStructure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>LSM_LOG_DATA</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mergeInsertFreelistSegments</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nFree</name></decl></parameter>,
  <parameter><decl><type><name>MergeWorker</name> <modifier>*</modifier></type><name>pMW</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nFree</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pCsr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><name><name>pMW</name><operator>-&gt;</operator><name>pLevel</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>aNew1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>aNew2</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>aNew1</name> <operator>=</operator> <operator>(</operator><name>SegmentPtr</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(
        <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentPtr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name><operator>+</operator><name>nFree</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNew1</name><index>[<expr><name>nFree</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentPtr</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name> <operator>+=</operator> <name>nFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aTree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name></name> <operator>=</operator> <name>aNew1</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>aNew2</name> <operator>=</operator> <operator>(</operator><name>Segment</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(
        <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Segment</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>+</operator><name>nFree</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNew2</name><index>[<expr><name>nFree</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Segment</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name> <operator>+=</operator> <name>nFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name></name> <operator>=</operator> <name>aNew2</name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>pIter</name><operator>!=</operator><name>pLvl</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIter</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSeg</name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pLevel</name> <operator>=</operator> <name>pLvl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrEnd</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name></name> <operator>=</operator> <name>pNext</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sortedFreeLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>nFree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name></name><operator>==</operator><name>pLvl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nFree</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPtr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSeg</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pMW</name><operator>-&gt;</operator><name>aGobble</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMW</name><operator>-&gt;</operator><name>aGobble</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedWork</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle. Must be worker. */</comment>
  <parameter><decl><type><name>int</name></type> <name>nWork</name></decl></parameter>,                      <comment type="block">/* Number of pages of work to do */</comment>
  <parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>,                     <comment type="block">/* Try to merge this many levels at once */</comment>
  <parameter><decl><type><name>int</name></type> <name>bFlush</name></decl></parameter>,                     <comment type="block">/* Set if call is to make room for a flush */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>                    <comment type="block">/* OUT: Actual number of pages written */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRemaining</name> <init>= <expr><name>nWork</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Units of work to do before returning */</comment>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWorker</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <while>while<condition>( <expr><name>nRemaining</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Find a level to work on. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedSelectLevel</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>pLevel</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>pLevel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pTopLevel</name> <init>= <expr><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>bFlush</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nMerge</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pTopLevel</name> <operator>&amp;&amp;</operator> <name><name>pTopLevel</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedMoveBlock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nRemaining</name> <operator>-=</operator> <name>nDone</name></expr>;</expr_stmt>

      <comment type="block">/* Could not find any work to do. Finished. */</comment>
      <if_stmt><if>if<condition>( <expr><name>nDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bSave</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Freelist</name></type> <name>freelist</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MergeWorker</name></type> <name>mergeworker</name></decl>;</decl_stmt>    <comment type="block">/* State used to work on the level merge */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bIncrMerge</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFreelist</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bIncrMerge</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerInit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mergeworker</name><operator>.</operator><name>nWork</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> 
          <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>mergeWorkerDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call> 
          <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mergeworker</name><operator>.</operator><name>nWork</name></name><operator>&lt;</operator><name>nRemaining</name> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>mergeworker</name><operator>.</operator><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeWorkerStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the cursor now points at the first entry past the end of the
        ** user data (i.e. either to EOF or to the first free-list entry
        ** that will be added to the run), then check if it is possible to
        ** merge in any free-list entries that are either in-memory or in
        ** free-list-only blocks.  */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nMerge</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>mergeworker</name><operator>.</operator><name>pCsr</name><operator>-&gt;</operator><name>eType</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>mergeWorkerDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Number of free-list-only levels to merge */</comment>
          <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFreelist</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Now check if all levels containing data newer than this one
          ** are single-segment free-list only levels. If so, they will be
          ** merged in now.  */</comment>
          <for>for<control>(<init><expr><name>pLvl</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</init> 
              <condition><expr><name>pLvl</name><operator>!=</operator><name><name>mergeworker</name><operator>.</operator><name>pLevel</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLvl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LEVEL_FREELIST_ONLY</name><operator>)</operator></expr>;</condition> 
              <incr><expr><name>pLvl</name><operator>=</operator><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>
          )</control><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nFree</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>pLvl</name><operator>==</operator><name><name>mergeworker</name><operator>.</operator><name>pLevel</name></name></expr> )</condition><block>{<block_content>

            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mergeInsertFreelistSegments</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>nFree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorVisitFreelist</name><argument_list>(<argument><expr><name><name>mergeworker</name><operator>.</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiCursorSetupTree</name><argument_list>(<argument><expr><name><name>mergeworker</name><operator>.</operator><name>pCsr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFreelist</name></name> <operator>=</operator> <operator>&amp;</operator><name>freelist</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>nRemaining</name> <operator>-=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><name><name>mergeworker</name><operator>.</operator><name>nWork</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Check if the merge operation is completely finished. If not,
        ** gobble up (declare eligible for recycling) any pages from rhs
        ** segments for which the content has been completely merged into 
        ** the lhs of the level.  */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>mergeWorkerDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>SegmentPtr</name> <modifier>*</modifier></type><name>pGobble</name> <init>= <expr><operator>&amp;</operator><name><name>mergeworker</name><operator>.</operator><name>pCsr</name><operator>-&gt;</operator><name>aPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pGobble</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedBtreeGobble</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>mergeworker</name><operator>.</operator><name>pCsr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>mergeworker</name><operator>.</operator><name>aGobble</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>lsmFsGobble</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pGobble</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mergeworker</name><operator>.</operator><name>aGobble</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>bEmpty</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>mergeWorkerShutdown</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>bEmpty</name> <operator>=</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iFirst</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

          <if_stmt><if>if<condition>( <expr><name>bEmpty</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSortedFinish</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>Freelist</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freelist</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>freelist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseFreelist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFreelist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>bSave</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>lsmFsSortedDelete</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>

          <if_stmt><if>if<condition>( <expr><name>bEmpty</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* If the new level is completely empty, remove it from the 
            ** database snapshot. This can only happen if all input keys were
            ** annihilated. Since keys are only annihilated if the new level
            ** is the last in the linked list (contains the most ancient of
            ** database content), this guarantees that pLevel-&gt;pNext==0.  */</comment> 
            <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pTop</name></decl>;</decl_stmt>          <comment type="block">/* Top level of worker snapshot */</comment>
            <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>           <comment type="block">/* Read/write iterator for Level.pNext list */</comment>

            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Remove the level from the worker snapshot. */</comment>
            <expr_stmt><expr><name>pTop</name> <operator>=</operator> <call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name>pTop</name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pLevel</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
            <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>lsmDbSnapshotSetLevel</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>pTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Free the Level structure. */</comment>
            <expr_stmt><expr><call><name>sortedFreeLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>

            <comment type="block">/* Free the separators of the next level, if required. */</comment>
            <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name><operator>-&gt;</operator><name>nInput</name></name> <operator>&gt;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iRoot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>iRoot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Zero the right-hand-side of pLevel */</comment>
            <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <comment type="block">/* Free the Merge object */</comment>
            <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pMerge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

          <if_stmt><if>if<condition>( <expr><name>bSave</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bIncrMerge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmSaveWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Clean up the MergeWorker object initialized above. If no error
      ** has occurred, invoke the work-hook to inform the application that
      ** the database structure has changed. */</comment>
      <expr_stmt><expr><call><name>mergeWorkerShutdown</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergeworker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bIncrMerge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sortedInvokeWorkHook</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LSM_LOG_STRUCTURE</name></expr></cpp:if>
      <expr_stmt><expr><call><name>lsmSortedDumpStructure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>LSM_LOG_DATA</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"work"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>assertBtreeOk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertRunInOrder</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If bFlush is true and the database is no longer considered "full",
      ** break out of the loop even if nRemaining is still greater than
      ** zero. The caller has an in-memory tree to flush to disk.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>bFlush</name> <operator>&amp;&amp;</operator> <call><name>sortedDbIsFull</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>pnWrite</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <operator>(</operator><name>nWork</name> <operator>-</operator> <name>nRemaining</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pWorker</name><operator>-&gt;</operator><name>nWrite</name></name> <operator>+=</operator> <operator>(</operator><name>nWork</name> <operator>-</operator> <name>nRemaining</name><operator>)</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_WORK</name></cpp:ifdef>
  <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"sortedWork(): %d pages"</literal></expr></argument>, <argument><expr><operator>(</operator><name>nWork</name><operator>-</operator><name>nRemaining</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The database connection passed as the first argument must be a worker
** connection. This function checks if there exists an "old" in-memory tree
** ready to be flushed to disk. If so, true is returned. Otherwise false.
**
** If an error occurs, *pRc is set to an LSM error code before returning.
** It is assumed that *pRc is set to LSM_OK when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedTreeHasOld</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> 
        <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldShmid</name></name>
        <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldLog</name></name><operator>!=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>iLogOff</name></name></expr> 
      )</condition><block>{<block_content>
      <expr_stmt><expr><name>bRet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>bRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>bRet</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>bRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new free-list only top-level segment. Return LSM_OK if successful
** or an LSM error code if some error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sortedNewFreelistOnly</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sortedNewToplevel</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>TREE_NONE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmSaveWorker</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bFlush</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name><operator>&gt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nMaxFreelist</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sortedNewFreelistOnly</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>lsmCheckpointSaveWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bFlush</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>doLsmSingleWork</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bShutdown</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>,                     <comment type="block">/* Minimum segments to merge together */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPage</name></decl></parameter>,                      <comment type="block">/* Number of pages to write to disk */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>,                   <comment type="block">/* OUT: Pages actually written to disk */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbCkpt</name></decl></parameter>                     <comment type="block">/* OUT: True if an auto-checkpoint is req. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>              <comment type="block">/* Worker snapshot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDirty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMax</name> <init>= <expr><name>nPage</name></expr></init></decl>;</decl_stmt>               <comment type="block">/* Maximum pages to write to disk */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>nPage</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bCkpt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPage</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open the worker 'transaction'. It will be closed before this function
  ** returns.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pWorker</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>

  <comment type="block">/* If this connection is doing auto-checkpoints, set nMax (and nRem) so
  ** that this call stops writing when the auto-checkpoint is due. The
  ** caller will do the checkpoint, then possibly call this function again. */</comment>
  <if_stmt><if>if<condition>( <expr><name>bShutdown</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nAutockpt</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>nSync</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>nUnsync</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nPgsz</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>lsmCheckpointSynced</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nUnsync</name> <operator>=</operator> <call><name>lsmCheckpointNWrite</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name><operator>-&gt;</operator><name>aSnap1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPgsz</name> <operator>=</operator> <call><name>lsmCheckpointPgsz</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name><operator>-&gt;</operator><name>aSnap1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nMax</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>LSM_MIN</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>nAutockpt</name></name><operator>/</operator><name>nPgsz</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>nUnsync</name><operator>-</operator><name>nSync</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nMax</name><operator>&lt;</operator><name>nRem</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bCkpt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there exists in-memory data ready to be flushed to disk, attempt
  ** to flush it now.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeLoadHeader</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sortedTreeHasOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* sortedDbIsFull() returns non-zero if either (a) there are too many
    ** levels in total in the db, or (b) there are too many levels with the
    ** the same age in the db. Either way, call sortedWork() to merge 
    ** existing segments together until this condition is cleared.  */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sortedDbIsFull</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>nRem</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nPg</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name>nRem</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>sortedDbIsFull</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bDirty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedNewToplevel</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>TREE_OLD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nPg</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>lsmTreeDiscardOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmSaveWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bDirty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If nPage is still greater than zero, do some merging. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bShutdown</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>nRem</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nPg</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nPg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bDirty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the in-memory part of the free-list is too large, write a new 
  ** top-level containing just the in-memory free-list entries to disk. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>nEntry</name></name> <operator>&gt;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nMaxFreelist</name></name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsmDatabaseFull</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nPg</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedNewFreelistOnly</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>bDirty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <operator>(</operator><name>nMax</name> <operator>-</operator> <name>nRem</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbCkpt</name> <operator>=</operator> <operator>(</operator><name>bCkpt</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>&lt;=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nMerge</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nAutockpt</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pnWrite</name><operator>&gt;</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name></name> 
     <operator>&amp;&amp;</operator> <name><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pbCkpt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bDirty</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFinishWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rcdummy</name> <init>= <expr><name>LSM_BUSY</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsmFinishWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rcdummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>doLsmWork</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPage</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of pages written */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMerge</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bCkpt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nThis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nReq</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nPage</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>nPage</name><operator>-</operator><name>nWrite</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0x7FFFFFFF</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>bCkpt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>doLsmSingleWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><name>nReq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nThis</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bCkpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nWrite</name> <operator>+=</operator> <name>nThis</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bCkpt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_checkpoint</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bCkpt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nWrite</name><operator>&lt;</operator><name>nPage</name> <operator>||</operator> <name>nPage</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pnWrite</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <name>nWrite</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Perform work to merge database segments together.
*/</comment>
<function><type><name>int</name></type> <name>lsm_work</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKB</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPgsz</name></decl>;</decl_stmt>                      <comment type="block">/* Nominal page size in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>                      <comment type="block">/* Equivalent of nKB in pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of pages written */</comment>

  <comment type="block">/* This function may not be called if pDb has an open read or write
  ** transaction. Return LSM_MISUSE if an application attempts this.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMerge</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMerge</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmFsPurgeCache</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Convert from KB to pages */</comment>
  <expr_stmt><expr><name>nPgsz</name> <operator>=</operator> <call><name>lsmFsPageSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nKB</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nKB</name> <operator>*</operator> <literal type="number">1024</literal> <operator>+</operator> <name>nPgsz</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>nPgsz</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>doLsmWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><name>nPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>pnWrite</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Convert back from pages to KB */</comment>
    <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nWrite</name> <operator>*</operator> <literal type="number">1024</literal> <operator>+</operator> <name>nPgsz</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>nPgsz</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_flush</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>pCsr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_MISUSE_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginWriteTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmFlushTreeToDisk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmTreeDiscardOld</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmTreeMakeOld</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmTreeDiscardOld</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFinishWriteTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>lsmFinishWriteTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>lsmFinishReadTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called in auto-work mode to perform merging work on
** the data structure. It performs enough merging work to prevent the
** height of the tree from growing indefinitely assuming that roughly
** nUnit database pages worth of data have been written to the database
** (i.e. the in-memory tree) since the last call.
*/</comment>
<function><type><name>int</name></type> <name>lsmSortedAutoWork</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nUnit</name></decl></parameter>                       <comment type="block">/* Pages of data written to in-memory tree */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Current height of tree (longest path) */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>                  <comment type="block">/* Used to iterate through levels */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRestore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Determine how many units of work to do before returning. One unit of
  ** work is achieved by writing one page (~4KB) of merged data.  */</comment>
  <for>for<control>(<init><expr><name>pLevel</name><operator>=</operator><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pLevel</name></expr>;</condition> <incr><expr><name>pLevel</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* nDepth += LSM_MAX(1, pLevel-&gt;nRight); */</comment>
    <expr_stmt><expr><name>nDepth</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>lsmTreeHasOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nDepth</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>bRestore</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmSaveCursors</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nDepth</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nRemaining</name></decl>;</decl_stmt>               <comment type="block">/* Units of work to do before returning */</comment>

    <expr_stmt><expr><name>nRemaining</name> <operator>=</operator> <name>nUnit</name> <operator>*</operator> <name>nDepth</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_WORK</name></cpp:ifdef>
    <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"lsmSortedAutoWork(): %d*%d = %d pages"</literal></expr></argument>, 
        <argument><expr><name>nUnit</name></expr></argument>, <argument><expr><name>nDepth</name></expr></argument>, <argument><expr><name>nRemaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRemaining</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>doLsmWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name></expr></argument>, <argument><expr><name>nRemaining</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bRestore</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmMCursorFreeCache</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFreeSnapshot</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointLoad</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointDeserialize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmRestoreCursors</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only called during system shutdown. The contents of
** any in-memory trees present (old or current) are written out to disk.
*/</comment>
<function><type><name>int</name></type> <name>lsmFlushTreeToDisk</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>sortedDbIsFull</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sortedNewToplevel</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>TREE_BOTH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmFinishWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a string representation of the segment passed as the only argument.
** Space for the returned string is allocated using lsmMalloc(), and should
** be freed by the caller using lsmFree().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>segToString</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nSize</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>nSize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRoot</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iFirst</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLast</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPad</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>z1</name> <operator>=</operator> <call><name>lsmMallocPrintf</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><literal type="string">"%d.%d"</literal></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iRoot</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z2</name> <operator>=</operator> <call><name>lsmMallocPrintf</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><literal type="string">"root=%d"</literal></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>z2</name> <operator>=</operator> <call><name>lsmMallocPrintf</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><literal type="string">"size=%d"</literal></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>nPad</name> <operator>=</operator> <name>nMin</name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z1</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPad</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nPad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iRoot</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>lsmMallocPrintf</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><literal type="string">"/%s %*s%s\\"</literal></expr></argument>, <argument><expr><name>z1</name></expr></argument>, <argument><expr><name>nPad</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>lsmMallocPrintf</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><literal type="string">"|%s %*s%s|"</literal></expr></argument>, <argument><expr><name>z1</name></expr></argument>, <argument><expr><name>nPad</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>z1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fileToString</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* For xMalloc() */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nMin</name></decl></parameter>,
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSeg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSeg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>zSeg</name> <operator>=</operator> <call><name>segToString</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>nMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nBuf</name><operator>-</operator><name>i</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
    <expr_stmt><expr><call><name>lsmInfoArrayStructure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nBuf</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"    (%s)"</literal></expr></argument>, <argument><expr><name>zSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>aBuf</name><index>[<expr><name>nBuf</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sortedDumpPage</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pRun</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bVals</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>       <comment type="block">/* LsmBlob used for keys */</comment>
  <decl_stmt><decl><type><name>LsmString</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,<argument><expr><literal type="string">"nCell=%d iPtr=%d flags=%d {"</literal></expr></argument>, <argument><expr><name>nRec</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>SEGMENT_BTREE_FLAG</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRec</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pRef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Pointer to page iRef */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iChar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Key */</comment>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iTopic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPgPtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>aCell</name> <operator>=</operator> <call><name>pageGetCell</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>*</operator><name>aCell</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPgPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRef</name></decl>;</decl_stmt>               <comment type="block">/* Page number of referenced page */</comment>
      <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet64</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>iRef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aKey</name> <operator>=</operator> <call><name>pageGetKey</name><argument_list>(<argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>pRef</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>rtIsWrite</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sortedReadData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>(</operator><name>aCell</name><operator>-</operator><name>aData</name><operator>)</operator></expr></argument>, <argument><expr><name>nKey</name><operator>+</operator><name>nVal</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>aKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aVal</name> <operator>=</operator> <operator>&amp;</operator><name><name>aKey</name><index>[<expr><name>nKey</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iTopic</name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"%s%2X:"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr>?</condition><then><expr><literal type="string">""</literal></expr></then><else>:<expr><literal type="string">" "</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iTopic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iChar</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iChar</name><operator>&lt;</operator><name>nKey</name></expr>;</condition> <incr><expr><name>iChar</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>isalnum</name><argument_list>(<argument><expr><name><name>aKey</name><index>[<expr><name>iChar</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>aKey</name><index>[<expr><name>iChar</name></expr>]</index></name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bVals</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"##"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iChar</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iChar</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>iChar</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>isalnum</name><argument_list>(<argument><expr><name><name>aVal</name><index>[<expr><name>iChar</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>aVal</name><index>[<expr><name>iChar</name></expr>]</index></name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name>iPgPtr</name><operator>+</operator><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lsmStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"      Page %d: %s"</literal></expr></argument>, <argument><expr><call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmStringClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>infoCellDump</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Segment page belongs to */</comment>
  <parameter><decl><type><name>int</name></type> <name>bIndirect</name></decl></parameter>,                  <comment type="block">/* True to follow indirect refs */</comment>
  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>peType</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPgPtr</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>paVal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>,
  <parameter><decl><type><name>LsmBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>           <comment type="block">/* Page data */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Key */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPgPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pRef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Pointer to page iRef */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aCell</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>aCell</name> <operator>=</operator> <call><name>pageGetCell</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>*</operator><name>aCell</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPgPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRef</name></decl>;</decl_stmt>                 <comment type="block">/* Page number of referenced page */</comment>
    <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet64</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bIndirect</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iRef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pageGetKeyCopy</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pRef</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aKey</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pBlob</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>aKey</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><literal type="string">"&lt;indirect&gt;"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>rtIsWrite</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>aCell</name> <operator>+=</operator> <call><name>lsmVarintGet32</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sortedReadData</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>(</operator><name>aCell</name><operator>-</operator><name>aData</name><operator>)</operator></expr></argument>, <argument><expr><name>nKey</name><operator>+</operator><name>nVal</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>aKey</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aVal</name> <operator>=</operator> <operator>&amp;</operator><name><name>aKey</name><index>[<expr><name>nKey</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>peType</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>peType</name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>piPgPtr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piPgPtr</name> <operator>=</operator> <name>iPgPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>paKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>paKey</name> <operator>=</operator> <name>aKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>paVal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>paVal</name> <operator>=</operator> <name>aVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnVal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>infoAppendBlob</name><parameter_list>(<parameter><decl><type><name>LsmString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bHex</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iChar</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>iChar</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iChar</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>iChar</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bHex</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>iChar</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>isalnum</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>iChar</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then><expr><name><name>z</name><index>[<expr><name>iChar</name></expr>]</index></name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_PAGE_DUMP_DATA</name></cpp:macro>     <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_PAGE_DUMP_VALUES</name></cpp:macro>   <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_PAGE_DUMP_HEX</name></cpp:macro>      <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_PAGE_DUMP_INDIRECT</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>infoPageDump</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>,                    <comment type="block">/* Page number of page to dump */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOut</name></decl></parameter>                    <comment type="block">/* OUT: lsmMalloc'd string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Handle for page iPg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                       <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>perLine</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Bytes per line in the raw hex dump */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnap</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>bValues</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INFO_PAGE_DUMP_VALUES</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bHex</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INFO_PAGE_DUMP_HEX</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bData</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INFO_PAGE_DUMP_DATA</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bIndirect</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INFO_PAGE_DUMP_INDIRECT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSnap</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSnap</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pSnap</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSnap</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bUse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pLvl</name><operator>=</operator><name><name>pSnap</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</init> <condition><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</condition> <incr><expr><name>pLvl</name><operator>=</operator><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSegmentContainsPg</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bUse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bUse</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* iPg is a real page number (not subject to redirection). So it is safe 
  ** to pass a NULL in place of the segment pointer as the second argument
  ** to lsmFsDbPageGet() here.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nKeyWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmString</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>         <comment type="block">/* Page data and size thereof */</comment>

    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRec</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>pageGetPtr</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags2</name> <operator>=</operator> <call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"Page : %lld  (%d bytes)\n"</literal></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"nRec : %d\n"</literal></expr></argument>, <argument><expr><name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"iPtr : %d\n"</literal></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"flags: %04x\n"</literal></expr></argument>, <argument><expr><name>flags2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>iCell</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCell</name><operator>&lt;</operator><name>nRec</name></expr>;</condition> <incr><expr><name>iCell</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>infoCellDump</name><argument_list>(
          <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>bIndirect</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>&gt;</operator><name>nKeyWidth</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKeyWidth</name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>bHex</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKeyWidth</name> <operator>=</operator> <name>nKeyWidth</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for<control>(<init><expr><name>iCell</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCell</name><operator>&lt;</operator><name>nRec</name></expr>;</condition> <incr><expr><name>iCell</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Key */</comment>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Value */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iPgPtr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iAbsPtr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zFlags</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>infoCellDump</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>bIndirect</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPgPtr</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>aKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iAbsPtr</name> <operator>=</operator> <name>iPgPtr</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags2</name> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>iPtr</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>lsmFlagsToString</name><argument_list>(<argument><expr><name>eType</name></expr></argument>, <argument><expr><name>zFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s %d (%s) "</literal></expr></argument>, 
          <argument><expr><name>zFlags</name></expr></argument>, <argument><expr><name>iAbsPtr</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"sys"</literal></expr> </then><else>: <expr><literal type="string">"usr"</literal></expr></else></ternary><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>infoAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>bHex</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bValues</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>nKeyWidth</name> <operator>-</operator> <operator>(</operator><name>nKey</name><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><name>bHex</name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>infoAppendBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>bHex</name></expr></argument>, <argument><expr><name>aVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>rtTopic</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>~</operator><call><name>lsmGetU32</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"  (block=%d"</literal></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>iSnap</name> <init>= <expr><call><name>lsmGetU64</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" snapshot=%lld"</literal></expr></argument>, <argument><expr><name>iSnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>bData</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n-------------------"</literal> 
          <literal type="string">"-------------------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"Page %d\n"</literal></expr></argument>,
          <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>(</operator><name>iPg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nData</name></expr></argument>, <argument><expr><name>iPg</name><operator>*</operator><name>nData</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nData</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>perLine</name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%04x: "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>perLine</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><name>j</name><operator>&gt;</operator><name>nData</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"   "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%02x "</literal></expr></argument>, <argument><expr><name><name>aData</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>perLine</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><name>j</name><operator>&gt;</operator><name>nData</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>isprint</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>aData</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmInfoPageDump</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>,                    <comment type="block">/* Page number of page to dump */</comment>
  <parameter><decl><type><name>int</name></type> <name>bHex</name></decl></parameter>,                       <comment type="block">/* True to output key/value in hex form */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOut</name></decl></parameter>                    <comment type="block">/* OUT: lsmMalloc'd string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INFO_PAGE_DUMP_DATA</name> <operator>|</operator> <name>INFO_PAGE_DUMP_VALUES</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>bHex</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INFO_PAGE_DUMP_HEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>infoPageDump</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pzOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sortedDumpSegment</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pRun</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bVals</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>xLog</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRun</name> <operator>&amp;&amp;</operator> <name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bVals</name></expr> ?</condition><then> <expr><name>INFO_PAGE_DUMP_VALUES</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSeg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>zSeg</name> <operator>=</operator> <call><name>segToString</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"Segment: %s"</literal></expr></argument>, <argument><expr><name>zSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>infoPageDump</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
      sortedDumpPage(pDb, pRun, pPg, bVals);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the log callback zero or more times with messages that describe
** the current database structure.
*/</comment>
<function><type><name>void</name></type> <name>lsmSortedDumpStructure</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle (used for xLog callback) */</comment>
  <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnap</name></decl></parameter>,                <comment type="block">/* Snapshot to dump */</comment>
  <parameter><decl><type><name>int</name></type> <name>bKeys</name></decl></parameter>,                      <comment type="block">/* Output the keys from each segment */</comment>
  <parameter><decl><type><name>int</name></type> <name>bVals</name></decl></parameter>,                      <comment type="block">/* Output the values from each segment */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWhy</name></decl></parameter>                <comment type="block">/* Caption to print near top of dump */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pDump</name> <init>= <expr><name>pSnap</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pTopLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSnap</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTopLevel</name> <operator>=</operator> <call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name>pDump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>xLog</name></name> <operator>&amp;&amp;</operator> <name>pTopLevel</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nCall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>nCall</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"Database structure %d (%s)"</literal></expr></argument>, <argument><expr><name>nCall</name></expr></argument>, <argument><expr><name>zWhy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if( nCall==1031 || nCall==1032 ) bKeys=1;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for<control>(<init><expr><name>pLevel</name><operator>=</operator><name>pTopLevel</name></expr>;</init> <condition><expr><name>pLevel</name></expr>;</condition> <incr><expr><name>pLevel</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zLeft</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zRight</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name><name>aLeft</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>  
      <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name><name>aRight</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>aLeft</name><index>[<expr><name>nLeft</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pSeg</name></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>aRight</name><index>[<expr><name>nRight</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>nRight</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aRight</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aRight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aRight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nRight</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nLeft</name> <operator>||</operator> <name>i</name><operator>&lt;</operator><name>nRight</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iPad</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>zLevel</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>zLeft</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zRight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nLeft</name></expr> )</condition><block>{<block_content> 
          <expr_stmt><expr><call><name>fileToString</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zLeft</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLeft</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name><name>aLeft</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nRight</name></expr> )</condition><block>{<block_content> 
          <expr_stmt><expr><call><name>fileToString</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zRight</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zRight</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name><name>aRight</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>zLevel</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"L%d: (age=%d) (flags=%.4x)"</literal></expr></argument>,
              <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iAge</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pLevel</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>zLevel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>nRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iPad</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"% 25s % *s% -35s %s"</literal></expr></argument>, 
            <argument><expr><name>zLevel</name></expr></argument>, <argument><expr><name>iPad</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>zLeft</name></expr></argument>, <argument><expr><name>zRight</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><name>iLevel</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>bKeys</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>pLevel</name><operator>=</operator><name>pTopLevel</name></expr>;</init> <condition><expr><name>pLevel</name></expr>;</condition> <incr><expr><name>pLevel</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sortedDumpSegment</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>bVals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sortedDumpSegment</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>bVals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmInfoFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"Freelist: %s"</literal></expr></argument>, <argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmFsIntegrityCheck</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmSortedFreeLevel</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pLevel</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sortedFreeLevel</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmSortedSaveTreeCursors</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</init> <condition><expr><name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>lsmTreeCursorSave</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmTreeCursorSave</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmSortedExpandBtreePage</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nOrig</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iHdr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>lsmFsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iHdr</name> <operator>=</operator> <call><name>SEGMENT_EOF</name><argument_list>(<argument><expr><name>nOrig</name></expr></argument>, <argument><expr><name>nEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iHdr</name> <operator>+</operator> <operator>(</operator><name>nData</name><operator>-</operator><name>nOrig</name><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>iHdr</name></expr>]</index></name></expr></argument>, <argument><expr><name>nOrig</name><operator>-</operator><name>iHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG_EXPENSIVE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assertRunInOrder</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob1</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob2</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>lsmFsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SEGMENT_BTREE_FLAG</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nRec</name> <init>= <expr><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRec</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iTopic1</name></decl>, <decl><type ref="prev"/><name>iTopic2</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>pageGetKeyCopy</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopic1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>blob2</name><operator>.</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sortedKeyCompare</name><argument_list>(
                <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, <argument><expr><name>iTopic2</name></expr></argument>, <argument><expr><name><name>blob2</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>blob2</name><operator>.</operator><name>nData</name></name></expr></argument>,
                <argument><expr><name>iTopic1</name></expr></argument>, <argument><expr><name><name>blob1</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>blob1</name><operator>.</operator><name>nData</name></name></expr></argument>
          )</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>nRec</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>pageGetKeyCopy</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopic2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sortedKeyCompare</name><argument_list>(
                <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument>, <argument><expr><name>iTopic1</name></expr></argument>, <argument><expr><name><name>blob1</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>blob1</name><operator>.</operator><name>nData</name></name></expr></argument>,
                <argument><expr><name>iTopic2</name></expr></argument>, <argument><expr><name><name>blob2</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>blob2</name><operator>.</operator><name>nData</name></name></expr></argument>
          )</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blob1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blob2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG_EXPENSIVE</name></cpp:ifdef>
<comment type="block">/*
** This function is only included in the build if LSM_DEBUG_EXPENSIVE is 
** defined. Its only purpose is to evaluate various assert() statements to 
** verify that the database is well formed in certain respects.
**
** More specifically, it checks that the array pOne contains the required 
** pointers to pTwo. Array pTwo must be a main array. pOne may be either a 
** separators array or another main array. If pOne does not contain the 
** correct set of pointers, an assert() statement fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>assertPointersOk</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pOne</name></decl></parameter>,                  <comment type="block">/* Segment containing pointers */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pTwo</name></decl></parameter>,                  <comment type="block">/* Segment containing pointer targets */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRhs</name></decl></parameter>                        <comment type="block">/* True if pTwo may have been Gobble()d */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Error code */</comment>
  <decl_stmt><decl><type><name>SegmentPtr</name></type> <name>ptr1</name></decl>;</decl_stmt>                <comment type="block">/* Iterates through pOne */</comment>
  <decl_stmt><decl><type><name>SegmentPtr</name></type> <name>ptr2</name></decl>;</decl_stmt>                <comment type="block">/* Iterates through pTwo */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPrev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOne</name> <operator>&amp;&amp;</operator> <name>pTwo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ptr1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ptr1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ptr1</name><operator>.</operator><name>pSeg</name></name> <operator>=</operator> <name>pOne</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ptr2</name><operator>.</operator><name>pSeg</name></name> <operator>=</operator> <name>pTwo</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>segmentPtrEndPage</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>segmentPtrEndPage</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that the footer pointer of the first page of pOne points to
  ** the first page of pTwo. */</comment>
  <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name><name>pTwo</name><operator>-&gt;</operator><name>iFirst</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>ptr1</name><operator>.</operator><name>iPtr</name></name><operator>!=</operator><name>iPrev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bRhs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>ptr1</name><operator>.</operator><name>nCell</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
      
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>ptr2</name><operator>.</operator><name>pPg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iThis</name></decl>;</decl_stmt>

    <comment type="block">/* Advance to the next page of segment pTwo that contains at least
    ** one cell. Break out of the loop if the iterator reaches EOF.  */</comment>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrNextPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>ptr2</name><operator>.</operator><name>pPg</name></name> <operator>&amp;&amp;</operator> <name><name>ptr2</name><operator>.</operator><name>nCell</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition>;</do>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>ptr2</name><operator>.</operator><name>pPg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iThis</name> <operator>=</operator> <call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name><name>ptr2</name><operator>.</operator><name>pPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>ptr2</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>PGFTR_SKIP_THIS_FLAG</name><operator>|</operator><name>SEGMENT_BTREE_FLAG</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>

      <comment type="block">/* Load the first cell in the array pTwo page. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrLoadCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Iterate forwards through pOne, searching for a key that matches the
      ** key ptr2.pKey/nKey. This key should have a pointer to the page that
      ** ptr2 currently points to. */</comment>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>rtTopic</name><argument_list>(<argument><expr><name><name>ptr1</name><operator>.</operator><name>eType</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>rtTopic</name><argument_list>(<argument><expr><name><name>ptr2</name><operator>.</operator><name>eType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>ptr1</name><operator>.</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>ptr1</name><operator>.</operator><name>nKey</name></name></expr></argument>, <argument><expr><name><name>ptr2</name><operator>.</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>ptr2</name><operator>.</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bRhs</name> <operator>||</operator> <name><name>ptr1</name><operator>.</operator><name>iPtr</name></name><operator>+</operator><name><name>ptr1</name><operator>.</operator><name>iPgPtr</name></name><operator>==</operator><name>iPrev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>ptr1</name><operator>.</operator><name>iPtr</name></name><operator>+</operator><name><name>ptr1</name><operator>.</operator><name>iPgPtr</name></name><operator>==</operator><name>iThis</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iThis</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentPtrAdvance</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>ptr1</name><operator>.</operator><name>pPg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>segmentPtrReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only included in the build if LSM_DEBUG_EXPENSIVE is 
** defined. Its only purpose is to evaluate various assert() statements to 
** verify that the database is well formed in certain respects.
**
** More specifically, it checks that the b-tree embedded in array pRun
** contains the correct keys. If not, an assert() fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>assertBtreeOk</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>     <comment type="block">/* Buffer used to cache overflow keys */</comment>
    <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* File system to read from */</comment>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Main run page */</comment>
    <decl_stmt><decl><type><name>BtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Btree cursor */</comment>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>fsPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pageGetFlags</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> 
       <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><operator>(</operator><name>SEGMENT_BTREE_FLAG</name><operator>|</operator><name>PGFTR_SKIP_THIS_FLAG</name><operator>)</operator> <operator>&amp;</operator> <name>flags</name><operator>)</operator>
       <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>!=</operator><call><name>pageGetNRec</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iTopic</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>pageGetKey</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTopic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nKey</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPtr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>btreeCursorNext</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pKey</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>btreeCursorFree</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sortedBlobFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef LSM_DEBUG_EXPENSIVE */</comment>
</unit>
