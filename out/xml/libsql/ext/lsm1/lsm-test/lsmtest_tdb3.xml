<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/lsm1/lsm-test/lsmtest_tdb3.c">
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmtest_tdb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmtest.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>LsmDb</name></name></type> <name>LsmDb</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>LsmWorker</name></name></type> <name>LsmWorker</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>LsmFile</name></name></type> <name>LsmFile</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_DFLT_MT_MAX_CKPT</name></cpp:macro> <cpp:value>(8*1024)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_DFLT_MT_MIN_CKPT</name></cpp:macro> <cpp:value>(2*1024)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_THREAD_CKPT</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_THREAD_WORKER</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_THREAD_WORKER_AC</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
** There are several different types of worker threads that run in different
** test configurations, depending on the value of LsmWorker.eType.
**
**   1. Checkpointer.
**   2. Worker with auto-checkpoint.
**   3. Worker without auto-checkpoint.
*/</comment>
<struct>struct <name>LsmWorker</name> <block>{
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                     <comment type="block">/* Main database structure */</comment>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>                <comment type="block">/* Worker database handle */</comment>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>worker_thread</name></decl>;</decl_stmt>        <comment type="block">/* Worker thread */</comment>
  <decl_stmt><decl><type><name>pthread_cond_t</name></type> <name>worker_cond</name></decl>;</decl_stmt>     <comment type="block">/* Condition var the worker waits on */</comment>
  <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>worker_mutex</name></decl>;</decl_stmt>   <comment type="block">/* Mutex used with worker_cond */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDoWork</name></decl>;</decl_stmt>                    <comment type="block">/* Set to true by client when there is work */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>worker_rc</name></decl>;</decl_stmt>                  <comment type="block">/* Store error code here */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                      <comment type="block">/* LSMTEST_THREAD_XXX constant */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bBlock</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<struct>struct <name>LsmWorker</name> <block>{ <decl_stmt><decl><type><name>int</name></type> <name>worker_rc</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>bBlock</name></decl>;</decl_stmt> }</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mt_shutdown</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>lsm_env</name> <modifier>*</modifier></type><name>tdb_lsm_env</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bInit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>lsm_env</name></type> <name>env</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>bInit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><call><name>lsm_default_env</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bInit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>&amp;</operator><name>env</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>FileSector</name></name></type> <name>FileSector</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>FileData</name></name></type> <name>FileData</name>;</typedef>

<struct>struct <name>FileSector</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld</name></decl>;</decl_stmt>                       <comment type="block">/* Old data for this sector */</comment>
}</block>;</struct>

<struct>struct <name>FileData</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nSector</name></decl>;</decl_stmt>                    <comment type="block">/* Allocated size of apSector[] array */</comment>
  <decl_stmt><decl><type><name>FileSector</name> <modifier>*</modifier></type><name>aSector</name></decl>;</decl_stmt>            <comment type="block">/* Array of file sectors */</comment>
}</block>;</struct>

<comment type="block">/*
** bPrepareCrash:
**   If non-zero, the file wrappers maintain enough in-memory data to
**   simulate the effect of a power-failure on the file-system (i.e. that
**   unsynced sectors may be written, not written, or overwritten with
**   arbitrary data when the crash occurs).
**
** bCrashed:
**   Set to true after a crash is simulated. Once this variable is true, all
**   VFS methods other than xClose() return LSM_IOERR as soon as they are
**   called (without affecting the contents of the file-system).
**
** env:
**   The environment object used by all lsm_db* handles opened by this
**   object (i.e. LsmDb.db plus any worker connections). Variable env.pVfsCtx
**   always points to the containing LsmDb structure.
*/</comment>
<struct>struct <name>LsmDb</name> <block>{
  <decl_stmt><decl><type><name>TestDb</name></type> <name>base</name></decl>;</decl_stmt>                    <comment type="block">/* Base class - methods table */</comment>
  <decl_stmt><decl><type><name>lsm_env</name></type> <name>env</name></decl>;</decl_stmt>                    <comment type="block">/* Environment used by connection db */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                    <comment type="block">/* Database file name */</comment>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                     <comment type="block">/* LSM database handle */</comment>

  <decl_stmt><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor held open during read transaction */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl>;</decl_stmt>                     <comment type="block">/* Buffer for tdb_fetch() output */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name></decl>;</decl_stmt>                       <comment type="block">/* Allocated (not used) size of pBuf */</comment>

  <comment type="block">/* Crash testing related state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bCrashed</name></decl>;</decl_stmt>                   <comment type="block">/* True once a crash has occurred */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAutoCrash</name></decl>;</decl_stmt>                 <comment type="block">/* Number of syncs until a crash */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPrepareCrash</name></decl>;</decl_stmt>              <comment type="block">/* True to store writes in memory */</comment>

  <comment type="block">/* Unsynced data (while crash testing) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szSector</name></decl>;</decl_stmt>                   <comment type="block">/* Assumed size of disk sectors (512B) */</comment>
  <decl_stmt><decl><type><name>FileData</name></type> <name><name>aFile</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>              <comment type="block">/* Database and log file data */</comment>

  <comment type="block">/* Other test instrumentation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bNoRecovery</name></decl>;</decl_stmt>                <comment type="block">/* If true, assume DMS2 is locked */</comment>

  <comment type="block">/* Work hook redirection */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xWork</name>)<parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pWorkCtx</name></decl>;</decl_stmt>

  <comment type="block">/* IO logging hook */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xWriteHook</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>lsm_i64</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pWriteCtx</name></decl>;</decl_stmt>
  
  <comment type="block">/* Worker threads (for lsm_mt) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMtMinCkpt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMtMaxCkpt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eMode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWorker</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmWorker</name> <modifier>*</modifier></type><name>aWorker</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_MODE_SINGLETHREAD</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_MODE_BACKGROUND_CKPT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_MODE_BACKGROUND_WORK</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSMTEST_MODE_BACKGROUND_BOTH</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*************************************************************************
**************************************************************************
** Begin test VFS code.
*/</comment>

<struct>struct <name>LsmFile</name> <block>{
  <decl_stmt><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pReal</name></decl>;</decl_stmt>                <comment type="block">/* Real underlying file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bLog</name></decl>;</decl_stmt>                       <comment type="block">/* True for log file. False for db file */</comment>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                     <comment type="block">/* Database handle that uses this file */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvFullpath</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>,                  <comment type="block">/* Environment for current LsmDb */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>,              <comment type="block">/* Relative path name */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>,                     <comment type="block">/* Output buffer */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>                      <comment type="block">/* IN/OUT: Size of output buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xFullpath</name></name><argument_list>(<argument><expr><name>pRealEnv</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvOpen</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>,                  <comment type="block">/* Environment for current LsmDb */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>,              <comment type="block">/* Name of file to open */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppFile</name></decl></parameter>               <comment type="block">/* OUT: New file handle object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name><name>pEnv</name><operator>-&gt;</operator><name>pVfsCtx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>                  <comment type="block">/* The new file handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFile</name></decl>;</decl_stmt>                      <comment type="block">/* Length of string zFile in bytes */</comment>

  <expr_stmt><expr><name>nFile</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><call><name>testMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>bLog</name></name> <operator>=</operator> <operator>(</operator><name>nFile</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"-log"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zFile</name><index>[<expr><name>nFile</name><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pRealEnv</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppFile</name> <operator>=</operator> <operator>(</operator><name>lsm_file</name> <operator>*</operator><operator>)</operator><name>pRet</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvRead</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>lsm_i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>bCrashed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_IOERR</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvWrite</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>lsm_i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bCrashed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_IOERR</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bPrepareCrash</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FileData</name> <modifier>*</modifier></type><name>pData2</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>bLog</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name></decl>;</decl_stmt>                 
    <decl_stmt><decl><type><name>int</name></type> <name>iLast</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iSector</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iOff</name> <operator>/</operator> <name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLast</name> <operator>=</operator>  <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>iOff</name> <operator>+</operator> <name>nData</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pData2</name><operator>-&gt;</operator><name>nSector</name></name><operator>&lt;</operator><operator>(</operator><name>iLast</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><operator>(</operator> <operator>(</operator><operator>(</operator><name>iLast</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">63</literal><operator>)</operator> <operator>/</operator> <literal type="number">64</literal> <operator>)</operator> <operator>*</operator> <literal type="number">64</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&gt;</operator><name>iLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pData2</name><operator>-&gt;</operator><name>aSector</name></name> <operator>=</operator> <operator>(</operator><name>FileSector</name> <operator>*</operator><operator>)</operator><call><name>testRealloc</name><argument_list>(
          <argument><expr><name><name>pData2</name><operator>-&gt;</operator><name>aSector</name></name></expr></argument>, <argument><expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>FileSector</name></expr></argument>)</argument_list></sizeof></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pData2</name><operator>-&gt;</operator><name>aSector</name><index>[<expr><name><name>pData2</name><operator>-&gt;</operator><name>nSector</name></name></expr>]</index></name></expr></argument>, 
          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>nNew</name> <operator>-</operator> <name><name>pData2</name><operator>-&gt;</operator><name>nSector</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileSector</name></expr></argument>)</argument_list></sizeof></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pData2</name><operator>-&gt;</operator><name>nSector</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>iSector</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>iSector</name><operator>&lt;=</operator><name>iLast</name></expr>;</condition> <incr><expr><name>iSector</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pData2</name><operator>-&gt;</operator><name>aSector</name><index>[<expr><name>iSector</name></expr>]</index></name><operator>.</operator><name>aOld</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>testMalloc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(
            <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><operator>(</operator><name>lsm_i64</name><operator>)</operator><name>iSector</name><operator>*</operator><name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name></expr></argument>, <argument><expr><name>aOld</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pData2</name><operator>-&gt;</operator><name>aSector</name><index>[<expr><name>iSector</name></expr>]</index></name><operator>.</operator><name>aOld</name> <operator>=</operator> <name>aOld</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>xWriteHook</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nUs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>t1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>t2</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nUs</name> <operator>=</operator> <operator>(</operator><name><name>t2</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>t1</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal> <operator>+</operator> <operator>(</operator><name><name>t2</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>t1</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>xWriteHook</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWriteCtx</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bLog</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nUs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doSystemCrash</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvSync</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileData</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>bLog</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bCrashed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_IOERR</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nAutoCrash</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nAutoCrash</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nAutoCrash</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>doSystemCrash</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bCrashed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>LSM_IOERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bPrepareCrash</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pData</name><operator>-&gt;</operator><name>nSector</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>aSector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>aSector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aOld</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>xWriteHook</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nUs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>t1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>t2</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nUs</name> <operator>=</operator> <operator>(</operator><name><name>t2</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>t1</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal> <operator>+</operator> <operator>(</operator><name><name>t2</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>t1</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>xWriteHook</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWriteCtx</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bLog</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nUs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvTruncate</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>lsm_i64</name></type> <name>iOff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>bCrashed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_IOERR</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvSectorSize</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvRemap</name><parameter_list>(
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_i64</name></type> <name>iMin</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>,
  <parameter><decl><type><name>lsm_i64</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xRemap</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iMin</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvFileid</name><parameter_list>(
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ppOut</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xFileid</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvClose</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvUnlink</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xUnlink</name></name><argument_list>(<argument><expr><name>pRealEnv</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvLock</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLock</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>LSM_LOCK_EXCL</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>bNoRecovery</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>LSM_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvTestLock</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLock</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>LSM_LOCK_EXCL</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>bNoRecovery</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>LSM_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xTestLock</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>nLock</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvShmMap</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iRegion</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>iRegion</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>testEnvShmBarrier</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvShmUnmap</name><parameter_list>(<parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bDel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pReal</name></name></expr></argument>, <argument><expr><name>bDel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testEnvSleep</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>us</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pRealEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pRealEnv</name><operator>-&gt;</operator><name>xSleep</name></name><argument_list>(<argument><expr><name>pRealEnv</name></expr></argument>, <argument><expr><name>us</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doSystemCrash</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSeed</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nSector</name> <operator>+</operator> <name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nSector</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>iFile</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iFile</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>iFile</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><name>iFile</name></expr>]</index></name><operator>.</operator><name>nSector</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><name>iFile</name></expr>]</index></name><operator>.</operator><name><name>aSector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aOld</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>aOld</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iOpt</name> <init>= <expr><call><name>testPrngValue</name><argument_list>(<argument><expr><name>iSeed</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>%</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>( <expr><name>iOpt</name></expr> )</condition><block>{<block_content>
          <case>case <expr><literal type="number">0</literal></expr>:</case>
            <break>break;</break>

          <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>iSeed</name><operator>++</operator></expr></argument>, <argument><expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name>aOld</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Fall-through */</comment>

          <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(
                <argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>(</operator><name>lsm_i64</name><operator>)</operator><name>i</name> <operator>*</operator> <name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name></expr></argument>, <argument><expr><name>aOld</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name>aOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><name>iFile</name></expr>]</index></name><operator>.</operator><name><name>aSector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aOld</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFree</name> <operator>=</operator> <name>zFile</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s-log"</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
** End test VFS code.
**************************************************************************
*************************************************************************/</comment>

<comment type="block" format="doxygen">/*************************************************************************
**************************************************************************
** Begin test compression hooks.
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ZLIB</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testZipBound</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>compressBound</name><argument_list>(<argument><expr><name>nSrc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testZipCompress</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* Context pointer */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,         <comment type="block">/* OUT: Buffer containing compressed data */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>        <comment type="block">/* Buffer containing input data */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>uLongf</name></type> <name>n</name> <init>= <expr><operator>*</operator><name>pnOut</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* In/out buffer size for compress() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* compress() return code */</comment>
 
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>compress</name><argument_list>(<argument><expr><operator>(</operator><name>Bytef</name><operator>*</operator><operator>)</operator><name>aOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>Bytef</name><operator>*</operator><operator>)</operator><name>aIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>Z_OK</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>LSM_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testZipUncompress</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* Context pointer */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,         <comment type="block">/* OUT: Buffer containing uncompressed data */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>        <comment type="block">/* Buffer containing input data */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>uLongf</name></type> <name>n</name> <init>= <expr><operator>*</operator><name>pnOut</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* In/out buffer size for uncompress() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* uncompress() return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>uncompress</name><argument_list>(<argument><expr><operator>(</operator><name>Bytef</name><operator>*</operator><operator>)</operator><name>aOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>Bytef</name><operator>*</operator><operator>)</operator><name>aIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>Z_OK</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>LSM_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testConfigureCompression</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>lsm_compress</name></type> <name>zip</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* Context pointer (unused) */</comment>
    <expr><literal type="number">1</literal></expr>,                            <comment type="block">/* Id value */</comment>
    <expr><name>testZipBound</name></expr>,                 <comment type="block">/* xBound method */</comment>
    <expr><name>testZipCompress</name></expr>,              <comment type="block">/* xCompress method */</comment>
    <expr><name>testZipUncompress</name></expr>             <comment type="block">/* xUncompress method */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lsm_config</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_CONFIG_SET_COMPRESSION</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zip</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef HAVE_ZLIB */</comment>

<comment type="block">/*
** End test compression hooks.
**************************************************************************
*************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_close</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>lsm_csr_close</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsm_close</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a multi-threaded database, wait on the worker threads. */</comment>
  <expr_stmt><expr><call><name>mt_shutdown</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nWorker</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>aWorker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_rc</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nSector</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>aSector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>aSector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nSector</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>aSector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>aSector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmDb</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0x11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pDb</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mt_signal_worker</name><parameter_list>(<parameter><decl><type><name>LsmDb</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>waitOnCheckpointer</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nSleep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKB</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>nKB</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_INFO_CHECKPOINT_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name>nKB</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nMtMaxCkpt</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>mt_signal_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, 
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pDb</name><operator>-&gt;</operator><name>eMode</name></name><operator>==</operator><name>LSMTEST_MODE_BACKGROUND_CKPT</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSleep</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><literal type="number">1</literal></expr> )</condition>;</do>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if( nSleep ) printf("# waitOnCheckpointer(): nSleep=%d\n", nSleep);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>waitOnWorker</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLimit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSleep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_config</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>LSM_CONFIG_AUTOFLUSH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nOld</name></decl>, <decl><type ref="prev"/><name>nNew</name></decl>, <decl><type ref="prev"/><name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>lsm_info</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>LSM_INFO_TREE_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOld</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc2</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nOld</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nNew</name><operator>&lt;</operator><operator>(</operator><name>nLimit</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>mt_signal_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSleep</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><literal type="number">1</literal></expr> )</condition>;</do>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  if( nSleep ) printf("# waitOnWorker(): nSleep=%d\n", nSleep);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_write</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>eMode</name></name><operator>==</operator><name>LSMTEST_MODE_BACKGROUND_CKPT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>waitOnCheckpointer</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( 
      <expr><name><name>pDb</name><operator>-&gt;</operator><name>eMode</name></name><operator>==</operator><name>LSMTEST_MODE_BACKGROUND_WORK</name>
   <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>eMode</name></name><operator>==</operator><name>LSMTEST_MODE_BACKGROUND_BOTH</name></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>waitOnWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_insert</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_delete</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lsm_delete</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_delete_range</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lsm_delete_range</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_fetch</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>csr</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_open</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>csr</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_seek</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>LSM_SEEK_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>lsm_csr_valid</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_value</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nBuf</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>=</operator> <call><name>testMalloc</name><argument_list>(<argument><expr><name>nVal</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>nVal</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm_csr_close</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_scan</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pFirst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nFirst</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLast</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter> , <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>csr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>csr2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_open</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>csr</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* To enhance testing, if both pLast and pFirst are defined, seek the
  ** cursor to the "end" boundary here. Then the next block seeks it to
  ** the "start" ready for the scan. The point is to test that cursors
  ** can be reused.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pLast</name> <operator>&amp;&amp;</operator> <name>pFirst</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bReverse</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_seek</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pFirst</name></expr></argument>, <argument><expr><name>nFirst</name></expr></argument>, <argument><expr><name>LSM_SEEK_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_seek</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pLast</name></expr></argument>, <argument><expr><name>nLast</name></expr></argument>, <argument><expr><name>LSM_SEEK_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bReverse</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pLast</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_seek</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pLast</name></expr></argument>, <argument><expr><name>nLast</name></expr></argument>, <argument><expr><name>LSM_SEEK_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_last</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pFirst</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_seek</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pFirst</name></expr></argument>, <argument><expr><name>nFirst</name></expr></argument>, <argument><expr><name>LSM_SEEK_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_first</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsm_csr_valid</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>lsm_csr_key</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_csr_value</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bReverse</name> <operator>&amp;&amp;</operator> <name>pFirst</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pFirst</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>nFirst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>cmp</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nFirst</name><operator>&gt;</operator><name>nKey</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bReverse</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pLast</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pLast</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>nLast</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>cmp</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nLast</name><operator>&lt;</operator><name>nKey</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>xCallback</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bReverse</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_prev</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_next</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm_csr_close</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_begin</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* iLevel==0 is a no-op. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_csr_open</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>iLevel</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_begin</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>iLevel</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_commit</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If iLevel==0, close any open read transaction */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm_csr_close</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If iLevel==0, close any open read transaction */</comment>
  <return>return <expr><call><name>lsm_commit</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iLevel</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_lsm_rollback</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pTestDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pTestDb</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If iLevel==0, close any open read transaction */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm_csr_close</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>lsm_rollback</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iLevel</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A log message callback registered with lsm connections. Prints all 
** messages to stderr.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>xLog</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* fprintf(stderr, "lsm: rc=%d \"%s\"\n", rc, z); */</comment>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xWorkHook</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xWork</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>xWork</name></name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWorkCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_NO_RECOVERY</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_COMPRESSION</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_MT_MODE</name></cpp:macro>     <cpp:value>-2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_MT_MIN_CKPT</name></cpp:macro> <cpp:value>-4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_MT_MAX_CKPT</name></cpp:macro> <cpp:value>-5</cpp:value></cpp:define>


<function><type><name>int</name></type> <name>test_lsm_config_str</name><parameter_list>(
  <parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pLsm</name></decl></parameter>,
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bWorker</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnThread</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <struct>struct <name>CfgParam</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bWorker</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eParam</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aParam</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"autoflush"</literal></expr>,        <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_AUTOFLUSH</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"page_size"</literal></expr>,        <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_PAGE_SIZE</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"block_size"</literal></expr>,       <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_BLOCK_SIZE</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"safety"</literal></expr>,           <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_SAFETY</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"autowork"</literal></expr>,         <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_AUTOWORK</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"autocheckpoint"</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_AUTOCHECKPOINT</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"mmap"</literal></expr>,             <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_MMAP</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"use_log"</literal></expr>,          <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_USE_LOG</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"automerge"</literal></expr>,        <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_AUTOMERGE</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"max_freelist"</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_MAX_FREELIST</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"multi_proc"</literal></expr>,       <expr><literal type="number">0</literal></expr>, <expr><name>LSM_CONFIG_MULTIPLE_PROCESSES</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"worker_automerge"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>LSM_CONFIG_AUTOMERGE</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_no_recovery"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>TEST_NO_RECOVERY</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"bg_min_ckpt"</literal></expr>,      <expr><literal type="number">0</literal></expr>, <expr><name>TEST_NO_RECOVERY</name></expr> }</block></expr>,

    <expr><block>{ <expr><literal type="string">"mt_mode"</literal></expr>,          <expr><literal type="number">0</literal></expr>, <expr><name>TEST_MT_MODE</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"mt_min_ckpt"</literal></expr>,      <expr><literal type="number">0</literal></expr>, <expr><name>TEST_MT_MIN_CKPT</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"mt_max_ckpt"</literal></expr>,      <expr><literal type="number">0</literal></expr>, <expr><name>TEST_MT_MAX_CKPT</name></expr> }</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ZLIB</name></cpp:ifdef>
    <expr><block>{ <expr><literal type="string">"compression"</literal></expr>,      <expr><literal type="number">0</literal></expr>, <expr><name>TEST_COMPRESSION</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zStr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nThread</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zStr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl>;</decl_stmt>

    <comment type="block">/* Skip whitespace */</comment>
    <while>while<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>

    <while>while<condition>( <expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>z</name><operator>!=</operator><literal type="char">'='</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>eParam</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iMul</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zParam</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nParam</name> <init>= <expr><name>z</name><operator>-</operator><name>zStart</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nParam</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nParam</name><operator>&gt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zParam</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>syntax_error</name>;</goto></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zParam</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>nParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zParam</name><index>[<expr><name>nParam</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>testArgSelect</name><argument_list>(<argument><expr><name>aParam</name></expr></argument>, <argument><expr><literal type="string">"param"</literal></expr></argument>, <argument><expr><name>zParam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>eParam</name> <operator>=</operator> <name><name>aParam</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eParam</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>*</operator><name>z</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>z</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'k'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'K'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iMul</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'M'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'M'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iMul</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nParam</name> <operator>=</operator> <name>z</name><operator>-</operator><name>zStart</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nParam</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nParam</name><operator>&gt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zParam</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zParam</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>nParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zParam</name><index>[<expr><name>nParam</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>zParam</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>iMul</name></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>eParam</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>bWorker</name> <operator>||</operator> <name><name>aParam</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bWorker</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>lsm_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>eParam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <switch>switch<condition>( <expr><name>eParam</name></expr> )</condition><block>{<block_content>
          <case>case <expr><name>TEST_NO_RECOVERY</name></expr>:</case>
            <if_stmt><if>if<condition>( <expr><name>pLsm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLsm</name><operator>-&gt;</operator><name>bNoRecovery</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
          <case>case <expr><name>TEST_MT_MODE</name></expr>:</case>
            <if_stmt><if>if<condition>( <expr><name>pLsm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nThread</name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
          <case>case <expr><name>TEST_MT_MIN_CKPT</name></expr>:</case>
            <if_stmt><if>if<condition>( <expr><name>pLsm</name> <operator>&amp;&amp;</operator> <name>iVal</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLsm</name><operator>-&gt;</operator><name>nMtMinCkpt</name></name> <operator>=</operator> <name>iVal</name><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
          <case>case <expr><name>TEST_MT_MAX_CKPT</name></expr>:</case>
            <if_stmt><if>if<condition>( <expr><name>pLsm</name> <operator>&amp;&amp;</operator> <name>iVal</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLsm</name><operator>-&gt;</operator><name>nMtMaxCkpt</name></name> <operator>=</operator> <name>iVal</name><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ZLIB</name></cpp:ifdef>
          <case>case <expr><name>TEST_COMPRESSION</name></expr>:</case>
            <expr_stmt><expr><call><name>testConfigureCompression</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></switch>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>z</name><operator>!=</operator><name>zStart</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>syntax_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>pnThread</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnThread</name> <operator>=</operator> <name>nThread</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pLsm</name> <operator>&amp;&amp;</operator> <name><name>pLsm</name><operator>-&gt;</operator><name>nMtMaxCkpt</name></name> <operator>&lt;</operator> <name><name>pLsm</name><operator>-&gt;</operator><name>nMtMinCkpt</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLsm</name><operator>-&gt;</operator><name>nMtMinCkpt</name></name> <operator>=</operator> <name><name>pLsm</name><operator>-&gt;</operator><name>nMtMaxCkpt</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
 <label><name>syntax_error</name>:</label>
  <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"syntax error at: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tdb_lsm_config_str</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pLsm</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>test_lsm_config_str</name><argument_list>(<argument><expr><name>pLsm</name></expr></argument>, <argument><expr><name><name>pLsm</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pLsm</name><operator>-&gt;</operator><name>nWorker</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>test_lsm_config_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pLsm</name><operator>-&gt;</operator><name>aWorker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pWorker</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tdb_lsm_configure</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zConfig</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>test_lsm_config_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zConfig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>testLsmStartWorkers</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testLsmOpen</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>DatabaseMethods</name></type> <name>LsmMethods</name> <init>= <expr><block>{
    <expr><name>test_lsm_close</name></expr>,
    <expr><name>test_lsm_write</name></expr>,
    <expr><name>test_lsm_delete</name></expr>,
    <expr><name>test_lsm_delete_range</name></expr>,
    <expr><name>test_lsm_fetch</name></expr>,
    <expr><name>test_lsm_scan</name></expr>,
    <expr><name>test_lsm_begin</name></expr>,
    <expr><name>test_lsm_commit</name></expr>,
    <expr><name>test_lsm_rollback</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFilename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <comment type="block">/* If the bClear flag is set, delete any existing database. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bClear</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testDeleteLsmdb</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nFilename</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><call><name>testMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmDb</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nFilename</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmDb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>LsmMethods</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>nFilename</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Default the sector size used for crash simulation to 512 bytes. 
  ** Todo: There should be an OS method to obtain this value - just as
  ** there is in SQLite. For now, LSM assumes that it is smaller than
  ** the page size (default 4KB).
  */</comment>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>szSector</name></name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>

  <comment type="block">/* Default values for the mt_min_ckpt and mt_max_ckpt parameters. */</comment>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMtMinCkpt</name></name> <operator>=</operator> <name>LSMTEST_DFLT_MT_MIN_CKPT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMtMaxCkpt</name></name> <operator>=</operator> <name>LSMTEST_DFLT_MT_MAX_CKPT</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lsm_env</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>pVfsCtx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xFullpath</name></name> <operator>=</operator> <name>testEnvFullpath</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xOpen</name></name> <operator>=</operator> <name>testEnvOpen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xRead</name></name> <operator>=</operator> <name>testEnvRead</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xWrite</name></name> <operator>=</operator> <name>testEnvWrite</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xTruncate</name></name> <operator>=</operator> <name>testEnvTruncate</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xSync</name></name> <operator>=</operator> <name>testEnvSync</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xSectorSize</name></name> <operator>=</operator> <name>testEnvSectorSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xRemap</name></name> <operator>=</operator> <name>testEnvRemap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xFileid</name></name> <operator>=</operator> <name>testEnvFileid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xClose</name></name> <operator>=</operator> <name>testEnvClose</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xUnlink</name></name> <operator>=</operator> <name>testEnvUnlink</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xLock</name></name> <operator>=</operator> <name>testEnvLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xTestLock</name></name> <operator>=</operator> <name>testEnvTestLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xShmBarrier</name></name> <operator>=</operator> <name>testEnvShmBarrier</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xShmMap</name></name> <operator>=</operator> <name>testEnvShmMap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xShmUnmap</name></name> <operator>=</operator> <name>testEnvShmUnmap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>env</name><operator>.</operator><name>xSleep</name></name> <operator>=</operator> <name>testEnvSleep</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nThread</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsm_config_log</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>xLog</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_config_work_hook</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>xWorkHook</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>test_lsm_config_str</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zCfg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nThread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_open</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>eMode</name></name> <operator>=</operator> <name>nThread</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nThread</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testLsmStartWorkers</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>nThread</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zCfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>test_lsm_close</name><argument_list>(<argument><expr><operator>(</operator><name>TestDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <operator>(</operator><name>TestDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_lsm_open</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpec</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zSpec</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_lsm_small_open</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpec</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name> <init>= <expr><literal type="string">"page_size=256 block_size=64 mmap=1024"</literal></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_lsm_lomem_open</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpec</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
    <comment type="block">/* "max_freelist=4 autocheckpoint=32" */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name> <init>= 
    <expr><literal type="string">"page_size=256 block_size=64 autoflush=16 "</literal>
    <literal type="string">"autocheckpoint=32"</literal>
    <literal type="string">"mmap=0 "</literal></expr></init></decl>
  ;</decl_stmt>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_lsm_lomem2_open</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpec</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
    <comment type="block">/* "max_freelist=4 autocheckpoint=32" */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name> <init>= 
    <expr><literal type="string">"page_size=512 block_size=64 autoflush=0 mmap=0 "</literal></expr></init></decl>
  ;</decl_stmt>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_lsm_zip_open</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpec</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name> <init>= 
    <expr><literal type="string">"page_size=256 block_size=64 autoflush=16 "</literal>
    <literal type="string">"autocheckpoint=32 compression=1 mmap=0 "</literal></expr></init></decl>
  ;</decl_stmt>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>lsm_db</name> <modifier>*</modifier></type><name>tdb_lsm</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><operator>==</operator><name>test_lsm_close</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name><operator>)</operator><operator>-&gt;</operator><name>db</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tdb_lsm_multithread</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>LsmDb</name><operator>*</operator><operator>)</operator><name>pDb</name><operator>)</operator><operator>-&gt;</operator><name>eMode</name><operator>!=</operator><name>LSMTEST_MODE_SINGLETHREAD</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_enable_log</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bEnable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm_config_log</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bEnable</name></expr> ?</condition><then> <expr><name>xLog</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="string">"client"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_application_crash</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bCrashed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_prepare_system_crash</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bPrepareCrash</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_system_crash</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bCrashed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doSystemCrash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_safety</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name><operator>==</operator><name>LSM_SAFETY_OFF</name> 
       <operator>||</operator> <name>eMode</name><operator>==</operator><name>LSM_SAFETY_NORMAL</name> 
       <operator>||</operator> <name>eMode</name><operator>==</operator><name>LSM_SAFETY_FULL</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iParam</name> <init>= <expr><name>eMode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsm_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>LSM_CONFIG_SAFETY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_prepare_sync_crash</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSync</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSync</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoCrash</name></name> <operator>=</operator> <name>iSync</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bPrepareCrash</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_config_work_hook</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xWork</name>)<parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pWorkCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xWork</name></name> <operator>=</operator> <name>xWork</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWorkCtx</name></name> <operator>=</operator> <name>pWorkCtx</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tdb_lsm_write_hook</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xWrite</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>lsm_i64</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pWriteCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xWriteHook</name></name> <operator>=</operator> <name>xWrite</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWriteCtx</name></name> <operator>=</operator> <name>pWriteCtx</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tdb_lsm_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>

<comment type="block">/*
** Signal worker thread iWorker that there may be work to do.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mt_signal_worker</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iWorker</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmWorker</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aWorker</name><index>[<expr><name>iWorker</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bDoWork</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine is used as the main() for all worker threads.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>worker_main</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmWorker</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LsmWorker</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>                <comment type="block">/* Connection to access db through */</comment>

  <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>pWorker</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Do some work. If an error occurs, exit. */</comment>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>LSMTEST_THREAD_CKPT</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nKB</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_info</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>LSM_INFO_CHECKPOINT_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nKB</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>nMtMinCkpt</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_checkpoint</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name></decl>;</decl_stmt>
      <do>do <block>{<block_content>

        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>LSMTEST_THREAD_WORKER</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>waitOnCheckpointer</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_work</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>LSMTEST_THREAD_WORKER</name> <operator>&amp;&amp;</operator> <name>nWrite</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>mt_signal_worker</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name>nWrite</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr> )</condition>;</do>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>worker_rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The thread will wake up when it is signaled either because another
    ** thread has created some work for this one or because the connection
    ** is being closed.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bDoWork</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bDoWork</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>mt_stop_worker</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iWorker</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmWorker</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aWorker</name><index>[<expr><name>iWorker</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pDummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>

    <comment type="block">/* Signal the worker to stop */</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWorker</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Join the worker thread. */</comment>
    <expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>worker_thread</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Free resources allocated in mt_start_worker() */</comment>
    <expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_close</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mt_shutdown</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nWorker</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>mt_stop_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** This callback is invoked by LSM when the client database writes to
** the database file (i.e. to flush the contents of the in-memory tree).
** This implies there may be work to do on the database, so signal
** the worker threads.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mt_client_work_hook</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* LsmDb database handle */</comment>

  <comment type="block">/* Invoke the user level work-hook, if any. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorkCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Wake up worker thread 0. */</comment>
  <expr_stmt><expr><call><name>mt_signal_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mt_worker_work_hook</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>(</operator><name>LsmDb</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* LsmDb database handle */</comment>

  <comment type="block">/* Invoke the user level work-hook, if any. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorkCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Launch worker thread iWorker for database connection pDb.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mt_start_worker</name><parameter_list>(
  <parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                     <comment type="block">/* Main database structure */</comment>
  <parameter><decl><type><name>int</name></type> <name>iWorker</name></decl></parameter>,                    <comment type="block">/* Worker number to start */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,          <comment type="block">/* File name of database to open */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name></decl></parameter>,               <comment type="block">/* Connection configuration string */</comment>
  <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>                       <comment type="block">/* Type of worker thread */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>LsmWorker</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                   <comment type="block">/* Object to initialize */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iWorker</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nWorker</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>LSMTEST_THREAD_CKPT</name> 
       <operator>||</operator> <name>eType</name><operator>==</operator><name>LSMTEST_THREAD_WORKER</name> 
       <operator>||</operator> <name>eType</name><operator>==</operator><name>LSMTEST_THREAD_WORKER_AC</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aWorker</name><index>[<expr><name>iWorker</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>

  <comment type="block">/* Open the worker connection */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCfg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>test_lsm_config_str</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zCfg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_open</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lsm_config_log</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>xLog</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="string">"worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Configure the work-hook */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsm_config_work_hook</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><name>mt_worker_work_hook</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>LSMTEST_THREAD_WORKER</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>test_lsm_config_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"autocheckpoint=0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Kick off the worker thread. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_cond</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_mutex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>worker_thread</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>worker_main</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>testLsmStartWorkers</name><parameter_list>(
  <parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eModel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>eModel</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>eModel</name></expr></argument>&gt;</argument_list></name><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>eModel</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Configure a work-hook for the client connection. Worker 0 is signalled
  ** every time the users connection writes to the database.  */</comment>
  <expr_stmt><expr><call><name>lsm_config_work_hook</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>mt_client_work_hook</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate space for two worker connections. They may not both be
  ** used, but both are allocated.  */</comment>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>aWorker</name></name> <operator>=</operator> <operator>(</operator><name>LsmWorker</name> <operator>*</operator><operator>)</operator><call><name>testMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmWorker</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aWorker</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmWorker</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>eModel</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>LSMTEST_MODE_BACKGROUND_CKPT</name></expr>:</case>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nWorker</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>test_lsm_config_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"autocheckpoint=0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mt_start_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>LSMTEST_THREAD_CKPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>LSMTEST_MODE_BACKGROUND_WORK</name></expr>:</case>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nWorker</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>test_lsm_config_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"autowork=0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mt_start_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>LSMTEST_THREAD_WORKER_AC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>LSMTEST_MODE_BACKGROUND_BOTH</name></expr>:</case>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nWorker</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>test_lsm_config_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"autowork=0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mt_start_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>LSMTEST_THREAD_WORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mt_start_worker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>LSMTEST_THREAD_CKPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>test_lsm_mt2</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpec</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name> <init>= <expr><literal type="string">"mt_mode=2"</literal></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_lsm_mt3</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpec</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCfg</name> <init>= <expr><literal type="string">"mt_mode=4"</literal></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>testLsmOpen</name><argument_list>(<argument><expr><name>zCfg</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mt_shutdown</name><parameter_list>(<parameter><decl><type><name>LsmDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list> <block>{<block_content> 
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>
<function><type><name>int</name></type> <name>test_lsm_mt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, <parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>bClear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"threads unavailable - recompile with LSM_MUTEX_PTHREADS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
