<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/lsm1/lsm-test/lsmtest8.c">
<comment type="block">/*
** This file contains test cases to verify that "live-recovery" following
** a mid-transaction failure of a writer process.
*/</comment>


<comment type="block">/* 
** This test file includes lsmInt.h to get access to the definition of the
** ShmHeader structure. This is required to cause strategic damage to the
** shared memory header as part of recovery testing.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmInt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmtest.h"</cpp:file></cpp:include>

<typedef>typedef <type><name><name>struct</name> <name>SetupStep</name></name></type> <name>SetupStep</name>;</typedef>
<struct>struct <name>SetupStep</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bFlush</name></decl>;</decl_stmt>                     <comment type="block">/* Flush to disk and checkpoint */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iInsStart</name></decl>;</decl_stmt>                  <comment type="block">/* First key-value from ds to insert */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIns</name></decl>;</decl_stmt>                       <comment type="block">/* Number of rows to insert */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDelStart</name></decl>;</decl_stmt>                  <comment type="block">/* First key from ds to delete */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDel</name></decl>;</decl_stmt>                       <comment type="block">/* Number of rows to delete */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doSetupStep</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>SetupStep</name> <modifier>*</modifier></type><name>pStep</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testWriteDatasourceRange</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>iInsStart</name></name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>nIns</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testDeleteDatasourceRange</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>iDelStart</name></name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>nDel</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSave</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>lsm_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_CONFIG_AUTOFLUSH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_CONFIG_AUTOFLUSH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_begin</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_commit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_CONFIG_AUTOFLUSH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>lsm_work</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>lsm_checkpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doSetupStepArray</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>SetupStep</name> <modifier>*</modifier></type><name>aStep</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nStep</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nStep</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>doSetupStep</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aStep</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setupDatabase1</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Datasource</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>SetupStep</name></type> <name><name>aStep</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="number">0</literal></expr>,                                  <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">2000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="number">1</literal></expr>,                                  <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="number">0</literal></expr>,                                  <expr><literal type="number">10001</literal></expr>, <expr><literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>DatasourceDefn</name></type> <name>defn</name> <init>= <expr><block>{<expr><name>TEST_DATASOURCE_RANDOM</name></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">500</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>testDatasourceNew</name><argument_list>(<argument><expr><operator>&amp;</operator><name>defn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doSetupStepArray</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>aStep</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aStep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ppData</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testDatasourceFree</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<function><type><name>void</name></type> <name>testReadFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>!=</operator><call><name>fseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nByte</name><operator>!=</operator><call><name>fread</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>testWriteFile</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iOff</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"r+b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>!=</operator><call><name>fseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nByte</name><operator>!=</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ShmHeader</name> <modifier>*</modifier></type><name>getShmHeader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zShm</name> <init>= <expr><call><name>testMallocPrintf</name><argument_list>(<argument><expr><literal type="string">"%s-shm"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pHdr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pHdr</name> <operator>=</operator> <call><name>testMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testReadFile</name><argument_list>(<argument><expr><name>zShm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>pHdr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function makes a copy of the three files associated with LSM 
** database zDb (i.e. if zDb is "test.db", it makes copies of "test.db",
** "test.db-log" and "test.db-shm").
**
** It then opens a new database connection to the copy with the xLock() call
** instrumented so that it appears that some other process already connected
** to the db (holding a shared lock on DMS2). This prevents recovery from
** running. Then:
**
**    1) Check that the checksum of the database is zCksum. 
**    2) Write a few keys to the database. Then delete the same keys. 
**    3) Check that the checksum is zCksum.
**    4) Flush the db to disk and run a checkpoint. 
**    5) Check once more that the checksum is still zCksum.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>doLiveRecovery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCksum</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>DatasourceDefn</name></type> <name>defn</name> <init>= <expr><block>{<expr><name>TEST_DATASOURCE_RANDOM</name></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">500</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCopy</name> <init>= <expr><literal type="string">"testcopy.lsm"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zCksum2</name><index>[<expr><name>TEST_CKSUM_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>testDatasourceNew</name><argument_list>(<argument><expr><operator>&amp;</operator><name>defn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>testCopyLsmdb</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_lsm_open</name><argument_list>(<argument><expr><literal type="string">"test_no_recovery=1"</literal></expr></argument>, <argument><expr><name>zCopy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pHdr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testCksumDatabase</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testCompareStr</name><argument_list>(<argument><expr><name>zCksum</name></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>testWriteDatasourceRange</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testDeleteDatasourceRange</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Test that the two tree-headers are now consistent. */</comment>
      <expr_stmt><expr><name>pHdr</name> <operator>=</operator> <call><name>getShmHeader</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pHdr</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name>pHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsm_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_CONFIG_AUTOFLUSH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsm_begin</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsm_commit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_work</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>testCksumDatabase</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testCompareStr</name><argument_list>(<argument><expr><name>zCksum</name></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>testDatasourceFree</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testDeleteLsmdb</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doWriterCrash1</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">2000</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nStep</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iWriteStart</name> <init>= <expr><literal type="number">20000</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_lsm_open</name><argument_list>(<argument><expr><literal type="string">"autowork=0"</literal></expr></argument>, <argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zCksum</name><index>[<expr><name>TEST_CKSUM_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setupDatabase1</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testCksumDatabase</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testBegin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nWrite</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>nStep</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>testCaseProgress</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>, <argument><expr><call><name>testCaseNDot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testWriteDatasourceRange</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>iWriteStart</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>nStep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>doLiveRecovery</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><name>zCksum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testCommit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testDatasourceFree</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This test case verifies that inconsistent tree-headers in shared-memory
** are resolved correctly. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>doWriterCrash2</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_lsm_open</name><argument_list>(<argument><expr><literal type="string">"autowork=0"</literal></expr></argument>, <argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pHdr1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pHdr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zCksum1</name><index>[<expr><name>TEST_CKSUM_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zCksum2</name><index>[<expr><name>TEST_CKSUM_BYTES</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pHdr1</name> <operator>=</operator> <call><name>testMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pHdr2</name> <operator>=</operator> <call><name>testMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setupDatabase1</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Grab a copy of the shared-memory header. And the db checksum */</comment>
    <expr_stmt><expr><call><name>testReadFile</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm-shm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHdr1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testCksumDatabase</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zCksum1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Modify the database */</comment>
    <expr_stmt><expr><call><name>testBegin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testWriteDatasourceRange</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><literal type="number">30000</literal></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testCommit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Grab a second copy of the shared-memory header. And the db checksum */</comment>
    <expr_stmt><expr><call><name>testReadFile</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm-shm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHdr2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testCksumDatabase</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doLiveRecovery</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If both tree-headers are valid, tree-header-1 is used. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr1</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pHdr1</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>bWriter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testWriteFile</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm-shm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHdr2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doLiveRecovery</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><name>zCksum1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If both tree-headers are valid, tree-header-1 is used. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pHdr1</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr1</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pHdr1</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>bWriter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testWriteFile</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm-shm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHdr2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doLiveRecovery</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If tree-header 1 is invalid, tree-header-2 is used */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pHdr1</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr1</name><operator>.</operator><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr1</name><operator>.</operator><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>bWriter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testWriteFile</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm-shm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHdr2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doLiveRecovery</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If tree-header 2 is invalid, tree-header-1 is used */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pHdr1</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr2</name><operator>.</operator><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>hdr2</name><operator>.</operator><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHdr2</name><operator>-&gt;</operator><name>bWriter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testWriteFile</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm-shm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHdr2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doLiveRecovery</name><argument_list>(<argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><name>zCksum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name>pHdr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name>pHdr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>do_writer_crash_test</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct>struct <name>Test</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aTest</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"writercrash1.lsm"</literal></expr>, <expr><name>doWriterCrash1</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"writercrash2.lsm"</literal></expr>, <expr><name>doWriterCrash2</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aTest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>Test</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aTest</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>testCaseBegin</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>xFunc</name></name><argument_list>(<argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testCaseFinish</name><argument_list>(<argument><expr><operator>*</operator><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

</block_content>}</block></function>
</unit>
