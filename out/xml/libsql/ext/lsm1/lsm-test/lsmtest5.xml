<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/lsm1/lsm-test/lsmtest5.c">
<comment type="block">/*
** This file is broken into three semi-autonomous parts:
**
**   1. The database functions.
**   2. The thread wrappers.
**   3. The implementation of the mt1.* tests.
*/</comment>

<comment type="block" format="doxygen">/*************************************************************************
** DATABASE CONTENTS:
**
**   The database contains up to N key/value pairs, where N is some large 
**   number (say 10,000,000). Keys are integer values between 0 and (N-1).
**   The value associated with each key is a pseudo-random blob of data.
**
**   Key/value pair keys are encoded as the two bytes "k." followed by a 
**   10-digit decimal number. i.e. key 45 -&gt; "k.0000000045".
**
**   As well as the key/value pairs, the database also contains checksum 
**   entries. The checksums form a hierarchy - for every F key/value
**   entries there is one level 1 checksum. And for each F level 1 checksums
**   there is one level 2 checksum. And so on.
**
**   Checksum keys are encoded as the two byte "c." followed by the 
**   checksum level, followed by a 10 digit decimal number containing
**   the value of the first key that contributes to the checksum value.
**   For example, assuming F==10, the level 1 checksum that spans keys
**   10 to 19 is "c.1.0000000010".
**
**   Clients may perform one of two operations on the database: a read
**   or a write.
** 
** READ OPERATIONS:
**
**   A read operation scans a range of F key/value pairs. It computes
**   the expected checksum and then compares the computed value to the
**   actual value stored in the level 1 checksum entry. It then scans 
**   the group of F level 1 checksums, and compares the computed checksum 
**   to the associated level 2 checksum value, and so on until the 
**   highest level checksum value has been verified.
**
**   If a checksum ever fails to match the expected value, the test 
**   has failed.
**
** WRITE OPERATIONS:
**
**   A write operation involves writing (possibly clobbering) a single
**   key/value pair. The associated level 1 checksum is then recalculated
**   updated. Then the level 2 checksum, and so on until the highest
**   level checksum has been modified.
**
**   All updates occur inside a single transaction.
**
** INTERFACE:
**
**   The interface used by test cases to read and write the db consists
**   of type DbParameters and the following functions:
**
**       dbReadOperation()
**       dbWriteOperation()
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmtest.h"</cpp:file></cpp:include>

<typedef>typedef <type><name><name>struct</name> <name>DbParameters</name></name></type> <name>DbParameters</name>;</typedef>
<struct>struct <name>DbParameters</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nFanout</name></decl>;</decl_stmt>                    <comment type="block">/* Checksum fanout (F) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>                       <comment type="block">/* Size of key space (N) */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_KEY_BYTES</name></cpp:macro>          <cpp:value>(2+5+10+1)</cpp:value></cpp:define>

<comment type="block">/*
** Argument aBuf[] must point to a buffer at least DB_KEY_BYTES in size.
** This function populates the buffer with a nul-terminated key string 
** corresponding to key iKey.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dbFormatKey</name><parameter_list>(
  <parameter><decl><type><name>DbParameters</name> <modifier>*</modifier></type><name>pParam</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iKey</name></decl></parameter>,                       <comment type="block">/* Key value */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>                      <comment type="block">/* Write key string here */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>DB_KEY_BYTES</name></expr></argument>, <argument><expr><literal type="string">"k.%.10d"</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iLevel</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>f</name> <operator>=</operator> <name>f</name> <operator>*</operator> <name><name>pParam</name><operator>-&gt;</operator><name>nFanout</name></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>DB_KEY_BYTES</name></expr></argument>, <argument><expr><literal type="string">"c.%d.%.10d"</literal></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>f</name><operator>*</operator><operator>(</operator><name>iKey</name><operator>/</operator><name>f</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Argument aBuf[] must point to a buffer at least DB_KEY_BYTES in size.
** This function populates the buffer with the string representation of
** checksum value iVal.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dbFormatCksumValue</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>iVal</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>DB_KEY_BYTES</name></expr></argument>, <argument><expr><literal type="string">"%.10u"</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the highest level of checksum in the database described
** by *pParam.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbMaxLevel</name><parameter_list>(<parameter><decl><type><name>DbParameters</name> <modifier>*</modifier></type><name>pParam</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iMax</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>iMax</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name><name>pParam</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</condition> <incr><expr><name>iMax</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <name><name>pParam</name><operator>-&gt;</operator><name>nFanout</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>iMax</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dbCksum</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Pointer to u32 containing cksum */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Database key. Unused. */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>            <comment type="block">/* Database value. Checksum this. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aVal</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>pCksum</name> <init>= <expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name> <init>= <expr><operator>*</operator><name>pCksum</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>cksum</name> <operator>+=</operator> <operator>(</operator><name>cksum</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>aVal</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>pCksum</name> <operator>=</operator> <name>cksum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compute the value of the checksum stored on level iLevel that contains
** data from key iKey by scanning the pParam-&gt;nFanout entries at level 
** iLevel-1.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>dbComputeCksum</name><parameter_list>(
  <parameter><decl><type><name>DbParameters</name> <modifier>*</modifier></type><name>pParam</name></decl></parameter>,           <comment type="block">/* Database parameters */</comment>
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database connection handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,                     <comment type="block">/* Level of checksum to compute */</comment>
  <parameter><decl><type><name>int</name></type> <name>iKey</name></decl></parameter>,                       <comment type="block">/* Compute checksum for this key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nFirst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nLast</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zFirst</name><index>[<expr><name>DB_KEY_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zLast</name><index>[<expr><name>DB_KEY_BYTES</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iLevel</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>f</name> <operator>=</operator> <name>f</name> <operator>*</operator> <name><name>pParam</name><operator>-&gt;</operator><name>nFanout</name></name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <name>f</name><operator>*</operator><operator>(</operator><name>iKey</name><operator>/</operator><name>f</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLast</name> <operator>=</operator> <name>iFirst</name> <operator>+</operator> <name>f</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbFormatKey</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><name>iLevel</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>zFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbFormatKey</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><name>iLevel</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLast</name></expr></argument>, <argument><expr><name>zLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFirst</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLast</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>tdb_scan</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>cksum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFirst</name></expr></argument>, <argument><expr><name>nFirst</name></expr></argument>, <argument><expr><name>zLast</name></expr></argument>, <argument><expr><name>nLast</name></expr></argument>,<argument><expr><name>dbCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>cksum</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dbReadOperation</name><parameter_list>(
  <parameter><decl><type><name>DbParameters</name> <modifier>*</modifier></type><name>pParam</name></decl></parameter>,           <comment type="block">/* Database parameters */</comment>
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database connection handle */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDelay</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pDelayCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iKey</name></decl></parameter>,                       <comment type="block">/* Key to read */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iMax</name> <init>= <expr><call><name>dbMaxLevel</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>tdb_transaction_support</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testBegin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><name>iMax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zCksum</name><index>[<expr><name>DB_KEY_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zKey</name><index>[<expr><name>DB_KEY_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iCksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>iCksum</name> <operator>=</operator> <call><name>dbComputeCksum</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCksum</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>xDelay</name> <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xDelay</name><argument_list>(<argument><expr><name>pDelayCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>dbFormatCksumValue</name><argument_list>(<argument><expr><name>iCksum</name></expr></argument>, <argument><expr><name>zCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dbFormatKey</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testFetchStr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>zCksum</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_transaction_support</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testCommit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dbWriteOperation</name><parameter_list>(
  <parameter><decl><type><name>DbParameters</name> <modifier>*</modifier></type><name>pParam</name></decl></parameter>,           <comment type="block">/* Database parameters */</comment>
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database connection handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iKey</name></decl></parameter>,                       <comment type="block">/* Key to write to */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zValue</name></decl></parameter>,             <comment type="block">/* Nul-terminated value to write */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iMax</name> <init>= <expr><call><name>dbMaxLevel</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zKey</name><index>[<expr><name>DB_KEY_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iKey</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iKey</name><operator>&lt;</operator><name><name>pParam</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dbFormatKey</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open a write transaction. This may fail - SQLITE4_BUSY */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>tdb_transaction_support</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_begin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">5</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>testWriteStr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>zValue</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iMax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zCksum</name><index>[<expr><name>DB_KEY_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iCksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>iCksum</name> <operator>=</operator> <call><name>dbComputeCksum</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbFormatCksumValue</name><argument_list>(<argument><expr><name>iCksum</name></expr></argument>, <argument><expr><name>zCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbFormatKey</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testWriteStr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>zCksum</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>tdb_transaction_support</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testCommit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************************************************************************
** The following block contains testXXX() functions that implement a
** wrapper around the systems native multi-thread support. There are no
** synchronization primitives - just functions to launch and join 
** threads. Wrapper functions are:
**
**    testThreadSupport()
**
**    testThreadInit()
**    testThreadShutdown()
**    testThreadLaunch()
**    testThreadWait()
**
**    testThreadSetHalt()
**    testThreadGetHalt()
**    testThreadSetResult()
**    testThreadGetResult()
**
**    testThreadEnterMutex()
**    testThreadLeaveMutex()
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ThreadSet</name></name></type> <name>ThreadSet</name>;</typedef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_MUTEX_PTHREADS</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><name><name>struct</name> <name>Thread</name></name></type> <name>Thread</name>;</typedef>
<struct>struct <name>Thread</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>id</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xMain</name>)<parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>ThreadSet</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bHalt</name></decl>;</decl_stmt>                      <comment type="block">/* Halt flag */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nThread</name></decl>;</decl_stmt>                    <comment type="block">/* Number of threads */</comment>
  <decl_stmt><decl><type><name>Thread</name> <modifier>*</modifier></type><name>aThread</name></decl>;</decl_stmt>                <comment type="block">/* Array of Thread structures */</comment>
  <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>mutex</name></decl>;</decl_stmt>          <comment type="block">/* Mutex used for cheating */</comment>
}</block>;</struct>

<comment type="block">/*
** Return true if this build supports threads, or false otherwise. If
** this function returns false, no other testThreadXXX() functions should
** be called.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testThreadSupport</name><parameter_list>()</parameter_list><block>{<block_content> <return>return <expr><literal type="number">1</literal></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** Allocate and return a thread-set handle with enough space allocated
** to handle up to nMax threads. Each call to this function should be
** matched by a call to testThreadShutdown() to delete the object.
*/</comment>
<function><type><specifier>static</specifier> <name>ThreadSet</name> <modifier>*</modifier></type><name>testThreadInit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Total space to allocate */</comment>
  <decl_stmt><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                   <comment type="block">/* Return value */</comment>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ThreadSet</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>Thread</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nMax</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>ThreadSet</name> <operator>*</operator><operator>)</operator><call><name>testMalloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nThread</name></name> <operator>=</operator> <name>nMax</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aThread</name></name> <operator>=</operator> <operator>(</operator><name>Thread</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a thread-set object and release all resources held by it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testThreadShutdown</name><parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nThread</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ttMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Thread</name> <modifier>*</modifier></type><name>pThread</name> <init>= <expr><operator>(</operator><name>Thread</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iThread</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>iThread</name> <operator>=</operator> <operator>(</operator><name>pThread</name> <operator>-</operator> <name><name>pThread</name><operator>-&gt;</operator><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pThread</name><operator>-&gt;</operator><name>xMain</name></name><argument_list>(<argument><expr><name><name>pThread</name><operator>-&gt;</operator><name>pThreadSet</name></name></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><name><name>pThread</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Launch a new thread.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testThreadLaunch</name><parameter_list>(
  <parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iThread</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xMain</name>)<parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Thread</name> <modifier>*</modifier></type><name>pThread</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iThread</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iThread</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nThread</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pThread</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>iThread</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pThread</name><operator>-&gt;</operator><name>pThreadSet</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pThread</name><operator>-&gt;</operator><name>xMain</name></name> <operator>=</operator> <name>xMain</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pThread</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pThread</name><operator>-&gt;</operator><name>pThreadSet</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pThread</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ttMain</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pThread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the thread-set "halt" flag.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testThreadSetHalt</name><parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pThreadSet</name><operator>-&gt;</operator><name>bHalt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the current value of the thread-set "halt" flag.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testThreadGetHalt</name><parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pThreadSet</name><operator>-&gt;</operator><name>bHalt</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>testThreadSleep</name><parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>nMs</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>testThreadGetHalt</name><argument_list>(<argument><expr><name>pThreadSet</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">50000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <literal type="number">50</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Wait for all threads launched to finish before returning. If nMs
** is greater than zero, set the "halt" flag to tell all threads
** to halt after waiting nMs milliseconds.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testThreadWait</name><parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>testThreadSleep</name><argument_list>(<argument><expr><name>pThreadSet</name></expr></argument>, <argument><expr><name>nMs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testThreadSetHalt</name><argument_list>(<argument><expr><name>pThreadSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pThreadSet</name><operator>-&gt;</operator><name>nThread</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Thread</name> <modifier>*</modifier></type><name>pThread</name> <init>= <expr><operator>&amp;</operator><name><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pThread</name><operator>-&gt;</operator><name>xMain</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>pThread</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Set the result for thread iThread. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testThreadSetResult</name><parameter_list>(
  <parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl></parameter>,          <comment type="block">/* Thread-set handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iThread</name></decl></parameter>,                    <comment type="block">/* Set result for this thread */</comment>
  <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>,                         <comment type="block">/* Result error code */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>,                     <comment type="block">/* Result string format */</comment>
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>                             <comment type="block">/* Result string formatting args... */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>testFree</name><argument_list>(<argument><expr><name><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>iThread</name></expr>]</index></name><operator>.</operator><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>iThread</name></expr>]</index></name><operator>.</operator><name>rc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>iThread</name></expr>]</index></name><operator>.</operator><name>zMsg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFmt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>iThread</name></expr>]</index></name><operator>.</operator><name>zMsg</name> <operator>=</operator> <call><name>testMallocVPrintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Retrieve the result for thread iThread. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testThreadGetResult</name><parameter_list>(
  <parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl></parameter>,          <comment type="block">/* Thread-set handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iThread</name></decl></parameter>,                    <comment type="block">/* Get result for this thread */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzRes</name></decl></parameter>              <comment type="block">/* OUT: Pointer to result string */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pzRes</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzRes</name> <operator>=</operator> <name><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>iThread</name></expr>]</index></name><operator>.</operator><name>zMsg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pThreadSet</name><operator>-&gt;</operator><name>aThread</name><index>[<expr><name>iThread</name></expr>]</index></name><operator>.</operator><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Enter and leave the test case mutex.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void testThreadEnterMutex(ThreadSet *p){
  pthread_mutex_lock(&amp;p-&gt;mutex);
}
static void testThreadLeaveMutex(ThreadSet *p){
  pthread_mutex_unlock(&amp;p-&gt;mutex);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LSM_MUTEX_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testThreadSupport</name><parameter_list>()</parameter_list><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadInit</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadShutdown</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadLaunch</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadWait</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadSetHalt</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadGetHalt</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadGetResult</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testThreadSleep</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>testThreadSetResult</name><parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* End of threads wrapper.
*************************************************************************/</comment>

<comment type="block" format="doxygen">/*************************************************************************
** Below this point is the third part of this file - the implementation
** of the mt1.* tests.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>Mt1Test</name></name></type> <name>Mt1Test</name>;</typedef>
<struct>struct <name>Mt1Test</name> <block>{
  <decl_stmt><decl><type><name>DbParameters</name></type> <name>param</name></decl>;</decl_stmt>             <comment type="block">/* Description of database to read/write */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReadwrite</name></decl>;</decl_stmt>                 <comment type="block">/* Number of read/write threads */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFastReader</name></decl>;</decl_stmt>                <comment type="block">/* Number of fast reader threads */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSlowReader</name></decl>;</decl_stmt>                <comment type="block">/* Number of slow reader threads */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMs</name></decl>;</decl_stmt>                        <comment type="block">/* How long to run for */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSystem</name></decl>;</decl_stmt>            <comment type="block">/* Database system to test */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>Mt1DelayCtx</name></name></type> <name>Mt1DelayCtx</name>;</typedef>
<struct>struct <name>Mt1DelayCtx</name> <block>{
  <decl_stmt><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pSet</name></decl>;</decl_stmt>                <comment type="block">/* Threadset to sleep within */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMs</name></decl>;</decl_stmt>                        <comment type="block">/* Sleep in ms */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xMt1Delay</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mt1DelayCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Mt1DelayCtx</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testThreadSleep</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSet</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nMs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MT1_THREAD_RDWR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MT1_THREAD_SLOW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MT1_THREAD_FAST</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xMt1Work</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  char *z = 0;
  lsm_info(pDb, LSM_INFO_DB_STRUCTURE, &amp;z);
  printf("%s\n", z);
  fflush(stdout);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** This is the main() proc for all threads in test case "mt1".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mt1Main</name><parameter_list>(<parameter><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pThreadSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iThread</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mt1Test</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Mt1Test</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Test parameters */</comment>
  <decl_stmt><decl><type><name>Mt1DelayCtx</name></type> <name>delay</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Number of calls to dbReadOperation() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of completed database writes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Error code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrng</name></decl>;</decl_stmt>                      <comment type="block">/* Prng argument variable */</comment>
  <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>delay</name><operator>.</operator><name>pSet</name></name> <operator>=</operator> <name>pThreadSet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>delay</name><operator>.</operator><name>nMs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iThread</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nReadwrite</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>MT1_THREAD_RDWR</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iThread</name><operator>&lt;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nReadwrite</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nFastReader</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>MT1_THREAD_FAST</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>MT1_THREAD_SLOW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>delay</name><operator>.</operator><name>nMs</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMs</name></name> <operator>/</operator> <literal type="number">20</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Open a new database connection. Initialize the pseudo-random number
  ** argument based on the thread number.  */</comment>
  <expr_stmt><expr><name>iPrng</name> <operator>=</operator> <call><name>testPrngValue</name><argument_list>(<argument><expr><name>iThread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <call><name>testOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSystem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>tdb_lsm_config_work_hook</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>xMt1Work</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Loop until either an error occurs or some other thread sets the
  ** halt flag.  */</comment>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>testThreadGetHalt</name><argument_list>(<argument><expr><name>pThreadSet</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>

    <comment type="block">/* Perform a read operation on an arbitrarily selected key. */</comment>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><call><name>testPrngValue</name><argument_list>(<argument><expr><name>iPrng</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>%</operator> <name><name>p</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nKey</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbReadOperation</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>param</name></name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>xMt1Delay</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>delay</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nRead</name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Attempt to write an arbitrary key value pair (and update the associated
    ** checksum entries). dbWriteOperation() returns 1 if the write is
    ** successful, or 0 if it failed with an LSM_BUSY error.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>MT1_THREAD_RDWR</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>aValue</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>aRnd</name><index>[<expr><literal type="number">25</literal></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>(</operator><call><name>testPrngValue</name><argument_list>(<argument><expr><name>iPrng</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>%</operator> <name><name>p</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nKey</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testPrngString</name><argument_list>(<argument><expr><name>iPrng</name></expr></argument>, <argument><expr><name>aRnd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aRnd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPrng</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aRnd</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d.%s"</literal></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><name>aRnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nWrite</name> <operator>+=</operator> <call><name>dbWriteOperation</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>param</name></name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>aValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If an error has occured, set the thread error code and the threadset 
  ** halt flag to tell the other test threads to halt. Otherwise, set the
  ** thread error code to 0 and post a message with the number of read
  ** and write operations completed.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testThreadSetResult</name><argument_list>(<argument><expr><name>pThreadSet</name></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testThreadSetHalt</name><argument_list>(<argument><expr><name>pThreadSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testThreadSetResult</name><argument_list>(<argument><expr><name>pThreadSet</name></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"r/w: %d/%d"</literal></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_test_mt1</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSystem</name></decl></parameter>,            <comment type="block">/* Database system name */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>,           <comment type="block">/* Run test cases that match this pattern */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mt1Test</name></type> <name><name>aTest</name><index>[]</index></name> <init>= <expr><block>{
    <comment type="block">/* param, nReadwrite, nFastReader, nSlowReader, nMs, zSystem */</comment>
    <expr><block>{ <expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr>,     <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">10000</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr>,     <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">2</literal></expr>,   <expr><literal type="number">100000</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">100000</literal></expr>}</block></expr>,   <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">10000</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">100000</literal></expr>}</block></expr>,   <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">2</literal></expr>,   <expr><literal type="number">100000</literal></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aTest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Mt1Test</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aTest</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bRun</name> <init>= <expr><call><name>testCaseBegin</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, 
        <argument><expr><literal type="string">"mt1.%s.db=%d,%d.ms=%d.rdwr=%d.fast=%d.slow=%d"</literal></expr></argument>, 
        <argument><expr><name>zSystem</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nFanout</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nKey</name></name></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nMs</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nReadwrite</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFastReader</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSlowReader</name></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>bRun</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ThreadSet</name> <modifier>*</modifier></type><name>pSet</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iThread</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nThread</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zSystem</name></name> <operator>=</operator> <name>zSystem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDb</name> <operator>=</operator> <call><name>testOpen</name><argument_list>(<argument><expr><name>zSystem</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>nThread</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nReadwrite</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nFastReader</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nSlowReader</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSet</name> <operator>=</operator> <call><name>testThreadInit</name><argument_list>(<argument><expr><name>nThread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iThread</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iThread</name><operator>&lt;</operator><name>nThread</name></expr>;</condition> <incr><expr><name>iThread</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>testThreadLaunch</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><name>mt1Main</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><call><name>testThreadWait</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nMs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iThread</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iThread</name><operator>&lt;</operator><name>nThread</name></expr>;</condition> <incr><expr><name>iThread</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>testThreadGetResult</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>testCaseFinish</name><argument_list>(<argument><expr><operator>*</operator><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>iThread</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iThread</name><operator>&lt;</operator><name>nThread</name></expr>;</condition> <incr><expr><name>iThread</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>testThreadGetResult</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Info: thread %d (%d): %s\n"</literal></expr></argument>, <argument><expr><name>iThread</name></expr></argument>, <argument><expr><operator>*</operator><name>pRc</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><call><name>testThreadShutdown</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>test_mt</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSystem</name></decl></parameter>,            <comment type="block">/* Database system name */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>,           <comment type="block">/* Run test cases that match this pattern */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>testThreadSupport</name><argument_list>()</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>do_test_mt1</name><argument_list>(<argument><expr><name>zSystem</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
