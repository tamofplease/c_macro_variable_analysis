<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/lsm1/lsm_tree.c"><comment type="block">/*
** 2011-08-18
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains the implementation of an in-memory tree structure.
**
** Technically the tree is a B-tree of order 4 (in the Knuth sense - each 
** node may have up to 4 children). Keys are stored within B-tree nodes by
** reference. This may be slightly slower than a conventional red-black
** tree, but it is simpler. It is also an easier structure to modify to 
** create a version that supports nested transaction rollback.
**
** This tree does not currently support a delete operation. One is not 
** required. When LSM deletes a key from a database, it inserts a DELETE
** marker into the data structure. As a result, although the value associated
** with a key stored in the in-memory tree structure may be modified, no
** keys are ever removed. 
*/</comment>

<comment type="block">/*
** MVCC NOTES
**
**   The in-memory tree structure supports SQLite-style MVCC. This means
**   that while one client is writing to the tree structure, other clients
**   may still be querying an older snapshot of the tree.
**
**   One way to implement this is to use an append-only b-tree. In this 
**   case instead of modifying nodes in-place, a copy of the node is made
**   and the required modifications made to the copy. The parent of the
**   node is then modified (to update the pointer so that it points to
**   the new copy), which causes a copy of the parent to be made, and so on.
**   This means that each time the tree is written to a new root node is
**   created. A snapshot is identified by the root node that it uses.
**
**   The problem with the above is that each time the tree is written to,
**   a copy of the node structure modified and all of its ancestor nodes
**   is made. This may prove excessive with large tree structures.
**
**   To reduce this overhead, the data structure used for a tree node is
**   designed so that it may be edited in place exactly once without 
**   affecting existing users. In other words, the node structure is capable
**   of storing two separate versions of the node at the same time.
**   When a node is to be edited, if the node structure already contains 
**   two versions, a copy is made as in the append-only approach. Or, if
**   it only contains a single version, it is edited in place.
**
**   This reduces the overhead so that, roughly, one new node structure
**   must be allocated for each write (on top of those allocations that 
**   would have been required by a non-MVCC tree). Logic: Assume that at 
**   any time, 50% of nodes in the tree already contain 2 versions. When
**   a new entry is written to a node, there is a 50% chance that a copy
**   of the node will be required. And a 25% chance that a copy of its 
**   parent is required. And so on.
**
** ROLLBACK
**
**   The in-memory tree also supports transaction and sub-transaction 
**   rollback. In order to rollback to point in time X, the following is
**   necessary:
**
**     1. All memory allocated since X must be freed, and 
**     2. All "v2" data adding to nodes that existed at X should be zeroed.
**     3. The root node must be restored to its X value.
**
**   The Mempool object used to allocate memory for the tree supports 
**   operation (1) - see the lsmPoolMark() and lsmPoolRevert() functions.
**
**   To support (2), all nodes that have v2 data are part of a singly linked 
**   list, sorted by the age of the v2 data (nodes that have had data added 
**   most recently are at the end of the list). So to zero all v2 data added
**   since X, the linked list is traversed from the first node added following
**   X onwards.
**
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_LSM_INT_H</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"lsmInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DEPTH</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>TreeKey</name></name></type> <name>TreeKey</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>TreeNode</name></name></type> <name>TreeNode</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>TreeLeaf</name></name></type> <name>TreeLeaf</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>NodeVersion</name></name></type> <name>NodeVersion</name>;</typedef>

<struct>struct <name>TreeOld</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>iShmid</name></decl>;</decl_stmt>                     <comment type="block">/* Last shared-memory chunk in use by old */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRoot</name></decl>;</decl_stmt>                      <comment type="block">/* Offset of root node in shm file */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nHeight</name></decl>;</decl_stmt>                    <comment type="block">/* Height of tree structure */</comment>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** assert() that a TreeKey.flags value is sane. Usage:
**
**   assert( lsmAssertFlagsOk(pTreeKey-&gt;flags) );
*/</comment>
static int lsmAssertFlagsOk(u8 keyflags){
  <comment type="block">/* At least one flag must be set. Otherwise, what is this key doing? */</comment>
  assert( keyflags!=0 );

  <comment type="block">/* The POINT_DELETE and INSERT flags cannot both be set. */</comment>
  assert( (keyflags &amp; LSM_POINT_DELETE)==0 || (keyflags &amp; LSM_INSERT)==0 );

  <comment type="block">/* If both the START_DELETE and END_DELETE flags are set, then the INSERT
  ** flag must also be set. In other words - the three DELETE flags cannot
  ** all be set */</comment>
  assert( (keyflags &amp; LSM_END_DELETE)==0 
       || (keyflags &amp; LSM_START_DELETE)==0 
       || (keyflags &amp; LSM_POINT_DELETE)==0 
  );

  return 1;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>assert_delete_ranges_match</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>treeCountEntries</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Container for a key-value pair. Within the *-shm file, each key/value
** pair is stored in a single allocation (which may not actually be 
** contiguous in memory). Layout is the TreeKey structure, followed by
** the nKey bytes of key blob, followed by the nValue bytes of value blob
** (if nValue is non-negative).
*/</comment>
<struct>struct <name>TreeKey</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>                       <comment type="block">/* Size of pKey in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nValue</name></decl>;</decl_stmt>                     <comment type="block">/* Size of pValue. Or negative. */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>flags</name></decl>;</decl_stmt>                       <comment type="block">/* Various LSM_XXX flags */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKV_KEY</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void *)&amp;(p)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKV_VAL</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void *)(((u8 *)&amp;(p)[1]) + (p)-&gt;nKey))</cpp:value></cpp:define>

<comment type="block">/*
** A single tree node. A node structure may contain up to 3 key/value
** pairs. Internal (non-leaf) nodes have up to 4 children.
**
** TODO: Update the format of this to be more compact. Get it working
** first though...
*/</comment>
<struct>struct <name>TreeNode</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aiKeyPtr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>                <comment type="block">/* Array of pointers to TreeKey objects */</comment>

  <comment type="block">/* The following fields are present for interior nodes only, not leaves. */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aiChildPtr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>              <comment type="block">/* Array of pointers to child nodes */</comment>

  <comment type="block">/* The extra child pointer slot. */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iV2</name></decl>;</decl_stmt>                        <comment type="block">/* Transaction number of v2 */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>iV2Child</name></decl>;</decl_stmt>                    <comment type="block">/* apChild[] entry replaced by pV2Ptr */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iV2Ptr</name></decl>;</decl_stmt>                     <comment type="block">/* Substitute pointer */</comment>
}</block>;</struct>

<struct>struct <name>TreeLeaf</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aiKeyPtr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>                <comment type="block">/* Array of pointers to TreeKey objects */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>TreeBlob</name></name></type> <name>TreeBlob</name>;</typedef>
<struct>struct <name>TreeBlob</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Cursor for searching a tree structure.
**
** If a cursor does not point to any element (a.k.a. EOF), then the
** TreeCursor.iNode variable is set to a negative value. Otherwise, the
** cursor currently points to key aiCell[iNode] on node apTreeNode[iNode].
**
** Entries in the apTreeNode[] and aiCell[] arrays contain the node and
** index of the TreeNode.apChild[] pointer followed to descend to the 
** current element. Hence apTreeNode[0] always contains the root node of
** the tree.
*/</comment>
<struct>struct <name>TreeCursor</name> <block>{
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle for this cursor */</comment>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>pRoot</name></decl>;</decl_stmt>                <comment type="block">/* Root node and height of tree to access */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iNode</name></decl>;</decl_stmt>                      <comment type="block">/* Cursor points at apTreeNode[iNode] */</comment>
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name><name>apTreeNode</name><index>[<expr><name>MAX_DEPTH</name></expr>]</index></name></decl>;</decl_stmt><comment type="block">/* Current position in tree */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aiCell</name><index>[<expr><name>MAX_DEPTH</name></expr>]</index></name></decl>;</decl_stmt>           <comment type="block">/* Current position in tree */</comment>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pSave</name></decl>;</decl_stmt>                 <comment type="block">/* Saved key */</comment>
  <decl_stmt><decl><type><name>TreeBlob</name></type> <name>blob</name></decl>;</decl_stmt>                  <comment type="block">/* Dynamic storage for a key */</comment>
}</block>;</struct>

<comment type="block">/*
** A value guaranteed to be larger than the largest possible transaction
** id (TreeHeader.iTransId).
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORKING_VERSION</name></cpp:macro> <cpp:value>(1&lt;&lt;30)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tblobGrow</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>TreeBlob</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>lsmMallocRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tblobFree</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>TreeBlob</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
** Start of IntArray methods.  */</comment>
<comment type="block">/*
** Append value iVal to the contents of IntArray *p. Return LSM_OK if 
** successful, or LSM_NOMEM if an OOM condition is encountered.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>intArrayAppend</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>IntArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">128</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>lsmRealloc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aArray</name></name></expr></argument>, <argument><expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArray</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArray</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Zero the IntArray object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>intArrayFree</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>IntArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of entries currently in the int-array object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>intArraySize</name><parameter_list>(<parameter><decl><type><name>IntArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a copy of the iIdx'th entry in the int-array.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>intArrayEntry</name><parameter_list>(<parameter><decl><type><name>IntArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>aArray</name><index>[<expr><name>iIdx</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate the int-array so that all but the first nVal values are 
** discarded.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>intArrayTruncate</name><parameter_list>(<parameter><decl><type><name>IntArray</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nArray</name></name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* End of IntArray methods.
***********************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treeKeycmp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n1</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><call><name>LSM_MIN</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>n1</name><operator>-</operator><name>n2</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The pointer passed as the first argument points to an interior node,
** not a leaf. This function returns the offset of the iCell'th child
** sub-tree of the node.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>getChildPtr</name><parameter_list>(<parameter><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVersion</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iVersion</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCell</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCell</name><operator>&lt;=</operator><call><name>array_size</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiChildPtr</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iV2</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iV2</name></name><operator>&lt;=</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iVersion</name> <operator>&amp;&amp;</operator> <name>iCell</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>iV2Child</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>iV2Ptr</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iCell</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given an offset within the *-shm file, return the associated chunk number.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeOffsetToChunk</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>iOff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>LSM_SHM_CHUNK_SIZE</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">15</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iOff</name><operator>&gt;&gt;</operator><literal type="number">15</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>treeShmptrUnsafe</name><parameter_list>(<parameter><type><name>pDb</name></type></parameter>, <parameter><type><name>iPtr</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>(&amp;((u8*)((pDb)-&gt;apShm[(iPtr)&gt;&gt;15]))[(iPtr) &amp; (LSM_SHM_CHUNK_SIZE-1)])</cpp:value></cpp:define>

<comment type="block">/*
** Return a pointer to the mapped memory location associated with *-shm 
** file offset iPtr.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>treeShmptr</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iPtr</name></decl></parameter>)</parameter_list><block>{<block_content>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>iPtr</name><operator>&gt;&gt;</operator><literal type="number">15</literal><operator>)</operator><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pDb</name><operator>-&gt;</operator><name>nShm</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><name>iPtr</name><operator>&gt;&gt;</operator><literal type="number">15</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><ternary><condition><expr><name>iPtr</name></expr> ?</condition><then> <expr><call><name>treeShmptrUnsafe</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ShmChunk</name> <modifier>*</modifier></type> <name>treeShmChunk</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>ShmChunk</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ShmChunk</name> <modifier>*</modifier></type> <name>treeShmChunkRc</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iChunk</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nShm</name></name> <operator>||</operator> <name>LSM_OK</name><operator>==</operator><operator>(</operator><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>lsmShmCacheChunks</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iChunk</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>ShmChunk</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assertIsWorkingChild</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, 
  <parameter><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iPtr</name> <init>= <expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>treeShmptr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><name>pNode</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>assertIsWorkingChild</name><parameter_list>(<parameter><type><name>w</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Values for the third argument to treeShmkey(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKV_LOADKEY</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKV_LOADVAL</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>TreeKey</name> <modifier>*</modifier></type><name>treeShmkey</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iPtr</name></decl></parameter>,                       <comment type="block">/* Shmptr to TreeKey struct */</comment>
  <parameter><decl><type><name>int</name></type> <name>eLoad</name></decl></parameter>,                      <comment type="block">/* Either zero or a TREEKEY_LOADXXX value */</comment>
  <parameter><decl><type><name>TreeBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>,                <comment type="block">/* Used if dynamic memory is required */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLoad</name><operator>==</operator><name>TKV_LOADKEY</name> <operator>||</operator> <name>eLoad</name><operator>==</operator><name>TKV_LOADVAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>TreeKey</name> <operator>*</operator><operator>)</operator><call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nReq</name></decl>;</decl_stmt>                     <comment type="block">/* Bytes of space required at pRet */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nAvail</name></decl>;</decl_stmt>                   <comment type="block">/* Bytes of space available at pRet */</comment>

    <expr_stmt><expr><name>nReq</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TreeKey</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pRet</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eLoad</name><operator>==</operator><name>TKV_LOADVAL</name> <operator>&amp;&amp;</operator> <name><name>pRet</name><operator>-&gt;</operator><name>nValue</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nReq</name> <operator>+=</operator> <name><name>pRet</name><operator>-&gt;</operator><name>nValue</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>LSM_SHM_CHUNK_SIZE</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">15</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nAvail</name> <operator>=</operator> <name>LSM_SHM_CHUNK_SIZE</name> <operator>-</operator> <operator>(</operator><name>iPtr</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_SHM_CHUNK_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>nAvail</name><operator>&lt;</operator><name>nReq</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>tblobGrow</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nReq</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nLoad</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>LSM_MIN</name><argument_list>(<argument><expr><name>nAvail</name></expr></argument>, <argument><expr><name>nReq</name><operator>-</operator><name>nLoad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBlob</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>nLoad</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nLoad</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>nLoad</name><operator>==</operator><name>nReq</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

          <expr_stmt><expr><name>pChunk</name> <operator>=</operator> <call><name>treeShmChunk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><call><name>treeOffsetToChunk</name><argument_list>(<argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChunk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <operator>(</operator><name><name>pChunk</name><operator>-&gt;</operator><name>iNext</name></name> <operator>*</operator> <name>LSM_SHM_CHUNK_SIZE</name><operator>)</operator> <operator>+</operator> <name>LSM_SHM_CHUNK_HDR</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nAvail</name> <operator>=</operator> <name>LSM_SHM_CHUNK_SIZE</name> <operator>-</operator> <name>LSM_SHM_CHUNK_HDR</name></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>TreeKey</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pBlob</name><operator>-&gt;</operator><name>a</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LSM_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LSM_EXPENSIVE_ASSERT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>assert_leaf_looks_ok</name><parameter_list>(<parameter><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>apKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>assert_node_looks_ok</name><parameter_list>(<parameter><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>apKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nHeight</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert_node_looks_ok</name><argument_list>(<argument><expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nHeight</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Run various assert() statements to check that the working-version of the
** tree is correct in the following respects:
**
**   * todo...
*/</comment>
<function><type><name>void</name></type> <name>assert_tree_looks_ok</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><name>Tree</name> <modifier>*</modifier></type><name>pTree</name></decl></parameter>)</parameter_list><block>{<block_content>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>assert_tree_looks_ok</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>lsmFlagsToString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zFlags</name></decl></parameter>)</parameter_list><block>{<block_content>

  <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator></expr>   ?</condition><then> <expr><literal type="char">']'</literal></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Only one of LSM_POINT_DELETE, LSM_INSERT and LSM_SEPARATOR should ever
  ** be set. If this is not true, write a '?' to the output.  */</comment>
  <switch>switch<condition>( <expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_POINT_DELETE</name><operator>|</operator><name>LSM_INSERT</name><operator>|</operator><name>LSM_SEPARATOR</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>                <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LSM_POINT_DELETE</name></expr>:</case> <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LSM_INSERT</name></expr>:</case>       <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LSM_SEPARATOR</name></expr>:</case>    <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'^'</literal></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default>               <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>LSM_SYSTEMKEY</name><operator>)</operator></expr>    ?</condition><then> <expr><literal type="char">'*'</literal></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'['</literal></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>

<comment type="block">/*
** Pointer pBlob points to a buffer containing a blob of binary data
** nBlob bytes long. Append the contents of this blob to *pStr, with
** each octet represented by a 2-digit hexadecimal number. For example,
** if the input blob is three bytes in size and contains {0x01, 0x44, 0xFF},
** then "0144ff" is appended to *pStr.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsmAppendStrBlob</name><parameter_list>(<parameter><decl><type><name>LsmString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsmStringExtend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>nBlob</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBlob</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>c</name> <init>= <expr><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pBlob</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>nBlob</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>i</name><operator>!=</operator><operator>(</operator><name>nBlob</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* NOT USED */</comment>
<comment type="block">/*
** Append nIndent space (0x20) characters to string *pStr.
*/</comment>
static void lsmAppendIndent(LsmString *pStr, int nIndent){
  int i;
  lsmStringExtend(pStr, nIndent);
  for(i=0; i&lt;nIndent; i++) lsmStringAppend(pStr, " ", 1);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>strAppendFlags</name><parameter_list>(<parameter><decl><type><name>LsmString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zFlags</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>lsmFlagsToString</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>zFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zFlags</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>lsmStringAppend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>zFlags</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dump_node_contents</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,
  <parameter><decl><type><name>u32</name></type> <name>iNode</name></decl></parameter>,                      <comment type="block">/* Print out the contents of this node */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,                    <comment type="block">/* Path from root to this node */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPath</name></decl></parameter>,                      <comment type="block">/* Number of bytes in zPath */</comment>
  <parameter><decl><type><name>int</name></type> <name>nHeight</name></decl></parameter>                     <comment type="block">/* Height: (0==leaf) (1==parent-of-leaf) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpace</name> <init>= <expr><literal type="string">"                                           "</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmString</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeBlob</name></type> <name>b</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nHeight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Append the nIndent bytes of space to string s. */</comment>
    <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Append each key to string s. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iPtr</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPtr</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><call><name>treeShmkey</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>TKV_LOADKEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>strAppendFlags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmAppendStrBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"     "</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"% 6d %.*sleaf%.*s: %s\n"</literal></expr></argument>, 
        <argument><expr><name>iNode</name></expr></argument>, <argument><expr><name>nPath</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">20</literal><operator>-</operator><name>nPath</name><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>zSpace</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>z</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>i</name><argument_list type="generic">&lt;<argument><expr><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>nHeight</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iPtr</name> <init>= <expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>zPath</name><index>[<expr><name>nPath</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zPath</name><index>[<expr><name>nPath</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>iPtr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>dump_node_contents</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>nPath</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>nHeight</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><call><name>treeShmkey</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>TKV_LOADKEY</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strAppendFlags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmAppendStrBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"% 6d %.*s%.*s: %s\n"</literal></expr></argument>, 
            <argument><expr><name>iNode</name></expr></argument>, <argument><expr><name>nPath</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">20</literal><operator>-</operator><name>nPath</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zSpace</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmStringClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dump_tree_contents</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCaption</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zPath</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s\n"</literal></expr></argument>, <argument><expr><name>zCaption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iRoot</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dump_node_contents</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iRoot</name></name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Initialize a cursor object, the space for which has already been
** allocated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>treeCursorInit</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bOld</name></decl></parameter>, <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bOld</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRoot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>oldroot</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRoot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the mapping of the TreeKey object that the cursor
** is pointing to. 
*/</comment>
<function><type><specifier>static</specifier> <name>TreeKey</name> <modifier>*</modifier></type><name>csrGetKey</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>TreeBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iPtr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>aiKeyPtr</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPtr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>TreeKey</name><operator>*</operator><operator>)</operator><call><name>treeShmptrUnsafe</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pRet</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_CONTIGUOUS</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>treeShmkey</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>, <argument><expr><name>TKV_LOADVAL</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Save the current position of tree cursor pCsr.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeCursorSave</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iNode</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name> <operator>=</operator> <call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Restore the position of a saved tree cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeCursorRestore</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRes</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorSeek</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate nByte bytes of space within the *-shm file. If successful, 
** return LSM_OK and set *piPtr to the offset within the file at which
** the allocated space is located.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>treeShmalloc</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bAlign</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>static</specifier> <name>int</name></type> <name>CHUNK_SIZE</name> <init>= <expr><name>LSM_SHM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>static</specifier> <name>int</name></type> <name>CHUNK_HDR</name> <init>= <expr><name>LSM_SHM_CHUNK_HDR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iWrite</name></decl>;</decl_stmt>                   <comment type="block">/* Current write offset */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iEof</name></decl>;</decl_stmt>                     <comment type="block">/* End of current chunk */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iChunk</name></decl>;</decl_stmt>                   <comment type="block">/* Current chunk */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name> <operator>&lt;=</operator> <operator>(</operator><name>CHUNK_SIZE</name><operator>-</operator><name>CHUNK_HDR</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if there is enough space on the current chunk to fit the
    ** new allocation. If not, link in a new chunk and put the new
    ** allocation at the start of it.  */</comment>
    <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iWrite</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bAlign</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <operator>(</operator><name>iWrite</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x0003</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>iWrite</name> <operator>%</operator> <literal type="number">4</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iWrite</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iChunk</name> <operator>=</operator> <call><name>treeOffsetToChunk</name><argument_list>(<argument><expr><name>iWrite</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iEof</name> <operator>=</operator> <operator>(</operator><name>iChunk</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>CHUNK_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iEof</name><operator>&gt;=</operator><name>iWrite</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iEof</name><operator>-</operator><name>iWrite</name><operator>)</operator><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>CHUNK_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iWrite</name><operator>+</operator><name>nByte</name><operator>)</operator><operator>&gt;</operator><name>iEof</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pHdr</name></decl>;</decl_stmt>           <comment type="block">/* Header of chunk just finished (iChunk) */</comment>
      <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>         <comment type="block">/* Header of chunk treehdr.iFirst */</comment>
      <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>          <comment type="block">/* Header of new chunk */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Next chunk */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <call><name>treeShmChunk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name></expr></argument>, <argument><expr><name><name>pFirst</name><operator>-&gt;</operator><name>iShmid</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name><operator>)</operator><operator>==</operator><name><name>pFirst</name><operator>-&gt;</operator><name>iShmid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check if the chunk at the start of the linked list is still in
      ** use. If not, reuse it. If so, allocate a new chunk by appending
      ** to the *-shm file.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name><operator>!=</operator><name><name>pFirst</name><operator>-&gt;</operator><name>iShmid</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bInUse</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeInUse</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pFirst</name><operator>-&gt;</operator><name>iShmid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bInUse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>bInUse</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name> <operator>=</operator> <name><name>pFirst</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iNext</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Set the header values for the new chunk */</comment>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <call><name>treeShmChunkRc</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNext</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>iShmid</name></name> <operator>=</operator> <operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Set the header values for the chunk just finished */</comment>
      <expr_stmt><expr><name>pHdr</name> <operator>=</operator> <operator>(</operator><name>ShmChunk</name> <operator>*</operator><operator>)</operator><call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iChunk</name><operator>*</operator><name>CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pHdr</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>

      <comment type="block">/* Advance to the next chunk */</comment>
      <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <name>iNext</name> <operator>*</operator> <name>CHUNK_SIZE</name> <operator>+</operator> <name>CHUNK_HDR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Allocate space at iWrite. */</comment>
    <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>iWrite</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iWrite</name></name> <operator>=</operator> <name>iWrite</name> <operator>+</operator> <name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nByte</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>iRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and zero nByte bytes of space within the *-shm file.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>treeShmallocZero</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>iPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <call><name>treeShmalloc</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piPtr</name> <operator>=</operator> <name>iPtr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TreeNode</name> <modifier>*</modifier></type><name>newTreeNode</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>treeShmallocZero</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeNode</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>piPtr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TreeLeaf</name> <modifier>*</modifier></type><name>newTreeLeaf</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>treeShmallocZero</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeLeaf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>piPtr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TreeKey</name> <modifier>*</modifier></type><name>newTreeKey</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piPtr</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key data */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,           <comment type="block">/* Value data (or nVal&lt;0 for delete) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <comment type="block">/* Allocate space for the TreeKey structure itself */</comment>
  <expr_stmt><expr><operator>*</operator><name>piPtr</name> <operator>=</operator> <name>iPtr</name> <operator>=</operator> <call><name>treeShmalloc</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeKey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>

  <comment type="block">/* Allocate and populate the space required for the key and value. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nRem</name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>a</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aAlloc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>iWrite</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iWrite</name></name> <operator>&amp;</operator> <operator>(</operator><name>LSM_SHM_CHUNK_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><name>iWrite</name></expr></argument>, <argument><expr><name>LSM_SHM_CHUNK_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <call><name>LSM_MIN</name><argument_list>(<argument><expr><operator>(</operator><name>LSM_SHM_CHUNK_SIZE</name><operator>-</operator><name>iWrite</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>nRem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>aAlloc</name> <operator>=</operator> <call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><call><name>treeShmalloc</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aAlloc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aAlloc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>n</name><operator>-</operator><name>nRem</name></expr>]</index></name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nAlloc</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nRem</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name>iPtr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TreeKey</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nKey</name> <operator>+</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPtr</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>LSM_SHM_CHUNK_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>!=</operator><operator>(</operator><name>iEnd</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>LSM_SHM_CHUNK_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>LSM_CONTIGUOUS</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  printf("store: %d %s\n", (int)iPtr, (char *)pKey);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TreeNode</name> <modifier>*</modifier></type><name>copyTreeNode</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>, 
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piNew</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>newTreeNode</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>piNew</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name></name></expr></argument>, <argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>aiKeyPtr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiChildPtr</name></name></expr></argument>, <argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>aiChildPtr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiChildPtr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOld</name><operator>-&gt;</operator><name>iV2</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name><name>pOld</name><operator>-&gt;</operator><name>iV2Child</name></name></expr>]</index></name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>iV2Ptr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TreeNode</name> <modifier>*</modifier></type><name>copyTreeLeaf</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>TreeLeaf</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>, 
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piNew</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeLeaf</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>newTreeLeaf</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>piNew</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeLeaf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The tree cursor passed as the second argument currently points to an 
** internal node (not a leaf). Specifically, to a sub-tree pointer. This
** function replaces the sub-tree that the cursor currently points to
** with sub-tree pNew.
**
** The sub-tree may be replaced either by writing the "v2 data" on the
** internal node, or by allocating a new TreeNode structure and then 
** calling this function on the parent of the internal node.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeUpdatePtr</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* iNew is the new root node */</comment>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iRoot</name></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If this node already has version 2 content, allocate a copy and
    ** update the copy with the new pointer value. Otherwise, store the
    ** new pointer as v2 data within the current node structure.  */</comment>

    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* The node to be modified */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iChildPtr</name></decl>;</decl_stmt>                <comment type="block">/* apChild[] entry to modify */</comment>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iChildPtr</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iV2</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The "allocate new TreeNode" option */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>iCopy</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pCopy</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <call><name>copyTreeNode</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pCopy</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCopy</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iChildPtr</name></expr>]</index></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeUpdatePtr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The "v2 data" option */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>iPtr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iTransId</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(
            <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, 
            <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iRoot</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>intArrayAppend</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>rollback</name></name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iV2</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iTransId</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iV2Child</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iChildPtr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iV2Ptr</name></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Cursor pCsr points at a node that is part of pTree. This function
** inserts a new key and optionally child node pointer into that node.
**
** The position into which the new key and pointer are inserted is
** determined by the iSlot parameter. The new key will be inserted to
** the left of the key currently stored in apKey[iSlot]. Or, if iSlot is
** greater than the index of the rightmost key in the node.
**
** Pointer pLeftPtr points to a child tree that contains keys that are
** smaller than pTreeKey.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeInsert</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Cursor indicating path to insert at */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iLeftPtr</name></decl></parameter>,                   <comment type="block">/* Left child pointer */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iTreeKey</name></decl></parameter>,                   <comment type="block">/* Location of key to insert */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iRightPtr</name></decl></parameter>,                  <comment type="block">/* Right child pointer */</comment>
  <parameter><decl><type><name>int</name></type> <name>iSlot</name></decl></parameter>                       <comment type="block">/* Position to insert key into */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check if the node is currently full. If so, split pNode in two and
  ** call this function recursively to add a key to the parent. Otherwise, 
  ** insert the new key directly into pNode.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>iLeft</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>   <comment type="block">/* New left-hand sibling node */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iRight</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt> <comment type="block">/* New right-hand sibling node */</comment>

    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>newTreeNode</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>newTreeNode</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* pNode is the root of the tree. Grow the tree by one level. */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>iRoot</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pRoot</name></decl>;</decl_stmt> <comment type="block">/* New root node */</comment>

      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <call><name>newTreeNode</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iRight</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iRoot</name></name> <operator>=</operator> <name>iRoot</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>

      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeInsert</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, 
          <argument><expr><name>iLeft</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iRight</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iV2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>iV2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>iSlot</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iLeftPtr</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iRightPtr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iRightPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">1</literal></expr>:</case>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>iRightPtr</name></expr> ?</condition><then> <expr><name>iRightPtr</name></expr> </then><else>: <expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iLeftPtr</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">2</literal></expr>:</case>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iLeftPtr</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iRightPtr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iRightPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">3</literal></expr>:</case>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>iRightPtr</name></expr> ?</condition><then> <expr><name>iRightPtr</name></expr> </then><else>: <expr><name><name>pRight</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iLeftPtr</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>piKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>piChild</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iStore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Allocate a new version of node pNode. */</comment>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>newTreeNode</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>piKey</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>piChild</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aiChildPtr</name></name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iSlot</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>piKey</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>piChild</name><operator>++</operator><operator>)</operator> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>piKey</name><operator>++</operator> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piChild</name><operator>++</operator> <operator>=</operator> <name>iLeftPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>iStore</name> <operator>=</operator> <name>iRightPtr</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iSlot</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>piKey</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>piChild</name><operator>++</operator><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>iStore</name></expr> ?</condition><then> <expr><name>iStore</name></expr> </then><else>: <expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>iStore</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piChild</name> <operator>=</operator> <name>iStore</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piChild</name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, 
          <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeUpdatePtr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treeInsertLeaf</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Cursor structure */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iTreeKey</name></decl></parameter>,                   <comment type="block">/* Key pointer to insert */</comment>
  <parameter><decl><type><name>int</name></type> <name>iSlot</name></decl></parameter>                       <comment type="block">/* Insert key to the left of this */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pLeaf</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeLeaf</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSlot</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iSlot</name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>--</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>newTreeLeaf</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The leaf is full. Split it in two. */</comment>
      <decl_stmt><decl><type><name>TreeLeaf</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>iRight</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>newTreeLeaf</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRight</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <switch>switch<condition>( <expr><name>iSlot</name></expr> )</condition><block>{<block_content>
          <case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeInsert</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iRight</name></expr></argument>, 
            <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>iSlot</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pLeaf</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeUpdatePtr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmTreeMakeOld</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* A write transaction must be open. Otherwise the code below that
  ** assumes (pDb-&gt;pClient-&gt;iLogOff) is current may malfunction. 
  **
  ** Update: currently this assert fails due to lsm_flush(), which does
  ** not set nTransOpen.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <comment type="block">/* pDb-&gt;nTransOpen&gt;0 &amp;&amp; */</comment> <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldShmid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldLog</name></name> <operator>=</operator> <operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>log</name><operator>.</operator><name>aRegion</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>iEnd</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldLog</name></name> <operator>|=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iLogOff</name></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>i64</name><operator>)</operator><literal type="number">0x0001</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>oldcksum0</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>log</name><operator>.</operator><name>cksum0</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>oldcksum1</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>log</name><operator>.</operator><name>cksum1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldShmid</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>oldroot</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeRoot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iTransId</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iRoot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmTreeDiscardOld</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmShmAssertLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_WRITER</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call> 
       <operator>||</operator> <call><name>lsmShmAssertLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS2</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldShmid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldShmid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeHasOld</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iOldShmid</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called during recovery to initialize the 
** tree header. Only the database connections private copy of the tree-header
** is initialized here - it will be copied into shared memory if log file
** recovery is successful.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeInit</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pOne</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iTransId</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iWrite</name></name> <operator>=</operator> <name>LSM_SHM_CHUNK_SIZE</name> <operator>+</operator> <name>LSM_SHM_CHUNK_HDR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>pOne</name> <operator>=</operator> <call><name>treeShmChunkRc</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOne</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOne</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOne</name><operator>-&gt;</operator><name>iShmid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>treeHeaderChecksum</name><parameter_list>(
  <parameter><decl><type><name>TreeHeader</name> <modifier>*</modifier></type><name>pHdr</name></decl></parameter>, 
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aCksum</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum1</name> <init>= <expr><literal type="number">0x12345678</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum2</name> <init>= <expr><literal type="number">0x9ABCDEF0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name>pHdr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><call><name>offsetof</name><argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof> <operator>%</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><call><name>offsetof</name><argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>cksum1</name> <operator>+=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cksum2</name> <operator>+=</operator> <operator>(</operator><name>cksum1</name> <operator>+</operator> <name><name>a</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cksum1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cksum2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the checksum stored in TreeHeader object *pHdr is 
** consistent with the contents of its other fields.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeHeaderChecksumOk</name><parameter_list>(<parameter><decl><type><name>TreeHeader</name> <modifier>*</modifier></type><name>pHdr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aCksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>treeHeaderChecksum</name><argument_list>(<argument><expr><name>pHdr</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>aCksum</name></expr></argument>, <argument><expr><name><name>pHdr</name><operator>-&gt;</operator><name>aCksum</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aCksum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This type is used by functions lsmTreeRepair() and treeSortByShmid() to
** make relinking the linked list of shared-memory chunks easier.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ShmChunkLoc</name></name></type> <name>ShmChunkLoc</name>;</typedef>
<struct>struct <name>ShmChunkLoc</name> <block>{
  <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pShm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iLoc</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** This function checks that the linked list of shared memory chunks 
** that starts at chunk db-&gt;treehdr.iFirst:
**
**   1) Includes all chunks in the shared-memory region, and
**   2) Links them together in order of ascending shm-id.
**
** If no error occurs and the conditions above are met, LSM_OK is returned.
**
** If either of the conditions are untrue, LSM_CORRUPT is returned. Or, if
** an error is encountered before the checks are completed, another LSM error
** code (i.e. LSM_IOERR or LSM_NOMEM) may be returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeCheckLinkedList</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVisit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>treeShmChunkRc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iNext</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iNext</name></name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><call><name>treeShmChunkRc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iNext</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pNext</name><operator>-&gt;</operator><name>iShmid</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>iShmid</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>nVisit</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>nVisit</name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Iterate through the current in-memory tree. If there are any v2-pointers
** with transaction ids larger than db-&gt;treehdr.iTransId, zero them.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeRepairPtrs</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeCursor</name></type> <name>csr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor used to iterate through tree */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iTransId</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iTransId</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Initialize the cursor structure. Also decrement the nHeight variable
    ** in the tree-header. This will prevent the cursor from visiting any
    ** leaf nodes.  */</comment>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>treeCursorInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><name><name>csr</name><operator>.</operator><name>apTreeNode</name><index>[<expr><name><name>csr</name><operator>.</operator><name>iNode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iV2</name></name><operator>&gt;</operator><name>iTransId</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iV2Child</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iV2Ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iV2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name><name>csr</name><operator>.</operator><name>pDb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>csr</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treeRepairList</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Iterate through all shm chunks. Find the smallest shm-id present in
  ** the shared-memory region. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>treeShmChunkRc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pMin</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name><name>pMin</name><operator>-&gt;</operator><name>iShmid</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iShmid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pMin</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Fix the shm-id values on any chunks with a shm-id greater than or 
  ** equal to treehdr.iNextShmid. Then do a merge-sort of all chunks to 
  ** fix the ShmChunk.iNext pointers.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSort</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iPrevShmid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmChunkLoc</name> <modifier>*</modifier></type><name>aSort</name></decl>;</decl_stmt>

    <comment type="block">/* Allocate space for a merge sort. */</comment>
    <expr_stmt><expr><name>nSort</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name>nSort</name> <operator>&lt;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nSort</name> <operator>=</operator> <name>nSort</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShmChunkLoc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nSort</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aSort</name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPrevShmid</name> <operator>=</operator> <name><name>pMin</name><operator>-&gt;</operator><name>iShmid</name></name></expr>;</expr_stmt>

    <comment type="block">/* Fix all shm-ids, if required. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPrevShmid</name> <operator>=</operator> <name><name>pMin</name><operator>-&gt;</operator><name>iShmid</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>u32</name><operator>)</operator><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>treeShmChunk</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aSort</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pShm</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aSort</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iLoc</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name>i</name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>iShmid</name></name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iShmid</name></name> <operator>=</operator> <name>iPrevShmid</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>iMin</name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>treeShmChunk</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iShmid</name></name> <operator>=</operator> <name>iPrevShmid</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>ShmChunkLoc</name> <modifier>*</modifier></type><name>aSpace</name> <init>= <expr><operator>&amp;</operator><name><name>aSort</name><index>[<expr><name>nSort</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSort</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aSort</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pShm</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name><name>aSort</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pShm</name><operator>-&gt;</operator><name>iShmid</name></name></expr></argument>, <argument><expr><name>iPrevShmid</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpace</name><index>[<expr><name><name>aSort</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pShm</name><operator>-&gt;</operator><name>iShmid</name></name> <operator>-</operator> <name>iPrevShmid</name></expr>]</index></name><operator>.</operator><name>pShm</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aSpace</name><index>[<expr><name><name>aSort</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pShm</name><operator>-&gt;</operator><name>iShmid</name></name> <operator>-</operator> <name>iPrevShmid</name></expr>]</index></name> <operator>=</operator> <name><name>aSort</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name><name>aSpace</name><index>[<expr><name>nSort</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pShm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aSpace</name><index>[<expr><name>nSort</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pShm</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSort</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aSpace</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pShm</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aSpace</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pShm</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>aSpace</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iLoc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeCheckLinkedList</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>aSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as part of opening a write-transaction if the
** writer-flag is already set - indicating that the previous writer 
** failed before ending its transaction.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeRepair</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeHeader</name></type> <name>hdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pHdr</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Ensure that the two tree-headers are consistent. Copy one over the other
  ** if necessary. Prefer the data from a tree-header for which the checksum
  ** computes. Or, if they both compute, prefer tree-header-1.  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>treeHeaderChecksumOk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHdr</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Save the connections current copy of the tree-header. It will be 
  ** restored before returning.  */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Walk the tree. Zero any v2 pointers with a transaction-id greater than
  ** the transaction-id currently in the tree-headers.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeRepairPtrs</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Repair the linked list of shared-memory chunks. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeRepairList</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>treeOverwriteKey</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Create a copy of this node */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>copyTreeLeaf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>TreeLeaf</name> <operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>copyTreeNode</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Modify the value in the new version */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>

      <comment type="block">/* Change the pointer in the parent (if any) to point at the new 
       ** TreeNode */</comment>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>treeUpdatePtr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treeNextIsEndDelete</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name>iNode</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Cursor currently points to a leaf node. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>iNode</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name>iNode</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&lt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><call><name>treeShmptr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iNode</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCell</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name>iNode</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treePrevIsStartDelete</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Cursor currently points to a leaf node. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>iNode</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name>iNode</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name>iNode</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><call><name>treeShmptr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iNode</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>treeInsertEntry</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                      <comment type="block">/* Flags associated with entry */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,                     <comment type="block">/* Pointer to key data */</comment>
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,                       <comment type="block">/* Size of key data in bytes */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,                     <comment type="block">/* Pointer to value data (or NULL) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>                        <comment type="block">/* Bytes in value data (or -ve for delete) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pTreeKey</name></decl>;</decl_stmt>              <comment type="block">/* New key-value being inserted */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iTreeKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeCursor</name></type> <name>csr</name></decl>;</decl_stmt>                 <comment type="block">/* Cursor to seek to pKey/nKey */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Result of seek operation on csr */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>pVal</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_tree_looks_ok</name><argument_list>(<argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><name>pTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><name>LSM_INSERT</name>       <operator>||</operator> <name>flags</name><operator>==</operator><name>LSM_POINT_DELETE</name> 
       <operator>||</operator> <name>flags</name><operator>==</operator><name>LSM_START_DELETE</name> <operator>||</operator> <name>flags</name><operator>==</operator><name>LSM_END_DELETE</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>LSM_CONTIGUOUS</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  dump_tree_contents(pDb, "before");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iRoot</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pRes</name></decl>;</decl_stmt>                <comment type="block">/* Key at end of seek operation */</comment>
    <expr_stmt><expr><call><name>treeCursorInit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Seek to the leaf (or internal node) that the new key belongs on */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRes</name> <operator>=</operator> <call><name>csrGetKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>csr</name><operator>.</operator><name>blob</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRes</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>LSM_START_DELETE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* When inserting a start-delete-range entry, if the key that
      ** occurs immediately before the new entry is already a START_DELETE,
      ** then the new entry is not required.  */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>res</name><operator>&gt;</operator><literal type="number">0</literal>  <operator>&amp;&amp;</operator> <call><name>treePrevIsStartDelete</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
      )</condition><block>{<block_content> 
        <goto>goto <name>insert_entry_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name><operator>==</operator><name>LSM_END_DELETE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* When inserting an start-delete-range entry, if the key that
      ** occurs immediately after the new entry is already an END_DELETE,
      ** then the new entry is not required.  */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal>  <operator>&amp;&amp;</operator> <call><name>treeNextIsEndDelete</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>res</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <goto>goto <name>insert_entry_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_END_DELETE</name><operator>|</operator><name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_INSERT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>pRes</name><operator>-&gt;</operator><name>nValue</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>TKV_VAL</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>flags</name> <operator>|</operator> <name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>LSM_INSERT</name><operator>|</operator><name>LSM_POINT_DELETE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_END_DELETE</name><operator>)</operator><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>flags</name> <operator>|</operator> <operator>(</operator><name>LSM_END_DELETE</name><operator>|</operator><name>LSM_START_DELETE</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>flags</name> <operator>|</operator> <operator>(</operator><name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>LSM_END_DELETE</name><operator>|</operator><name>LSM_START_DELETE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Allocate and populate a new key-value pair structure */</comment>
  <expr_stmt><expr><name>pTreeKey</name> <operator>=</operator> <call><name>newTreeKey</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTreeKey</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTreeKey</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTreeKey</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>LSM_CONTIGUOUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTreeKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iRoot</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The tree is completely empty. Add a new root node and install
    ** (pKey/nKey) as the middle entry. Even though it is a leaf at the
    ** moment, use newTreeNode() to allocate the node (i.e. allocate enough
    ** space for the fields used by interior nodes). This is because the
    ** treeInsert() routine may convert this node to an interior node. */</comment>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><call><name>newTreeNode</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>iRoot</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iTreeKey</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The search found a match within the tree. */</comment>
      <expr_stmt><expr><call><name>treeOverwriteKey</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><name>iTreeKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The cursor now points to the leaf node into which the new entry should
      ** be inserted. There may or may not be a free slot within the leaf for
      ** the new key-value pair. 
      **
      ** iSlot is set to the index of the key within pLeaf that the new key
      ** should be inserted to the left of (or to a value 1 greater than the
      ** index of the rightmost key if the new key is larger than all keys
      ** currently stored in the node).
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iSlot</name> <init>= <expr><name><name>csr</name><operator>.</operator><name>aiCell</name><index>[<expr><name><name>csr</name><operator>.</operator><name>iNode</name></name></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>csr</name><operator>.</operator><name>iNode</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeInsert</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iTreeKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeInsertLeaf</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><name>iTreeKey</name></expr></argument>, <argument><expr><name>iSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  dump_tree_contents(pDb, "after");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 <label><name>insert_entry_out</name>:</label>
  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>csr</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_tree_looks_ok</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>pTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert a new entry into the in-memory tree.
**
** If the value of the 5th parameter, nVal, is negative, then a delete-marker
** is inserted into the tree. In this case the value pointer, pVal, must be
** NULL.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeInsert</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,                     <comment type="block">/* Pointer to key data */</comment>
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,                       <comment type="block">/* Size of key data in bytes */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,                     <comment type="block">/* Pointer to value data (or NULL) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>                        <comment type="block">/* Bytes in value data (or -ve for delete) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>LSM_POINT_DELETE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>LSM_INSERT</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><call><name>treeInsertEntry</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treeDeleteEntry</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iNewptr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSlot</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bLeaf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iSlot</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSlot</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iSlot</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iSlot</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>iNewptr</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>bLeaf</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* There are currently at least 2 keys on this node. So just create
    ** a new copy of the node with one of the keys removed. If the node
    ** happens to be the root node of the tree, allocate an entire 
    ** TreeNode structure instead of just a TreeLeaf.  */</comment>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iNew</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>bLeaf</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>newTreeLeaf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>newTreeNode</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>iSlot</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name>iNewptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>iOut</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bLeaf</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>iOut</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOut</name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bLeaf</name> <operator>||</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeUpdatePtr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Removing the only key in the root node. iNewptr is the new root. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSlot</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iRoot</name></name> <operator>=</operator> <name>iNewptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name><operator>--</operator></expr>;</expr_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* There is only one key on this node and the node is not the root
    ** node. Find a peer for this node. Then redistribute the contents of
    ** the peer and the parent cell between the parent and either one or
    ** two new nodes.  */</comment>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pParent</name></decl>;</decl_stmt>            <comment type="block">/* Parent tree node */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iPSlot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iPeer</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to peer leaf node */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iDir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pPeer</name></decl>;</decl_stmt>              <comment type="block">/* The peer leaf node */</comment>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNew1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>u32</name></type> <name>iNew1</name></decl>;</decl_stmt>   <comment type="block">/* First new leaf node */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSlot</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pParent</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPSlot</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iPSlot</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>iPSlot</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iDir</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iDir</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>iPeer</name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>iPSlot</name><operator>+</operator><name>iDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPeer</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>treeShmptr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertIsWorkingChild</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>iPSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate the first new leaf node. This is always required. */</comment>
    <if_stmt><if>if<condition>( <expr><name>bLeaf</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNew1</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>newTreeLeaf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNew1</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>newTreeNode</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Peer node is completely full. This means that two new leaf nodes
      ** and a new parent node are required. */</comment>

      <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNew2</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>u32</name></type> <name>iNew2</name></decl>;</decl_stmt> <comment type="block">/* Second new leaf node */</comment>
      <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNewP</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>u32</name></type> <name>iNewP</name></decl>;</decl_stmt> <comment type="block">/* New parent node */</comment>

      <if_stmt><if>if<condition>( <expr><name>bLeaf</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pNew2</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>newTreeLeaf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pNew2</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>newTreeNode</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>pNewP</name> <operator>=</operator> <call><name>copyTreeNode</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNewP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>iDir</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>pNewP</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iPSlot</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iNew1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewP</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iPSlot</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewP</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iPSlot</name></expr>]</index></name> <operator>=</operator> <name>iNew2</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iPSlot</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iNewptr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iPSlot</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iNewptr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>pNewP</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iPSlot</name></expr>]</index></name> <operator>=</operator> <name>iNew1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewP</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iPSlot</name></expr>]</index></name> <operator>=</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewP</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iPSlot</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iNew2</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew2</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pNew2</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeUpdatePtr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iNewP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iKOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iPOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>iDir</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iKOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iPSlot</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iPOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iNewptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iKOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pPeer</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iPOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pPeer</name></expr></argument>, <argument><expr><name>WORKING_VERSION</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iDir</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iPSlot</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iKOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iPSlot</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew1</name><operator>-&gt;</operator><name>aiChildPtr</name><index>[<expr><name>iPOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iNewptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iPSlot</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeDeleteEntry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iNew1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a range of keys from the tree structure (i.e. the lsm_delete_range()
** function, not lsm_delete()).
**
** This is a two step process: 
**
**     1) Remove all entries currently stored in the tree that have keys
**        that fall into the deleted range.
**
**        TODO: There are surely good ways to optimize this step - removing 
**        a range of keys from a b-tree. But for now, this function removes
**        them one at a time using the usual approach.
**
**     2) Unless the largest key smaller than or equal to (pKey1/nKey1) is
**        already marked as START_DELETE, insert a START_DELETE key. 
**        Similarly, unless the smallest key greater than or equal to
**        (pKey2/nKey2) is already START_END, insert a START_END key.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeDelete</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,         <comment type="block">/* Start of range */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>          <comment type="block">/* End of range */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The range must be sensible - that (key1 &lt; key2). */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>treeKeycmp</name><argument_list>(<argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_delete_ranges_match</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  static int nCall = 0;
  printf("\n");
  nCall++;
  printf("%d delete %s .. %s\n", nCall, (char *)pKey1, (char *)pKey2);
  dump_tree_contents(db, "before delete");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Step 1. This loop runs until the tree contains no keys within the
  ** range being deleted. Or until an error occurs. */</comment>
  <while>while<condition>( <expr><name>bDone</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeCursor</name></type> <name>csr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor to seek to first key in range */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pDel</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nDel</name></decl>;</decl_stmt>         <comment type="block">/* Key to (possibly) delete this iteration */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><call><name>treeCountEntries</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Seek the cursor to the first entry in the tree greater than pKey1. */</comment>
    <expr_stmt><expr><call><name>treeCursorInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmTreeCursorSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If there is no such entry, or if it is greater than pKey2, then the
    ** tree now contains no keys in the range being deleted. In this case
    ** break out of the loop.  */</comment>
    <expr_stmt><expr><name>bDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmTreeCursorKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>treeKeycmp</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>, <argument><expr><name>nDel</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bDone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>csr</name><operator>.</operator><name>iNode</name></name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* The element to delete already lies on a leaf node */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeDeleteEntry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* 1. Overwrite the current key with a copy of the next key in the 
        **    tree (key N).
        **
        ** 2. Seek to key N (cursor will stop at the internal node copy of
        **    N). Move to the next key (original copy of N). Delete
        **    this entry. 
        */</comment>
        <decl_stmt><decl><type><name>u32</name></type> <name>iKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iNode</name> <init>= <expr><name><name>csr</name><operator>.</operator><name>iNode</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>csr</name><operator>.</operator><name>iNode</name></name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>csr</name><operator>.</operator><name>apTreeNode</name><index>[<expr><name><name>csr</name><operator>.</operator><name>iNode</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>aiKeyPtr</name><index>[<expr><name><name>csr</name><operator>.</operator><name>aiCell</name><index>[<expr><name><name>csr</name><operator>.</operator><name>iNode</name></name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmTreeCursorPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>treeOverwriteKey</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>treeShmkey</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>TKV_LOADKEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pKey</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>csr</name><operator>.</operator><name>iNode</name></name><operator>==</operator><name>iNode</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeDeleteEntry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clean up any memory allocated by the cursor. */</comment>
    <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>csr</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    dump_tree_contents(db, "ddd delete");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bDone</name> <operator>||</operator> <call><name>treeCountEntries</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><name>nEntry</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  dump_tree_contents(db, "during delete");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Now insert the START_DELETE and END_DELETE keys. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeInsertEntry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_START_DELETE</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  dump_tree_contents(db, "during delete 2");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeInsertEntry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_END_DELETE</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  dump_tree_contents(db, "after delete");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_delete_ranges_match</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return, in bytes, the amount of memory currently used by the tree 
** structure.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeSize</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nByte</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a cursor on the in-memory tree pTree.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeCursorNew</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bOld</name></decl></parameter>, <parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <name>pCsr</name> <operator>=</operator> <call><name>lsmMalloc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>treeCursorInit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bOld</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>LSM_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close an in-memory tree cursor.
*/</comment>
<function><type><name>void</name></type> <name>lsmTreeCursorDestroy</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmTreeCursorReset</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>treeCsrCompare</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>treeKeycmp</name><argument_list>(<argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Attempt to seek the cursor passed as the first argument to key (pKey/nKey)
** in the tree structure. If an exact match for the key is found, leave the
** cursor pointing to it and set *pRes to zero before returning. If an
** exact match cannot be found, do one of the following:
**
**   * Leave the cursor pointing to the smallest element in the tree that 
**     is larger than the key and set *pRes to +1, or
**
**   * Leave the cursor pointing to the largest element in the tree that 
**     is smaller than the key and set *pRes to -1, or
**
**   * If the tree is empty, leave the cursor at EOF and set *pRes to -1.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeCursorSeek</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRoot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iNodePtr</name></decl>;</decl_stmt>                   <comment type="block">/* Location of current node in search */</comment>

  <comment type="block">/* Discard any saved position data */</comment>
  <expr_stmt><expr><call><name>treeCursorRestore</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>iRoot</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iNodePtr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Either an error occurred or the tree is completely empty. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>iRoot</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>TreeBlob</name></type> <name>b</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Result of comparison function */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iNode</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>iNodePtr</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>            <comment type="block">/* Node at location iNodePtr */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iTest</name></decl>;</decl_stmt>                  <comment type="block">/* Index of second key to test (0 or 2) */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>iTreeKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pTreeKey</name></decl>;</decl_stmt>          <comment type="block">/* Key to compare against */</comment>

      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>treeShmptrUnsafe</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iNodePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNode</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name>iNode</name></expr>]</index></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>

      <comment type="block">/* Compare (pKey/nKey) with the key in the middle slot of B-tree node
      ** pNode. The middle slot is never empty. If the comparison is a match,
      ** then the search is finished. Break out of the loop. */</comment>
      <expr_stmt><expr><name>pTreeKey</name> <operator>=</operator> <operator>(</operator><name>TreeKey</name><operator>*</operator><operator>)</operator><call><name>treeShmptrUnsafe</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pTreeKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_CONTIGUOUS</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pTreeKey</name> <operator>=</operator> <call><name>treeShmkey</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TKV_LOADKEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>treeKeycmp</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTreeKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pTreeKey</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name>iNode</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Based on the results of the previous comparison, compare (pKey/nKey)
      ** to either the left or right key of the B-tree node, if such a key
      ** exists. */</comment>
      <expr_stmt><expr><name>iTest</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iTreeKey</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iTest</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iTreeKey</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pTreeKey</name> <operator>=</operator> <operator>(</operator><name>TreeKey</name><operator>*</operator><operator>)</operator><call><name>treeShmptrUnsafe</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iTreeKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pTreeKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_CONTIGUOUS</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pTreeKey</name> <operator>=</operator> <call><name>treeShmkey</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iTreeKey</name></expr></argument>, <argument><expr><name>TKV_LOADKEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>treeKeycmp</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTreeKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pTreeKey</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name>iNode</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iTest</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iTest</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name>iNode</name><operator>&lt;</operator><operator>(</operator><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name>iTest</name> <operator>+</operator> <operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name>iNode</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>iTest</name> <operator>+</operator> <operator>(</operator><name>iNodePtr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <name>iNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* assert() that *pRes has been set properly */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>treeCsrCompare</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <operator>*</operator><name>pRes</name><operator>==</operator><name>cmp</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>pRes</name> <operator>^</operator> <name>cmp</name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeCursorNext</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pK1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeBlob</name></type> <name>key1</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRoot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iLeaf</name> <init>= <expr><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt> 

  <comment type="block">/* Restore the cursor position, if required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRestore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>treeCursorRestore</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iRestore</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Save a pointer to the current key. This is used in an assert() at the
  ** end of this function - to check that the 'next' key really is larger
  ** than the current key. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><name>pK1</name> <operator>=</operator> <call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name><operator>&lt;</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCell</name> <operator>=</operator> <operator>++</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* If the current node is not a leaf, and the current cell has sub-tree
  ** associated with it, descend to the left-most key on the left-most
  ** leaf of the sub-tree.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&lt;</operator><name>iLeaf</name> <operator>&amp;&amp;</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iNodePtr</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iNodePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>&lt;</operator> <name>iLeaf</name></expr> )</condition>;</do>
  </block_content>}</block></if>

  <comment type="block">/* Otherwise, the next key is found by following pointer up the tree 
  ** until there is a key immediately to the right of the pointer followed 
  ** to reach the sub-tree containing the current key. */</comment>
  <if type="elseif">else if<condition>( <expr><name>iCell</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><operator>(</operator><operator>--</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&lt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pK2</name> <init>= <expr><call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>||</operator><call><name>treeKeycmp</name><argument_list>(<argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pK2</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>pK2</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,<argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pK1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>pK1</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeCursorPrev</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pK1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeBlob</name></type> <name>key1</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRoot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iLeaf</name> <init>= <expr><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt> 

  <comment type="block">/* Restore the cursor position, if required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRestore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>treeCursorRestore</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iRestore</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Save a pointer to the current key. This is used in an assert() at the
  ** end of this function - to check that the 'next' key really is smaller
  ** than the current key. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><name>pK1</name> <operator>=</operator> <call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCell</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCell</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCell</name><operator>&lt;</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the current node is not a leaf, and the current cell has sub-tree
  ** associated with it, descend to the right-most key on the right-most
  ** leaf of the sub-tree.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&lt;</operator><name>iLeaf</name> <operator>&amp;&amp;</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iNodePtr</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iNodePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>&lt;</operator> <name>iLeaf</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iCell</name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>&lt;</operator> <name>iLeaf</name></expr> )</condition>;</do>
  </block_content>}</block></if>

  <comment type="block">/* Otherwise, the next key is found by following pointer up the tree until
  ** there is a key immediately to the left of the pointer followed to reach
  ** the sub-tree containing the current key. */</comment>
  <else>else<block>{<block_content>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>aiKeyPtr</name><index>[<expr><name>iCell</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>--</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iCell</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pK2</name> <init>= <expr><call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name> <operator>||</operator> <call><name>treeKeycmp</name><argument_list>(<argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pK2</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>pK2</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>,<argument><expr><call><name>TKV_KEY</name><argument_list>(<argument><expr><name>pK1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>pK1</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Move the cursor to the first (bLast==0) or last (bLast!=0) entry in the
** in-memory tree.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeCursorEnd</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeRoot</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRoot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>u32</name></type> <name>iNodePtr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* Discard any saved position data */</comment>
  <expr_stmt><expr><call><name>treeCursorRestore</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>iRoot</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>iNodePtr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>TreeNode</name> <operator>*</operator><operator>)</operator><call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iNodePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bLast</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iCell</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>aiKeyPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&lt;</operator><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <call><name>getChildPtr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>iTransId</name></name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iNodePtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>iCell</name> <operator>-</operator> <operator>(</operator><name>iNodePtr</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bLast</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeCursorFlags</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><operator>(</operator><name>TreeKey</name> <operator>*</operator><operator>)</operator><call><name>treeShmptrUnsafe</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
        <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apTreeNode</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>aiKeyPtr</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>aiCell</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name></expr>]</index></name></expr>]</index></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>LSM_CONTIGUOUS</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeCursorKey</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pFlags</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pTreeKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTreeKey</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTreeKey</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pTreeKey</name> <operator>=</operator> <call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name><name>pTreeKey</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pFlags</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pFlags</name> <operator>=</operator> <name><name>pTreeKey</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppKey</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTreeKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeCursorValue</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>treeCursorRestore</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pTreeKey</name> <init>= <expr><call><name>csrGetKey</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTreeKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LSM_INSERT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <name><name>pTreeKey</name><operator>-&gt;</operator><name>nValue</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <call><name>TKV_VAL</name><argument_list>(<argument><expr><name>pTreeKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the cursor currently points to a valid entry. 
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeCursorValid</name><parameter_list>(<parameter><decl><type><name>TreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>pCsr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pSave</name></name> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iNode</name></name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Store a mark in *pMark. Later on, a call to lsmTreeRollback() with a
** pointer to the same TreeMark structure may be used to roll the tree
** contents back to their current state.
*/</comment>
<function><type><name>void</name></type> <name>lsmTreeMark</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>TreeMark</name> <modifier>*</modifier></type><name>pMark</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pMark</name><operator>-&gt;</operator><name>iRoot</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iRoot</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMark</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMark</name><operator>-&gt;</operator><name>iWrite</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iWrite</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMark</name><operator>-&gt;</operator><name>nChunk</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMark</name><operator>-&gt;</operator><name>iNextShmid</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMark</name><operator>-&gt;</operator><name>iRollback</name></name> <operator>=</operator> <call><name>intArraySize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>rollback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Roll back to mark pMark. Structure *pMark should have been previously
** populated by a call to lsmTreeMark().
*/</comment>
<function><type><name>void</name></type> <name>lsmTreeRollback</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>TreeMark</name> <modifier>*</modifier></type><name>pMark</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iChunk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iShmid</name></decl>;</decl_stmt>

  <comment type="block">/* Revert all required v2 pointers. */</comment>
  <expr_stmt><expr><name>nIdx</name> <operator>=</operator> <call><name>intArraySize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>rollback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iIdx</name> <operator>=</operator> <name><name>pMark</name><operator>-&gt;</operator><name>iRollback</name></name></expr>;</init> <condition><expr><name>iIdx</name><operator>&lt;</operator><name>nIdx</name></expr>;</condition> <incr><expr><name>iIdx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>TreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>treeShmptr</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><call><name>intArrayEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>rollback</name></name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNode</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iV2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iV2Child</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iV2Ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>intArrayTruncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>rollback</name></name></expr></argument>, <argument><expr><name><name>pMark</name><operator>-&gt;</operator><name>iRollback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Restore the free-chunk list. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMark</name><operator>-&gt;</operator><name>iWrite</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iChunk</name> <operator>=</operator> <call><name>treeOffsetToChunk</name><argument_list>(<argument><expr><name><name>pMark</name><operator>-&gt;</operator><name>iWrite</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pChunk</name> <operator>=</operator> <call><name>treeShmChunk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name><name>pChunk</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pChunk</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>pChunk</name> <operator>=</operator> <call><name>treeShmChunk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iShmid</name> <operator>=</operator> <name><name>pChunk</name><operator>-&gt;</operator><name>iShmid</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>iNext</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>iFree</name> <init>= <expr><name>iNext</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Current chunk being rollback-freed */</comment>
    <decl_stmt><decl><type><name>ShmChunk</name> <modifier>*</modifier></type><name>pFree</name></decl>;</decl_stmt>              <comment type="block">/* Pointer to chunk iFree */</comment>

    <expr_stmt><expr><name>pFree</name> <operator>=</operator> <call><name>treeShmChunk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name><name>pFree</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iFree</name><operator>&lt;</operator><name><name>pMark</name><operator>-&gt;</operator><name>nChunk</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>iShmid</name></name> <operator>=</operator> <name>iShmid</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iFirst</name></name> <operator>=</operator> <name>iFree</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Restore the tree-header fields */</comment>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>iRoot</name></name> <operator>=</operator> <name><name>pMark</name><operator>-&gt;</operator><name>iRoot</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>root</name><operator>.</operator><name>nHeight</name></name> <operator>=</operator> <name><name>pMark</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iWrite</name></name> <operator>=</operator> <name><name>pMark</name><operator>-&gt;</operator><name>iWrite</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name> <operator>=</operator> <name><name>pMark</name><operator>-&gt;</operator><name>nChunk</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name> <operator>=</operator> <name><name>pMark</name><operator>-&gt;</operator><name>iNextShmid</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Load the in-memory tree header from shared-memory into pDb-&gt;treehdr.
** If the header cannot be loaded, return LSM_PROTOCOL.
**
** If the header is successfully loaded and parameter piRead is not NULL,
** is is set to 1 if the header was loaded from ShmHeader.hdr1, or 2 if
** the header was loaded from ShmHeader.hdr2.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeLoadHeader</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piRead</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>LSM_ATTEMPTS_BEFORE_PROTOCOL</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>nRem</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>treeHeaderChecksumOk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>piRead</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piRead</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>LSM_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>treeHeaderChecksumOk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>piRead</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piRead</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>LSM_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmShmBarrier</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>LSM_PROTOCOL_BKPT</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeLoadHeaderOk</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iRead</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeHeader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>iRead</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name><operator>-&gt;</operator><name>hdr1</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name><operator>-&gt;</operator><name>hdr2</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iRead</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iRead</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>aCksum</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCksum</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to conclude a transaction. If argument bCommit
** is true, the transaction is committed. Otherwise it is rolled back.
*/</comment>
<function><type><name>int</name></type> <name>lsmTreeEndTransaction</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bCommit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>treeHeaderChecksum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>aCksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>hdr2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmShmBarrier</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pShm</name><operator>-&gt;</operator><name>bWriter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>intArrayFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>rollback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>assert_delete_ranges_match</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeBlob</name></type> <name>blob</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeCursor</name></type> <name>csr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor used to iterate through tree */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>treeCursorInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>( <init><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</condition>
       <incr><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr></incr>
  )</control><block>{<block_content>
    <decl_stmt><decl><type><name>TreeKey</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><call><name>csrGetKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>prev</name><operator>&amp;</operator><name>LSM_START_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>LSM_END_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name><name>csr</name><operator>.</operator><name>pDb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>csr</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name><name>csr</name><operator>.</operator><name>pDb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treeCountEntries</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TreeCursor</name></type> <name>csr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor used to iterate through tree */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>treeCursorInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>( <init><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>lsmTreeCursorValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</condition>
       <incr><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeCursorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr></incr>
  )</control><block>{<block_content>
    <expr_stmt><expr><name>nEntry</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>tblobFree</name><argument_list>(<argument><expr><name><name>csr</name><operator>.</operator><name>pDb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>csr</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>nEntry</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
