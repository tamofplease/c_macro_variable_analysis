<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/lsm1/lsm_main.c"><comment type="block">/*
** 2011-08-18
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** The main interface to the LSM module.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmInt.h"</cpp:file></cpp:include>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** This function returns a copy of its only argument.
**
** When the library is built with LSM_DEBUG defined, this function is called
** whenever an error code is generated (not propagated - generated). So
** if the library is mysteriously returning (say) LSM_IOERR, a breakpoint
** may be set in this function to determine why.
*/</comment>
<function><type><name>int</name></type> <name>lsmErrorBkpt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Set breakpoint here! */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function contains various assert() statements that test that the
** lsm_db structure passed as an argument is internally consistent.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assert_db_state</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* If there is at least one cursor or a write transaction open, the database
  ** handle must be holding a pointer to a client snapshot. And the reverse 
  ** - if there are no open cursors and no write transactions then there must 
  ** not be a client snapshot.  */</comment>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>!=</operator><literal type="number">0</literal><operator>||</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&gt;=</operator><literal type="number">0</literal><operator>||</operator><name><name>pDb</name><operator>-&gt;</operator><name>bRoTrans</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bRoTrans</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>assert_db_state</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The default key-compare function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>xCmp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n1</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><call><name>LSM_MIN</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>n1</name><operator>-</operator><name>n2</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xLog</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>rc</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>pCtx</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new db handle.
*/</comment>
<function><type><name>int</name></type> <name>lsm_new</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <comment type="block">/* If the user did not provide an environment, use the default. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pEnv</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pEnv</name> <operator>=</operator> <call><name>lsm_default_env</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEnv</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate the new database handle */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <name>pDb</name> <operator>=</operator> <operator>(</operator><name>lsm_db</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZero</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lsm_db</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Initialize the new object */</comment>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name> <operator>=</operator> <name>pEnv</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTreeLimit</name></name> <operator>=</operator> <name>LSM_DFLT_AUTOFLUSH</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nAutockpt</name></name> <operator>=</operator> <name>LSM_DFLT_AUTOCHECKPOINT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bAutowork</name></name> <operator>=</operator> <name>LSM_DFLT_AUTOWORK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>eSafety</name></name> <operator>=</operator> <name>LSM_DFLT_SAFETY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>=</operator> <name>xCmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nDfltPgsz</name></name> <operator>=</operator> <name>LSM_DFLT_PAGE_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nDfltBlksz</name></name> <operator>=</operator> <name>LSM_DFLT_BLOCK_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name> <operator>=</operator> <name>LSM_DFLT_AUTOMERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMaxFreelist</name></name> <operator>=</operator> <name>LSM_MAX_FREELIST_ENTRIES</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseLog</name></name> <operator>=</operator> <name>LSM_DFLT_USE_LOG</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>iRwclient</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bMultiProc</name></name> <operator>=</operator> <name>LSM_DFLT_MULTIPLE_PROCESSES</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>iMmap</name></name> <operator>=</operator> <name>LSM_DFLT_MMAP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>xLog</name></name> <operator>=</operator> <name>xLog</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>iId</name></name> <operator>=</operator> <name>LSM_COMPRESSION_NONE</name></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>lsm_env</name> <modifier>*</modifier></type><name>lsm_get_env</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If database handle pDb is currently holding a client snapshot, but does
** not have any open cursors or write transactions, release it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dbReleaseClientSnapshot</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFinishReadTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getFullpathname</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRel</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzAbs</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nReq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <do>do<block>{<block_content>
    <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>nReq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEnv</name><operator>-&gt;</operator><name>xFullpath</name></name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>zRel</name></expr></argument>, <argument><expr><name>zAlloc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nReq</name><operator>&gt;</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zAlloc</name> <operator>=</operator> <call><name>lsmReallocOrFreeRc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>zAlloc</name></expr></argument>, <argument><expr><name>nReq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>nReq</name><operator>&gt;</operator><name>nAlloc</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition>;</do>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>zAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zAlloc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzAbs</name> <operator>=</operator> <name>zAlloc</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check that the bits in the db-&gt;mLock mask are consistent with the
** value stored in db-&gt;iRwclient. An assert shall fail otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assertRwclientLockValue</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u64</name></type> <name>msk</name></decl>;</decl_stmt>                        <comment type="block">/* Mask of mLock bits for RWCLIENT locks */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>rwclient</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Bit corresponding to db-&gt;iRwclient */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>iRwclient</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rwclient</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>iRwclient</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>msk</name>  <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><name>LSM_LOCK_NRWCLIENT</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>msk</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>msk</name><operator>)</operator><operator>==</operator><name>rwclient</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Open a new connection to database zFilename.
*/</comment>
<function><type><name>int</name></type> <name>lsm_open</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_MISUSE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFull</name></decl>;</decl_stmt>

    <comment type="block">/* Translate the possibly relative pathname supplied by the user into
    ** an absolute pathname. This is required because the supplied path
    ** is used (either directly or with "-log" appended to it) for more 
    ** than one purpose - to open both the database and log files, and 
    ** perhaps to unlink the log file during disconnection. An absolute
    ** path is required to ensure that the correct files are operated
    ** on even if the application changes the cwd.  */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getFullpathname</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>zFull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Connect to the database. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmDbDatabaseConnect</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Configure the file-system connection with the page-size and block-size
      ** of this database. Even if the database file is zero bytes in size
      ** on disk, these values have been set in shared-memory by now, and so 
      ** are guaranteed not to change during the lifetime of this connection.  
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>LSM_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointLoad</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmFsSetPageSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><call><name>lsmCheckpointPgsz</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmFsSetBlockSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><call><name>lsmCheckpointBlksz</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertRwclientLockValue</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_close</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDb</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert_db_state</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_MISUSE_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>lsmMCursorFreeCache</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFreeSnapshot</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assertRwclientLockValue</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>lsmDbDatabaseRelease</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmLogClose</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsClose</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* assert( pDb-&gt;mLock==0 ); */</comment>
      
      <comment type="block">/* Invoke any destructors registered for the compression or 
      ** compression factory callbacks.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>xFree</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>xFree</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>xFree</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>xFree</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>rollback</name><operator>.</operator><name>aArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aTrans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_config</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eParam</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>eParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>eParam</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>LSM_CONFIG_AUTOFLUSH</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* This parameter is read and written in KB. But all internal 
      ** processing is done in bytes.  */</comment>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iVal</name> <init>= <expr><operator>*</operator><name>piVal</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iVal</name><operator>&lt;=</operator><operator>(</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTreeLimit</name></name> <operator>=</operator> <name>iVal</name><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTreeLimit</name></name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_AUTOWORK</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bAutowork</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bAutowork</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_AUTOCHECKPOINT</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* This parameter is read and written in KB. But all internal processing
      ** (including the lsm_db.nAutockpt variable) is done in bytes.  */</comment>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iVal</name> <init>= <expr><operator>*</operator><name>piVal</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nAutockpt</name></name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iVal</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>nAutockpt</name></name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_PAGE_SIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If lsm_open() has been called, this is a read-only parameter. 
        ** Set the output variable to the page-size according to the 
        ** FileSystem object.  */</comment>
        <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <call><name>lsmFsPageSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piVal</name><operator>&gt;=</operator><literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>piVal</name><operator>&lt;=</operator><literal type="number">65536</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>piVal</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>*</operator><name>piVal</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nDfltPgsz</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nDfltPgsz</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_BLOCK_SIZE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* This parameter is read and written in KB. But all internal 
      ** processing is done in bytes.  */</comment>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If lsm_open() has been called, this is a read-only parameter. 
        ** Set the output variable to the block-size in KB according to the 
        ** FileSystem object.  */</comment>
        <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <call><name>lsmFsBlockSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iVal</name> <init>= <expr><operator>*</operator><name>piVal</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&gt;=</operator><literal type="number">64</literal> <operator>&amp;&amp;</operator> <name>iVal</name><operator>&lt;=</operator><literal type="number">65536</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>iVal</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>iVal</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nDfltBlksz</name></name> <operator>=</operator> <name>iVal</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nDfltBlksz</name></name> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_SAFETY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piVal</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>piVal</name><operator>&lt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>eSafety</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>eSafety</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_MMAP</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>piVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>iMmap</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsConfigure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>iMmap</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_USE_LOG</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>piVal</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>piVal</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bUseLog</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bUseLog</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_AUTOMERGE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piVal</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nMerge</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_MAX_FREELIST</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piVal</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>piVal</name><operator>&lt;=</operator><name>LSM_MAX_FREELIST_ENTRIES</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nMaxFreelist</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nMaxFreelist</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_MULTIPLE_PROCESSES</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If lsm_open() has been called, this is a read-only parameter. 
        ** Set the output variable to true if this connection is currently
        ** in multi-process mode.  */</comment>
        <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <call><name>lsmDbMultiProc</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bMultiProc</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>piVal</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_READONLY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* If lsm_open() has been called, this is a read-only parameter. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>piVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name> <operator>=</operator> <operator>*</operator><name>piVal</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>piVal</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_SET_COMPRESSION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>lsm_compress</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>lsm_compress</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bInFactory</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* May not change compression schemes with an open transaction */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_MISUSE_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>xFree</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Invoke any destructor belonging to the current compression. */</comment>
          <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>xFree</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xBound</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lsm_compress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>iId</name></name> <operator>=</operator> <name>LSM_COMPRESSION_NONE</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lsm_compress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsConfigure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_SET_COMPRESSION_FACTORY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>lsm_compress_factory</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>lsm_compress_factory</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>xFree</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Invoke any destructor belonging to the current factory. */</comment>
        <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>xFree</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>factory</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lsm_compress_factory</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_CONFIG_GET_COMPRESSION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>lsm_compress</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>lsm_compress</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lsm_compress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_MISUSE</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmAppendSegmentList</name><parameter_list>(<parameter><decl><type><name>LsmString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zPre</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%s{%d %d %d %d}"</literal></expr></argument>, <argument><expr><name>zPre</name></expr></argument>, 
        <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>nSize</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>infoGetWorker</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbUnlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbUnlock</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbUnlock</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>infoFreeWorker</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bUnlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>bUnlock</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rcdummy</name> <init>= <expr><name>LSM_BUSY</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsmFinishWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rcdummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmStructList</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOut</name></decl></parameter>                    <comment type="block">/* OUT: Nul-terminated string (tcl list) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pTopLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Top level of snapshot to report on */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmString</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>              <comment type="block">/* Worker snapshot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bUnlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Obtain the worker snapshot */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>infoGetWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pWorker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bUnlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Format the contents of the snapshot as text */</comment>
  <expr_stmt><expr><name>pTopLevel</name> <operator>=</operator> <call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pTopLevel</name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"%s{%d"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>.</operator><name>n</name></name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iAge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmAppendSegmentList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>lsmAppendSegmentList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>lsmStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>.</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>LSM_OK</name></expr> </then><else>: <expr><name>LSM_NOMEM</name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Release the snapshot and return */</comment>
  <expr_stmt><expr><call><name>infoFreeWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bUnlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>infoFreelistCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmString</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><operator>(</operator><name>LsmString</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%s{%d %lld}"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name></expr>?</condition><then><expr><literal type="string">" "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><name>iSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmInfoFreelist</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>              <comment type="block">/* Worker snapshot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bUnlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmString</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Obtain the worker snapshot */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>infoGetWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pWorker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bUnlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmWalkFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>infoFreelistCb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release the snapshot and return */</comment>
  <expr_stmt><expr><call><name>infoFreeWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bUnlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>infoTreeSize</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOldKB</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnNewKB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TreeHeader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>hdr1</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The following code suffers from two race conditions, as it accesses and
  ** trusts the contents of shared memory without verifying checksums:
  **
  **   * The two values read - TreeHeader.root.nByte and oldroot.nByte - are 
  **     32-bit fields. It is assumed that reading from one of these
  **     is atomic - that it is not possible to read a partially written
  **     garbage value. However the two values may be mutually inconsistent. 
  **
  **   * TreeHeader.iLogOff is a 64-bit value. And lsmCheckpointLogOffset()
  **     reads a 64-bit value from a snapshot stored in shared memory. It
  **     is assumed that in each case it is possible to read a partially
  **     written garbage value. If this occurs, then the value returned
  **     for the size of the "old" tree may reflect the size of an "old"
  **     tree that was recently flushed to disk.
  **
  ** Given the context in which this function is called (as a result of an
  ** lsm_info(LSM_INFO_TREE_SIZE) request), neither of these are considered to
  ** be problems.
  */</comment>
  <expr_stmt><expr><operator>*</operator><name>pnNewKB</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>root</name><operator>.</operator><name>nByte</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iOldShmid</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iOldLog</name></name><operator>==</operator><call><name>lsmCheckpointLogOffset</name><argument_list>(<argument><expr><name><name>pShm</name><operator>-&gt;</operator><name>aSnap1</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnOldKB</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnOldKB</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>oldroot</name><operator>.</operator><name>nByte</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnOldKB</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_info</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eParam</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>eParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>eParam</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>LSM_INFO_NWRITE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <call><name>lsmFsNWrite</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_NREAD</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <call><name>lsmFsNRead</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_DB_STRUCTURE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmStructList</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_ARRAY_STRUCTURE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>LsmPgno</name></type> <name>pgno</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>LsmPgno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmInfoArrayStructure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_ARRAY_PAGES</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>LsmPgno</name></type> <name>pgno</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>LsmPgno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmInfoArrayPages</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_PAGE_HEX_DUMP</name></expr>:</case>
    <case>case <expr><name>LSM_INFO_PAGE_ASCII_DUMP</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>LsmPgno</name></type> <name>pgno</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>LsmPgno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bUnlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>infoGetWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bUnlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bHex</name> <init>= <expr><operator>(</operator><name>eParam</name><operator>==</operator><name>LSM_INFO_PAGE_HEX_DUMP</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmInfoPageDump</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>bHex</name></expr></argument>, <argument><expr><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>infoFreeWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bUnlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_LOG_STRUCTURE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmInfoLogStructure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_FREELIST</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmInfoFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pzVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_CHECKPOINT_SIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKB</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointSize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pnKB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_TREE_SIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOld</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pnNew</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>infoTreeSize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pnOld</name></expr></argument>, <argument><expr><name>pnNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>LSM_INFO_COMPRESSION_ID</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>piOut</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int *</argument>)</argument_list></macro></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>piOut</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iCmpId</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmInfoCompressionId</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>piOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_MISUSE</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>doWriteOp</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bDeleteRange</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,     <comment type="block">/* Key to write or delete */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>      <comment type="block">/* Value to write. Or nVal==-1 for a delete */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bCommit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* True to commit before returning */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bCommit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_begin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bDeleteRange</name></expr> ?</condition><then> <expr><name>LSM_DRANGE</name></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>nVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr>?</condition><then><expr><name>LSM_WRITE</name></expr></then><else>:<expr><name>LSM_DELETE</name></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmLogWrite</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmSortedSaveTreeCursors</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name> <init>= <expr><call><name>lsmFsPageSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nQuant</name> <init>= <expr><name>LSM_AUTOWORK_QUANT</name> <operator>*</operator> <name>pgsz</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBefore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nAfter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDiff</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>nQuant</name><operator>&gt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTreeLimit</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nQuant</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTreeLimit</name></name></expr></argument>, <argument><expr><name>pgsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nBefore</name> <operator>=</operator> <call><name>lsmTreeSize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bDeleteRange</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeDelete</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeInsert</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>nAfter</name> <operator>=</operator> <call><name>lsmTreeSize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDiff</name> <operator>=</operator> <operator>(</operator><name>nAfter</name><operator>/</operator><name>nQuant</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>nBefore</name><operator>/</operator><name>nQuant</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bAutowork</name></name> <operator>&amp;&amp;</operator> <name>nDiff</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmSortedAutoWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>nDiff</name> <operator>*</operator> <name>LSM_AUTOWORK_QUANT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If a transaction was opened at the start of this function, commit it. 
  ** Or, if an error has occurred, roll it back.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>bCommit</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_commit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>lsm_rollback</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Write a new value into the database.
*/</comment>
<function><type><name>int</name></type> <name>lsm_insert</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                     <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,     <comment type="block">/* Key to write or delete */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>      <comment type="block">/* Value to write. Or nVal==-1 for a delete */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>doWriteOp</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a value from the database. 
*/</comment>
<function><type><name>int</name></type> <name>lsm_delete</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>doWriteOp</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a range of database keys.
*/</comment>
<function><type><name>int</name></type> <name>lsm_delete_range</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                     <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,   <comment type="block">/* Lower bound of range to delete */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>    <comment type="block">/* Upper bound of range to delete */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name><name>db</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>doWriteOp</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new cursor handle. 
**
** If there are currently no other open cursor handles, and no open write
** transaction, open a read transaction here.
*/</comment>
<function><type><name>int</name></type> <name>lsm_csr_open</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>MultiCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* New cursor object */</comment>

  <comment type="block">/* Open a read transaction if one is not already open. */</comment>
  <expr_stmt><expr><call><name>assert_db_state</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginRoTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginReadTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate the multi-cursor. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMCursorNew</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If an error has occured, set the output to NULL and delete any partially
  ** allocated cursor. If this means there are no open cursors, release the
  ** client snapshot.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbReleaseClientSnapshot</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert_db_state</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <operator>(</operator><name>lsm_cursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a cursor opened using lsm_csr_open().
*/</comment>
<function><type><name>int</name></type> <name>lsm_csr_close</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><call><name>lsmMCursorDb</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert_db_state</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmMCursorClose</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbReleaseClientSnapshot</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_db_state</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to seek the cursor to the database entry specified by pKey/nKey.
** If an error occurs (e.g. an OOM or IO error), return an LSM error code.
** Otherwise, return LSM_OK.
*/</comment>
<function><type><name>int</name></type> <name>lsm_csr_seek</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eSeek</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorSeek</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>eSeek</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_csr_next</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorNext</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_csr_prev</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorPrev</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_csr_first</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorFirst</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_csr_last</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorLast</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_csr_valid</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorValid</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_csr_key</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorKey</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>ppKey</name></expr></argument>, <argument><expr><name>pnKey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_csr_value</name><parameter_list>(<parameter><decl><type><name>lsm_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMCursorValue</name><argument_list>(<argument><expr><operator>(</operator><name>MultiCursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>ppVal</name></expr></argument>, <argument><expr><name>pnVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsm_config_log</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xLog</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>xLog</name></name> <operator>=</operator> <name>xLog</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pLogCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsm_config_work_hook</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xWork</name>)<parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name> <operator>=</operator> <name>xWork</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorkCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmLogMessage</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>xLog</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmString</name></type> <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>, <decl><type ref="prev"/><name>ap2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap2</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringVAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name>ap2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>xLog</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pLogCtx</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmStringClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_begin</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert_db_state</name><argument_list>( <argument><expr><name>pDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name></expr> ?</condition><then> <expr><name>LSM_READONLY</name></expr> </then><else>: <expr><name>LSM_OK</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* A value less than zero means open one more transaction. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLevel</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&gt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Extend the pDb-&gt;aTrans[] array if required. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nTransAlloc</name></name><operator>&lt;</operator><name>iLevel</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>TransMark</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>            <comment type="block">/* New allocation */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransMark</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>iLevel</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><name>TransMark</name> <operator>*</operator><operator>)</operator><call><name>lsmRealloc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aTrans</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransMark</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>iLevel</name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nTransAlloc</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransAlloc</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransAlloc</name></name> <operator>=</operator> <name>iLevel</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>aTrans</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginWriteTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iLevel</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>lsmTreeMark</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aTrans</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmLogTell</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aTrans</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name> <operator>=</operator> <name>iLevel</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_commit</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert_db_state</name><argument_list>( <argument><expr><name>pDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* A value less than zero means close the innermost nested transaction. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLevel</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
      <comment type="block">/* Commit the transaction to disk. */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmLogCommit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>eSafety</name></name><operator>==</operator><name>LSM_SAFETY_FULL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSyncLog</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>lsmFinishWriteTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>LSM_OK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name> <operator>=</operator> <name>iLevel</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>dbReleaseClientSnapshot</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_rollback</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert_db_state</name><argument_list>( <argument><expr><name>pDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* A value less than zero means close the innermost nested transaction. */</comment>
    <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLevel</name> <operator>=</operator> <call><name>LSM_MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&lt;=</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>TransMark</name> <modifier>*</modifier></type><name>pMark</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>aTrans</name><index>[<expr><operator>(</operator><ternary><condition><expr><name>iLevel</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>iLevel</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lsmTreeRollback</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMark</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iLevel</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmLogSeek</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMark</name><operator>-&gt;</operator><name>log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name> <operator>=</operator> <name>iLevel</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmFinishWriteTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dbReleaseClientSnapshot</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_get_user_version</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>piUsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>

  <comment type="block">/* Open a read transaction if one is not already open. */</comment>
  <expr_stmt><expr><call><name>assert_db_state</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginRoTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginReadTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate the multi-cursor. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piUsr</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsrVersion</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>dbReleaseClientSnapshot</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_db_state</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_set_user_version</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iUsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bCommit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* True to commit before returning */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bCommit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_begin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsrVersion</name></name> <operator>=</operator> <name>iUsr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If a transaction was opened at the start of this function, commit it. 
  ** Or, if an error has occurred, roll it back.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>bCommit</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsm_commit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>lsm_rollback</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
