<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/wasm/c-pp.c"><comment type="block">/*
** 2022-11-12:
**
** In place of a legal notice, here is a blessing:
**
**  * May you do good and not evil.
**  * May you find forgiveness for yourself and forgive others.
**  * May you share freely, never taking more than you give.
**
************************************************************************
**
** The C-minus Preprocessor: a truly minimal C-like preprocessor.
** Why? Because C preprocessors _can_ process non-C code but generally make
** quite a mess of it. The purpose of this application is an extremely
** minimal preprocessor with only the most basic functionality of a C
** preprocessor, namely:
**
** - Limited `#if`, where its one argument is a macro name which
**   resolves to true if it's defined, false if it's not. Likewise,
**   `#ifnot` is the inverse. Includes `#else` and `#elif` and
**   `#elifnot`. Such chains are terminated with `#endif`.
**
** - `#define` accepts one or more arguments, the names of
**   macros. Each one is implicitly true.
**
** - `#undef` undefine one or more macros.
**
** - `#error` treats the rest of the line as a fatal error message.
**
** - `#include` treats its argument as a filename token (NOT quoted,
**   though support for quoting may be added later). Some effort is
**   made to prevent recursive inclusion, but that support is both
**   somewhat fragile and possibly completely unnecessary.
**
** - `#pragma` is in place for adding "meta-commands", but it does not
**   yet have any concrete list of documented commands.
**
*  - `#stderr` outputs its file name, line number, and the remaininder
**   of that line to stderr.
**
** - `#//` acts as a single-line comment, noting that there must be as
**   space after the `//` part because `//` is (despite appearances)
**   parsed like a keyword.
**
** Note that "#" above is symbolic. The keyword delimiter is
** configurable and defaults to "##". Define CMPP_DEFAULT_DELIM to a
** string when compiling to define the default at build-time.
**
** This preprocessor does no expansion of content except within the
** bounds of its `#keywords`.
**
** Design note: this code makes use of sqlite3. Though not _strictly_
** needed in order to implement it, this tool was specifically created
** for potential use with the sqlite3 project's own JavaScript code,
** so there's no reason not to make use of it to do some of the heavy
** lifting. It does not require any cutting-edge sqlite3 features and
** should be usable with any version which supports `WITHOUT ROWID`.
**
** Author(s):
**
** - Stephan Beal &lt;https://wanderinghorse.net/home/stephan/&gt;
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>access</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>access</name><parameter_list>(<parameter><type><name>f</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_access((f),(m))</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CMPP_DEFAULT_DELIM</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMPP_DEFAULT_DELIM</name></cpp:macro> <cpp:value>"##"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CMPP_NORETURN</name></cpp:macro> <cpp:value>__attribute__((noreturn))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CMPP_NORETURN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Fatally exits the app with the given printf-style message. */</comment>
<function_decl><type><specifier>static</specifier> <name>CMPP_NORETURN</name> <name>void</name></type> <name>fatalv</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CMPP_NORETURN</name> <name>void</name></type> <name>fatal</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/** Proxy for free(), for symmetry with cmpp_realloc(). */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/** A realloc() proxy which dies fatally on allocation error. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>cmpp_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block" format="doxygen">/** A malloc() proxy which dies fatally on allocation error. */</comment>
static void * cmpp_malloc(unsigned n);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If p is stdin or stderr then this is a no-op, else it is a
** proxy for fclose(). This is a no-op if p is NULL.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FILE_close</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Works like fopen() but accepts the special name "-" to mean either
** stdin (if zMode indicates a real-only mode) or stdout. Fails
** fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type> <name>FILE_open</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zMode</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Reads the entire contents of the given file, allocating it in a
** buffer which gets assigned to `*pOut`. `*nOut` gets assigned the
** length of the output buffer. Fails fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FILE_slurp</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pOut</name></decl></parameter>,
                       <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type> <name>nOut</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Intended to be passed an sqlite3 result code. If it's non-0
** then it emits a fatal error message which contains both the
** given string and the sqlite3_errmsg() from the application's
** database instance.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_affirm_rc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zMsg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Proxy for sqlite3_str_finish() which fails fatally if that
** routine returns NULL.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>db_str_finish</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Proxy for sqlite3_str_new() which fails fatally if that
** routine returns NULL.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>sqlite3_str</name> <modifier>*</modifier></type> <name>db_str_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Proxy for sqlite3_finalize(). */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_finalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Proxy for sqlite3_step() which fails fatally if the result
** is anything other than SQLITE_ROW or SQLITE_DONE.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>db_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Proxy for sqlite3_bind_int() which fails fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_bind_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Proxy for sqlite3_bind_null() which fails fatally on error.
*/</comment>
static void db_bind_null(sqlite3_stmt *pStmt, int col);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** Proxy for sqlite3_bind_text() which fails fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_bind_text</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zStr</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Proxy for sqlite3_bind_text() which fails fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_bind_textn</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zStr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Proxy for sqlite3_bind_text() which fails fatally on error. It uses
** sqlite3_str_vappendf() so supports all of its formatting options.
*/</comment>
static void db_bind_textv(sqlite3_stmt *pStmt, int col, const char * zFmt, ...);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** Proxy for sqlite3_free(), to be passed any memory which is allocated
** by sqlite3_malloc().
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Adds the given `#define` macro name to the list of macros, ignoring
** any duplicates. Fails fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_define_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Returns true if the given key is already in the `#define` list,
** else false. Fails fatally on db error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>db_define_has</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Removes the given `#define` macro name from the list of
** macros. Fails fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_define_rm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Adds the given filename to the list of being-`#include`d files,
** using the given source file name and line number of error reporting
** purposes. If recursion is later detected.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_including_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zSrc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcLine</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Adds the given dir to the list of includes. They are checked in the
** order they are added.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_include_dir_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Returns a resolved path of PREFIX+'/'+zKey, where PREFIX is one of
** the `#include` dirs (db_include_dir_add()). If no file match is
** found, NULL is returned. Memory must eventually be passed to
** db_free() to free it.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>db_include_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Removes the given key from the `#include` list.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_include_rm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** A proxy for sqlite3_prepare() which fails fatally on error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>db_prepare</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zSql</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Opens the given file and processes its contents as c-pp, sending
** all output to the global c-pp output channel. Fails fatally on
** error.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_process_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Returns the number newline characters between the given starting
** point and inclusive ending point. Results are undefined if zFrom is
** greater than zTo.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>count_lines</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zFrom</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zTo</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Wrapper around a FILE handle.
*/</comment>
<struct>struct <name>FileWrapper</name> <block>{
  <comment type="block">/* File's name. */</comment>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <comment type="block">/* FILE handle. */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>pFile</name></decl>;</decl_stmt>
  <comment type="block">/* Where FileWrapper_slurp() stores the file's contents. */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>zContent</name></decl>;</decl_stmt>
  <comment type="block">/* Size of this-&gt;zContent, as set by FileWrapper_slurp(). */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nContent</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>FileWrapper</name></name></type> <name>FileWrapper</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FileWrapper_empty_m</name></cpp:macro> <cpp:value>{0,0,0,0}</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FileWrapper</name></type> <name>FileWrapper_empty</name> <init>= <expr><name>FileWrapper_empty_m</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Proxy for FILE_close(). */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FileWrapper_close</name><parameter_list>(<parameter><decl><type><name>FileWrapper</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Proxy for FILE_open(). */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FileWrapper_open</name><parameter_list>(<parameter><decl><type><name>FileWrapper</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMode</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Proxy for FILE_slurp(). */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FileWrapper_slurp</name><parameter_list>(<parameter><decl><type><name>FileWrapper</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Outputs a printf()-formatted message to stderr.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>g_stderr</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Outputs a printf()-formatted message to stderr.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>g_stderrv</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>g_debug</name><parameter_list>(<parameter><type><name>lvl</name></type></parameter>,<parameter><type><name>pfexpr</name></type></parameter>)</parameter_list></cpp:macro>                                          \
  <cpp:value>if(lvl&lt;=g.doDebug) g_stderr("%s @ %s:%d: ",g.zArgv0,__FILE__,__LINE__); \
  if(lvl&lt;=g.doDebug) g_stderr pfexpr</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>fatalv</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>va</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>zFmt</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zFmt</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>fatal</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fatalv</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmpp_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type> <name>cmpp_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>rc</name> <init>= <expr><call><name>realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"realloc(P,%u) failed"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
void * cmpp_malloc(unsigned n){
  void * const rc = malloc(n);
  if(!rc) fatal("malloc(%u) failed", n);
  return rc;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>FILE</name> <modifier>*</modifier></type> <name>FILE_open</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><literal type="char">'-'</literal><operator>==</operator><name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><name><name>zName</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><call><name>strstr</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>stdout</name></expr> </then><else>: <expr><name>stdin</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Cannot open file [%s] with mode [%s]"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FILE_close</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name>p</name><operator>!=</operator><name>stdout</name> <operator>&amp;&amp;</operator> <name>p</name><operator>!=</operator><name>stderr</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FILE_slurp</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pOut</name></decl></parameter>,
                <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type> <name>nOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>pDest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Note that this needs to be able to work on non-seekable streams,
  ** thus we read in chunks instead of doing a single alloc and
  ** filling it in one go. */</comment>
  <while>while<condition>( <expr><operator>!</operator><call><name>feof</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>n</name> <init>= <expr><call><name>fread</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
      <if_stmt><if>if<condition>(<expr><name>nAlloc</name> <operator>&lt;</operator> <name>nOff</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>nOff</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDest</name> <operator>=</operator> <call><name>cmpp_realloc</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDest</name> <operator>+</operator> <name>nOff</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nOff</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>(<expr><name>pDest</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pDest</name><index>[<expr><name>nOff</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pOut</name> <operator>=</operator> <name>pDest</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>nOut</name> <operator>=</operator> <name>nOff</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FileWrapper_close</name><parameter_list>(<parameter><decl><type><name>FileWrapper</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FILE_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>zContent</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmpp_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zContent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>FileWrapper_empty</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FileWrapper_open</name><parameter_list>(<parameter><decl><type><name>FileWrapper</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>FileWrapper_close</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <call><name>FILE_open</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FileWrapper_slurp</name><parameter_list>(<parameter><decl><type><name>FileWrapper</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>zContent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FILE_slurp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zContent</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nContent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name></type> <name>count_lines</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zFrom</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zTo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>ln</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zPos</name> <init>= <expr><name>zFrom</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zFrom</name> <operator>&amp;&amp;</operator> <name>zTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zFrom</name> <operator>&lt;=</operator> <name>zTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>zPos</name> <operator>&lt;</operator> <name>zTo</name></expr>;</condition> <incr><expr><operator>++</operator><name>zPos</name></expr></incr>)</control><block>{<block_content>
    <switch>switch<condition>(<expr><operator>*</operator><name>zPos</name></expr>)</condition><block>{<block_content>
      <case>case <expr><operator>(</operator><name>unsigned</name><operator>)</operator><literal type="char">'\n'</literal></expr>:</case> <expr_stmt><expr><operator>++</operator><name>ln</name></expr>;</expr_stmt> <break>break;</break>
      <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <return>return <expr><name>ln</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>CmppParseState</name> <block>{
<decl><name>TS_Start</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>TS_If</name></decl>,
<decl><name>TS_IfPassed</name></decl>,
<decl><name>TS_Else</name></decl>,
<decl><name>TS_Error</name></decl>
}</block>;</enum>
<typedef>typedef <type><name><name>enum</name> <name>CmppParseState</name></name></type> <name>CmppParseState</name>;</typedef>
<enum>enum <name>CmppTokenType</name> <block>{
<decl><name>TT_Invalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>TT_Comment</name></decl>,
<decl><name>TT_Define</name></decl>,
<decl><name>TT_Elif</name></decl>,
<decl><name>TT_ElifNot</name></decl>,
<decl><name>TT_Else</name></decl>,
<decl><name>TT_EndIf</name></decl>,
<decl><name>TT_Error</name></decl>,
<decl><name>TT_If</name></decl>,
<decl><name>TT_IfNot</name></decl>,
<decl><name>TT_Include</name></decl>,
<decl><name>TT_Line</name></decl>,
<decl><name>TT_Pragma</name></decl>,
<decl><name>TT_Stderr</name></decl>,
<decl><name>TT_Undef</name></decl>
}</block>;</enum>
<typedef>typedef <type><name><name>enum</name> <name>CmppTokenType</name></name></type> <name>CmppTokenType</name>;</typedef>

<struct>struct <name>CmppToken</name> <block>{
  <decl_stmt><decl><type><name>CmppTokenType</name></type> <name>ttype</name></decl>;</decl_stmt>
  <comment type="block">/* Line number of this token in the source file. */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>lineNo</name></decl>;</decl_stmt>
  <comment type="block">/* Start of the token. */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zBegin</name></decl>;</decl_stmt>
  <comment type="block">/* One-past-the-end byte of the token. */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zEnd</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>CmppToken</name></name></type> <name>CmppToken</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CmppToken_empty_m</name></cpp:macro> <cpp:value>{TT_Invalid,0,0,0}</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CmppToken</name></type> <name>CmppToken_empty</name> <init>= <expr><name>CmppToken_empty_m</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** CmppLevel represents one "level" of tokenization, starting at the
** top of the main input, incrementing once for each level of `#if`,
** and decrementing for each `#endif`.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>CmppLevel</name></name></type> <name>CmppLevel</name>;</typedef>
<struct>struct <name>CmppLevel</name> <block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>flags</name></decl>;</decl_stmt>
  <comment type="block">/*
  ** Used for controlling which parts of an if/elif/...endif chain
  ** should get output.
  */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>skipLevel</name></decl>;</decl_stmt>
  <comment type="block">/* The token which started this level (an 'if' or 'ifnot'). */</comment>
  <decl_stmt><decl><type><name>CmppToken</name></type> <name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppParseState</name></type> <name>pstate</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CmppLevel_empty_m</name></cpp:macro> <cpp:value>{0U,0U,CmppToken_empty_m,TS_Start}</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CmppLevel</name></type> <name>CmppLevel_empty</name> <init>= <expr><name>CmppLevel_empty_m</name></expr></init></decl>;</decl_stmt>
<enum>enum <name>CmppLevel_Flags</name> <block>{
<comment type="block">/* Max depth of nested `#if` constructs in a single tokenizer. */</comment>
<decl><name>CmppLevel_Max</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>,
<comment type="block">/* Max number of keyword arguments. */</comment>
<decl><name>CmppArgs_Max</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>,
<comment type="block">/* Flag indicating that output for a CmpLevel should be elided. */</comment>
<decl><name>CmppLevel_F_ELIDE</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
<comment type="block">/*
** Mask of CmppLevel::flags which are inherited when CmppLevel_push()
** is used.
*/</comment>
<decl><name>CmppLevel_F_INHERIT_MASK</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>
}</block>;</enum>

<typedef>typedef <type><name><name>struct</name> <name>CmppTokenizer</name></name></type> <name>CmppTokenizer</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>CmppKeyword</name></name></type> <name>CmppKeyword</name>;</typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cmpp_keyword_f</name>)<parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<struct>struct <name>CmppKeyword</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bTokenize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppTokenType</name></type> <name>ttype</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cmpp_keyword_f</name></type> <name>xCall</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>CmppKeyword_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_process_keyword</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Tokenizer for c-pp input files.
*/</comment>
<struct>struct <name>CmppTokenizer</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl>;</decl_stmt>            <comment type="block">/* Input (file) name for error reporting */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zBegin</name></decl>;</decl_stmt>  <comment type="block">/* start of input */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zEnd</name></decl>;</decl_stmt>    <comment type="block">/* one-after-the-end of input */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zAnchor</name></decl>;</decl_stmt> <comment type="block">/* start of input or end point of
                                    previous token */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zPos</name></decl>;</decl_stmt>    <comment type="block">/* current position */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lineNo</name></decl>;</decl_stmt>           <comment type="block">/* line # of current pos */</comment>
  <decl_stmt><decl><type><name>CmppParseState</name></type> <name>pstate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppToken</name></type> <name>token</name></decl>;</decl_stmt>               <comment type="block">/* current token result */</comment>
  <struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>ndx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CmppLevel</name></type> <name><name>stack</name><index>[<expr><name>CmppLevel_Max</name></expr>]</index></name></decl>;</decl_stmt>
  }</block> <decl><name>level</name></decl>;</struct>
  <comment type="block">/* Args for use in cmpp_keyword_f() impls. */</comment>
  <struct>struct <block>{
    <decl_stmt><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name><name>argv</name><index>[<expr><name>CmppArgs_Max</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>lineBuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
  }</block> <decl><name>args</name></decl>;</struct>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CT_level</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(t)-&gt;level.stack[(t)-&gt;level.ndx]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CT_pstate</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CT_level(t).pstate</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CT_skipLevel</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CT_level(t).skipLevel</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLvl_skip</name><parameter_list>(<parameter><type><name>lvl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((lvl)-&gt;skipLevel || ((lvl)-&gt;flags &amp; CmppLevel_F_ELIDE))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CT_skip</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CLvl_skip(&amp;CT_level(t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CmppTokenizer_empty_m</name></cpp:macro> <cpp:value>{                 \
    0,0,0,0,0,1U<comment type="block">/*lineNo*/</comment>,                     \
    TS_Start,                                 \
    CmppToken_empty_m,                        \
    {<comment type="block">/*level*/</comment>0U,{CmppLevel_empty_m}},       \
    {<comment type="block">/*args*/</comment>0,0,{0},{0}}                \
  }</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CmppTokenizer</name></type> <name>CmppTokenizer_empty</name> <init>= <expr><name>CmppTokenizer_empty_m</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_t_out</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*static void cmpp_t_outf(CmppTokenizer * t, char const *zFmt, ...);*/</comment>

<comment type="block">/*
** Pushes a new level into the given tokenizer. Fails fatally if
** it's too deep.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CmppLevel_push</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Pops a level from the tokenizer. Fails fatally if the top
** level is popped.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CmppLevel_pop</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
** Returns the current level object.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>CmppLevel</name> <modifier>*</modifier></type> <name>CmppLevel_get</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Global app state singleton. */</comment>
<struct><specifier>static</specifier> struct <name>Global</name> <block>{
  <comment type="block">/* main()'s argv[0]. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zArgv0</name></decl>;</decl_stmt>
  <comment type="block">/*
  ** Bytes of the keyword delimiter/prefix. Owned
  ** elsewhere.
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zDelim</name></decl>;</decl_stmt>
  <comment type="block">/* Byte length of this-&gt;zDelim. */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>nDelim</name></decl>;</decl_stmt>
  <comment type="block">/* If true, enables certain debugging output. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>doDebug</name></decl>;</decl_stmt>
  <comment type="block">/* App's db instance. */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type> <name>db</name></decl>;</decl_stmt>
  <comment type="block">/* Output channel. */</comment>
  <decl_stmt><decl><type><name>FileWrapper</name></type> <name>out</name></decl>;</decl_stmt>
  <struct>struct <block>{
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>defIns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>defDel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>defHas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>inclIns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>inclDel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>inclHas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>inclPathAdd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>inclSearch</name></decl>;</decl_stmt>
  }</block> <decl><name>stmt</name></decl>;</struct>
}</block> <decl><name>g</name> <init>= <expr><block>{
<expr><literal type="string">"?"</literal></expr>,
<expr><name>CMPP_DEFAULT_DELIM</name></expr><comment type="block">/*zDelim*/</comment>,
<expr><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CMPP_DEFAULT_DELIM</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr><comment type="block">/*nDelim*/</comment>,
<expr><literal type="number">0</literal></expr><comment type="block">/*doDebug*/</comment>,
<expr><literal type="number">0</literal></expr><comment type="block">/*db*/</comment>,
<expr><name>FileWrapper_empty_m</name></expr><comment type="block">/*out*/</comment>,
<expr><block>{<comment type="block">/*stmt*/</comment>
  <expr><literal type="number">0</literal></expr><comment type="block">/*defIns*/</comment>, <expr><literal type="number">0</literal></expr><comment type="block">/*defDel*/</comment>, <expr><literal type="number">0</literal></expr><comment type="block">/*defHas*/</comment>,
  <expr><literal type="number">0</literal></expr><comment type="block">/*inclIns*/</comment>, <expr><literal type="number">0</literal></expr><comment type="block">/*inclDel*/</comment>, <expr><literal type="number">0</literal></expr><comment type="block">/*inclHas*/</comment>,
  <expr><literal type="number">0</literal></expr><comment type="block">/*inclPathAdd*/</comment>
}</block></expr>
}</block></expr></init></decl>;</struct>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Outputs a printf()-formatted message to c-pp's global output
** channel.
*/</comment>
static void g_outf(char const *zFmt, ...);
void g_outf(char const *zFmt, ...){
  va_list va;
  va_start(va, zFmt);
  vfprintf(g.out.pFile, zFmt, va);
  va_end(va);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* Outputs n bytes from z to c-pp's global output channel. */</comment>
static void g_out(void const *z, unsigned int n);
void g_out(void const *z, unsigned int n){
  if(1!=fwrite(z, n, 1, g.out.pFile)){
    int const err = errno;
    fatal("fwrite() output failed with errno #%d", err);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>g_stderrv</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>va</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>g_stderr</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>g_stderrv</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
void cmpp_t_outf(CmppTokenizer * t, char const *zFmt, ...){
  if(!CT_skip(t)){
    va_list va;
    va_start(va, zFmt);
    vfprintf(g.out.pFile, zFmt, va);
    va_end(va);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>cmpp_t_out</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>CT_skip</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <if_stmt><if>if<condition>(<expr><literal type="number">1</literal><operator>!=</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>out</name><operator>.</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"fwrite() output failed with errno #%d"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>CmppLevel_push</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CmppLevel</name> <modifier>*</modifier></type> <name>pPrev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppLevel</name> <modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name><operator>+</operator><literal type="number">1</literal> <operator>==</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>CmppLevel_Max</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"%sif nesting level is too deep. Max=%d\n"</literal></expr></argument>,
          <argument><expr><name><name>g</name><operator>.</operator><name>zDelim</name></name></expr></argument>, <argument><expr><name>CmppLevel_Max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <operator>&amp;</operator><call><name>CT_level</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>stack</name><index>[<expr><operator>++</operator><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>CmppLevel_empty</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>token</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name>CmppLevel_F_INHERIT_MASK</name> <operator>&amp;</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><call><name>CLvl_skip</name><argument_list>(<argument><expr><name>pPrev</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CmppLevel_F_ELIDE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>CmppLevel_pop</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Internal error: CmppLevel_pop() at the top of the stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>stack</name><index>[<expr><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name><operator>--</operator></expr>]</index></name> <operator>=</operator> <name>CmppLevel_empty</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>CmppLevel</name> <modifier>*</modifier></type> <name>CmppLevel_get</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>stack</name><index>[<expr><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>db_affirm_rc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zMsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Db error #%d %s: %s"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_finalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>db_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>rc</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_ROW</name><operator>!=</operator><name>rc</name> <operator>&amp;&amp;</operator> <name>SQLITE_DONE</name><operator>!=</operator><name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"from db_step()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sqlite3_str</name> <modifier>*</modifier></type> <name>db_str_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type> <name>rc</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Alloc failed for sqlite3_str_new()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>db_str_finish</name><parameter_list>(<parameter><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>rc</name> <init>= <expr><call><name>sqlite3_str_errcode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Error #%d from sqlite3_str_errcode()"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>n</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>sqlite3_str_length</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>z</name> <init>= <expr><call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>z</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Alloc failed for sqlite3_str_new()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_prepare</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zSql</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type> <name>str</name> <init>= <expr><call><name>db_str_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"sqlite3_str_new() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_vappendf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_str_errcode</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"sqlite3_str_errcode() = %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>db_str_finish</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Error #%d (%s) preparing: %s"</literal></expr></argument>,
               <argument><expr><name>rc</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_bind_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>rc</name> <init>= <expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>,<argument><expr><literal type="string">"from db_bind_int()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
void db_bind_null(sqlite3_stmt *pStmt, int col){
  int const rc = sqlite3_bind_null(pStmt, col);
  db_affirm_rc(rc,"from db_bind_null()");
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>db_bind_textn</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zStr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>rc</name> <init>= <expr><ternary><condition><expr><name>zStr</name></expr>
    ?</condition><then> <expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>
    </then><else>: <expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>,<argument><expr><literal type="string">"from db_bind_textn()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_bind_text</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>db_bind_textn</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
void db_bind_textv(sqlite3_stmt *pStmt, int col,
                   const char * zFmt, ...){
  int rc;
  sqlite3_str * str = db_str_new();
  int n = 0;
  char * z;
  va_list va;
  va_start(va,zFmt);
  sqlite3_str_vappendf(str, zFmt, va);
  va_end(va);
  z = db_str_finish(str, &amp;n);
  rc = sqlite3_bind_text(pStmt, col, z, n, sqlite3_free);
  db_affirm_rc(rc,"from db_bind_textv()");
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>db_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_define_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defIns</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defIns</name></name></expr></argument>,
               <argument><expr><literal type="string">"INSERT OR REPLACE INTO def(k) VALUES(?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defIns</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defIns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_DONE</name> <operator>!=</operator> <name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Stepping INSERT on def"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"define: %s\n"</literal><operator>,</operator><name>zKey</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defIns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>db_define_has</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defHas</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defHas</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM def WHERE k=?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defHas</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defHas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_ROW</name> <operator>==</operator> <name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_DONE</name><operator>==</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"define has [%s] = %d\n"</literal><operator>,</operator><name>zName</name><operator>,</operator> <name>rc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defHas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defHas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>db_define_rm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPos</name> <init>= <expr><name>zKey</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defDel</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defDel</name></name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM def WHERE k=?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>( <init>;</init> <condition><expr><operator>*</operator><name>zPos</name> <operator>&amp;&amp;</operator> <literal type="char">'='</literal><operator>!=</operator><operator>*</operator><name>zPos</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr><operator>,</operator> <expr><operator>++</operator><name>zPos</name></expr></incr>)</control> <block>{<block_content/>}</block></for>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defDel</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defDel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_DONE</name> <operator>!=</operator> <name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Stepping DELETE on def"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"undefine: %.*s\n"</literal><operator>,</operator><name>n</name><operator>,</operator> <name>zKey</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defDel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>defDel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_including_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zSrc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcLine</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr></argument>,
               <argument><expr><literal type="string">"INSERT OR FAIL INTO incl(file,srcFile,srcLine) VALUES(?,?,?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>db_bind_int</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>srcLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_DONE</name> <operator>!=</operator> <name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Stepping INSERT on incl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"inclpath add [%s] from [%s]:%d\n"</literal><operator>,</operator> <name>zKey</name><operator>,</operator> <name>zSrc</name><operator>,</operator> <name>srcLine</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclIns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_include_rm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclDel</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclDel</name></name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM incl WHERE file=?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclDel</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclDel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_DONE</name> <operator>!=</operator> <name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Stepping DELETE on incl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"inclpath rm [%s]\n"</literal><operator>,</operator> <name>zKey</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclDel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclDel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type> <name>db_include_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclSearch</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclSearch</name></name></expr></argument>,
               <argument><expr><literal type="string">"SELECT ?1 fn WHERE fileExists(fn) "</literal>
               <literal type="string">"UNION ALL SELECT * FROM ("</literal>
               <literal type="string">"SELECT replace(dir||'/'||?1, '//','/') AS fn "</literal>
               <literal type="string">"FROM inclpath WHERE fileExists(fn) ORDER BY seq"</literal>
               <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclSearch</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_ROW</name><operator>==</operator><call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclSearch</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>z</name> <init>= <expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclSearch</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <ternary><condition><expr><name>z</name></expr> ?</condition><then> <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>zName</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Alloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclSearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclSearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>db_including_has</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclHas</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclHas</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM incl WHERE file=?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclHas</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclHas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_ROW</name> <operator>==</operator> <name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_DONE</name><operator>==</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"inclpath has [%s] = %d\n"</literal><operator>,</operator><name>zName</name><operator>,</operator> <name>rc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclHas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclHas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Fails fatally if the `#include` list contains the given key.
*/</comment>
static void db_including_check(const char * zKey);
void db_including_check(const char * zName){
  if(db_including_has(zName)){
    fatal("Recursive include detected: %s\n", zName);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>db_include_dir_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zDir</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>seq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclPathAdd</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclPathAdd</name></name></expr></argument>,
               <argument><expr><literal type="string">"INSERT OR FAIL INTO inclpath(seq,dir) VALUES(?,?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>db_bind_int</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclPathAdd</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>++</operator><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>db_bind_text</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclPathAdd</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>db_step</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclPathAdd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>SQLITE_DONE</name> <operator>!=</operator> <name>rc</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Stepping INSERT on inclpath"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"inclpath add #%d: %s\n"</literal><operator>,</operator><name>seq</name><operator>,</operator> <name>zDir</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclPathAdd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>stmt</name><operator>.</operator><name>inclPathAdd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINI</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if(g.stmt.M) sqlite3_finalize(g.stmt.M)</cpp:value></cpp:define>
  <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>defIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>defDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>defHas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>inclIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>inclDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>inclHas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>inclPathAdd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FINI</name><argument_list>(<argument><expr><name>inclSearch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FINI</name></cpp:undef>
  <expr_stmt><expr><call><name>FileWrapper_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>g</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** sqlite3 UDF which returns true if its argument refers to an
** accessible file, else false.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>udf_file_exists</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>argc</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>access</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize g.db, failing fatally on error. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_initdb</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zSchema</name> <init>=
    <expr><literal type="string">"CREATE TABLE def("</literal>
      <literal type="string">"k TEXT PRIMARY KEY NOT NULL"</literal>
    <comment type="block">/*"v INTEGER DEFAULT 1"*/</comment>
    <literal type="string">") WITHOUT ROWID;"</literal>
    <comment type="block">/* ^^^ defines */</comment>
    <literal type="string">"CREATE TABLE incl("</literal>
      <literal type="string">"file TEXT PRIMARY KEY NOT NULL,"</literal>
      <literal type="string">"srcFile TEXT DEFAULT NULL,"</literal>
      <literal type="string">"srcLine INTEGER DEFAULT 0"</literal>
    <literal type="string">") WITHOUT ROWID;"</literal>
    <comment type="block">/* ^^^ files currently being included */</comment>
    <literal type="string">"CREATE TABLE inclpath("</literal>
      <literal type="string">"seq INTEGER UNIQUE, "</literal>
      <literal type="string">"dir TEXT PRIMARY KEY NOT NULL ON CONFLICT IGNORE"</literal>
    <literal type="string">")"</literal></expr></init></decl>
    <comment type="block">/* ^^^ include path */</comment>
    ;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal><operator>==</operator><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>g</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_OPEN_READWRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Error opening :memory: db."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Error initializing database: %s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"fileExists"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
                               <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DIRECTONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>udf_file_exists</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>db_affirm_rc</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"UDF registration failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** For position zPos, which must be in the half-open range
** [zBegin,zEnd), returns g.nDelim if it is at the start of a line and
** starts with g.zDelim, else returns 0.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>short</name></type> <name>cmpp_is_delim</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zBegin</name></decl></parameter>,
                                    <parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>,
                                    <parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zPos</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zEnd</name><operator>&gt;</operator><name>zBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zPos</name><operator>&lt;</operator><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zPos</name><operator>&gt;=</operator><name>zBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>zPos</name><operator>&gt;</operator><name>zBegin</name> <operator>&amp;&amp;</operator>
     <operator>(</operator><literal type="char">'\n'</literal><operator>!=</operator><operator>*</operator><operator>(</operator><name>zPos</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator>
      <operator>||</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zPos</name><operator>)</operator> <operator>&lt;=</operator> <name><name>g</name><operator>.</operator><name>nDelim</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>(<expr><literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>zPos</name></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>zDelim</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>nDelim</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <return>return <expr><name><name>g</name><operator>.</operator><name>nDelim</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Scans t to the next keyword line, emitting all input before that
** which is _not_ a keyword line unless it's elided due to being
** inside a block which elides its content. Returns 0 if no keyword
** line was found, in which case the end of the input has been
** reached, else returns a truthy value and sets up t's state for use
** with cmpp_process_keyword(), which should then be called.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpp_next_keyword_line</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppToken</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>tok</name> <init>= <expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>token</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>isDelim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>zBegin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&gt;</operator> <name><name>t</name><operator>-&gt;</operator><name>zBegin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>zPos</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>zPos</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>zBegin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>zAnchor</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>zPos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>z</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>zPos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>tok</name> <operator>=</operator> <name>CmppToken_empty</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><name>z</name><operator>&lt;</operator><name><name>t</name><operator>-&gt;</operator><name>zEnd</name></name>
        <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name>isDelim</name> <operator>=</operator> <call><name>cmpp_is_delim</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>zBegin</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>zEnd</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><operator>++</operator><name>z</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>(<expr><name>z</name><operator>&gt;</operator><name>zStart</name></expr>)</condition><block>{<block_content>
    <comment type="block">/* We passed up content */</comment>
    <expr_stmt><expr><call><name>cmpp_t_out</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>z</name> <operator>-</operator> <name>zStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isDelim</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isDelim</name><operator>==</operator><name><name>g</name><operator>.</operator><name>nDelim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>lineNo</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>lineNo</name></name> <operator>+=</operator> <call><name>count_lines</name><argument_list>(<argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>isDelim</name></expr>)</condition><block>{<block_content>
    <comment type="block">/* Handle backslash-escaped newlines */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isEsc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>atEol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name> <operator>=</operator> <name>z</name><operator>+</operator><name>isDelim</name></expr>;</expr_stmt>
    <for>for<control>( <init><expr><operator>++</operator><name>z</name></expr> ;</init> <condition><expr><name>z</name><operator>&lt;</operator><name><name>t</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><name>atEol</name></expr>;</condition> <incr><expr><operator>++</operator><name>z</name></expr></incr> )</control><block>{<block_content>
      <switch>switch<condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>z</name></expr>)</condition><block>{<block_content>
        <case>case <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="char">'\\'</literal></expr>:</case>
          <expr_stmt><expr><name>isEsc</name> <operator>=</operator> <literal type="number">0</literal><operator>==</operator><name>isEsc</name></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="char">'\n'</literal></expr>:</case>
          <expr_stmt><expr><name>atEol</name> <operator>=</operator> <literal type="number">0</literal><operator>==</operator><name>isEsc</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>isEsc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>++</operator><name><name>t</name><operator>-&gt;</operator><name>lineNo</name></name></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>=</operator> <ternary><condition><expr><name>atEol</name></expr> ?</condition><then> <expr><name>z</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>z</name></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* Strip leading spaces */</comment>
    <while>while<condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name> <operator>&lt;</operator> <name><name>tok</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>*</operator><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name>TT_Line</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Keyword @ line %u: [[[%.*s]]]\n"</literal><operator>,</operator>
               <name><name>tok</name><operator>-&gt;</operator><name>lineNo</name></name><operator>,</operator>
               <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>tok</name><operator>-&gt;</operator><name>zEnd</name></name><operator>-</operator><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name><operator>)</operator><operator>,</operator> <name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>zPos</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>isDelim</name></expr>)</condition><block>{<block_content>
    <comment type="block">/* Split t-&gt;token into arguments for the line's keyword */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>prevChar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>tokLen</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>tok</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>-</operator> <name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>zKwd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>zEsc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>zz</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TT_Line</name><operator>==</operator><name><name>tok</name><operator>-&gt;</operator><name>ttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>lineBuf</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name>tokLen</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Keyword line is unreasonably long: %.*s"</literal></expr></argument>,
            <argument><expr><name>tokLen</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>(<expr><operator>!</operator><name>tokLen</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Line #%u has no keyword after delimiter"</literal></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>lineNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"token @ line %u len=%u [[[%.*s]]]\n"</literal><operator>,</operator>
               <name><name>tok</name><operator>-&gt;</operator><name>lineNo</name></name><operator>,</operator> <name>tokLen</name><operator>,</operator> <name>tokLen</name><operator>,</operator> <name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zKwd</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>lineBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zKwd</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name></expr></argument>, <argument><expr><name>tokLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zKwd</name> <operator>+</operator> <name>tokLen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>lineBuf</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>tokLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>zEsc</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>zz</name> <operator>=</operator> <name>zKwd</name></expr>;</init> <condition><expr><operator>*</operator><name>zz</name></expr>;</condition> <incr><expr><operator>++</operator><name>zz</name></expr></incr> )</control><block>{<block_content>
      <comment type="block">/* Convert backslash-escaped newlines to whitespace */</comment>
      <switch>switch<condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>zz</name></expr>)</condition><block>{<block_content>
        <case>case <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="char">'\\'</literal></expr>:</case>
          <if_stmt><if>if<condition>(<expr><name>zEsc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zEsc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>zEsc</name> <operator>=</operator> <name>zz</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          <break>break;</break>
        <case>case <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="char">'\n'</literal></expr>:</case>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zEsc</name> <operator>&amp;&amp;</operator> <literal type="string">"Should not have an unescaped newline?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>(<expr><name>zEsc</name><operator>==</operator><name>zz</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>zEsc</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><literal type="char">' '</literal></expr>;</expr_stmt>
            <comment type="block">/* FIXME?: memmove() lnBuf content one byte to the left here
            ** to collapse backslash and newline into a single
            ** byte. Also consider collapsing all leading space on the
            ** next line. */</comment>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>zEsc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>zz</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><literal type="char">' '</literal></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>
          <expr_stmt><expr><name>zEsc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>zKwd</name></expr>;</expr_stmt>
    <for>for<control>( <init><expr><name>zz</name> <operator>=</operator> <name>zKwd</name></expr>;</init> <condition><expr><operator>*</operator><name>zz</name></expr>;</condition> <incr><expr><operator>++</operator><name>zz</name></expr></incr> )</control><block>{<block_content>
      <if_stmt><if>if<condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zz</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>zz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name></name> <operator>=</operator> <call><name>CmppKeyword_search</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>zKwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Unknown keyword '%s' at line %u\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>zKwd</name></expr></argument>,
            <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>lineNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>( <init><expr><operator>++</operator><name>zz</name></expr> ;</init> <condition><expr><operator>*</operator><name>zz</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zz</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>zz</name></expr></incr> )</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name><operator>-&gt;</operator><name>bTokenize</name></name></expr>)</condition><block>{<block_content>
      <for>for<control>( <init>;</init> <condition><expr><operator>*</operator><name>zz</name></expr>;</condition> <incr><expr><name>prevChar</name> <operator>=</operator> <operator>*</operator><name>zz</name></expr><operator>,</operator> <expr><operator>++</operator><name>zz</name></expr></incr> )</control><block>{<block_content>
        <comment type="block">/* Split string into word-shaped tokens. 
        ** TODO ?= quoted strings, for the sake of the
        ** #error keyword. */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zz</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zz</name><operator>!=</operator><name>zKwd</name> <operator>&amp;&amp;</operator> <literal type="string">"Leading space was stripped earlier."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>zz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>(<expr><name>argc</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>CmppArgs_Max</name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Too many arguments @ line %u: %.*s"</literal></expr></argument>,
                  <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>lineNo</name></name></expr></argument>, <argument><expr><name>tokLen</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>zBegin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>(<expr><name>zz</name><operator>&gt;</operator><name>zKwd</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prevChar</name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>zz</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Treat rest of line as one token */</comment>
      <if_stmt><if>if<condition>(<expr><operator>*</operator><name>zz</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>zz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name><operator>-&gt;</operator><name>ttype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>g</name><operator>.</operator><name>doDebug</name></name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"line %u arg #%d=%s\n"</literal><operator>,</operator>
                   <name><name>tok</name><operator>-&gt;</operator><name>lineNo</name></name><operator>,</operator> <name>i</name><operator>,</operator>
                   <operator>(</operator><name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>isDelim</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd__err_prefix</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zPrefix</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>g_stderr</name><argument_list>(<argument><expr><literal type="string">"%s%s%s @ %s line %u: "</literal></expr></argument>,
           <argument><expr><ternary><condition><expr><name>zPrefix</name></expr> ?</condition><then> <expr><name>zPrefix</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
           <argument><expr><ternary><condition><expr><name>zPrefix</name></expr> ?</condition><then> <expr><literal type="string">": "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
           <argument><expr><name><name>pKw</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>token</name><operator>.</operator><name>lineNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Internal error reporting helper for cmpp_keyword_f() impls. */</comment>
<function><type><specifier>static</specifier> <name>CMPP_NORETURN</name> <name>void</name></type> <name>cmpp_kwd__misuse</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>,
                                           <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
                                           <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cmpp_kwd__err_prefix</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Fatal error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fatalv</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* No-op cmpp_keyword_f() impl. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_noop</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>t</name> <operator>||</operator> <name>pKw</name></expr>)</condition><block>{<block_content><comment type="block">/*unused*/</comment></block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* #error impl. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_error</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><call><name>CT_skip</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if>
  <else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBegin</name> <init>= <expr><ternary><condition><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr>
      ?</condition><then> <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cmpp_kwd__err_prefix</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>zBegin</name></expr> ?</condition><then> <expr><name>zBegin</name></expr> </then><else>: <expr><literal type="string">"(no additional info)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Impl. for #define, #undef */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_define</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><call><name>CT_skip</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name><operator>&lt;</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Expecting one or more arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><ternary><condition><expr><name>TT_Define</name><operator>==</operator><name><name>pKw</name><operator>-&gt;</operator><name>ttype</name></name></expr>
      ?</condition><then> <expr><name>db_define_add</name></expr></then></ternary></expr> <operator>:</operator> <expr><name>db_define_rm</name></expr></init>;</function_decl>
    <for>for<control>( <init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>func</name><argument_list>( <argument><expr><operator>(</operator><name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Impl. for #if, #ifnot, #elif, #elifnot. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_if</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>buul</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppParseState</name></type> <name>tmpState</name> <init>= <expr><name>TS_Start</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name><operator>!=</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Expecting exactly 1 argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/*g_debug(0,("%s %s level %u pstate=%d\n", pKw-&gt;zName,
             (char const *)t-&gt;args.argv[1],
             t-&gt;level.ndx, (int)CT_pstate(t)));*/</comment>
  <switch>switch<condition>(<expr><name><name>pKw</name><operator>-&gt;</operator><name>ttype</name></name></expr>)</condition><block>{<block_content>
    <case>case <expr><name>TT_Elif</name></expr>:</case>
    <case>case <expr><name>TT_ElifNot</name></expr>:</case>
      <switch>switch<condition>(<expr><call><name>CT_pstate</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <case>case <expr><name>TS_If</name></expr>:</case> <break>break;</break>
        <case>case <expr><name>TS_IfPassed</name></expr>:</case> <expr_stmt><expr><call><name>CT_level</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>.</operator><name>flags</name> <operator>|=</operator> <name>CmppLevel_F_ELIDE</name></expr>;</expr_stmt> <return>return;</return>
        <default>default:</default> <goto>goto <name>misuse</name>;</goto>
      </block_content>}</block></switch>
      <break>break;</break>
    <case>case <expr><name>TT_If</name></expr>:</case>
    <case>case <expr><name>TT_IfNot</name></expr>:</case>
      <expr_stmt><expr><call><name>CmppLevel_push</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Unpexected keyword token type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><name>buul</name> <operator>=</operator> <call><name>db_define_has</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>TT_IfNot</name><operator>==</operator><name><name>pKw</name><operator>-&gt;</operator><name>ttype</name></name> <operator>||</operator> <name>TT_ElifNot</name><operator>==</operator><name><name>pKw</name><operator>-&gt;</operator><name>ttype</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>buul</name> <operator>=</operator> <operator>!</operator><name>buul</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>buul</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>CT_pstate</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tmpState</name> <operator>=</operator> <name>TS_IfPassed</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CT_skipLevel</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>CT_pstate</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>TS_If</name></expr> <comment type="block">/* also for TT_IfNot, TT_Elif, TT_ElifNot */</comment>;</expr_stmt>
    <expr_stmt><expr><call><name>CT_skipLevel</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>TT_If</name><operator>==</operator><name><name>pKw</name><operator>-&gt;</operator><name>ttype</name></name> <operator>||</operator> <name>TT_IfNot</name><operator>==</operator><name><name>pKw</name><operator>-&gt;</operator><name>ttype</name></name></expr>)</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>lvlIf</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CmppToken</name> <specifier>const</specifier></type> <name>lvlToken</name> <init>= <expr><call><name>CT_level</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>.</operator><name>token</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><call><name>cmpp_next_keyword_line</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>cmpp_process_keyword</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><name>lvlIf</name> <operator>&gt;</operator> <name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TT_EndIf</name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>token</name><operator>.</operator><name>ttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>(<expr><name>TS_IfPassed</name><operator>==</operator><name>tmpState</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>tmpState</name> <operator>=</operator> <name>TS_Start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>stack</name><index>[<expr><name>lvlIf</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>|=</operator> <name>CmppLevel_F_ELIDE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>(<expr><name>lvlIf</name> <operator>&lt;=</operator> <name><name>t</name><operator>-&gt;</operator><name>level</name><operator>.</operator><name>ndx</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>cmpp_kwd__err_prefix</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Input ended inside an unterminated %sif "</literal>
            <literal type="string">"opened at [%s] line %u"</literal></expr></argument>,
            <argument><expr><name><name>g</name><operator>.</operator><name>zDelim</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>lvlToken</name><operator>.</operator><name>lineNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return;</return>
  <label><name>misuse</name>:</label>
  <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"'%s' used out of context"</literal></expr></argument>,
                   <argument><expr><name><name>pKw</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Impl. for #else. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_else</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Expecting no arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>(<expr><call><name>CT_pstate</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <case>case <expr><name>TS_IfPassed</name></expr>:</case> <expr_stmt><expr><call><name>CT_skipLevel</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>TS_If</name></expr>:</case> <expr_stmt><expr><call><name>CT_skipLevel</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"'%s' with no matching 'if'"</literal></expr></argument>,
                      <argument><expr><name><name>pKw</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
  <comment type="block">/*g_debug(0,("else flags=0x%02x skipLevel=%u\n",
    CT_level(t).flags, CT_level(t).skipLevel));*/</comment>
  <expr_stmt><expr><call><name>CT_pstate</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>TS_Else</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Impl. for #endif. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_endif</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Maintenance reminder: we ignore all arguments after the endif
  ** to allow for constructs like:
  **
  ** #endif // foo
  **
  ** in a manner which does not require a specific comment style */</comment>
  <switch>switch<condition>(<expr><call><name>CT_pstate</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <case>case <expr><name>TS_Else</name></expr>:</case>
    <case>case <expr><name>TS_If</name></expr>:</case>
    <case>case <expr><name>TS_IfPassed</name></expr>:</case>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"'%s' with no matching 'if'"</literal></expr></argument>,
                       <argument><expr><name><name>pKw</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>CmppLevel_pop</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Impl. for #include. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_include</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>zResolved</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><call><name>CT_skip</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if>
  <if type="elseif">else if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name><operator>!=</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Expecting exactly 1 filename argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zFile</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><call><name>db_including_has</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <comment type="block">/* Note that different spellings of the same filename
    ** will elude this check, but that seems okay, as different
    ** spellings means that we're not re-running the exact same
    ** invocation. We might want some other form of multi-include
    ** protection, rather than this, however. There may well be
    ** sensible uses for recursion. */</comment>
    <expr_stmt><expr><call><name>cmpp_kwd__err_prefix</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Recursive include of file: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zResolved</name> <operator>=</operator> <call><name>db_include_search</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>zResolved</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>db_including_add</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>token</name><operator>.</operator><name>lineNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cmpp_process_file</name><argument_list>(<argument><expr><name>zResolved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>db_include_rm</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>db_free</name><argument_list>(<argument><expr><name>zResolved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_kwd__err_prefix</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"file not found: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Impl. for #pragma. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_pragma</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zArg</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><call><name>CT_skip</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if>
  <if type="elseif">else if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name><operator>!=</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Expecting one argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zArg</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0==strcmp(zArg,X)</cpp:value></cpp:define>
  <if_stmt><if>if<condition>(<expr><call><name>M</name><argument_list>(<argument><expr><literal type="string">"defines"</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type> <name>q</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>db_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT k FROM def ORDER BY k"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_stderr</name><argument_list>(<argument><expr><literal type="string">"cmpp defines:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>SQLITE_ROW</name><operator>==</operator><call><name>db_step</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>n</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>g_stderr</name><argument_list>(<argument><expr><literal type="string">"\t%.*s\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>db_finalize</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_kwd__misuse</name><argument_list>(<argument><expr><name>pKw</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"Unknown pragma"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>M</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/* #stder impl. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cmpp_kwd_stderr</name><parameter_list>(<parameter><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>pKw</name></decl></parameter>, <parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><call><name>CT_skip</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if>
  <else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBegin</name> <init>= <expr><ternary><condition><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr>
      ?</condition><then> <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><name>zBegin</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>g_stderr</name><argument_list>(<argument><expr><literal type="string">"%s:%u: %s\n"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>token</name><operator>.</operator><name>lineNo</name></name></expr></argument>, <argument><expr><name>zBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>g_stderr</name><argument_list>(<argument><expr><literal type="string">"%s:%u: (no %.*s%s argument)\n"</literal></expr></argument>,
               <argument><expr><name><name>t</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>token</name><operator>.</operator><name>lineNo</name></name></expr></argument>,
               <argument><expr><name><name>g</name><operator>.</operator><name>nDelim</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>zDelim</name></name></expr></argument>, <argument><expr><name><name>pKw</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* Impl. for dummy placeholder. */</comment>
static void cmpp_kwd_todo(CmppKeyword const * pKw, CmppTokenizer *t){
  if(t){<comment type="block">/*unused*/</comment>}
  g_debug(0,("TODO: keyword handler for %s\n", pKw-&gt;zName));
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>CmppKeyword</name></type> <name><name>aKeywords</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/* Keep these sorted by zName */</comment>
  <expr><block>{<expr><literal type="string">"//"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>TT_Comment</name></expr>, <expr><name>cmpp_kwd_noop</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"define"</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_Define</name></expr>, <expr><name>cmpp_kwd_define</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"elif"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_Elif</name></expr>, <expr><name>cmpp_kwd_if</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"elifnot"</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_ElifNot</name></expr>, <expr><name>cmpp_kwd_if</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"else"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_Else</name></expr>, <expr><name>cmpp_kwd_else</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"endif"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>TT_EndIf</name></expr>, <expr><name>cmpp_kwd_endif</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>TT_Error</name></expr>, <expr><name>cmpp_kwd_error</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"if"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_If</name></expr>, <expr><name>cmpp_kwd_if</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"ifnot"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_IfNot</name></expr>, <expr><name>cmpp_kwd_if</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"include"</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>TT_Include</name></expr>, <expr><name>cmpp_kwd_include</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"pragma"</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_Pragma</name></expr>, <expr><name>cmpp_kwd_pragma</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"stderr"</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>TT_Stderr</name></expr>, <expr><name>cmpp_kwd_stderr</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"undef"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>TT_Undef</name></expr>, <expr><name>cmpp_kwd_define</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><name>TT_Invalid</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_CmppKeyword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>kw</name> <init>= <expr><operator>(</operator><name>CmppKeyword</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>p2</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>CmppKeyword</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>CmppKeyword_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>CmppKeyword</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><call><name>bsearch</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aKeywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aKeywords</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aKeywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aKeywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                      <argument><expr><name>cmp_CmppKeyword</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmpp_process_keyword</name><parameter_list>(<parameter><decl><type><name>CmppTokenizer</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name><operator>-&gt;</operator><name>xCall</name></name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>pKw</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmpp_process_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FileWrapper</name></type> <name>fw</name> <init>= <expr><name>FileWrapper_empty</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmppTokenizer</name></type> <name>ct</name> <init>= <expr><name>CmppTokenizer_empty</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>FileWrapper_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fw</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FileWrapper_slurp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Read %u byte(s) from [%s]\n"</literal><operator>,</operator> <name><name>fw</name><operator>.</operator><name>nContent</name></name><operator>,</operator> <name><name>fw</name><operator>.</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ct</name><operator>.</operator><name>zName</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ct</name><operator>.</operator><name>zBegin</name></name> <operator>=</operator> <name><name>fw</name><operator>.</operator><name>zContent</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ct</name><operator>.</operator><name>zEnd</name></name> <operator>=</operator> <name><name>fw</name><operator>.</operator><name>zContent</name></name> <operator>+</operator> <name><name>fw</name><operator>.</operator><name>nContent</name></name></expr>;</expr_stmt>
  <while>while<condition>(<expr><call><name>cmpp_next_keyword_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>cmpp_process_keyword</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>FileWrapper_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><literal type="number">0</literal><operator>!=</operator><name><name>ct</name><operator>.</operator><name>level</name><operator>.</operator><name>ndx</name></name></expr>)</condition><block>{<block_content>
    <decl_stmt><decl><type><name>CmppLevel</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>lv</name> <init>= <expr><call><name>CmppLevel_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Input ended inside an unterminated nested construct"</literal>
          <literal type="string">"opened at [%s] line %u"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>lv</name><operator>-&gt;</operator><name>token</name><operator>.</operator><name>lineNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>isErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>fOut</name> <init>= <expr><ternary><condition><expr><name>isErr</name></expr> ?</condition><then> <expr><name>stderr</name></expr> </then><else>: <expr><name>stdout</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fOut</name></expr></argument>,
          <argument><expr><literal type="string">"Usage: %s [flags] [infile]\n"</literal>
          <literal type="string">"Flags:\n"</literal></expr></argument>,
          <argument><expr><name><name>g</name><operator>.</operator><name>zArgv0</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>arg</name><parameter_list>(<parameter><type><name>F</name></type></parameter>,<parameter><type><name>D</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fprintf(fOut,"  %s\n      %s\n",F, D)</cpp:value></cpp:define>
  <expr_stmt><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="string">"-f|--file FILE"</literal></expr></argument>,<argument><expr><literal type="string">"Read input from FILE (default=- (stdin)).\n"</literal>
      <literal type="string">"      Alternately, the first non-flag argument is assumed to "</literal>
      <literal type="string">"be the input file."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="string">"-o|--outfile FILE"</literal></expr></argument>,<argument><expr><literal type="string">"Send output to FILE (default=- (stdout))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="string">"-DXYZ"</literal></expr></argument>,<argument><expr><literal type="string">"Define XYZ to true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="string">"-UXYZ"</literal></expr></argument>,<argument><expr><literal type="string">"Undefine XYZ (equivalent to false)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="string">"-IXYZ"</literal></expr></argument>,<argument><expr><literal type="string">"Add dir XYZ to include path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="string">"-d|--delimiter VALUE"</literal></expr></argument>, <argument><expr><literal type="string">"Set keyword delimiter to VALUE "</literal>
      <literal type="string">"(default="</literal> <name>CMPP_DEFAULT_DELIM</name> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>arg</name></cpp:undef>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><name>fOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type> <name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inclCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zInfile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0==strcmp(X,zArg))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISFLAG</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>else if(M(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISFLAG2</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>else if(M(X) || M(Y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGVAL</name></cpp:macro> \
  <cpp:value>if(i+1&gt;=argc) fatal("Missing value for flag '%s'", zArg);  \
  zArg = argv[++i]</cpp:value></cpp:define>
  <expr_stmt><expr><name><name>g</name><operator>.</operator><name>zArgv0</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>cmpp_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cmpp_initdb</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type> <name>zArg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><literal type="char">'-'</literal><operator>==</operator><operator>*</operator><name>zArg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>zArg</name></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>(<expr><call><name>M</name><argument_list>(<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>M</name><argument_list>(<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>end</name>;</goto>
    </block_content>}</block></if><if type="elseif">else if<condition>(<expr><literal type="char">'D'</literal><operator>==</operator><operator>*</operator><name>zArg</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name>zArg</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>*</operator><name>zArg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Missing key for -D"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>db_define_add</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>(<expr><literal type="char">'U'</literal><operator>==</operator><operator>*</operator><name>zArg</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name>zArg</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>*</operator><name>zArg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Missing key for -U"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>db_define_rm</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>(<expr><literal type="char">'I'</literal><operator>==</operator><operator>*</operator><name>zArg</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name>zArg</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>*</operator><name>zArg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Missing directory for -I"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>db_include_dir_add</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name>inclCount</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <macro><name>ISFLAG2</name><argument_list>(<argument><literal type="string">"o"</literal></argument>,<argument><literal type="string">"outfile"</literal></argument>)</argument_list></macro><block>{<block_content>
      <expr_stmt><expr><name>ARGVAL</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><name><name>g</name><operator>.</operator><name>out</name><operator>.</operator><name>zName</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Cannot use -o more than once."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>g</name><operator>.</operator><name>out</name><operator>.</operator><name>zName</name></name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
    </block_content>}</block>
    <macro><name>ISFLAG2</name><argument_list>(<argument><literal type="string">"f"</literal></argument>,<argument><literal type="string">"file"</literal></argument>)</argument_list></macro><block>{<block_content>
      <expr_stmt><expr><name>ARGVAL</name></expr>;</expr_stmt>
      <label><name>do_infile</name>:</label>
      <if_stmt><if>if<condition>(<expr><name>zInfile</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Cannot use -i more than once."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>zInfile</name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
    </block_content>}</block>
    <macro><name>ISFLAG2</name><argument_list>(<argument><literal type="string">"d"</literal></argument>,<argument><literal type="string">"delimiter"</literal></argument>)</argument_list></macro><block>{<block_content>
      <expr_stmt><expr><name>ARGVAL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>.</operator><name>zDelim</name></name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>.</operator><name>nDelim</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>nDelim</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Keyword delimiter may not be empty."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <macro><name>ISFLAG</name><argument_list>(<argument><literal type="string">"debug"</literal></argument>)</argument_list></macro><block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name><name>g</name><operator>.</operator><name>doDebug</name></name></expr>;</expr_stmt>
    </block_content>}</block><if_stmt><if type="elseif">else if<condition>(<expr><operator>!</operator><name>zInfile</name></expr>)</condition><block>{<block_content>
      <goto>goto <name>do_infile</name>;</goto>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Unhandled flag: %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>zInfile</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zInfile</name> <operator>=</operator> <literal type="string">"-"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>g</name><operator>.</operator><name>out</name><operator>.</operator><name>zName</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>g</name><operator>.</operator><name>out</name><operator>.</operator><name>zName</name></name> <operator>=</operator> <literal type="string">"-"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>inclCount</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>db_include_dir_add</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>FileWrapper_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>out</name><operator>.</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cmpp_process_file</name><argument_list>(<argument><expr><name>zInfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FileWrapper_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>end</name>:</label>
  <return>return <expr><ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><name>EXIT_FAILURE</name></expr> </then><else>: <expr><name>EXIT_SUCCESS</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CT_level</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CT_pstate</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CT_skipLevel</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CT_skip</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CLvl_skip</name></cpp:undef>
</unit>
