<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/wasm/api/sqlite3-wasm.c"><comment type="block">/*
** This file requires access to sqlite3.c static state in order to
** implement certain WASM-specific features, and thus directly
** includes that file. Unlike the rest of sqlite3.c, this file
** requires compiling with -std=c99 (or equivalent, or a later C
** version) because it makes use of features not available in C89.
**
** At its simplest, to build sqlite3.wasm either place this file
** in the same directory as sqlite3.c/h before compilation or use the
** -I/path flag to tell the compiler where to find both of those
** files, then compile this file. For example:
**
** emcc -o sqlite3.wasm ... -I/path/to/sqlite3-c-and-h sqlite3-wasm.c
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_WASM</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WASM_ENABLE_C_TESTS</name></cpp:ifdef>
<comment type="block">/*
** Code blocked off by SQLITE_WASM_TESTS is intended solely for use in
** unit/regression testing. They may be safely omitted from
** client-side builds. The main unit test script, tester1.js, will
** skip related tests if it doesn't find the corresponding functions
** in the WASM exports.
*/</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_WASM_TESTS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_WASM_TESTS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Threading and file locking: JS is single-threaded. Each Worker
** thread is a separate instance of the JS engine so can never access
** the same db handle as another thread, thus multi-threading support
** is unnecessary in the library. Because the filesystems are virtual
** and local to a given wasm runtime instance, two Workers can never
** access the same db file at once, with the exception of OPFS.
**
** Summary: except for the case of OPFS, which supports locking using
** its own API, threading and file locking support are unnecessary in
** the wasm build.
*/</comment>

<comment type="block">/*
** Undefine any SQLITE_... config flags which we specifically do not
** want defined. Please keep these alphabetized.
*/</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:undef>

<comment type="block">/*
** Define any SQLITE_... config defaults we want if they aren't
** overridden by the builder. Please keep these alphabetized.
*/</comment>

<comment type="block" format="doxygen">/**********************************************************************/</comment>
<comment type="block">/* SQLITE_D... */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEFAULT_CACHE_SIZE</name></cpp:ifndef>
<comment type="block">/*
** The OPFS impls benefit tremendously from an increased cache size
** when working on large workloads, e.g. speedtest1 --size 50 or
** higher. On smaller workloads, e.g. speedtest1 --size 25, they
** clearly benefit from having 4mb of cache, but not as much as a
** larger cache benefits the larger workloads. Speed differences
** between 2x and nearly 3x have been measured with ample page cache.
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEFAULT_CACHE_SIZE</name></cpp:macro> <cpp:value>-16384</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** OPFS performance is improved by approx. 12% with a page size of 8kb
** instead of 4kb. Performance with 16kb is equivalent to 8kb.
**
** Performance difference of kvvfs with a page size of 8kb compared to
** 4kb, as measured by speedtest1 --size 4, is indeterminate:
** measurements are all over the place either way and not
** significantly different.
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEFAULT_PAGE_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEFAULT_UNIX_VFS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEFAULT_UNIX_VFS</name></cpp:macro> <cpp:value>"unix-none"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SQLITE_DQS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DQS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**********************************************************************/</comment>
<comment type="block">/* SQLITE_ENABLE_... */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_BYTECODE_VTAB</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_BYTECODE_VTAB</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_DBPAGE_VTAB</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_DBPAGE_VTAB</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_DBSTAT_VTAB</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_DBSTAT_VTAB</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_FTS4</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_FTS4</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_RTREE</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_RTREE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_STMTVTAB</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_STMTVTAB</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**********************************************************************/</comment>
<comment type="block">/* SQLITE_O... */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_DEPRECATED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_SHARED_CACHE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_UTF16</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OS_KV_OPTIONAL</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OS_KV_OPTIONAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**********************************************************************/</comment>
<comment type="block">/* SQLITE_T... */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_TEMP_STORE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_TEMP_STORE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_THREADSAFE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_THREADSAFE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**********************************************************************/</comment>
<comment type="block">/* SQLITE_USE_... */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_USE_URI</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_USE_URI</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.c"</cpp:file></cpp:include> <comment type="block">/* yes, .c instead of .h. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__EMSCRIPTEN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;emscripten/console.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** SQLITE_WASM_KEEP is functionally identical to EMSCRIPTEN_KEEPALIVE
** but is not Emscripten-specific. It explicitly marks functions for
** export into the target wasm file without requiring explicit listing
** of those functions in Emscripten's -sEXPORTED_FUNCTIONS=... list
** (or equivalent in other build platforms). Any function with neither
** this attribute nor which is listed as an explicit export will not
** be exported from the wasm file (but may still be used internally
** within the wasm file).
**
** The functions in this file (sqlite3-wasm.c) which require exporting
** are marked with this flag. They may also be added to any explicit
** build-time export list but need not be. All of these APIs are
** intended for use only within the project's own JS/WASM code, and
** not by client code, so an argument can be made for reducing their
** visibility by not including them in any build-time export lists.
**
** 2022-09-11: it's not yet _proven_ that this approach works in
** non-Emscripten builds. If not, such builds will need to export
** those using the --export=... wasm-ld flag (or equivalent). As of
** this writing we are tied to Emscripten for various reasons
** and cannot test the library with other build environments.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_WASM_KEEP</name></cpp:macro> <cpp:value>__attribute__((used,visibility("default")))</cpp:value></cpp:define>
<comment type="line">// See also:</comment>
<comment type="line">//__attribute__((export_name("theExportedName"), used, visibility("default")))</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** An EXPERIMENT in implementing a stack-based allocator analog to
** Emscripten's stackSave(), stackAlloc(), stackRestore().
** Unfortunately, this cannot work together with Emscripten because
** Emscripten defines its own native one and we'd stomp on each
** other's memory. Other than that complication, basic tests show it
** to work just fine.
**
** Another option is to malloc() a chunk of our own and call that our
** "stack".
*/</comment>
SQLITE_WASM_KEEP void * sqlite3_wasm_stack_end(void){
  extern void __heap_base
    <comment type="block">/* see https://stackoverflow.com/questions/10038964 */</comment>;
  return &amp;__heap_base;
}
SQLITE_WASM_KEEP void * sqlite3_wasm_stack_begin(void){
  extern void __data_end;
  return &amp;__data_end;
}
static void * pWasmStackPtr = 0;
SQLITE_WASM_KEEP void * sqlite3_wasm_stack_ptr(void){
  if(!pWasmStackPtr) pWasmStackPtr = sqlite3_wasm_stack_end();
  return pWasmStackPtr;
}
SQLITE_WASM_KEEP void sqlite3_wasm_stack_restore(void * p){
  pWasmStackPtr = p;
}
SQLITE_WASM_KEEP void * sqlite3_wasm_stack_alloc(int n){
  if(n&lt;=0) return 0;
  n = (n + 7) &amp; ~7 <comment type="block">/* align to 8-byte boundary */</comment>;
  unsigned char * const p = (unsigned char *)sqlite3_wasm_stack_ptr();
  unsigned const char * const b = (unsigned const char *)sqlite3_wasm_stack_begin();
  if(b + n &gt;= p || b + n &lt; b<comment type="block">/*overflow*/</comment>) return 0;
  return pWasmStackPtr = p - n;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* stack allocator experiment */</comment>

<comment type="block">/*
** State for the "pseudo-stack" allocator implemented in
** sqlite3_wasm_pstack_xyz(). In order to avoid colliding with
** Emscripten-controled stack space, it carves out a bit of stack
** memory to use for that purpose. This memory ends up in the
** WASM-managed memory, such that routines which manipulate the wasm
** heap can also be used to manipulate this memory.
**
** This particular allocator is intended for small allocations such as
** storage for output pointers. We cannot reasonably size it large
** enough for general-purpose string conversions because some of our
** tests use input files (strings) of 16MB+.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>PStack_mem</name><index>[<expr><literal type="number">512</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<struct><specifier>static</specifier> struct <block>{
  <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pBegin</name></decl>;</decl_stmt><comment type="block">/* Start (inclusive) of memory */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pEnd</name></decl>;</decl_stmt>  <comment type="block">/* One-after-the-end of memory */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>pPos</name></decl>;</decl_stmt>              <comment type="block">/* Current stack pointer */</comment>
}</block> <decl><name>PStack</name> <init>= <expr><block>{
  <expr><operator>&amp;</operator><name><name>PStack_mem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>,
  <expr><operator>&amp;</operator><name><name>PStack_mem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PStack_mem</name></expr></argument>)</argument_list></sizeof></expr>,
  <expr><operator>&amp;</operator><name><name>PStack_mem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> sizeof<operator>(</operator><name>PStack_mem</name><operator>)</operator></expr>
}</block></expr></init></decl>;</struct>
<comment type="block">/*
** Returns the current pstack position.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name> <name>void</name> <modifier>*</modifier></type> <name>sqlite3_wasm_pstack_ptr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>PStack</name><operator>.</operator><name>pPos</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Sets the pstack position poitner to p. Results are undefined if the
** given value did not come from sqlite3_wasm_pstack_ptr().
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name> <name>void</name></type> <name>sqlite3_wasm_pstack_restore</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name><operator>&gt;=</operator><name><name>PStack</name><operator>.</operator><name>pBegin</name></name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;=</operator><name><name>PStack</name><operator>.</operator><name>pEnd</name></name> <operator>&amp;&amp;</operator> <name>p</name><operator>&gt;=</operator><name><name>PStack</name><operator>.</operator><name>pPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>p</name><operator>&gt;=</operator><name><name>PStack</name><operator>.</operator><name>pBegin</name></name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;=</operator><name><name>PStack</name><operator>.</operator><name>pEnd</name></name></expr> <comment type="block">/*&amp;&amp; p&gt;=PStack.pPos*/</comment>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>PStack</name><operator>.</operator><name>pPos</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Allocate and zero out n bytes from the pstack. Returns a pointer to
** the memory on success, 0 on error (including a negative n value). n
** is always adjusted to be a multiple of 8 and returned memory is
** always zeroed out before returning (because this keeps the client
** JS code from having to do so, and most uses of the pstack will
** call for doing so).
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name> <name>void</name> <modifier>*</modifier></type> <name>sqlite3_wasm_pstack_alloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <comment type="line">//if( n &amp; 0x7 ) n += 8 - (n &amp; 0x7) /* align to 8-byte boundary */;</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">7</literal></expr> <comment type="block">/* align to 8-byte boundary */</comment>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>PStack</name><operator>.</operator><name>pBegin</name></name> <operator>+</operator> <name>n</name> <operator>&gt;</operator> <name><name>PStack</name><operator>.</operator><name>pPos</name></name> <comment type="block">/*not enough space left*/</comment>
      <operator>||</operator> <name><name>PStack</name><operator>.</operator><name>pBegin</name></name> <operator>+</operator> <name>n</name> <operator>&lt;=</operator> <name><name>PStack</name><operator>.</operator><name>pBegin</name></name></expr> <comment type="block">/*overflow*/</comment> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name><name>PStack</name><operator>.</operator><name>pPos</name></name> <operator>=</operator> <name><name>PStack</name><operator>.</operator><name>pPos</name></name> <operator>-</operator> <name>n</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>PStack</name><operator>.</operator><name>pPos</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Return the number of bytes left which can be
** sqlite3_wasm_pstack_alloc()'d.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name> <name>int</name></type> <name>sqlite3_wasm_pstack_remaining</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>PStack</name><operator>.</operator><name>pPos</name></name> <operator>&gt;=</operator> <name><name>PStack</name><operator>.</operator><name>pBegin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>PStack</name><operator>.</operator><name>pPos</name></name> <operator>&lt;=</operator> <name><name>PStack</name><operator>.</operator><name>pEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>PStack</name><operator>.</operator><name>pPos</name></name> <operator>-</operator> <name><name>PStack</name><operator>.</operator><name>pBegin</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the total number of bytes available in the pstack, including
** any space which is currently allocated. This value is a
** compile-time constant.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name> <name>int</name></type> <name>sqlite3_wasm_pstack_quota</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>PStack</name><operator>.</operator><name>pEnd</name></name> <operator>-</operator> <name><name>PStack</name><operator>.</operator><name>pBegin</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings.
**
** For purposes of certain hand-crafted C/Wasm function bindings, we
** need a way of reporting errors which is consistent with the rest of
** the C API, as opposed to throwing JS exceptions. To that end, this
** internal-use-only function is a thin proxy around
** sqlite3ErrorWithMessage(). The intent is that it only be used from
** Wasm bindings such as sqlite3_prepare_v2/v3(), and definitely not
** from client code.
**
** Returns err_code.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_db_error</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>!=</operator><name>zMsg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMsg</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>err_code</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>nMsg</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>err_code</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>err_code</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_WASM_TESTS</name></expr></cpp:if>
<struct>struct <name>WasmTestStruct</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>v4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type> <name>ppV</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>cstr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>v8</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>WasmTestStruct</name></name></type> <name>WasmTestStruct</name>;</typedef>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>void</name></type> <name>sqlite3_wasm_test_struct</name><parameter_list>(<parameter><decl><type><name>WasmTestStruct</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>s</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v4</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v8</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>v4</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ppV</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cstr</name></name> <operator>=</operator> <name>__FILE__</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xFunc</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>xFunc</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_WASM_TESTS */</comment>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings. Unlike the
** rest of the sqlite3 API, this part requires C99 for snprintf() and
** variadic macros.
**
** Returns a string containing a JSON-format "enum" of C-level
** constants and struct-related metadata intended to be imported into
** the JS environment. The JSON is initialized the first time this
** function is called and that result is reused for all future calls.
**
** If this function returns NULL then it means that the internal
** buffer is not large enough for the generated JSON and needs to be
** increased. In debug builds that will trigger an assert().
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>sqlite3_wasm_enum_json</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>aBuffer</name><index>[<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">12</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl> <comment type="block">/* where the JSON goes */</comment>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nChildren</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nStruct</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>
    <comment type="block">/* output counters for figuring out where commas go */</comment>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>zPos</name> <init>= <expr><operator>&amp;</operator><name><name>aBuffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl> <comment type="block">/* skip first byte for now to help protect
                            ** against a small race condition */</comment>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aBuffer</name></expr></argument>)</argument_list></sizeof></expr></init></decl> <comment type="block">/* one-past-the-end */</comment>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>aBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>aBuffer</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Leave aBuffer[0] at 0 until the end to help guard against a tiny
  ** race condition. If this is called twice concurrently, they might
  ** end up both writing to aBuffer, but they'll both write the same
  ** thing, so that's okay. If we set byte 0 up front then the 2nd
  ** instance might return and use the string before the 1st instance
  ** is done filling it. */</comment>

<comment type="block">/* Core output macros... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lenCheck</name></cpp:macro> <cpp:value>assert(zPos &lt; zEnd - 128 \
  &amp;&amp; "sqlite3_wasm_enum_json() buffer is too small."); \
  if( zPos &gt;= zEnd - 128 ) return 0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>outf</name><parameter_list>(<parameter><type><name>format</name></type></parameter>,<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>zPos += snprintf(zPos, ((size_t)(zEnd - zPos)), format, __VA_ARGS__); \
  lenCheck</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>out</name><parameter_list>(<parameter><type><name>TXT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>outf("%s",TXT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CloseBrace</name><parameter_list>(<parameter><type><name>LEVEL</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>assert(LEVEL&lt;5); memset(zPos, '}', LEVEL); zPos+=LEVEL; lenCheck</cpp:value></cpp:define>

<comment type="block">/* Macros for emitting maps of integer- and string-type macros to
** their values. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefGroup</name><parameter_list>(<parameter><type><name>KEY</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>n = 0; \
  outf("%s\"" #KEY "\": {",(nChildren++ ? "," : ""));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefInt</name><parameter_list>(<parameter><type><name>KEY</name></type></parameter>)</parameter_list></cpp:macro>                                     \
  <cpp:value>outf("%s\"%s\": %d", (n++ ? ", " : ""), #KEY, (int)KEY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefStr</name><parameter_list>(<parameter><type><name>KEY</name></type></parameter>)</parameter_list></cpp:macro>                                     \
  <cpp:value>outf("%s\"%s\": \"%s\"", (n++ ? ", " : ""), #KEY, KEY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DefGroup</name></cpp:macro> <cpp:value>CloseBrace(1)</cpp:value></cpp:define>

  <comment type="block">/* The following groups are sorted alphabetic by group name. */</comment>
  <macro><name>DefGroup</name><argument_list>(<argument>access</argument>)</argument_list></macro><block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ACCESS_READWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ACCESS_READ</name></expr></argument>)</argument_list></call></expr><comment type="block">/*docs say this is unused*/</comment>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>blobFinalizers</argument>)</argument_list></macro> <block>{<block_content>
    <comment type="block">/* SQLITE_STATIC/TRANSIENT need to be handled explicitly as
    ** integers to avoid casting-related warnings. */</comment>
    <expr_stmt><expr><call><name>out</name><argument_list>(<argument><expr><literal type="string">"\"SQLITE_STATIC\":0, \"SQLITE_TRANSIENT\":-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>dataTypes</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FLOAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_BLOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>encodings</argument>)</argument_list></macro> <block>{<block_content>
    <comment type="block">/* Noting that the wasm binding only aims to support UTF-8. */</comment>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_UTF16LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_UTF16BE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_UTF16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*deprecated DefInt(SQLITE_ANY); */</comment>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_UTF16_ALIGNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>fcntl</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_LOCKSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_GET_LOCKPROXYFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_SET_LOCKPROXYFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_LAST_ERRNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_SYNC_OMITTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_WIN32_AV_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_OVERWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_VFSNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_POWERSAFE_OVERWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_PRAGMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_BUSYHANDLER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_TEMPFILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_MMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_TRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_HAS_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_COMMIT_PHASETWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_WIN32_SET_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_WAL_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_ZIPVFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_RBU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_VFS_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_JOURNAL_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_WIN32_GET_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_PDB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_BEGIN_ATOMIC_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_COMMIT_ATOMIC_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_LOCK_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_DATA_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_SIZE_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_CKPT_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_RESERVE_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_CKPT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_EXTERNAL_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_CKSM_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>flock</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCK_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCK_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCK_RESERVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCK_PENDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>ioCap</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC512</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC1K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC2K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC4K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC8K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC16K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC32K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC64K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_SAFE_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_SEQUENTIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_POWERSAFE_OVERWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_IMMUTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_BATCH_ATOMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>openFlags</argument>)</argument_list></macro> <block>{<block_content>
    <comment type="block">/* Noting that not all of these will have any effect in
    ** WASM-space. */</comment>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_READWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_URI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_NOMUTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_FULLMUTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_SHAREDCACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_PRIVATECACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_EXRESCODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_NOFOLLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* OPEN flags for use with VFSes... */</comment>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_MAIN_DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_TEMP_DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_TEMP_JOURNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_TRANSIENT_DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_SUBJOURNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_SUPER_JOURNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_WAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_DELETEONCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OPEN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>prepareFlags</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_PREPARE_PERSISTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_PREPARE_NORMALIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_PREPARE_NO_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>resultCodes</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_PERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_INTERRUPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NOTFOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_PROTOCOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_SCHEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NOLFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_AUTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_FORMAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NOTADB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NOTICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Extended Result Codes</comment>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ERROR_MISSING_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ERROR_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ERROR_SNAPSHOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHORT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_FSYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DIR_FSYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_FSTAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_RDLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_BLOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DIR_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMOPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMMAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SEEK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DELETE_NOENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_MMAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_GETTEMPPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_CONVPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_VNODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_AUTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_BEGIN_ATOMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_COMMIT_ATOMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_ROLLBACK_ATOMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_IOERR_CORRUPTFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCKED_SHAREDCACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_LOCKED_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_BUSY_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_BUSY_SNAPSHOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_BUSY_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_NOTEMPDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_ISDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_FULLPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_CONVPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//DefInt(SQLITE_CANTOPEN_DIRTYWAL)/*docs say not used*/;</comment>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_SYMLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT_SEQUENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_READONLY_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_READONLY_CANTLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_READONLY_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_READONLY_DBMOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_READONLY_CANTINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_READONLY_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_COMMITHOOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_PRIMARYKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_UNIQUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_ROWID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_PINNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_CONSTRAINT_DATATYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NOTICE_RECOVER_WAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_NOTICE_RECOVER_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_WARNING_AUTOINDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_AUTH_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_OK_LOAD_PERMANENTLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//DefInt(SQLITE_OK_SYMLINK) /* internal use only */;</comment>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>serialize</argument>)</argument_list></macro><block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_SERIALIZE_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_DESERIALIZE_FREEONCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_DESERIALIZE_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_DESERIALIZE_RESIZEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>syncFlags</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_SYNC_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_SYNC_DATAONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>trace</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_TRACE_STMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_TRACE_PROFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_TRACE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_TRACE_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>udfFlags</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_DETERMINISTIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_DIRECTONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>

  <macro><name>DefGroup</name><argument_list>(<argument>version</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>DefInt</name><argument_list>(<argument><expr><name>SQLITE_VERSION_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefStr</name><argument_list>(<argument><expr><name>SQLITE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DefStr</name><argument_list>(<argument><expr><name>SQLITE_SOURCE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> <expr_stmt><expr><name>_DefGroup</name></expr>;</expr_stmt>
  
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DefGroup</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DefStr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DefInt</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_DefGroup</name></cpp:undef>

  <comment type="block">/*
  ** Emit an array of "StructBinder" struct descripions, which look
  ** like:
  **
  ** {
  **   "name": "MyStruct",
  **   "sizeof": 16,
  **   "members": {
  **     "member1": {"offset": 0,"sizeof": 4,"signature": "i"},
  **     "member2": {"offset": 4,"sizeof": 4,"signature": "p"},
  **     "member3": {"offset": 8,"sizeof": 8,"signature": "j"}
  **   }
  ** }
  **
  ** Detailed documentation for those bits are in the docs for the
  ** Jaccwabyt JS-side component.
  */</comment>

  <comment type="block" format="doxygen">/** Macros for emitting StructBinder description. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StructBinder__</name><parameter_list>(<parameter><type><name>TYPE</name></type></parameter>)</parameter_list></cpp:macro>                 \
  <cpp:value>n = 0;                                     \
  outf("%s{", (nStruct++ ? ", " : ""));      \
  out("\"name\": \"" # TYPE "\",");          \
  outf("\"sizeof\": %d", (int)sizeof(TYPE)); \
  out(",\"members\": {");</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StructBinder_</name><parameter_list>(<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>StructBinder__(T)</cpp:value></cpp:define>
  <comment type="block" format="doxygen">/** ^^^ indirection needed to expand CurrentStruct */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StructBinder</name></cpp:macro> <cpp:value>StructBinder_(CurrentStruct)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_StructBinder</name></cpp:macro> <cpp:value>CloseBrace(2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M</name><parameter_list>(<parameter><type><name>MEMBER</name></type></parameter>,<parameter><type><name>SIG</name></type></parameter>)</parameter_list></cpp:macro>                                         \
  <cpp:value>outf("%s\"%s\": "                                           \
       "{\"offset\":%d,\"sizeof\": %d,\"signature\":\"%s\"}", \
       (n++ ? ", " : ""), #MEMBER,                            \
       (int)offsetof(CurrentStruct,MEMBER),                   \
       (int)sizeof(((CurrentStruct*)0)-&gt;MEMBER),              \
       SIG)</cpp:value></cpp:define>

  <expr_stmt><expr><name>nStruct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>out</name><argument_list>(<argument><expr><literal type="string">", \"structs\": ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CurrentStruct</name></cpp:macro> <cpp:value>sqlite3_vfs</cpp:value></cpp:define>
    <macro><name>StructBinder</name></macro> <block>{<block_content>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>iVersion</name></expr></argument>,          <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>szOsFile</name></expr></argument>,          <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>mxPathname</name></expr></argument>,        <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>,             <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,             <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>pAppData</name></expr></argument>,          <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xOpen</name></expr></argument>,             <argument><expr><literal type="string">"i(pppip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xDelete</name></expr></argument>,           <argument><expr><literal type="string">"i(ppi)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xAccess</name></expr></argument>,           <argument><expr><literal type="string">"i(ppip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xFullPathname</name></expr></argument>,     <argument><expr><literal type="string">"i(ppip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xDlOpen</name></expr></argument>,           <argument><expr><literal type="string">"p(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xDlError</name></expr></argument>,          <argument><expr><literal type="string">"p(pip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xDlSym</name></expr></argument>,            <argument><expr><literal type="string">"p()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xDlClose</name></expr></argument>,          <argument><expr><literal type="string">"v(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xRandomness</name></expr></argument>,       <argument><expr><literal type="string">"i(pip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xSleep</name></expr></argument>,            <argument><expr><literal type="string">"i(pi)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xCurrentTime</name></expr></argument>,      <argument><expr><literal type="string">"i(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xGetLastError</name></expr></argument>,     <argument><expr><literal type="string">"i(pip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xCurrentTimeInt64</name></expr></argument>, <argument><expr><literal type="string">"i(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xSetSystemCall</name></expr></argument>,    <argument><expr><literal type="string">"i(ppp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xGetSystemCall</name></expr></argument>,    <argument><expr><literal type="string">"p(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xNextSystemCall</name></expr></argument>,   <argument><expr><literal type="string">"p(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <expr_stmt><expr><name>_StructBinder</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CurrentStruct</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CurrentStruct</name></cpp:macro> <cpp:value>sqlite3_io_methods</cpp:value></cpp:define>
    <macro><name>StructBinder</name></macro> <block>{<block_content>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>iVersion</name></expr></argument>,               <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xClose</name></expr></argument>,                 <argument><expr><literal type="string">"i(p)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xRead</name></expr></argument>,                  <argument><expr><literal type="string">"i(ppij)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xWrite</name></expr></argument>,                 <argument><expr><literal type="string">"i(ppij)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xTruncate</name></expr></argument>,              <argument><expr><literal type="string">"i(pj)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xSync</name></expr></argument>,                  <argument><expr><literal type="string">"i(pi)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xFileSize</name></expr></argument>,              <argument><expr><literal type="string">"i(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xLock</name></expr></argument>,                  <argument><expr><literal type="string">"i(pi)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xUnlock</name></expr></argument>,                <argument><expr><literal type="string">"i(pi)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xCheckReservedLock</name></expr></argument>,     <argument><expr><literal type="string">"i(pp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xFileControl</name></expr></argument>,           <argument><expr><literal type="string">"i(pip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xSectorSize</name></expr></argument>,            <argument><expr><literal type="string">"i(p)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xDeviceCharacteristics</name></expr></argument>, <argument><expr><literal type="string">"i(p)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xShmMap</name></expr></argument>,                <argument><expr><literal type="string">"i(piiip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xShmLock</name></expr></argument>,               <argument><expr><literal type="string">"i(piii)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xShmBarrier</name></expr></argument>,            <argument><expr><literal type="string">"v(p)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xShmUnmap</name></expr></argument>,              <argument><expr><literal type="string">"i(pi)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xFetch</name></expr></argument>,                 <argument><expr><literal type="string">"i(pjip)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xUnfetch</name></expr></argument>,               <argument><expr><literal type="string">"i(pjp)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <expr_stmt><expr><name>_StructBinder</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CurrentStruct</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CurrentStruct</name></cpp:macro> <cpp:value>sqlite3_file</cpp:value></cpp:define>
    <macro><name>StructBinder</name></macro> <block>{<block_content>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>pMethods</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <expr_stmt><expr><name>_StructBinder</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CurrentStruct</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CurrentStruct</name></cpp:macro> <cpp:value>sqlite3_kvvfs_methods</cpp:value></cpp:define>
    <macro><name>StructBinder</name></macro> <block>{<block_content>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xRead</name></expr></argument>,    <argument><expr><literal type="string">"i(sspi)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xWrite</name></expr></argument>,   <argument><expr><literal type="string">"i(sss)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xDelete</name></expr></argument>,  <argument><expr><literal type="string">"i(ss)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>nKeySize</name></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <expr_stmt><expr><name>_StructBinder</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CurrentStruct</name></cpp:undef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_WASM_TESTS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CurrentStruct</name></cpp:macro> <cpp:value>WasmTestStruct</cpp:value></cpp:define>
    <macro><name>StructBinder</name></macro> <block>{<block_content>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>v4</name></expr></argument>,    <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>,  <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>ppV</name></expr></argument>,   <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>v8</name></expr></argument>,    <argument><expr><literal type="string">"j"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>xFunc</name></expr></argument>, <argument><expr><literal type="string">"v(p)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <expr_stmt><expr><name>_StructBinder</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CurrentStruct</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  </block_content>}</block> <expr_stmt><expr><call><name>out</name><argument_list>( <argument><expr><literal type="string">"]"</literal></expr></argument><comment type="block">/*structs*/</comment>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>out</name><argument_list>(<argument><expr><literal type="string">"}"</literal></expr></argument><comment type="block">/*top-level object*/</comment>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>zPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'{'</literal></expr><comment type="block">/*end of the race-condition workaround*/</comment>;</expr_stmt>
  <return>return <expr><name>aBuffer</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>StructBinder</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>StructBinder_</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>StructBinder__</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>M</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_StructBinder</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CloseBrace</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>out</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>outf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>lenCheck</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings.
**
** This function invokes the xDelete method of the given VFS (or the
** default VFS if pVfs is NULL), passing on the given filename. If
** zName is NULL, no default VFS is found, or it has no xDelete
** method, SQLITE_MISUSE is returned, else the result of the xDelete()
** call is returned.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_vfs_unlink</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_MISUSE</name></expr></init></decl> <comment type="block">/* ??? */</comment>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>pVfs</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>!=</operator><name>zName</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name> <operator>&amp;&amp;</operator> <name>pVfs</name> <operator>&amp;&amp;</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>xDelete</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings.
**
** Returns a pointer to the given DB's VFS for the given DB name,
** defaulting to "main" if zDbName is 0. Returns 0 if no db with the
** given name is open.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>sqlite3_vfs</name> <modifier>*</modifier></type> <name>sqlite3_wasm_db_vfs</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type> <name>pVfs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zDbName</name></expr> ?</condition><then> <expr><name>zDbName</name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></argument>,
                       <argument><expr><name>SQLITE_FCNTL_VFS_POINTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pVfs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings.
**
** This function resets the given db pointer's database as described at
**
** https://www.sqlite.org/c3ref/c_dbconfig_defensive.html#sqlitedbconfigresetdatabase
**
** Returns 0 on success, an SQLITE_xxx code on error. Returns
** SQLITE_MISUSE if pDb is NULL.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_db_reset</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_MISUSE</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDb</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_RESET_DATABASE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="string">"VACUUM"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_RESET_DATABASE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Uses the given database's VFS xRead to stream the db file's
** contents out to the given callback. The callback gets a single
** chunk of size n (its 2nd argument) on each call and must return 0
** on success, non-0 on error. This function returns 0 on success,
** SQLITE_NOTFOUND if no db is open, or propagates any other non-0
** code from the callback. Note that this is not thread-friendly: it
** expects that it will be the only thread reading the db file and
** takes no measures to ensure that is the case.
**
** This implementation appears to work fine, but
** sqlite3_wasm_db_serialize() is arguably the better way to achieve
** this.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_db_export_chunked</name><parameter_list>( <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>pDb</name></decl></parameter>,
                                    <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type> <name>pFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><ternary><condition><expr><name>pDb</name></expr>
    ?</condition><then> <expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>,
                           <argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFile</name></expr></argument>)</argument_list></call></expr>
    </then><else>: <expr><name>SQLITE_NOTFOUND</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>nSize</name> <operator>%</operator> <name>nBuf</name></expr>)</condition><block>{<block_content>
    <comment type="block">/* DB size is not an even multiple of the buffer size. Reduce
    ** buffer size so that we do not unduly inflate the db size
    ** with zero-padding when exporting. */</comment>
    <if_stmt><if>if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>nSize</name> <operator>%</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>nSize</name> <operator>%</operator> <literal type="number">2048</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">2048</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>nSize</name> <operator>%</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>( <init>;</init> <condition><expr><literal type="number">0</literal><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <name>nPos</name><operator>&lt;</operator><name>nSize</name></expr>;</condition> <incr><expr><name>nPos</name> <operator>+=</operator> <name>nBuf</name></expr></incr> )</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>nPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_IOERR_SHORT_READ</name> <operator>==</operator> <name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nPos</name> <operator>+</operator> <name>nBuf</name><operator>)</operator> <operator>&lt;</operator> <name>nSize</name></expr> ?</condition><then> <expr><name>rc</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr><comment type="block">/*assume EOF*/</comment>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xCallback</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A proxy for sqlite3_serialize() which serializes the schema zSchema
** of pDb, placing the serialized output in pOut and nOut. nOut may be
** NULL. If zSchema is NULL then "main" is assumed. If pDb or pOut are
** NULL then SQLITE_MISUSE is returned. If allocation of the
** serialized copy fails, SQLITE_NOMEM is returned.  On success, 0 is
** returned and `*pOut` will contain a pointer to the memory unless
** mFlags includes SQLITE_SERIALIZE_NOCOPY and the database has no
** contiguous memory representation, in which case `*pOut` will be
** NULL but 0 will be returned.
**
** If `*pOut` is not NULL, the caller is responsible for passing it to
** sqlite3_free() to free it.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_db_serialize</name><parameter_list>( <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl></parameter>,
                               <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pOut</name></decl></parameter>,
                               <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>nOut</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mFlags</name></decl></parameter> )</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pDb</name> <operator>||</operator> <operator>!</operator><name>pOut</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>nOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_serialize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zSchema</name></expr> ?</condition><then> <expr><name>zSchema</name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>mFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name> <operator>||</operator> <operator>(</operator><name>SQLITE_SERIALIZE_NOCOPY</name> <operator>&amp;</operator> <name>mFlags</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOut</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings.
**
** Creates a new file using the I/O API of the given VFS, containing
** the given number of bytes of the given data. If the file exists, it
** is truncated to the given length and populated with the given
** data.
**
** This function exists so that we can implement the equivalent of
** Emscripten's FS.createDataFile() in a VFS-agnostic way. This
** functionality is intended for use in uploading database files.
**
** Not all VFSes support this functionality, e.g. the "kvvfs" does
** not.
**
** If pVfs is NULL, sqlite3_vfs_find(0) is used.
**
** If zFile is NULL, pVfs is NULL (and sqlite3_vfs_find(0) returns
** NULL), or nData is negative, SQLITE_MISUSE are returned.
**
** On success, it creates a new file with the given name, populated
** with the fist nData bytes of pData. If pData is NULL, the file is
** created and/or truncated to nData bytes.
**
** Whether or not directory components of zFilename are created
** automatically or not is unspecified: that detail is left to the
** VFS. The "opfs" VFS, for example, creates them.
**
** If an error happens while populating or truncating the file, the
** target file will be deleted (if needed) if this function created
** it. If this function did not create it, it is not deleted but may
** be left in an undefined state.
**
** Returns 0 on success. On error, it returns a code described above
** or propagates a code from one of the I/O methods.
**
** Design note: nData is an integer, instead of int64, for WASM
** portability, so that the API can still work in builds where BigInt
** support is disabled or unavailable.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_vfs_create_file</name><parameter_list>( <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>pData</name></decl></parameter>,
                                  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter> )</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_io_methods</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pIo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>openFlags</name> <init>= <expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flagsOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fileExisted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>doUnlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pPos</name> <init>= <expr><name>pData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>blockSize</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>
    <comment type="block">/* Because we are using pFile-&gt;pMethods-&gt;xWrite() for writing, and
    ** it may have a buffer limit related to sqlite3's pager size, we
    ** conservatively write in 512-byte blocks (smallest page
    ** size). */</comment>;</decl_stmt>
  <comment type="line">//fprintf(stderr, "pVfs=%p, zFilename=%s, nData=%d\n", pVfs, zFilename, nData);</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVfs</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVfs</name> <operator>||</operator> <operator>!</operator><name>zFilename</name> <operator>||</operator> <name>nData</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileExisted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpenMalloc</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFile</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagsOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RC</name></cpp:macro> <cpp:value>fprintf(stderr,"create_file(%s,%s) @%d rc=%d\n", \
                    pVfs-&gt;zName, zFilename, __LINE__, rc);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RC</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>RC</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pIo</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIo</name><operator>-&gt;</operator><name>xLock</name></name></expr> )</condition> <block>{<block_content>
    <comment type="block">/* We need xLock() in order to accommodate the OPFS VFS, as it
    ** obtains a writeable handle via the lock operation and releases
    ** it in xUnlock(). If we don't do those here, we have to add code
    ** to the VFS to account check whether it was locked before
    ** xFileSize(), xTruncate(), and the like, and release the lock
    ** only if it was unlocked when the op was started. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pIo</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SQLITE_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>RC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>doUnlock</name> <operator>=</operator> <literal type="number">0</literal><operator>==</operator><name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pIo</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>RC</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>!=</operator><name>pData</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><name>nData</name><operator>&gt;=</operator><name>blockSize</name></expr> ?</condition><then> <expr><name>blockSize</name></expr> </then><else>: <expr><name>nData</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>pPos</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>pPos</name> <operator>-</operator> <name>pData</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>RC</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPos</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&lt;</operator><name>blockSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>pPos</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>,
                       <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>pPos</name> <operator>-</operator> <name>pData</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>RC</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIo</name><operator>-&gt;</operator><name>xUnlock</name></name> <operator>&amp;&amp;</operator> <name>doUnlock</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pIo</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SQLITE_LOCK_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name><name>pIo</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><name>fileExisted</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>RC</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RC</name></cpp:undef>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings.
**
** Allocates sqlite3KvvfsMethods.nKeySize bytes from
** sqlite3_wasm_pstack_alloc() and returns 0 if that allocation fails,
** else it passes that string to kvstorageMakeKey() and returns a
** NUL-terminated pointer to that string. It is up to the caller to
** use sqlite3_wasm_pstack_restore() to free the returned pointer.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>char</name> <modifier>*</modifier></type> <name>sqlite3_wasm_kvvfsMakeKeyOnPstack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zClass</name></decl></parameter>,
                                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKeyIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sqlite3KvvfsMethods</name><operator>.</operator><name>nKeySize</name></name><operator>&gt;</operator><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKeyOut</name> <init>=
    <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_wasm_pstack_alloc</name><argument_list>(<argument><expr><name><name>sqlite3KvvfsMethods</name><operator>.</operator><name>nKeySize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name>zKeyOut</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>kvstorageMakeKey</name><argument_list>(<argument><expr><name>zClass</name></expr></argument>, <argument><expr><name>zKeyIn</name></expr></argument>, <argument><expr><name>zKeyOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zKeyOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings.
**
** Returns the pointer to the singleton object which holds the kvvfs
** I/O methods and associated state.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>sqlite3_kvvfs_methods</name> <modifier>*</modifier></type> <name>sqlite3_wasm_kvvfs_methods</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>&amp;</operator><name>sqlite3KvvfsMethods</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__EMSCRIPTEN__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_WASMFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;emscripten/wasmfs.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** This function is NOT part of the sqlite3 public API. It is strictly
** for use by the sqlite project's own JS/WASM bindings, specifically
** only when building with Emscripten's WASMFS support.
**
** This function should only be called if the JS side detects the
** existence of the Origin-Private FileSystem (OPFS) APIs in the
** client. The first time it is called, this function instantiates a
** WASMFS backend impl for OPFS. On success, subsequent calls are
** no-ops.
**
** This function may be passed a "mount point" name, which must have a
** leading "/" and is currently restricted to a single path component,
** e.g. "/foo" is legal but "/foo/" and "/foo/bar" are not. If it is
** NULL or empty, it defaults to "/opfs".
**
** Returns 0 on success, SQLITE_NOMEM if instantiation of the backend
** object fails, SQLITE_IOERR if mkdir() of the zMountPoint dir in
** the virtual FS fails. In builds compiled without SQLITE_ENABLE_WASMFS
** defined, SQLITE_NOTFOUND is returned without side effects.
*/</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_init_wasmfs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMountPoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>backend_t</name></type> <name>pOpfs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zMountPoint</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>zMountPoint</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zMountPoint</name> <operator>=</operator> <literal type="string">"/opfs"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pOpfs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOpfs</name> <operator>=</operator> <call><name>wasmfs_create_opfs_backend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block" format="doxygen">/** It's not enough to instantiate the backend. We have to create a
      mountpoint in the VFS and attach the backend to it. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pOpfs</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>!=</operator><call><name>access</name><argument_list>(<argument><expr><name>zMountPoint</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Note that this check and is not robust but it will
       hypothetically suffice for the transient wasm-based virtual
       filesystem we're currently running in. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rc</name> <init>= <expr><call><name>wasmfs_create_directory</name><argument_list>(<argument><expr><name>zMountPoint</name></expr></argument>, <argument><expr><literal type="number">0777</literal></expr></argument>, <argument><expr><name>pOpfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/*emscripten_console_logf("OPFS mkdir(%s) rc=%d", zMountPoint, rc);*/</comment>
    <if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><name>pOpfs</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>SQLITE_NOMEM</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_init_wasmfs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUnused</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="line">//emscripten_console_warn("WASMFS OPFS is not compiled in.");</comment>
  <if_stmt><if>if<condition>(<expr><name>zUnused</name></expr>)</condition><block>{<block_content><comment type="block">/*unused*/</comment></block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __EMSCRIPTEN__ &amp;&amp; SQLITE_ENABLE_WASMFS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_WASM_TESTS</name></expr></cpp:if>

<function><type><name>SQLITE_WASM_KEEP</name>
<name>int</name></type> <name>sqlite3_wasm_test_intptr</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>*</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>SQLITE_WASM_KEEP</name>
<name>int64_t</name></type> <name>sqlite3_wasm_test_int64_max</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">0x7fffffffffffffff</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>SQLITE_WASM_KEEP</name>
<name>int64_t</name></type> <name>sqlite3_wasm_test_int64_min</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>~</operator><call><name>sqlite3_wasm_test_int64_max</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SQLITE_WASM_KEEP</name>
<name>int64_t</name></type> <name>sqlite3_wasm_test_int64_times2</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>x</name> <operator>*</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>SQLITE_WASM_KEEP</name>
<name>void</name></type> <name>sqlite3_wasm_test_int64_minmax</name><parameter_list>(<parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>sqlite3_wasm_test_int64_max</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <call><name>sqlite3_wasm_test_int64_min</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/*printf("minmax: min=%lld, max=%lld\n", *min, *max);*/</comment>
</block_content>}</block></function>

<function><type><name>SQLITE_WASM_KEEP</name>
<name>int64_t</name></type> <name>sqlite3_wasm_test_int64ptr</name><parameter_list>(<parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/*printf("sqlite3_wasm_test_int64ptr( @%lld = 0x%llx )\n", (int64_t)p, *p);*/</comment>
  <return>return <expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>*</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>SQLITE_WASM_KEEP</name>
<name>void</name></type> <name>sqlite3_wasm_test_stack_overflow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_wasm_test_stack_overflow</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* For testing the 'string-free' whwasmutil.xWrap() conversion. */</comment>
<function><type><name>SQLITE_WASM_KEEP</name>
<name>char</name> <modifier>*</modifier></type> <name>sqlite3_wasm_test_str_hello</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fail</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>s</name> <init>= <expr><ternary><condition><expr><name>fail</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name>s</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_WASM_TESTS */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SQLITE_WASM_KEEP</name></cpp:undef>
</unit>
