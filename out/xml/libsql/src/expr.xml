<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/expr.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains routines used for analyzing expressions and
** for generating VDBE code that evaluates expressions in SQLite.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/* Forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exprCodeBetween</name><parameter_list>(<parameter><decl><type><name>Parse</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Expr</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier>)<parameter_list>(<parameter><decl><type><name>Parse</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Expr</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exprCodeVector</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piToFree</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Return the affinity character for a single column of a table.
*/</comment>
<function><type><name>char</name></type> <name>sqlite3TableColumnAffinity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name>iCol</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_AFF_INTEGER</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the 'affinity' of the expression pExpr if any.
**
** If pExpr is a column, a reference to a column via an 'AS' alias,
** or a sub-select with a column as the return value, then the 
** affinity of that column is returned. Otherwise, 0x00 is returned,
** indicating no affinity for the expression.
**
** i.e. the WHERE clause expressions in the following statements all
** have an affinity:
**
** CREATE TABLE t1(a);
** SELECT * FROM t1 WHERE a;
** SELECT a AS b FROM t1 WHERE b;
** SELECT * FROM t1 WHERE (select a from t1);
*/</comment>
<function><type><name>char</name></type> <name>sqlite3ExprAffinity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Skip</name><operator>|</operator><name>EP_IfNullRow</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name>
         <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name>
         <operator>||</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_REGISTER</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <operator>(</operator><name>op</name><operator>==</operator><name>TK_AGG_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3TableColumnAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_CAST</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_SELECT_COLUMN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>&lt;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3ExprAffinity</name><argument_list>(
        <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>
    )</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_VECTOR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the collating sequence for expression pExpr to be the collating
** sequence named by pToken.   Return a pointer to a new Expr node that
** implements the COLLATE operator.
**
** If a memory allocation error occurs, that fact is recorded in pParse-&gt;db
** and the pExpr parameter is returned unchanged.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAddCollateToken</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,             <comment type="block">/* Add the "COLLATE" clause to this expression */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pCollName</name></decl></parameter>,  <comment type="block">/* Name of collating sequence */</comment>
  <parameter><decl><type><name>int</name></type> <name>dequote</name></decl></parameter>              <comment type="block">/* True to dequote pCollName */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCollName</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_COLLATE</name></expr></argument>, <argument><expr><name>pCollName</name></expr></argument>, <argument><expr><name>dequote</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Collate</name><operator>|</operator><name>EP_Skip</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAddCollateString</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,  <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,          <comment type="block">/* Add the "COLLATE" clause to this expression */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zC</name></decl></parameter>        <comment type="block">/* The collating sequence name */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Token</name></type> <name>s</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3TokenInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ExprAddCollateToken</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Skip over any TK_COLLATE operators.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprSkipCollate</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>pExpr</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Skip</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>   
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Skip over any TK_COLLATE operators and/or any unlikely()
** or likelihood() or likely() functions at the root of an
** expression.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprSkipCollateAndLikely</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>pExpr</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Skip</name><operator>|</operator><name>EP_Unlikely</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Unlikely</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>   
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the collation sequence for the expression pExpr. If
** there is no defined collating sequence, return NULL.
**
** See also: sqlite3ExprNNCollSeq()
**
** The sqlite3ExprNNCollSeq() works the same exact that it returns the
** default collation if pExpr has no defined collation.
**
** The collating sequence might be determined by a COLLATE operator
** or by the presence of a column with a defined collating sequence.
** COLLATE operators take first precedence.  Left operands take
** precedence over right operands.
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3ExprCollSeq</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pExpr</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_AGG_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator> 
     <operator>||</operator> <name>op</name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_TRIGGER</name></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>j</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_CAST</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UPLUS</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_VECTOR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3GetCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNext</name>  <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* The Expr.x union is never used at the same time as Expr.pRight */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Collate</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3CheckCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pColl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the collation sequence for the expression pExpr. If
** there is no defined collating sequence, return a pointer to the
** defautl collation sequence.
**
** See also: sqlite3ExprCollSeq()
**
** The sqlite3ExprCollSeq() routine works the same except that it
** returns NULL if there is no defined collation.
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3ExprNNCollSeq</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the two expressions have equivalent collating sequences.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCollSeqMatch</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pE1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pE2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl1</name> <init>= <expr><call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl2</name> <init>= <expr><call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl1</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pColl2</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is an operand of a comparison operator.  aff2 is the
** type affinity of the other operand.  This routine returns the
** type affinity that should be used for the comparison operator.
*/</comment>
<function><type><name>char</name></type> <name>sqlite3CompareAffinity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>aff2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff1</name> <init>= <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aff1</name><operator>&gt;</operator><name>SQLITE_AFF_NONE</name> <operator>&amp;&amp;</operator> <name>aff2</name><operator>&gt;</operator><name>SQLITE_AFF_NONE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Both sides of the comparison are columns. If one has numeric
    ** affinity, use that. Otherwise use no affinity.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_AFF_NUMERIC</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_AFF_BLOB</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* One side is a column, the other is not. Use the columns affinity. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aff1</name><operator>&lt;=</operator><name>SQLITE_AFF_NONE</name> <operator>||</operator> <name>aff2</name><operator>&lt;=</operator><name>SQLITE_AFF_NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>aff1</name><operator>&lt;=</operator><name>SQLITE_AFF_NONE</name></expr> ?</condition><then> <expr><name>aff2</name></expr> </then><else>: <expr><name>aff1</name></expr></else></ternary><operator>)</operator> <operator>|</operator> <name>SQLITE_AFF_NONE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is a comparison operator.  Return the type affinity that should
** be applied to both operands prior to doing the comparison.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name></type> <name>comparisonAffinity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name> <operator>||</operator>
          <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name> <operator>||</operator>
          <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NE</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>aff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is a comparison expression, eg. '=', '&lt;', IN(...) etc.
** idx_affinity is the affinity of an indexed column. Return true
** if the index with affinity idx_affinity may be used to implement
** the comparison in pExpr.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IndexAffinityOk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>idx_affinity</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name> <init>= <expr><call><name>comparisonAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aff</name><operator>&lt;</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>aff</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>idx_affinity</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>idx_affinity</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the P5 value that should be used for a binary comparison
** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.
*/</comment>
<function><type><specifier>static</specifier> <name>u8</name></type> <name>binaryCompareP5</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr1</name></decl></parameter>,   <comment type="block">/* Left operand */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr2</name></decl></parameter>,   <comment type="block">/* Right operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>        <comment type="block">/* Extra flags added to P5 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>aff</name> <init>= <expr><operator>(</operator><name>char</name><operator>)</operator><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>aff</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pExpr1</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>jumpIfNull</name></expr>;</expr_stmt>
  <return>return <expr><name>aff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the collation sequence that should be used by
** a binary comparison operator comparing pLeft and pRight.
**
** If the left hand expression has a collating sequence type, then it is
** used. Otherwise the collation sequence for the right hand expression
** is used, or the default (BINARY) if neither expression has a collating
** type.
**
** Argument pRight (but not pLeft) may be a null pointer. In this case,
** it is not considered.
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3BinaryCompareCollSeq</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pRight</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRight</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pColl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Expresssion p is a comparison operator.  Return a collation sequence
** appropriate for the comparison operator.
**
** This is normally just a wrapper around sqlite3BinaryCompareCollSeq().
** However, if the OP_Commuted flag is set, then the order of the operands
** is reversed in the sqlite3BinaryCompareCollSeq() call so that the
** correct collating sequence is found.
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3ExprCompareCollSeq</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Commuted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a comparison operator.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeCompare</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* The parsing (and code generating) context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,      <comment type="block">/* The left operand */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,     <comment type="block">/* The right operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>,       <comment type="block">/* The comparison opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>in1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in2</name></decl></parameter>, <comment type="block">/* Register holding operands */</comment>
  <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>,         <comment type="block">/* Jump here if true.  */</comment>
  <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>,   <comment type="block">/* If true, jump if either operand is NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>isCommuted</name></decl></parameter>    <comment type="block">/* The comparison has been commuted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>p5</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>p4</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isCommuted</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p4</name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p4</name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>p5</name> <operator>=</operator> <call><name>binaryCompareP5</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>in1</name></expr></argument>,
                           <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if expression pExpr is a vector, or false otherwise.
**
** A vector is defined as any expression that results in two or more
** columns of result.  Every TK_VECTOR node is an vector because the
** parser will not generate a TK_VECTOR with fewer than two entries.
** But a TK_SELECT might be either a vector or a scalar. It is only
** considered a vector if it has two or more result columns.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsVector</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the expression passed as the only argument is of type TK_VECTOR 
** return the number of expressions in the vector. Or, if the expression
** is a sub-select, return the number of columns in the sub-select. For
** any other type of expression, return 1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprVectorSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_VECTOR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to a subexpression of pVector that is the i-th
** column of the vector (numbered starting with 0).  The caller must
** ensure that i is within range.
**
** If pVector is really a scalar (and "scalar" here includes subqueries
** that return a single column!) then return pVector unmodified.
**
** pVector retains ownership of the returned subexpression.
**
** If the vector is a (SELECT ...) then the expression returned is
** just the expression for the i-th term of the result set, and may
** not be ready for evaluation because the table cursor has not yet
** been positioned.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3VectorFieldSubexpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pVector</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pVector</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVector</name><operator>-&gt;</operator><name>op2</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pVector</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_REGISTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pVector</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name> <operator>||</operator> <name><name>pVector</name><operator>-&gt;</operator><name>op2</name></name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name><name>pVector</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name><name>pVector</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pVector</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute and return a new Expr object which when passed to
** sqlite3ExprCode() will generate all necessary code to compute
** the iField-th column of the vector expression pVector.
**
** It is ok for pVector to be a scalar (as long as iField==0).  
** In that case, this routine works like sqlite3ExprDup().
**
** The caller owns the returned Expr object and is responsible for
** ensuring that the returned value eventually gets freed.
**
** The caller retains ownership of pVector.  If pVector is a TK_SELECT,
** then the returned object will reference pVector and so pVector must remain
** valid for the life of the returned object.  If pVector is a TK_VECTOR
** or a scalar expression, then it can be deleted as soon as this routine
** returns.
**
** A trick to cause a TK_SELECT pVector to be deleted together with
** the returned Expr object is to attach the pVector to the pRight field
** of the returned TK_SELECT_COLUMN Expr object.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprForVectorField</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pVector</name></decl></parameter>,       <comment type="block">/* The vector.  List of expressions or a sub-SELECT */</comment>
  <parameter><decl><type><name>int</name></type> <name>iField</name></decl></parameter>,          <comment type="block">/* Which column of the vector to return */</comment>
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>           <comment type="block">/* Total number of columns in the vector */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVector</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The TK_SELECT_COLUMN Expr node:
    **
    ** pLeft:           pVector containing TK_SELECT.  Not deleted.
    ** pRight:          not used.  But recursively deleted.
    ** iColumn:         Index of a column in pVector
    ** iTable:          0 or the number of columns on the LHS of an assignment
    ** pLeft-&gt;iTable:   First in an array of register holding result, or 0
    **                  if the result is not yet computed.
    **
    ** sqlite3ExprDelete() specifically skips the recursive delete of
    ** pLeft on TK_SELECT_COLUMN nodes.  But pRight is followed, so pVector
    ** can be attached to pRight to cause this node to take ownership of
    ** pVector.  Typically there will be multiple TK_SELECT_COLUMN nodes
    ** with the same pLeft pointer to the pVector, but only one of them
    ** will own the pVector.
    */</comment>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_SELECT_COLUMN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iField</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pVector</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pVector</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVector</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ppVector</name> <operator>=</operator> <operator>&amp;</operator><name><name>pVector</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVector</name> <operator>=</operator> <operator>*</operator><name>ppVector</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* This must be a vector UPDATE inside a trigger */</comment>
        <expr_stmt><expr><operator>*</operator><name>ppVector</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>pVector</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pVector</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If expression pExpr is of type TK_SELECT, generate code to evaluate
** it. Return the register in which the result is stored (or, if the 
** sub-select returns more than one column, the first in an array
** of registers in which the result is stored).
**
** If pExpr is not a TK_SELECT expression, return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprCodeSubselect</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>reg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>reg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument pVector points to a vector expression - either a TK_VECTOR
** or TK_SELECT that returns more than one column. This function returns
** the register number of a register that contains the value of
** element iField of the vector.
**
** If pVector is a TK_SELECT expression, then code for it must have 
** already been generated using the exprCodeSubselect() routine. In this
** case parameter regSelect should be the first in an array of registers
** containing the results of the sub-select. 
**
** If pVector is of type TK_VECTOR, then code for the requested field
** is generated. In this case (*pRegFree) may be set to the number of
** a temporary register to be freed by the caller before returning.
**
** Before returning, output parameter (*ppExpr) is set to point to the
** Expr object corresponding to element iElem of the vector.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprVectorRegister</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pVector</name></decl></parameter>,                  <comment type="block">/* Vector to extract element from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iField</name></decl></parameter>,                     <comment type="block">/* Field to extract from pVector */</comment>
  <parameter><decl><type><name>int</name></type> <name>regSelect</name></decl></parameter>,                  <comment type="block">/* First in array of registers */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExpr</name></decl></parameter>,                  <comment type="block">/* OUT: Expression element */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRegFree</name></decl></parameter>                   <comment type="block">/* OUT: Temp register to free */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name> <init>= <expr><name><name>pVector</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_VECTOR</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_REGISTER</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_SELECT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>, <argument><expr><name>iField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pVector</name><operator>-&gt;</operator><name>iTable</name></name><operator>+</operator><name>iField</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <name><name>pVector</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
     <return>return <expr><name>regSelect</name><operator>+</operator><name>iField</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_VECTOR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pVector</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <name><name>pVector</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>*</operator><name>ppExpr</name></expr></argument>, <argument><expr><name>pRegFree</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Expression pExpr is a comparison between two vector values. Compute
** the result of the comparison (1, 0, or NULL) and write that
** result into register dest.
**
** The caller must satisfy the following preconditions:
**
**    if pExpr-&gt;op==TK_IS:      op==TK_EQ and p5==SQLITE_NULLEQ
**    if pExpr-&gt;op==TK_ISNOT:   op==TK_NE and p5==SQLITE_NULLEQ
**    otherwise:                op==pExpr-&gt;op and p5==0
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeVectorCompare</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Code generator context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,          <comment type="block">/* The comparison operation */</comment>
  <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>,             <comment type="block">/* Write results into this register */</comment>
  <parameter><decl><type><name>u8</name></type> <name>op</name></decl></parameter>,                <comment type="block">/* Comparison operator */</comment>
  <parameter><decl><type><name>u8</name></type> <name>p5</name></decl></parameter>                 <comment type="block">/* SQLITE_NULLEQ or zero */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name> <init>= <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>opx</name> <init>= <expr><name>op</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addrDone</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isCommuted</name> <init>= <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Commuted</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nLeft</name><operator>!=</operator><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"row value misused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NE</name> 
       <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name> 
       <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name> 
       <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>op</name> <operator>||</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>TK_EQ</name><operator>)</operator>
            <operator>||</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>TK_NE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p5</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>op</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p5</name><operator>==</operator><name>SQLITE_NULLEQ</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>op</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_LE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opx</name> <operator>=</operator> <name>TK_LT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_GE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opx</name> <operator>=</operator> <name>TK_GT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_NE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opx</name> <operator>=</operator> <name>TK_EQ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>regLeft</name> <operator>=</operator> <call><name>exprCodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRight</name> <operator>=</operator> <call><name>exprCodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><literal type="number">1</literal></expr> <comment type="block">/*Loop exits by "break"*/</comment>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>regFree2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>addrCmp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>exprVectorRegister</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>exprVectorRegister</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrCmp</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pL</name></expr></argument>, <argument><expr><name>pR</name></expr></argument>, <argument><expr><name>opx</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>addrDone</name></expr></argument>, <argument><expr><name>p5</name></expr></argument>, <argument><expr><name>isCommuted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>opx</name><operator>==</operator><name>TK_LT</name> <operator>||</operator> <name>opx</name><operator>==</operator><name>TK_GT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nLeft</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrCmp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ElseEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>opx</name><operator>==</operator><name>TK_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>opx</name><operator>==</operator><name>TK_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>opx</name><operator>==</operator><name>TK_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>opx</name><operator>==</operator><name>TK_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>p5</name><operator>==</operator><name>SQLITE_NULLEQ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ZeroOrNull</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nLeft</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>opx</name><operator>==</operator><name>TK_EQ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>addrDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_LT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_GT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_LE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nLeft</name><operator>-</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opx</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_NE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Not</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Check that argument nHeight is less than or equal to the maximum
** expression depth allowed. If it is not, leave an error message in
** pParse.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCheckHeight</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxHeight</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_EXPR_DEPTH</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nHeight</name><operator>&gt;</operator><name>mxHeight</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
       <argument><expr><literal type="string">"Expression tree is too large (maximum depth %d)"</literal></expr></argument>, <argument><expr><name>mxHeight</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The following three functions, heightOfExpr(), heightOfExprList()
** and heightOfSelect(), are used to determine the maximum height
** of any expression tree referenced by the structure passed as the
** first argument.
**
** If this maximum height is greater than the current value pointed
** to by pnHeight, the second parameter, then set *pnHeight to that
** value.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>heightOfExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>&gt;</operator><operator>*</operator><name>pnHeight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnHeight</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>heightOfExprList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>heightOfSelect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Select</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pSelect</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Set the Expr.nHeight variable in the structure passed as an 
** argument. An expression with no children, Expr.pList or 
** Expr.pSelect member has a height of 1. Any other expression
** has a height equal to the maximum height of any other 
** referenced Expr plus one.
**
** Also propagate EP_Propagate flags up from Expr.x.pList to Expr.flags,
** if appropriate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprSetHeight</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nHeight</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>nHeight</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>nHeight</name></name><operator>&gt;</operator><name>nHeight</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nHeight</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <call><name>sqlite3ExprListFlags</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <name>nHeight</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the Expr.nHeight variable using the exprSetHeight() function. If
** the height is greater than the maximum allowed expression depth,
** leave an error in pParse.
**
** Also propagate all EP_Propagate flags from the Expr.x.pList into
** Expr.flags. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprSetHeightAndFlags</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>exprSetHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the maximum height of any expression tree referenced
** by the select statement passed as an argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3SelectExprHeight</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nHeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nHeight</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* ABOVE:  Height enforcement enabled.  BELOW: Height enforcement off */</comment>
<comment type="block">/*
** Propagate all EP_Propagate flags from the Expr.x.pList into
** Expr.flags. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprSetHeightAndFlags</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <call><name>sqlite3ExprListFlags</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>exprSetHeight</name><parameter_list>(<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_EXPR_DEPTH&gt;0 */</comment>

<comment type="block">/*
** This routine is the core allocator for Expr nodes.
**
** Construct a new expression node and return a pointer to it.  Memory
** for this node and for the pToken argument is a single allocation
** obtained from sqlite3DbMalloc().  The calling function
** is responsible for making sure the node eventually gets freed.
**
** If dequote is true, then the token (if it exists) is dequoted.
** If dequote is false, no dequoting is performed.  The deQuote
** parameter is ignored if pToken is NULL or if the token does not
** appear to be quoted.  If the quotes were of the form "..." (double-quotes)
** then the EP_DblQuoted flag is set on the expression node.
**
** Special case:  If op==TK_INTEGER and pToken points to a string that
** can be translated into a 32-bit integer, then the token is not
** stored in u.zToken.  Instead, the integer values is written
** into u.iValue and the EP_IntValue flag is set.  No extra storage
** is allocated to hold the integer text and the dequote flag is ignored.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAlloc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Handle for sqlite3DbMallocRawNN() */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                 <comment type="block">/* Expression opcode */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>,    <comment type="block">/* Token argument.  Might be NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>dequote</name></decl></parameter>             <comment type="block">/* True to dequote */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pToken</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_INTEGER</name> <operator>||</operator> <name><name>pToken</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal>
          <operator>||</operator> <call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iValue</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nExtra</name> <operator>=</operator> <name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iValue</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pToken</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nExtra</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_IntValue</name><operator>|</operator><name>EP_Leaf</name><operator>|</operator><operator>(</operator><ternary><condition><expr><name>iValue</name></expr>?</condition><then><expr><name>EP_IsTrue</name></expr></then><else>:<expr><name>EP_IsFalse</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <name>iValue</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>dequote</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isquote</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3DequoteExpr</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new expression node from a zero-terminated token that has
** already been dequoted.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3Expr</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Handle for sqlite3DbMallocZero() (may be null) */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                 <comment type="block">/* Expression opcode */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl></parameter>      <comment type="block">/* Token argument.  Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Token</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>zToken</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attach subtrees pLeft and pRight to the Expr node pRoot.
**
** If pRoot==NULL that means that a memory allocation error has occurred.
** In that case, delete the subtrees pLeft and pRight.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAttachSubtrees</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRoot</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>nHeight</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pLeft</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
      <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>nHeight</name></name><operator>&gt;=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>nHeight</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate an Expr node which joins as many as two subtrees.
**
** One or both of the subtrees can be NULL.  Return a pointer to the new
** Expr node.  Or, if an OOM error occurs, set pParse-&gt;db-&gt;mallocFailed,
** free the subtrees and return NULL.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3PExpr</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                 <comment type="block">/* Expression opcode */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,            <comment type="block">/* Left operand */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>            <comment type="block">/* Right operand */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAttachSubtrees</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add pSelect to the Expr.x.pSelect field.  Or, if pExpr is NULL (due
** do a memory allocation failure) then delete the pSelect object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PExprAddSelect</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <name>pSelect</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name><operator>|</operator><name>EP_Subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprSetHeightAndFlags</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Expression list pEList is a list of vector values. This function
** converts the contents of pEList to a VALUES(...) Select statement
** returning 1 row for each element of the list. For example, the 
** expression list:
**
**   ( (1,2), (3,4) (5,6) )
**
** is translated to the equivalent of:
**
**   VALUES(1,2), (3,4), (5,6)
**
** Each of the vector values in pEList must contain exactly nElem terms.
** If a list element that is not a vector or does not contain nElem terms,
** an error message is left in pParse.
**
** This is used as part of processing IN(...) expressions with a list
** of vectors on the RHS. e.g. "... IN ((1,2), (3,4), (5,6))".
*/</comment>
<function><type><name>Select</name> <modifier>*</modifier></type><name>sqlite3ExprListToValues</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nElem</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nElem</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nExprElem</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExprElem</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nExprElem</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nExprElem</name><operator>!=</operator><name>nElem</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"IN(...) element has %d term%s - expected %d"</literal></expr></argument>, 
          <argument><expr><name>nExprElem</name></expr></argument>, <argument><expr><ternary><condition><expr><name>nExprElem</name><operator>&gt;</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="string">"s"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>nElem</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSel</name> <operator>=</operator> <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SF_Values</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSel</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name>pSel</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>pRet</name> <operator>&amp;&amp;</operator> <name><name>pRet</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_MultiValue</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Join two expressions using an AND operator.  If either expression is
** NULL, then just return the other expression.
**
** If one side or the other of the AND is known to be false, then instead
** of returning an AND expression, just return a constant expression with
** a value of false.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAnd</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pLeft</name><operator>==</operator><literal type="number">0</literal></expr>  )</condition><block>{<block_content>
    <return>return <expr><name>pRight</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pLeft</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><call><name>ExprAlwaysFalse</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ExprAlwaysFalse</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call><operator>)</operator> 
         <operator>&amp;&amp;</operator> <operator>!</operator><name>IN_RENAME_OBJECT</name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDeferredDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDeferredDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Construct a new expression node for a function with multiple
** arguments.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprFunction</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,      <comment type="block">/* Argument list */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>,  <comment type="block">/* Name of the function */</comment>
  <parameter><decl><type><name>int</name></type> <name>eDistinct</name></decl></parameter>         <comment type="block">/* SF_Distinct or SF_ALL or 0 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_FUNCTION</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Avoid memory leak when malloc fails */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_InnerON</name><operator>|</operator><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iOfst</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name> <operator>-</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zTail</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name> 
   <operator>&amp;&amp;</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>&gt;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr>]</index></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many arguments on function %T"</literal></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_HasFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprSetHeightAndFlags</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eDistinct</name><operator>==</operator><name>SF_Distinct</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_Distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if a function is usable according to current access
** rules:
**
**    SQLITE_FUNC_DIRECT    -     Only usable from top-level SQL
**
**    SQLITE_FUNC_UNSAFE    -     Usable if TRUSTED_SCHEMA or from
**                                top-level SQL
**
** If the function is not usable, create an error.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprFunctionUsable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,     <comment type="block">/* The function invocation */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl></parameter>    <comment type="block">/* The function being invoked */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>IN_RENAME_OBJECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_DIRECT</name><operator>|</operator><name>SQLITE_FUNC_UNSAFE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromDDL</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_DIRECT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>||</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_TrustedSchema</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* Functions prohibited in triggers and views if:
      **     (1) tagged with SQLITE_DIRECTONLY
      **     (2) not tagged with SQLITE_INNOCUOUS (which means it
      **         is tagged with SQLITE_FUNC_UNSAFE) and 
      **         SQLITE_DBCONFIG_TRUSTED_SCHEMA is off (meaning
      **         that the schema is possibly tainted).
      */</comment>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unsafe use of %#T()"</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Assign a variable number to an expression that encodes a wildcard
** in the original SQL statement.  
**
** Wildcards consisting of a single "?" are assigned the next sequential
** variable number.
**
** Wildcards of the form "?nnn" are assigned the number "nnn".  We make
** sure "nnn" is not too big to avoid a denial of service attack when
** the SQL statement comes from an external source.
**
** Wildcards of the form ":aaa", "@aaa", or "$aaa" are assigned the same number
** as the previous instance of the same wildcard.  Or if this is the first
** instance of the wildcard, the next sequential variable number is
** assigned.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAssignVarNumber</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ynVar</name></type> <name>x</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name><operator>|</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Wildcard of the form "?".  Assign the next variable number */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><operator>(</operator><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>doAdd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Wildcard of the form "?nnn".  Convert "nnn" to an integer and
      ** use it as the variable number */</comment>
      <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bOk</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content> <comment type="block">/*OPTIMIZATION-IF-TRUE*/</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt>  <comment type="block">/* The common case of ?N for a single digit N */</comment>
        <expr_stmt><expr><name>bOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>bOk</name> <operator>=</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bOk</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>i</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>i</name></expr></argument>&gt;</argument_list></name><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"variable number must be between ?1 and ?%d"</literal></expr></argument>,
            <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3RecordErrorOffsetOfExpr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>doAdd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3VListNumToName</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVList</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>doAdd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Wildcards like ":aaa", "$aaa" or "@aaa".  Reuse the same variable
      ** number as the prior appearance of the same name, or if the name
      ** has never appeared before, reuse the same variable number
      */</comment>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><call><name>sqlite3VListNameToNum</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVList</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><operator>(</operator><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>doAdd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>doAdd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVList</name></name> <operator>=</operator> <call><name>sqlite3VListAdd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVList</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many SQL variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3RecordErrorOffsetOfExpr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Recursively delete an expression tree.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>sqlite3ExprDeleteNN</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprUseUValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprUseYWin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ExprUseYSub</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprUseYWin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_FUNCTION</name> <operator>||</operator> <operator>!</operator><call><name>ExprUseYSub</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Leaf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>EP_TokenOnly</name><operator>|</operator><name>EP_Leaf</name><operator>)</operator></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* The Expr.x union is never used at the same time as Expr.pRight */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_SELECT_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ExprDeleteNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDeleteNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WindowDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Static</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3ExprDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ExprDeleteNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear both elements of an OnOrUsing object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ClearOnOrUsing</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>OnOrUsing</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Nothing to clear */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pOn</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDeleteNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pUsing</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUsing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Arrange to cause pExpr to be deleted when the pParse is deleted.
** This is similar to sqlite3ExprDelete() except that the delete is
** deferred untilthe pParse is deleted.
**
** The pExpr might be deleted immediately on an OOM error.
**
** The deferred delete is (currently) implemented by adding the
** pExpr to the pParse-&gt;pConstExpr list with a register number of 0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprDeferredDelete</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
    <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3ExprDelete</name></expr></argument>,
    <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Invoke sqlite3RenameExprUnmap() and sqlite3ExprDelete() on the
** expression.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprUnmapAndDelete</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3RenameExprUnmap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDeleteNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes allocated for the expression structure 
** passed as the first argument. This is always one of EXPR_FULLSIZE,
** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprStructSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EXPR_TOKENONLYSIZE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EXPR_REDUCEDSIZE</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>EXPR_FULLSIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The dupedExpr*Size() routines each return the number of bytes required
** to store a copy of an expression or expression tree.  They differ in
** how much of the tree is measured.
**
**     dupedExprStructSize()     Size of only the Expr structure 
**     dupedExprNodeSize()       Size of Expr + space for token
**     dupedExprSize()           Expr + token + subtree components
**
***************************************************************************
**
** The dupedExprStructSize() function returns two values OR-ed together:  
** (1) the space required for a copy of the Expr structure only and 
** (2) the EP_xxx flags that indicate what the structure size should be.
** The return values is always one of:
**
**      EXPR_FULLSIZE
**      EXPR_REDUCEDSIZE   | EP_Reduced
**      EXPR_TOKENONLYSIZE | EP_TokenOnly
**
** The size of the structure can be found by masking the return value
** of this routine with 0xfff.  The flags can be found by masking the
** return value with EP_Reduced|EP_TokenOnly.
**
** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size
** (unreduced) Expr objects as they or originally constructed by the parser.
** During expression analysis, extra information is computed and moved into
** later parts of the Expr object and that extra information might get chopped
** off if the expression is reduced.  Note also that it does not work to
** make an EXPRDUP_REDUCE copy of a reduced expression.  It is only legal
** to reduce a pristine expression tree from the parser.  The implementation
** of dupedExprStructSize() contain multiple assert() statements that attempt
** to enforce this constraint.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dupedExprStructSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nSize</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><name>EXPRDUP_REDUCE</name> <operator>||</operator> <name>flags</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Only one flag value allowed */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>EXPR_FULLSIZE</name><operator>&lt;=</operator><literal type="number">0xfff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">0xfff</literal> <operator>&amp;</operator> <operator>(</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>flags</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT_COLUMN</name> 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
   <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>EXPR_FULLSIZE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasVVAProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>EXPR_REDUCEDSIZE</name> <operator>|</operator> <name>EP_Reduced</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>EXPR_TOKENONLYSIZE</name> <operator>|</operator> <name>EP_TokenOnly</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>nSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function returns the space in bytes required to store the copy 
** of the Expr structure and a copy of the Expr.u.zToken string (if that
** string is defined.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dupedExprNodeSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><call><name>dupedExprStructSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xfff</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>sqlite3Strlen30NN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>ROUND8</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes required to create a duplicate of the 
** expression passed as the first argument. The second argument is a
** mask containing EXPRDUP_XXX flags.
**
** The value returned includes space to create a copy of the Expr struct
** itself and the buffer referred to by Expr.u.zToken, if any.
**
** If the EXPRDUP_REDUCE flag is set, then the return value includes 
** space to duplicate all Expr nodes in the tree formed by Expr.pLeft 
** and Expr.pRight variables (but not for any structures pointed to or 
** descended from the Expr.x.pList or Expr.x.pSelect variables).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dupedExprSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>dupedExprNodeSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>EXPRDUP_REDUCE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>dupedExprSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>dupedExprSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nByte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is similar to sqlite3ExprDup(), except that if pzBuffer 
** is not NULL then *pzBuffer is assumed to point to a buffer large enough 
** to store the copy of expression p, the copies of p-&gt;u.zToken
** (if applicable), and the copies of the p-&gt;pLeft and p-&gt;pRight expressions,
** if any. Before returning, *pzBuffer is set to the first byte past the
** portion of the buffer copied into by this function.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>exprDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dupFlags</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzBuffer</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>           <comment type="block">/* Value to return */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zAlloc</name></decl>;</decl_stmt>           <comment type="block">/* Memory space from which to build Expr object */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>staticFlag</name></decl>;</decl_stmt>       <comment type="block">/* EP_Static if space not obtained from malloc */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>dupFlags</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>dupFlags</name><operator>==</operator><name>EXPRDUP_REDUCE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pzBuffer</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>dupFlags</name><operator>==</operator><name>EXPRDUP_REDUCE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out where to write the new Expr structure. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pzBuffer</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zAlloc</name> <operator>=</operator> <operator>*</operator><name>pzBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>staticFlag</name> <operator>=</operator> <name>EP_Static</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zAlloc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zAlloc</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>dupedExprSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dupFlags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>staticFlag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>zAlloc</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Set nNewSize to the size allocated for the structure pointed to
    ** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or
    ** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed
    ** by the copy of the p-&gt;u.zToken string (if any).
    */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>nStructSize</name> <init>= <expr><call><name>dupedExprStructSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dupFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nNewSize</name> <init>= <expr><name>nStructSize</name> <operator>&amp;</operator> <literal type="number">0xfff</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nToken</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nToken</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>dupFlags</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Reduced</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zAlloc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nNewSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>nSize</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>exprStructSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zAlloc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&lt;</operator><name>EXPR_FULLSIZE</name></expr> )</condition><block>{<block_content> 
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zAlloc</name><index>[<expr><name>nSize</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EXPR_FULLSIZE</name><operator>-</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */</comment>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>|</operator><name>EP_Static</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>nStructSize</name> <operator>&amp;</operator> <operator>(</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>staticFlag</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprClearVVAProperties</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dupFlags</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Copy the p-&gt;u.zToken string, if any. */</comment>
    <if_stmt><if>if<condition>( <expr><name>nToken</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zToken</name> <init>= <expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zAlloc</name><index>[<expr><name>nNewSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>|</operator><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>EP_TokenOnly</name><operator>|</operator><name>EP_Leaf</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* Fill in the pNew-&gt;x.pSelect or pNew-&gt;x.pList member. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><name>dupFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><name>dupFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fill in pNew-&gt;pLeft and pNew-&gt;pRight. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>|</operator><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zAlloc</name> <operator>+=</operator> <call><name>dupedExprNodeSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dupFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Leaf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr> ?</condition><then>
                      <expr><call><name>exprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zAlloc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr> ?</condition><then>
                       <expr><call><name>exprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zAlloc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name> <operator>=</operator> <call><name>sqlite3WindowDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>
      <if_stmt><if>if<condition>( <expr><name>pzBuffer</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzBuffer</name> <operator>=</operator> <name>zAlloc</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Leaf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT_COLUMN</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal>  <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name>
                                <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>EP_Subquery</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create and return a deep copy of the object passed as the second 
** argument. If an OOM condition is encountered, NULL is returned
** and the db-&gt;mallocFailed flag set.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
<function><type><name>With</name> <modifier>*</modifier></type><name>sqlite3WithDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>With</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nCte</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>nCte</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSelect</name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCols</name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCols</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eM10d</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eM10d</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3WithDup</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
<comment type="block">/*
** The gatherSelectWindows() procedure and its helper routine
** gatherSelectWindowsCallback() are used to scan all the expressions
** an a newly duplicated SELECT statement and gather all of the Window
** objects found there, assembling them onto the linked list at Select-&gt;pWin.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>gatherSelectWindowsCallback</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsWindowFunc</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>ppThis</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WindowLink</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>gatherSelectWindowsSelectCallback</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>p</name><operator>==</operator><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pSelect</name></name></expr> ?</condition><then> <expr><name>WRC_Continue</name></expr> </then><else>: <expr><name>WRC_Prune</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gatherSelectWindows</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>gatherSelectWindowsCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>gatherSelectWindowsSelectCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** The following group of routines make deep copies of expressions,
** expression lists, ID lists, and select statements.  The copies can
** be deleted (by being passed to their respective ...Delete() routines)
** without effecting the originals.
**
** The expression list, ID, and source lists return by sqlite3ExprListDup(),
** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded 
** by subsequent calls to sqlite*ListAppend() routines.
**
** Any tables that the SrcList might point to are not duplicated.
**
** The flags parameter contains a combination of the EXPRDUP_XXX flags.
** If the EXPRDUP_REDUCE flag is set, then the structure returned is a
** truncated version of the usual Expr structure that will be stored as
** part of the in-memory representation of the database schema.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>flags</name><operator>==</operator><name>EXPRDUP_REDUCE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><call><name>exprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pOldItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pPriorSelectColOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pPriorSelectColNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOldItem</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOldItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOldExpr</name> <init>= <expr><name><name>pOldItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNewExpr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldExpr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOldExpr</name> 
     <operator>&amp;&amp;</operator> <name><name>pOldExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT_COLUMN</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>pNewExpr</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pNewExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pPriorSelectColOld</name> <operator>=</operator> <name><name>pOldExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPriorSelectColNew</name> <operator>=</operator> <name><name>pNewExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>pNewExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pOldExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><name>pPriorSelectColOld</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pPriorSelectColOld</name> <operator>=</operator> <name><name>pOldExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPriorSelectColNew</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pPriorSelectColOld</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNewExpr</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pPriorSelectColNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pNewExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pPriorSelectColNew</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zEName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>fg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>u</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If cursors, triggers, views and subqueries are all omitted from
** the build, then none of the following routines, except for 
** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes
** called with a NULL argument.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call> \
 <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>SrcList</name> <modifier>*</modifier></type><name>sqlite3SrcListDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SrcList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pNewItem</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>pOldItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zDatabase</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zAlias</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>fg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>addrFillSub</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>regReturn</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u2</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>u2</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pCteUse</name><operator>-&gt;</operator><name>nUse</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name> <operator>=</operator> 
          <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pNewItem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOldItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isUsing</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name> <operator>=</operator> <call><name>sqlite3IdListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>u3</name><operator>.</operator><name>pOn</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>colUsed</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>IdList</name> <modifier>*</modifier></type><name>sqlite3IdListDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IdList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eU4</name></name><operator>!=</operator><name>EU4_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nId</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nId</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eU4</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eU4</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>IdList_item</name></name> <modifier>*</modifier></type><name>pNewItem</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>IdList_item</name></name> <modifier>*</modifier></type><name>pOldItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u4</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>u4</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>Select</name> <modifier>*</modifier></type><name>sqlite3SelectDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Select</name> <modifier>*</modifier></type><name>pDup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>&amp;</operator><name>pRet</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Select</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pDup</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>~</operator><name>SF_UsesEphemeral</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <call><name>sqlite3WithDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWinDefn</name></name> <operator>=</operator> <call><name>sqlite3WindowListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWinDefn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gatherSelectWindows</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>selId</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>selId</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Any prior OOM might have left the Select object incomplete.
      ** Delete the whole thing rather than allow an incomplete Select
      ** to be used by the code generator. */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>Select</name> <modifier>*</modifier></type><name>sqlite3SelectDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Add a new element to the end of an expression list.  If pList is
** initially NULL, then create a new expression list.
**
** The pList argument must be either NULL or a pointer to an ExprList
** obtained from a prior call to sqlite3ExprListAppend().  This routine
** may not be used with an ExprList obtained from sqlite3ExprListDup().
** Reason:  This routine assumes that the number of slots in pList-&gt;a[]
** is a power of two.  That is true for sqlite3ExprListAppend() returns
** but is not necessarily true from the return value of sqlite3ExprListDup().
**
** If a memory allocation error occurs, the entire list is freed and
** NULL is returned.  If non-NULL is returned, then it is guaranteed
** that the new entry was successfully appended.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ExprList_item</name></name></type> <name>zeroItem</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<function><type><name>SQLITE_NOINLINE</name> <name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListAppendNew</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Database handle.  Used for memory allocation */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>             <comment type="block">/* Expression to be appended. Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprList</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pItem</name> <operator>=</operator> <name>zeroItem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>SQLITE_NOINLINE</name> <name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListAppendGrow</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Database handle.  Used for memory allocation */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to append. Might be NULL */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>             <comment type="block">/* Expression to be appended. Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, 
       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pList</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pItem</name> <operator>=</operator> <name>zeroItem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListAppend</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to append. Might be NULL */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>             <comment type="block">/* Expression to be appended. Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3ExprListAppendNew</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3ExprListAppendGrow</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>pList</name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pItem</name> <operator>=</operator> <name>zeroItem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pColumns and pExpr form a vector assignment which is part of the SET
** clause of an UPDATE statement.  Like this:
**
**        (a,b,c) = (expr1,expr2,expr3)
** Or:    (a,b,c) = (SELECT x,y,z FROM ....)
**
** For each term of the vector assignment, append new entries to the
** expression list pList.  In the case of a subquery on the RHS, append
** TK_SELECT_COLUMN expressions.
*/</comment>
<function><type><name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListAppendVector</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,       <comment type="block">/* List to which to append. Might be NULL */</comment>
  <parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pColumns</name></decl></parameter>,      <comment type="block">/* List of names of LHS of the assignment */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>            <comment type="block">/* Vector expression to be appended. Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name> <init>= <expr><ternary><condition><expr><name>pList</name></expr> ?</condition><then> <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <comment type="block">/* pColumns can only be NULL due to an OOM but an OOM will cause an
  ** exit prior to this routine being invoked */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pColumns</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>vector_append_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>vector_append_error</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* If the RHS is a vector, then we can immediately check to see that 
  ** the size of the RHS and LHS match.  But if the RHS is a SELECT, 
  ** wildcards ("*") in the result set of the SELECT must be expanded before
  ** we can do the size check, so defer the size check until code generation.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_SELECT</name> <operator>&amp;&amp;</operator> <name><name>pColumns</name><operator>-&gt;</operator><name>nId</name></name><operator>!=</operator><operator>(</operator><name>n</name><operator>=</operator><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%d columns assigned %d values"</literal></expr></argument>,
                    <argument><expr><name><name>pColumns</name><operator>-&gt;</operator><name>nId</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>vector_append_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pColumns</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pSubExpr</name> <init>= <expr><call><name>sqlite3ExprForVectorField</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pColumns</name><operator>-&gt;</operator><name>nId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSubExpr</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSubExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pSubExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>iFirst</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zEName</name> <operator>=</operator> <name><name>pColumns</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pColumns</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pFirst</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iFirst</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFirst</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFirst</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
     
    <comment type="block">/* Store the SELECT statement in pRight so it will be deleted when
    ** sqlite3ExprListDelete() is called */</comment>
    <expr_stmt><expr><name><name>pFirst</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Remember the size of the LHS in iTable so that we can check that
    ** the RHS and LHS sizes match during code generation. */</comment>
    <expr_stmt><expr><name><name>pFirst</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pColumns</name><operator>-&gt;</operator><name>nId</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>vector_append_error</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprUnmapAndDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the sort order for the last element on the given ExprList.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListSetSortOrder</name><parameter_list>(<parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSortOrder</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eNulls</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>SQLITE_SO_UNDEFINED</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SQLITE_SO_ASC</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SQLITE_SO_DESC</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSortOrder</name><operator>==</operator><name>SQLITE_SO_UNDEFINED</name> 
       <operator>||</operator> <name>iSortOrder</name><operator>==</operator><name>SQLITE_SO_ASC</name> 
       <operator>||</operator> <name>iSortOrder</name><operator>==</operator><name>SQLITE_SO_DESC</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eNulls</name><operator>==</operator><name>SQLITE_SO_UNDEFINED</name> 
       <operator>||</operator> <name>eNulls</name><operator>==</operator><name>SQLITE_SO_ASC</name> 
       <operator>||</operator> <name>eNulls</name><operator>==</operator><name>SQLITE_SO_DESC</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bNulls</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSortOrder</name><operator>==</operator><name>SQLITE_SO_UNDEFINED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iSortOrder</name> <operator>=</operator> <name>SQLITE_SO_ASC</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iSortOrder</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eNulls</name><operator>!=</operator><name>SQLITE_SO_UNDEFINED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bNulls</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iSortOrder</name><operator>!=</operator><name>eNulls</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>|=</operator> <name>KEYINFO_ORDER_BIGNULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the ExprList.a[].zEName element of the most recently added item
** on the expression list.
**
** pList might be NULL following an OOM error.  But pName should never be
** NULL.  If a memory allocation fails, the pParse-&gt;db-&gt;mallocFailed flag
** is set.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListSetName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to add the span. */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>,     <comment type="block">/* Name to be added */</comment>
  <parameter><decl><type><name>int</name></type> <name>dequote</name></decl></parameter>             <comment type="block">/* True to cause the name to be dequoted */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name><operator>!=</operator><name>PARSE_MODE_UNMAP</name> <operator>||</operator> <name>dequote</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dequote</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If dequote==0, then pName-&gt;z does not point to part of a DDL
      ** statement handled by the parser. And so no token need be added
      ** to the token-map.  */</comment>
      <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RenameTokenMap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the ExprList.a[].zSpan element of the most recently added item
** on the expression list.
**
** pList might be NULL following an OOM error.  But pSpan should never be
** NULL.  If a memory allocation fails, the pParse-&gt;db-&gt;mallocFailed flag
** is set.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListSetSpan</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to add the span. */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl></parameter>,     <comment type="block">/* Start of the span */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>        <comment type="block">/* End of the span */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name> <operator>=</operator> <call><name>sqlite3DbSpanDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>eEName</name></name> <operator>=</operator> <name>ENAME_SPAN</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If the expression list pEList contains more than iLimit elements,
** leave an error message in pParse.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListCheckLength</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zObject</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pEList</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>mx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pEList</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>mx</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEList</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name>mx</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many columns in %s"</literal></expr></argument>, <argument><expr><name>zObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Delete an entire expression list.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>exprListDeleteNN</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>=  <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zEName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pItem</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><operator>--</operator><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3ExprListDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exprListDeleteNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the bitwise-OR of all Expr.flags fields in the given
** ExprList.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3ExprListFlags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
     <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>m</name> <operator>|=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a SELECT-node callback for the expression walker that
** always "fails".  By "fail" in this case, we mean set
** pWalker-&gt;eCode to zero and abort.
**
** This callback is used by multiple expression walkers.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3SelectWalkFail</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Abort</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check the input string to see if it is "true" or "false" (in any case).
**
**       If the string is....           Return
**         "true"                         EP_IsTrue
**         "false"                        EP_IsFalse
**         anything else                  0
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3IsTrueOrFalse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>  )</condition><block type="pseudo"><block_content> <return>return <expr><name>EP_IsTrue</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EP_IsFalse</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** If the input expression is an ID with the name "true" or "false"
** then convert it into an TK_TRUEFALSE term.  Return non-zero if
** the conversion happened, and zero if the expression is unaltered.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIdToTrueFalse</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Quoted</name><operator>|</operator><name>EP_IntValue</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>v</name> <operator>=</operator> <call><name>sqlite3IsTrueOrFalse</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_TRUEFALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The argument must be a TK_TRUEFALSE Expr node.  Return 1 if it is TRUE
** and 0 if it is FALSE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprTruthValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRUEFALSE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If pExpr is an AND or OR expression, try to simplify it by eliminating
** terms that are always true or false.  Return the simplified expression.
** Or return the original expression if no simplification is possible.
**
** Examples:
**
**     (x&lt;10) AND true                =&gt;   (x&lt;10)
**     (x&lt;10) AND false               =&gt;   false
**     (x&lt;10) AND (y=22 OR false)     =&gt;   (x&lt;10) AND (y=22)
**     (x&lt;10) AND (y=22 OR true)      =&gt;   (x&lt;10)
**     (y=22) OR true                 =&gt;   true
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprSimplifiedAndOr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_OR</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><call><name>sqlite3ExprSimplifiedAndOr</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><call><name>sqlite3ExprSimplifiedAndOr</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprAlwaysTrue</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ExprAlwaysFalse</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> ?</condition><then> <expr><name>pRight</name></expr> </then><else>: <expr><name>pLeft</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprAlwaysTrue</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ExprAlwaysFalse</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> ?</condition><then> <expr><name>pLeft</name></expr> </then><else>: <expr><name>pRight</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** These routines are Walker callbacks used to check expressions to
** see if they are "constant" for some definition of constant.  The
** Walker.eCode value determines the type of "constant" we are looking
** for.
**
** These callback routines are used to implement the following:
**
**     sqlite3ExprIsConstant()                  pWalker-&gt;eCode==1
**     sqlite3ExprIsConstantNotJoin()           pWalker-&gt;eCode==2
**     sqlite3ExprIsTableConstant()             pWalker-&gt;eCode==3
**     sqlite3ExprIsConstantOrFunction()        pWalker-&gt;eCode==4 or 5
**
** In all cases, the callbacks set Walker.eCode=0 and abort if the expression
** is found to not be a constant.
**
** The sqlite3ExprIsConstantOrFunction() is used for evaluating DEFAULT
** expressions in a CREATE TABLE statement.  The Walker.eCode value is 5
** when parsing an existing schema out of the sqlite_schema table and 4
** when processing a new CREATE TABLE statement.  A bound parameter raises
** an error for new statements, but is silently converted
** to NULL for existing schemas.  This allows sqlite_schema tables that 
** contain a bound parameter because they were generated by older versions
** of SQLite to be parsed by newer versions of SQLite without raising a
** malformed schema error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprNodeIsConstant</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* If pWalker-&gt;eCode is 2 then any term of the expression that comes from
  ** the ON or USING clauses of an outer join disqualifies the expression
  ** from being considered constant. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Consider functions to be constant if all their arguments are constant
    ** and either pWalker-&gt;eCode==4 or 5 or the function has the
    ** SQLITE_FUNC_CONST flag. */</comment>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>&gt;=</operator><literal type="number">4</literal> <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_ConstFunc</name></expr></argument>)</argument_list></call><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">5</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromDDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    <case>case <expr><name>TK_ID</name></expr>:</case>
      <comment type="block">/* Convert "true" or "false" in a DEFAULT clause into the
      ** appropriate TK_TRUEFALSE operator */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIdToTrueFalse</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Prune</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case>
    <case>case <expr><name>TK_AGG_FUNCTION</name></expr>:</case>
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iCur</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><name>TK_IF_NULL_ROW</name></expr>:</case>
    <case>case <expr><name>TK_REGISTER</name></expr>:</case>
    <case>case <expr><name>TK_DOT</name></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_REGISTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_DOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    <case>case <expr><name>TK_VARIABLE</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Silently convert bound parameters that appear inside of CREATE
        ** statements into a NULL when parsing the CREATE statement text out
        ** of the sqlite_schema table */</comment>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* A bound parameter in a CREATE statement that originates from
        ** sqlite3_prepare() causes an error */</comment>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <default>default:</default>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sqlite3SelectWalkFail() disallows */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sqlite3SelectWalkFail() disallows */</comment>
      <return>return <expr><name>WRC_Continue</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprIsConst</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>initFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <name>initFlag</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprNodeIsConstant</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkFail</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <name>sqlite3SelectWalkAssert2</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>iCur</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return non-zero if the expression is constant
** and 0 if it involves variables or function calls.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstant</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return non-zero if
**
**   (1) the expression is constant, and
**   (2) the expression does originate in the ON or USING clause
**       of a LEFT JOIN, and
**   (3) the expression does not contain any EP_FixedCol TK_COLUMN
**       operands created by the constant propagation optimization.
**
** When this routine returns true, it indicates that the expression
** can be added to the pParse-&gt;pConstExpr list and evaluated once when
** the prepared statement starts up.  See sqlite3ExprCodeRunJustOnce().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstantNotJoin</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return non-zero if the expression is constant
** for any single row of the table with cursor iCur.  In other words, the
** expression must not refer to any non-deterministic function nor any
** table other than iCur.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsTableConstant</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check pExpr to see if it is an invariant constraint on data source pSrc.
** This is an optimization.  False negatives will perhaps cause slower
** queries, but false positives will yield incorrect answers.  So when in
** doubt, return 0.
**
** To be an invariant constraint, the following must be true:
**
**   (1)  pExpr cannot refer to any table other than pSrc-&gt;iCursor.
**
**   (2)  pExpr cannot use subqueries or non-deterministic functions.
**
**   (3)  pSrc cannot be part of the left operand for a RIGHT JOIN.
**        (Is there some way to relax this constraint?)
**
**   (4)  If pSrc is the right operand of a LEFT JOIN, then...
**         (4a)  pExpr must come from an ON clause..
           (4b)  and specifically the ON clause associated with the LEFT JOIN.
**
**   (5)  If pSrc is not the right operand of a LEFT JOIN or the left
**        operand of a RIGHT JOIN, then pExpr must be from the WHERE
**        clause, not an ON clause.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsTableConstraint</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* rule (3) */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* rule (4a) */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>         <comment type="block">/* rule (4b) */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* rule (5) */</comment>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>sqlite3ExprIsTableConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</return> <comment type="block">/* rules (1), (2) */</comment>
</block_content>}</block></function>


<comment type="block">/*
** sqlite3WalkExpr() callback used by sqlite3ExprIsConstantOrGroupBy().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprNodeIsConstantOrGroupBy</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGroupBy</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pGroupBy</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Check if pExpr is identical to any GROUP BY term. If so, consider
  ** it constant.  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pGroupBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsBinary</name><argument_list>(<argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Prune</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Check if pExpr is a sub-select. If so, consider it variable. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>exprNodeIsConstant</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk the expression tree passed as the first argument. Return non-zero
** if the expression consists entirely of constants or copies of terms 
** in pGroupBy that sort with the BINARY collation sequence.
**
** This routine is used to determine if a term of the HAVING clause can
** be promoted into the WHERE clause.  In order for such a promotion to work,
** the value of the HAVING clause term must be the same for all members of
** a "group".  The requirement that the GROUP BY term must be BINARY
** assumes that no other collating sequence will have a finer-grained
** grouping than binary.  In other words (A=B COLLATE binary) implies
** A=B in every other collating sequence.  The requirement that the
** GROUP BY be BINARY is stricter than necessary.  It would also work
** to promote HAVING clauses that use the same alternative collating
** sequence as the GROUP BY term, but that is much harder to check,
** alternative collating sequences are uncommon, and this is only an
** optimization, so we take the easy way out and simply require the
** GROUP BY to use the BINARY collating sequence.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstantOrGroupBy</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGroupBy</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprNodeIsConstantOrGroupBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pGroupBy</name></name> <operator>=</operator> <name>pGroupBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree for the DEFAULT field of a column definition
** in a CREATE TABLE statement.  Return non-zero if the expression is 
** acceptable for use as a DEFAULT.  That is to say, return non-zero if
** the expression is constant or a function call with constant arguments.
** Return and 0 if there are any variables.
**
** isInit is true when parsing from sqlite_schema.  isInit is false when
** processing a new CREATE TABLE statement.  When isInit is true, parameters
** (such as ? or $abc) in the expression are converted into NULL.  When
** isInit is false, parameters raise an error.  Parameters should not be
** allowed in a CREATE TABLE statement, but some legacy versions of SQLite
** allowed it, so we need to support it when reading sqlite_schema for
** backwards compatibility.
**
** If isInit is true, set EP_FromDDL on every TK_FUNCTION node.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstantOrFunction</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>isInit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isInit</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isInit</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>+</operator><name>isInit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
<comment type="block">/*
** Walk an expression tree.  Return 1 if the expression contains a
** subquery of some kind.  Return 0 if there are no subqueries.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprContainsSubquery</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>sqlite3ExprWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkFail</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <name>sqlite3SelectWalkAssert2</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the expression p codes a constant integer that is small enough
** to fit in a 32-bit integer, return 1 and put the value of the integer
** in *pValue.  If the expression is not an integer or if it is too big
** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsInteger</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Used to only happen following on OOM */</comment>

  <comment type="block">/* If an expression is an integer literal that fits in a signed 32-bit
  ** integer, then the EP_IntValue flag will have already been set */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_INTEGER</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_IntValue</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>||</operator> <call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_IntValue</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_UPLUS</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_UMINUS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>v</name><operator>)</operator><operator>!=</operator><literal type="number">0x80000000</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return FALSE if there is no chance that the expression can be NULL.
**
** If the expression might be NULL or if the expression is too complex
** to tell return TRUE.  
**
** This routine is used as an optimization, to skip OP_IsNull opcodes
** when we know that a value cannot be NULL.  Hence, a false positive
** (returning TRUE when in fact the expression can never be NULL) might
** be a small performance hit but is otherwise harmless.  On the other
** hand, a false negative (returning FALSE when the result could be NULL)
** will likely result in an incorrect answer.  So when in doubt, return
** TRUE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCanBeNull</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UPLUS</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UMINUS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case>
    <case>case <expr><name>TK_STRING</name></expr>:</case>
    <case>case <expr><name>TK_FLOAT</name></expr>:</case>
    <case>case <expr><name>TK_BLOB</name></expr>:</case>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_CanBeNull</name></expr></argument>)</argument_list></call> <operator>||</operator>
             <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator>  <comment type="block">/* Reference to column of index on expression */</comment>
             <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal>
              <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name><operator>!=</operator><literal type="number">0</literal> <comment type="block">/* Possible due to prior error */</comment>
              <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    <default>default:</default>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the given expression is a constant which would be
** unchanged by OP_Affinity with the affinity given in the second
** argument.
**
** This routine is used to determine if the OP_Affinity operation
** can be omitted.  When in doubt return FALSE.  A false negative
** is harmless.  A false positive, however, can result in the wrong
** answer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprNeedsNoAffinityChange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>aff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>unaryMinus</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aff</name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UPLUS</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UMINUS</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UMINUS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>unaryMinus</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case> <block>{<block_content>
      <return>return <expr><name>aff</name><operator>&gt;=</operator><name>SQLITE_AFF_NUMERIC</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_FLOAT</name></expr>:</case> <block>{<block_content>
      <return>return <expr><name>aff</name><operator>&gt;=</operator><name>SQLITE_AFF_NUMERIC</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>
      <return>return <expr><operator>!</operator><name>unaryMinus</name> <operator>&amp;&amp;</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_BLOB</name></expr>:</case> <block>{<block_content>
      <return>return <expr><operator>!</operator><name>unaryMinus</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* p cannot be part of a CHECK constraint */</comment>
      <return>return <expr><name>aff</name><operator>&gt;=</operator><name>SQLITE_AFF_NUMERIC</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the given string is a row-id column name.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsRowid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"_ROWID_"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"ROWID"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"OID"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pX is the RHS of an IN operator.  If pX is a SELECT statement 
** that can be simplified to a direct table access, then return
** a pointer to the SELECT statement.  If pX is not a SELECT statement,
** or if the SELECT statement needs to be manifested into a transient
** table, then return NULL.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>Select</name> <modifier>*</modifier></type><name>isCandidateForInOpt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                 <comment type="block">/* Not a subquery */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call></expr>  )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Correlated subq */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Not a compound SELECT */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SF_Distinct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SF_Aggregate</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* No DISTINCT keyword and no aggregate functions */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>              <comment type="block">/* Has no GROUP BY clause */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Has no LIMIT clause */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Has no WHERE clause */</comment>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>          <comment type="block">/* Single term in FROM clause */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>     <comment type="block">/* FROM is not a subquery or view */</comment>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>  )</argument_list></call></expr>;</expr_stmt>              <comment type="block">/* FROM clause is not a view */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* FROM clause not a virtual table */</comment>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* All SELECT results must be columns. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRes</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pRes</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRes</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Not a correlated subquery */</comment>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** Generate code that checks the left-most column of index table iCur to see if
** it contains any NULL entries.  Cause the register at regHasNull to be set
** to a non-NULL value if iCur contains no NULLs.  Cause register regHasNull
** to be set to NULL if iCur contains one or more NULL values.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3SetHasNullFlag</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regHasNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regHasNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regHasNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_TYPEOFARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"first_entry_in(%d)"</literal><operator>,</operator> <name>iCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** The argument is an IN operator with a list (not a subquery) on the 
** right-hand side.  Return TRUE if that list is constant.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3InRhsIsConstant</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLHS</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLHS</name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLHS</name></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function is used by the implementation of the IN (...) operator.
** The pX parameter is the expression on the RHS of the IN operator, which
** might be either a list of expressions or a subquery.
**
** The job of this routine is to find or create a b-tree object that can
** be used either to test for membership in the RHS set or to iterate through
** all members of the RHS set, skipping duplicates.
**
** A cursor is opened on the b-tree object that is the RHS of the IN operator
** and the *piTab parameter is set to the index of that cursor.
**
** The returned value of this function indicates the b-tree type, as follows:
**
**   IN_INDEX_ROWID      - The cursor was opened on a database table.
**   IN_INDEX_INDEX_ASC  - The cursor was opened on an ascending index.
**   IN_INDEX_INDEX_DESC - The cursor was opened on a descending index.
**   IN_INDEX_EPH        - The cursor was opened on a specially created and
**                         populated epheremal table.
**   IN_INDEX_NOOP       - No cursor was allocated.  The IN operator must be
**                         implemented as a sequence of comparisons.
**
** An existing b-tree might be used if the RHS expression pX is a simple
** subquery such as:
**
**     SELECT &lt;column1&gt;, &lt;column2&gt;... FROM &lt;table&gt;
**
** If the RHS of the IN operator is a list or a more complex subquery, then
** an ephemeral table might need to be generated from the RHS and then
** pX-&gt;iTable made to point to the ephemeral table instead of an
** existing table.  In this case, the creation and initialization of the
** ephmeral table might be put inside of a subroutine, the EP_Subrtn flag
** will be set on pX and the pX-&gt;y.sub fields will be set to show where
** the subroutine is coded.
**
** The inFlags parameter must contain, at a minimum, one of the bits
** IN_INDEX_MEMBERSHIP or IN_INDEX_LOOP but not both.  If inFlags contains
** IN_INDEX_MEMBERSHIP, then the generated table will be used for a fast
** membership test.  When the IN_INDEX_LOOP bit is set, the IN index will
** be used to loop over all values of the RHS of the IN operator.
**
** When IN_INDEX_LOOP is used (and the b-tree will be used to iterate
** through the set members) then the b-tree must not contain duplicates.
** An epheremal table will be created unless the selected columns are guaranteed
** to be unique - either because it is an INTEGER PRIMARY KEY or due to
** a UNIQUE constraint or index.
**
** When IN_INDEX_MEMBERSHIP is used (and the b-tree will be used 
** for fast set membership tests) then an epheremal table must 
** be used unless &lt;columns&gt; is a single INTEGER PRIMARY KEY column or an 
** index can be found with the specified &lt;columns&gt; as its left-most.
**
** If the IN_INDEX_NOOP_OK and IN_INDEX_MEMBERSHIP are both set and
** if the RHS of the IN operator is a list (not a subquery) then this
** routine might decide that creating an ephemeral b-tree for membership
** testing is too expensive and return IN_INDEX_NOOP.  In that case, the
** calling routine should implement the IN operator using a sequence
** of Eq or Ne comparison operations.
**
** When the b-tree is being used for membership tests, the calling function
** might need to know whether or not the RHS side of the IN operator
** contains a NULL.  If prRhsHasNull is not a NULL pointer and 
** if there is any chance that the (...) might contain a NULL value at
** runtime, then a register is allocated and the register number written
** to *prRhsHasNull. If there is no chance that the (...) contains a
** NULL value, then *prRhsHasNull is left unchanged.
**
** If a register is allocated and its location stored in *prRhsHasNull, then
** the value in that register will be NULL if the b-tree contains one or more
** NULL values, and it will be some non-NULL value if the b-tree contains no
** NULL values.
**
** If the aiMap parameter is not NULL, it must point to an array containing
** one element for each column returned by the SELECT statement on the RHS
** of the IN(...) operator. The i'th entry of the array is populated with the
** offset of the index column that matches the i'th column returned by the
** SELECT. For example, if the expression and selected index are:
**
**   (?,?,?) IN (SELECT a, b, c FROM t1)
**   CREATE INDEX i1 ON t1(b, c, a);
**
** then aiMap[] is populated with {2, 0, 1}.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3FindInIndex</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,             <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>,                  <comment type="block">/* The IN expression */</comment>
  <parameter><decl><type><name>u32</name></type> <name>inFlags</name></decl></parameter>,               <comment type="block">/* IN_INDEX_LOOP, _MEMBERSHIP, and/or _NOOP_OK */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>prRhsHasNull</name></decl></parameter>,         <comment type="block">/* Register holding NULL status.  See notes */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiMap</name></decl></parameter>,                <comment type="block">/* Mapping from Index fields to RHS fields */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piTab</name></decl></parameter>                 <comment type="block">/* OUT: index to use */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                            <comment type="block">/* SELECT to the right of IN operator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Type of RHS table. IN_INDEX_* */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>                             <comment type="block">/* Cursor of the RHS table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mustBeUnique</name></decl>;</decl_stmt>                     <comment type="block">/* True if RHS must be unique */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* Virtual machine being coded */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mustBeUnique</name> <operator>=</operator> <operator>(</operator><name>inFlags</name> <operator>&amp;</operator> <name>IN_INDEX_LOOP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>iTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* If the RHS of this IN(...) operator is a SELECT, and if it matters 
  ** whether or not the SELECT result contains NULL values, check whether
  ** or not NULL is actually possible (it may not be, for example, due 
  ** to NOT NULL constraints in the schema). If no NULL values are possible,
  ** set prRhsHasNull to 0 before continuing.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>prRhsHasNull</name> <operator>&amp;&amp;</operator> <call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name> <init>= <expr><name><name>pX</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>prRhsHasNull</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check to see if an existing table or index can be used to
  ** satisfy the query.  This is preferable to generating a new 
  ** ephemeral table.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>=</operator> <call><name>isCandidateForInOpt</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Database connection */</comment>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                           <comment type="block">/* Table &lt;table&gt;. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                               <comment type="block">/* Database idx for pTab */</comment>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* Because of isCandidateForInOpt(p) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Because of isCandidateForInOpt(p) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* Because of isCandidateForInOpt(p) */</comment>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>

    <comment type="block">/* Code an OP_Transaction and OP_TableLock for &lt;table&gt;. */</comment>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name>SQLITE_MAX_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sqlite3GetVdbe() has always been previously called */</comment>
    <if_stmt><if>if<condition>( <expr><name>nExpr</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The "x IN (SELECT rowid FROM table)" case */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name> <init>= <expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_ROWID</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator>
            <literal type="string">"USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR"</literal><operator>,</operator><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                         <comment type="block">/* Iterator variable */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>affinity_ok</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <comment type="block">/* Check that the affinity that will be used to perform each 
      ** comparison is the same as the affinity of each column in table
      ** on the RHS of the IN operator.  If it not, it is not possible to
      ** use any index of the RHS table.  */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nExpr</name> <operator>&amp;&amp;</operator> <name>affinity_ok</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLhs</name> <init>= <expr><call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>idxaff</name> <init>= <expr><call><name>sqlite3TableColumnAffinity</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* RHS table */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>cmpaff</name> <init>= <expr><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pLhs</name></expr></argument>, <argument><expr><name>idxaff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>cmpaff</name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>cmpaff</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <switch>switch<condition>( <expr><name>cmpaff</name></expr> )</condition><block>{<block_content>
          <case>case <expr><name>SQLITE_AFF_BLOB</name></expr>:</case>
            <break>break;</break>
          <case>case <expr><name>SQLITE_AFF_TEXT</name></expr>:</case>
            <comment type="block">/* sqlite3CompareAffinity() only returns TEXT if one side or the
            ** other has no affinity and the other side is TEXT.  Hence,
            ** the only way for cmpaff to be TEXT is for idxaff to be TEXT
            ** and for the term on the LHS of the IN to have no affinity. */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idxaff</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <default>default:</default>
            <expr_stmt><expr><name>affinity_ok</name> <operator>=</operator> <call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>idxaff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name>affinity_ok</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Search for an existing index that will work for this IN operator */</comment>
        <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>Bitmask</name></type> <name>colUsed</name></decl>;</decl_stmt>      <comment type="block">/* Columns of the index used */</comment>
          <decl_stmt><decl><type><name>Bitmask</name></type> <name>mCol</name></decl>;</decl_stmt>         <comment type="block">/* Mask for the current column */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>&lt;</operator><name>nExpr</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <comment type="block">/* Maximum nColumn is BMS-2, not BMS-1, so that we can compute
          ** BITMASK(nExpr) without overflowing */</comment>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>&gt;=</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>mustBeUnique</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>&gt;</operator><name>nExpr</name>
             <operator>||</operator><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>&gt;</operator><name>nExpr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
            )</condition><block>{<block_content>
              <continue>continue;</continue>  <comment type="block">/* This index is not unique over the IN RHS columns */</comment>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
  
          <expr_stmt><expr><name>colUsed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* Columns of index used so far */</comment>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nExpr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLhs</name> <init>= <expr><call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRhs</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pReq</name> <init>= <expr><call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLhs</name></expr></argument>, <argument><expr><name>pRhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pReq</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>XN_ROWID</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nExpr</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><name><name>pRhs</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>pReq</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pReq</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <continue>continue;</continue>
              </block_content>}</block></if></if_stmt>
              <break>break;</break>
            </block_content>}</block></for>
            <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>nExpr</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>mCol</name> <operator>=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>mCol</name> <operator>&amp;</operator> <name>colUsed</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Each column used only once */</comment>
            <expr_stmt><expr><name>colUsed</name> <operator>|=</operator> <name>mCol</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>aiMap</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aiMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
  
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>nExpr</name> <operator>||</operator> <name>colUsed</name><operator>!=</operator><operator>(</operator><call><name>MASKBIT</name><argument_list>(<argument><expr><name>nExpr</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>colUsed</name><operator>==</operator><operator>(</operator><call><name>MASKBIT</name><argument_list>(<argument><expr><name>nExpr</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
            <comment type="block">/* If we reach this point, that means the index pIdx is usable */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name> <init>= <expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator>
                              <literal type="string">"USING INDEX %s FOR IN-OPERATOR"</literal><operator>,</operator><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>IN_INDEX_INDEX_DESC</name> <operator>==</operator> <name>IN_INDEX_INDEX_ASC</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_INDEX_ASC</name> <operator>+</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  
            <if_stmt><if>if<condition>( <expr><name>prRhsHasNull</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_USED_MASK</name></cpp:ifdef>
              <decl_stmt><decl><type><name>i64</name></type> <name>mask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>nExpr</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ColumnsUsed</name></expr></argument>, 
                  <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <expr_stmt><expr><operator>*</operator><name>prRhsHasNull</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>nExpr</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3SetHasNullFlag</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><operator>*</operator><name>prRhsHasNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for> <comment type="block">/* End loop over indexes */</comment>
      </block_content>}</block></if></if_stmt> <comment type="block">/* End if( affinity_ok ) */</comment>
    </block_content>}</block></else></if_stmt> <comment type="block">/* End if not an rowid index */</comment>
  </block_content>}</block></if></if_stmt> <comment type="block">/* End attempt to optimize using an index */</comment>

  <comment type="block">/* If no preexisting index is available for the IN clause
  ** and IN_INDEX_NOOP is an allowed reply
  ** and the RHS of the IN operator is a list, not a subquery
  ** and the RHS is not constant or has two or fewer terms,
  ** then it is not worth creating an ephemeral table to evaluate
  ** the IN operator so return IN_INDEX_NOOP.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>inFlags</name> <operator>&amp;</operator> <name>IN_INDEX_NOOP_OK</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>sqlite3InRhsIsConstant</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&lt;=</operator><literal type="number">2</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Back out the allocation of the unused cursor */</comment>
    <expr_stmt><expr><name>iTab</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>       <comment type="block">/* Cursor is not allocated */</comment>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_NOOP</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Could not find an existing table or index to use as the RHS b-tree.
    ** We will have to generate an ephemeral table to do the job.
    */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>savedNQueryLoop</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rMayHaveNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_EPH</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>inFlags</name> <operator>&amp;</operator> <name>IN_INDEX_LOOP</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>prRhsHasNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>prRhsHasNull</name> <operator>=</operator> <name>rMayHaveNull</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3CodeRhsOfIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rMayHaveNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SetHasNullFlag</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>rMayHaveNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <name>savedNQueryLoop</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>aiMap</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><name>IN_INDEX_INDEX_ASC</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><name>IN_INDEX_INDEX_DESC</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aiMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>piTab</name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
  <return>return <expr><name>eType</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** Argument pExpr is an (?, ?...) IN(...) expression. This 
** function allocates and returns a nul-terminated string containing 
** the affinities to be used for each column of the comparison.
**
** It is the responsibility of the caller to ensure that the returned
** string is eventually freed using sqlite3DbFree().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>exprINAffinity</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><ternary><condition><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nVal</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>a</name> <init>= <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>nVal</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** Load the Parse object passed as the first argument with an error 
** message of the form:
**
**   "sub-select returns N columns - expected M"
*/</comment>   
<function><type><name>void</name></type> <name>sqlite3SubselectError</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nActual</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nExpect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name> <init>= <expr><literal type="string">"sub-select returns %d columns - expected %d"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>nActual</name></expr></argument>, <argument><expr><name>nExpect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Expression pExpr is a vector that has been used in a context where
** it is not permitted. If pExpr is a sub-select vector, this routine 
** loads the Parse object with a message of the form:
**
**   "sub-select returns N columns - expected 1"
**
** Or, if it is a regular scalar vector:
**
**   "row value misused"
*/</comment>   
<function><type><name>void</name></type> <name>sqlite3VectorErrorMsg</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SubselectError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"row value misused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** Generate code that will construct an ephemeral table containing all terms
** in the RHS of an IN operator.  The IN operator can be in either of two
** forms:
**
**     x IN (4,5,11)              -- IN operator with list on right-hand side
**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right
**
** The pExpr parameter is the IN operator.  The cursor number for the
** constructed ephermeral table is returned.  The first time the ephemeral
** table is computed, the cursor number is also stored in pExpr-&gt;iTable,
** however the cursor number returned might not be the same, as it might
** have been duplicated using OP_OpenDup.
**
** If the LHS expression ("x" in the examples) is a column value, or
** the SELECT statement returns a column value, then the affinity of that
** column is used to build the index keys. If both 'x' and the
** SELECT... statement are columns, then numeric affinity is used
** if either column has NUMERIC or INTEGER affinity. If neither
** 'x' nor the SELECT... statement are columns, then numeric affinity
** is used.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CodeRhsOfIN</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,            <comment type="block">/* The IN operator */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>                <comment type="block">/* Use this cursor number */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOnce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Address of the OP_Once instruction at top */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>                   <comment type="block">/* Address of OP_OpenEphemeral instruction */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>                <comment type="block">/* the LHS of the IN operator */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Key information */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>                   <comment type="block">/* Size of vector pLeft */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                    <comment type="block">/* The prepared statement under construction */</comment>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The evaluation of the IN must be repeated every time it
  ** is encountered if any of the following is true:
  **
  **    *  The right-hand side is a correlated subquery
  **    *  The right-hand side is an expression list containing variables
  **    *  We are inside a trigger
  **
  ** If all of the above are false, then we can compute the RHS just once
  ** and reuse it many names.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Reuse of the RHS is allowed */</comment>
    <comment type="block">/* If this routine has already been coded, but the previous code
    ** might not have been invoked yet, so invoke it now as a subroutine. 
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Subrtn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrOnce</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator> <literal type="string">"REUSE LIST SUBQUERY %d"</literal><operator>,</operator>
              <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>selId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYSub</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name></expr></argument>,
                        <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTab</name><operator>!=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Begin coding the subroutine */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprUseYWin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Subrtn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name> <operator>=</operator>
      <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_BeginSubrtn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>addrOnce</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check to see if this is a vector IN operator */</comment>
  <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nVal</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Construct the ephemeral table that will contain the content of
  ** RHS of the IN operator.
  */</comment>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Result of SELECT %u"</literal><operator>,</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>selId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"RHS of IN operator"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 1:     expr IN (SELECT ...)
    **
    ** Generate code to write the results of the select into the temporary
    ** table allocated and opened above.
    */</comment>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"%sLIST SUBQUERY %d"</literal><operator>,</operator>
        <ternary><condition><expr><name>addrOnce</name></expr>?</condition><then><expr><literal type="string">""</literal></expr></then><else>:<expr><literal type="string">"CORRELATED "</literal></expr></else></ternary><operator>,</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>selId</name></name>
    <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If the LHS and RHS of the IN operator do not match, that
    ** error will have been caught long before we reach this point. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>nVal</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pCopy</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_Set</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>zAffSdst</name></name> <operator>=</operator> <call><name>exprINAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pKeyInfo</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Caused by OOM in sqlite3KeyInfoAlloc() */</comment>
      <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>:<expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>zAffSdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>      
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKeyInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* OOM will cause exit after sqlite3Select() */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(
            <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 2:     expr IN (exprlist)
    **
    ** For each expression, build an index key from the evaluation and
    ** store it in the temporary table. If &lt;expr&gt; is a column, then use
    ** that columns affinity when building index keys. If &lt;expr&gt; is not
    ** a column, use numeric affinity.
    */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>            <comment type="block">/* Affinity of the LHS of the IN */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>affinity</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>affinity</name><operator>&lt;=</operator><name>SQLITE_AFF_NONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>affinity</name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>affinity</name> <operator>=</operator> <name>SQLITE_AFF_NUMERIC</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Loop through each expression in &lt;exprlist&gt;. */</comment>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If the expression is not constant then we will need to
      ** disable the test that was generated above that makes sure
      ** this code only executes once.  Because for a non-constant
      ** expression we need to rerun this code each time.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>addrOnce</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Subrtn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addrOnce</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Evaluate the expression and insert it into the temp table */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>affinity</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>addrOnce</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Subroutine return */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYSub</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_BeginSubrtn</name>
            <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name></expr></argument>,
                      <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ClearTempRegCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<comment type="block">/*
** Generate code for scalar subqueries used as a subquery expression
** or EXISTS operator:
**
**     (SELECT a FROM b)          -- subquery
**     EXISTS (SELECT a FROM b)   -- EXISTS subquery
**
** The pExpr parameter is the SELECT or EXISTS operator to be coded.
**
** Return the register that holds the result.  For a multi-column SELECT, 
** the result is stored in a contiguous array of registers and the
** return value is the register of the left-most result column.
** Return 0 if an error occurs.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3CodeSubselect</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOnce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Address of OP_Once at top of subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Register storing resulting */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>               <comment type="block">/* SELECT statement to encode */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>            <comment type="block">/* How to deal with SELECT result */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReg</name></decl>;</decl_stmt>                   <comment type="block">/* Registers to allocate */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl>;</decl_stmt>               <comment type="block">/* New limit expression */</comment>

  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSel</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr>;</expr_stmt>

  <comment type="block">/* If this routine has already been coded, then invoke it as a
  ** subroutine. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Subrtn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator> <literal type="string">"REUSE SUBQUERY %d"</literal><operator>,</operator> <name><name>pSel</name><operator>-&gt;</operator><name>selId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYSub</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name></expr></argument>,
                      <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Begin coding the subroutine */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprUseYWin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Subrtn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name> <operator>=</operator>
    <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_BeginSubrtn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* The evaluation of the EXISTS/SELECT must be repeated every time it
  ** is encountered if any of the following is true:
  **
  **    *  The right-hand side is a correlated subquery
  **    *  The right-hand side is an expression list containing variables
  **    *  We are inside a trigger
  **
  ** If all of the above are false, then we can run this code just once
  ** save the results, and reuse the same result on subsequent invocations.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addrOnce</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* For a SELECT, generate code to put the values for all columns of
  ** the first row into an array of registers and return the index of
  ** the first register.
  **
  ** If this is an EXISTS, write an integer 0 (not exists) or 1 (exists)
  ** into a register and return that register number.
  **
  ** In both cases, the query is augmented with "LIMIT 1".  Any 
  ** preexisting limit is discarded in place of the new LIMIT 1.
  */</comment>
  <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">1</literal><operator>,</operator> <literal type="string">"%sSCALAR SUBQUERY %d"</literal><operator>,</operator>
        <ternary><condition><expr><name>addrOnce</name></expr>?</condition><then><expr><literal type="string">""</literal></expr></then><else>:<expr><literal type="string">"CORRELATED "</literal></expr></else></ternary><operator>,</operator> <name><name>pSel</name><operator>-&gt;</operator><name>selId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nReg</name> <operator>=</operator> <ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr> ?</condition><then> <expr><name><name>pSel</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nReg</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>eDest</name></name> <operator>=</operator> <name>SRT_Mem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>iSdst</name></name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>nSdst</name></name> <operator>=</operator> <name>nReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name><operator>+</operator><name>nReg</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Init subquery result"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>eDest</name></name> <operator>=</operator> <name>SRT_Exists</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Init EXISTS result"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The subquery already has a limit.  If the pre-existing limit is X
    ** then make the new limit X&lt;&gt;0 so that the new limit is either 1 or 0 */</comment>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pLimit</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLimit</name><operator>-&gt;</operator><name>affExpr</name></name> <operator>=</operator> <name>SQLITE_AFF_NUMERIC</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_NE</name></expr></argument>,
                            <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDeferredDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLimit</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If there is no pre-existing limit add a limit of 1 */</comment>
    <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_LIMIT</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_ERROR</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>rReg</name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>addrOnce</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Subroutine return */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYSub</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_BeginSubrtn</name>
          <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>regReturn</name></name></expr></argument>,
                    <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>sub</name><operator>.</operator><name>iAddr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ClearTempRegCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rReg</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** Expr pIn is an IN(...) expression. This function checks that the 
** sub-select on the RHS of the IN() operator has the same number of 
** columns as the vector on the LHS. Or, if the RHS of the IN() is not 
** a sub-query, that the LHS is a vector of size 1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCheckIN</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nVector</name> <init>= <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nVector</name><operator>!=</operator><name><name>pIn</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SubselectError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>, <argument><expr><name>nVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVector</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VectorErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** Generate code for an IN expression.
**
**      x IN (SELECT ...)
**      x IN (value, value, ...)
**
** The left-hand side (LHS) is a scalar or vector expression.  The 
** right-hand side (RHS) is an array of zero or more scalar values, or a
** subquery.  If the RHS is a subquery, the number of result columns must
** match the number of columns in the vector on the LHS.  If the RHS is
** a list of values, the LHS must be a scalar. 
**
** The IN operator is true if the LHS value is contained within the RHS.
** The result is false if the LHS is definitely not in the RHS.  The 
** result is NULL if the presence of the LHS in the RHS cannot be 
** determined due to NULLs.
**
** This routine generates code that jumps to destIfFalse if the LHS is not 
** contained within the RHS.  If due to NULLs we cannot determine if the LHS
** is contained in the RHS then jump to destIfNull.  If the LHS is contained
** within the RHS then fall through.
**
** See the separate in-operator.md documentation file in the canonical
** SQLite source tree for additional information.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3ExprCodeIN</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,          <comment type="block">/* The IN expression */</comment>
  <parameter><decl><type><name>int</name></type> <name>destIfFalse</name></decl></parameter>,      <comment type="block">/* Jump here if LHS is not contained in the RHS */</comment>
  <parameter><decl><type><name>int</name></type> <name>destIfNull</name></decl></parameter>        <comment type="block">/* Jump here if the results are unknown due to NULLs */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rRhsHasNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Register that is true if RHS contains NULL values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>            <comment type="block">/* Type of the RHS */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rLhs</name></decl>;</decl_stmt>             <comment type="block">/* Register(s) holding the LHS values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rLhsOrig</name></decl>;</decl_stmt>         <comment type="block">/* LHS values prior to reordering by aiMap[] */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Statement under construction */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiMap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Map from vector field to index column */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Affinity string for comparisons */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVector</name></decl>;</decl_stmt>          <comment type="block">/* Size of vectors for this IN operator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDummy</name></decl>;</decl_stmt>           <comment type="block">/* Dummy parameter to exprCodeVector() */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>          <comment type="block">/* The LHS of the IN operator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                <comment type="block">/* loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>destStep2</name></decl>;</decl_stmt>        <comment type="block">/* Where to jump when NULLs seen in step 2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>destStep6</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Start of code for Step 6 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTruthOp</name></decl>;</decl_stmt>      <comment type="block">/* Address of opcode that determines the IN is true */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>destNotNull</name></decl>;</decl_stmt>      <comment type="block">/* Jump here if a comparison is not true in step 6 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>          <comment type="block">/* Top of the step-6 loop */</comment> 
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Index to use */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>okConstFactor</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCheckIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zAff</name> <operator>=</operator> <call><name>exprINAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nVector</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aiMap</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(
      <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nVector</name><operator>*</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>sqlite3ExprCodeIN_oom_error</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Attempt to compute the RHS. After this step, if anything other than
  ** IN_INDEX_NOOP is returned, the table opened with cursor iTab
  ** contains the values that make up the RHS. If IN_INDEX_NOOP is returned,
  ** the RHS has not yet been coded.  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* OOM detected prior to this routine */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"begin IN expr"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>,
                             <argument><expr><name>IN_INDEX_MEMBERSHIP</name> <operator>|</operator> <name>IN_INDEX_NOOP_OK</name></expr></argument>,
                             <argument><expr><ternary><condition><expr><name>destIfFalse</name><operator>==</operator><name>destIfNull</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>&amp;</operator><name>rRhsHasNull</name></expr></else></ternary></expr></argument>,
                             <argument><expr><name>aiMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name>nVector</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eType</name><operator>==</operator><name>IN_INDEX_EPH</name>
       <operator>||</operator> <name>eType</name><operator>==</operator><name>IN_INDEX_INDEX_ASC</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>IN_INDEX_INDEX_DESC</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Confirm that aiMap[] contains nVector integer values between 0 and
  ** nVector-1. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVector</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>cnt</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>cnt</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nVector</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>aiMap</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cnt</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Code the LHS, the &lt;expr&gt; from "&lt;expr&gt; IN (...)". If the LHS is a 
  ** vector, then it is stored in an array of nVector registers starting 
  ** at r1.
  **
  ** sqlite3FindInIndex() might have reordered the fields of the LHS vector
  ** so that the fields are in the same order as an existing index.   The
  ** aiMap[] array contains a mapping from the original LHS field order to
  ** the field order that matches the RHS index.
  **
  ** Avoid factoring the LHS of the IN(...) expression out of the loop,
  ** even if it is constant, as OP_Affinity may be used on the register
  ** by code generated below.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name><operator>==</operator><name>okConstFactor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rLhsOrig</name> <operator>=</operator> <call><name>exprCodeVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <name>okConstFactor</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVector</name> <operator>&amp;&amp;</operator> <name><name>aiMap</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for> <comment type="block">/* Are LHS fields reordered? */</comment>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nVector</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* LHS fields are not reordered */</comment>
    <expr_stmt><expr><name>rLhs</name> <operator>=</operator> <name>rLhsOrig</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Need to reorder the LHS fields according to aiMap */</comment>
    <expr_stmt><expr><name>rLhs</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVector</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>rLhsOrig</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>rLhs</name><operator>+</operator><name><name>aiMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If sqlite3FindInIndex() did not find or create an index that is
  ** suitable for evaluating the IN operator, then evaluate using a
  ** sequence of comparisons.
  **
  ** This is step (1) in the in-operator.md optimized algorithm.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_NOOP</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>labelOk</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r2</name></decl>, <decl><type ref="prev"/><name>regToFree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regCkNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>destIfNull</name><operator>!=</operator><name>destIfFalse</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>regCkNull</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_BitAnd</name></expr></argument>, <argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>regCkNull</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_BitAnd</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>destIfNull</name><operator>!=</operator><name>destIfFalse</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><ternary><condition><expr><name>rLhs</name><operator>!=</operator><name>r2</name></expr> ?</condition><then> <expr><name>OP_Eq</name></expr> </then><else>: <expr><name>OP_NotNull</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>labelOk</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>,
                          <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ii</name><operator>==</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>OP_NotNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ii</name><operator>==</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>OP_NotNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><ternary><condition><expr><name>rLhs</name><operator>!=</operator><name>r2</name></expr> ?</condition><then> <expr><name>OP_Ne</name></expr> </then><else>: <expr><name>OP_IsNull</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>destIfNull</name><operator>==</operator><name>destIfFalse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>,
                          <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>regCkNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>sqlite3ExprCodeIN_finished</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Step 2: Check to see if the LHS contains any NULL columns.  If the
  ** LHS does contain NULLs then the result must be either FALSE or NULL.
  ** We will then skip the binary search of the RHS.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>destIfNull</name><operator>==</operator><name>destIfFalse</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>destStep2</name> <operator>=</operator> <name>destIfFalse</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>destStep2</name> <operator>=</operator> <name>destStep6</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVector</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>sqlite3ExprCodeIN_oom_error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>rLhs</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>destStep2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Step 3.  The LHS is now known to be non-NULL.  Do the binary search
  ** of the RHS using the LHS as a probe.  If found, the result is
  ** true.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_ROWID</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* In this case, the RHS is the ROWID of table b-tree and so we also
    ** know that the RHS is non-NULL.  Hence, we combine steps 3 and 4
    ** into a single opcode. */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekRowid</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>rLhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrTruthOp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Return True */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>nVector</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zAff</name></expr></argument>, <argument><expr><name>nVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>destIfFalse</name><operator>==</operator><name>destIfNull</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Combine Step 3 and Step 5 into a single opcode */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>,
                           <argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>nVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>sqlite3ExprCodeIN_finished</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Ordinary Step 3, for the case where FALSE and NULL are distinct */</comment>
    <expr_stmt><expr><name>addrTruthOp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                      <argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>nVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Step 4.  If the RHS is known to be non-NULL and we did not find
  ** an match on the search above, then the result must be FALSE.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rRhsHasNull</name> <operator>&amp;&amp;</operator> <name>nVector</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>rRhsHasNull</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Step 5.  If we do not care about the difference between NULL and
  ** FALSE, then just return false. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>destIfFalse</name><operator>==</operator><name>destIfNull</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Step 6: Loop through rows of the RHS.  Compare each row to the LHS.
  ** If any comparison is NULL, then the result is NULL.  If all
  ** comparisons are FALSE then the final result is FALSE.
  **
  ** For a scalar LHS, it is sufficient to check just the first row
  ** of the RHS.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>destStep6</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destStep6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVector</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>destNotNull</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* For nVector==1, combine steps 6 and 7 by immediately returning
    ** FALSE if the first comparison is not NULL */</comment>
    <expr_stmt><expr><name>destNotNull</name> <operator>=</operator> <name>destIfFalse</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVector</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r3</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ne</name></expr></argument>, <argument><expr><name>rLhs</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>destNotNull</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>,
                      <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVector</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destNotNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addrTop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Step 7:  If we reach this point, we know that the result must
    ** be false. */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Jumps here in order to return true. */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTruthOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>sqlite3ExprCodeIN_finished</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rLhs</name><operator>!=</operator><name>rLhsOrig</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rLhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"end IN expr"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>sqlite3ExprCodeIN_oom_error</name>:</label>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>aiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** Generate an instruction that will put the floating point
** value described by z[0..n-1] into register iMem.
**
** The z[] string will probably not be zero-terminated.  But the 
** z[n] character is guaranteed to be something that does not look
** like the continuation of the number.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeReal</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>negateFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* The new AtoF never returns NaN */</comment>
    <if_stmt><if>if<condition>( <expr><name>negateFlag</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Real</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>P4_REAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Generate an instruction that will put the integer describe by
** text z[0..n-1] into register iMem.
**
** Expr.u.zToken is always UTF8 and zero-terminated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeInteger</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>negFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_IntValue</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>negFlag</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3DecOrHexToI64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>negFlag</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="number">2</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>negFlag</name> <operator>&amp;&amp;</operator> <name>value</name><operator>==</operator><name>SMALLEST_INT64</name><operator>)</operator></expr>)</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"oversized integer: %s%#T"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>negFlag</name></expr>?</condition><then><expr><literal type="string">"-"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_HEX_INTEGER</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"0x"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"hex literal too big: %s%#T"</literal></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>negFlag</name></expr>?</condition><then><expr><literal type="string">"-"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
        <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>negFlag</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>negFlag</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>value</name> <operator>=</operator> <ternary><condition><expr><name>c</name><operator>==</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name>SMALLEST_INT64</name></expr> </then><else>: <expr><operator>-</operator><name>value</name></expr></else></ternary></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Int64</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Generate code that will load into register regOut a value that is
** appropriate for the iIdxCol-th column of index pIdx.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeLoadIndexColumn</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,  <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,    <comment type="block">/* The index whose column is to be loaded */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>,    <comment type="block">/* Cursor pointing to a table row */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCol</name></decl></parameter>,    <comment type="block">/* The column of the index to be loaded */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOut</name></decl></parameter>      <comment type="block">/* Store the index column value in this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i16</name></type> <name>iTabCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iIdxCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iTabCol</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name>iIdxCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <name>iTabCur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iIdxCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>,
                                    <argument><expr><name>iTabCol</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
<comment type="block">/*
** Generate code that will compute the value of generated column pCol
** and store the result in register regOut
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeGeneratedColumn</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,       <comment type="block">/* Table containing the generated column */</comment>
  <parameter><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>,      <comment type="block">/* The generated column */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOut</name></decl></parameter>         <comment type="block">/* Put the result in this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iAddr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNullRow</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iAddr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>&gt;=</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iAddr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_GENERATED_COLUMNS */</comment>

<comment type="block">/*
** Generate code to extract the value of the iCol-th column of a table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeGetColumnOfTable</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,    <comment type="block">/* The table containing the value */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>,    <comment type="block">/* The table cursor.  Or the PK cursor for WITHOUT ROWID */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,       <comment type="block">/* Index of the column to extract */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOut</name></decl></parameter>      <comment type="block">/* Extract the value into this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s.rowid"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_VColumn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><call><name>sqlite3VdbeParser</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"generated column loop on \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>savedSelfTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_BUSY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <name>iTabCur</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGeneratedColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <name>savedSelfTab</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>COLFLAG_BUSY</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>!=</operator><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Column</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>!=</operator><name>iCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Column</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ColumnDefault</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will extract the iColumn-th column from
** table pTab and store the column value in register iReg. 
**
** There must be an open cursor to pTab in iTable when this routine
** is called.  If iColumn&lt;0 then code is generated that extracts the rowid.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeGetColumn</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,     <comment type="block">/* Description of the table we are reading from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,     <comment type="block">/* Index of the table column */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>,      <comment type="block">/* The cursor pointing to the table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>,        <comment type="block">/* Store results here */</comment>
  <parameter><decl><type><name>u8</name></type> <name>p5</name></decl></parameter>            <comment type="block">/* P5 value for OP_Column + FLAGS */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p5</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetLastOp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Column</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <name>p5</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>iReg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to move content from registers iFrom...iFrom+nReg-1
** over to iTo..iTo+nReg-1.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeMove</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_Move</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert a scalar expression node to a TK_REGISTER referencing
** register iReg.  The caller must ensure that iReg already contains
** the correct value for the expression.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprToRegister</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_REGISTER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Evaluate an expression (either a vector or a scalar expression) and store
** the result in continguous temporary registers.  Return the index of
** the first register used to store the result.
**
** If the returned result register is a temporary scalar, then also write
** that register number into *piFreeable.  If the returned result register
** is not a temporary or if the expression is a vector set *piFreeable
** to 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprCodeVector</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piFreeable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iResult</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nResult</name> <init>= <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nResult</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iResult</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>piFreeable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piFreeable</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OMIT_SUBQUERY</name></expr></cpp:if>
      <expr_stmt><expr><name>iResult</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>iResult</name> <operator>=</operator> <call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iResult</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nResult</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nResult</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCodeFactorable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>iResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>iResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the last opcode is a OP_Copy, then set the do-not-merge flag (p5)
** so that a subsequent copy will not be merged into this one.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setDoNotMergeFlagOnCopy</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeGetLastOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_Copy</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Tag trailing OP_Copy as not mergable */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to implement special SQL functions that are implemented
** in-line rather than by using the usual callbacks.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprCodeInlineFunction</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pFarg</name></decl></parameter>,      <comment type="block">/* List of function arguments */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFuncId</name></decl></parameter>,          <comment type="block">/* Function ID.  One of the INTFUNC_... values */</comment>
  <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>            <comment type="block">/* Store function result in this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nFarg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFarg</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFarg</name> <operator>=</operator> <name><name>pFarg</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* All in-line functions have at least one argument */</comment>
  <switch>switch<condition>( <expr><name>iFuncId</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>INLINEFUNC_coalesce</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Attempt a direct implementation of the built-in COALESCE() and
      ** IFNULL() functions.  This avoids unnecessary evaluation of
      ** arguments past the first non-NULL argument.
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>endCoalesce</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nFarg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>endCoalesce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>setDoNotMergeFlagOnCopy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endCoalesce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>INLINEFUNC_iif</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name></type> <name>caseExpr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>caseExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>caseExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>caseExpr</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_CASE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>caseExpr</name><operator>.</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>pFarg</name></expr>;</expr_stmt>
      <return>return <expr><call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>caseExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:ifdef>
    <case>case <expr><name>INLINEFUNC_sqlite_offset</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pArg</name><operator>-&gt;</operator><name>iTable</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Offset</name></expr></argument>, <argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <default>default:</default> <block>{<block_content>   
      <comment type="block">/* The UNLIKELY() function is a no-op.  The result is the value
      ** of the first argument.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>nFarg</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

  <comment type="block" format="doxygen">/***********************************************************************
  ** Test-only SQL functions that are only usable if enabled
  ** via SQLITE_TESTCTRL_INTERNAL_FUNCTIONS
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_UNTESTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <case>case <expr><name>INLINEFUNC_expr_compare</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Compare two expressions using sqlite3ExprCompare() */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, 
         <argument><expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>INLINEFUNC_expr_implies_expr</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Compare two expressions using sqlite3ExprImpliesExpr() */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, 
         <argument><expr><call><name>sqlite3ExprImpliesExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>INLINEFUNC_implies_nonnull_row</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* REsult of sqlite3ExprImpliesNonNullRow() */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pA1</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA1</name> <operator>=</operator> <name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pA1</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, 
           <argument><expr><call><name>sqlite3ExprImpliesNonNullRow</name><argument_list>(<argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,<argument><expr><name><name>pA1</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>INLINEFUNC_affinity</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* The AFFINITY() function evaluates to a string that describes
      ** the type affinity of the argument.  This is used for testing of
      ** the SQLite type logic.
      */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azAff</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"blob"</literal></expr>, <expr><literal type="string">"text"</literal></expr>, <expr><literal type="string">"numeric"</literal></expr>, <expr><literal type="string">"integer"</literal></expr>, <expr><literal type="string">"real"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, 
              <argument><expr><ternary><condition><expr><operator>(</operator><name>aff</name><operator>&lt;=</operator><name>SQLITE_AFF_NONE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"none"</literal></expr> </then><else>: <expr><name><name>azAff</name><index>[<expr><name>aff</name><operator>-</operator><name>SQLITE_AFF_BLOB</name></expr>]</index></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_UNTESTABLE) */</comment>
  </block_content>}</block></switch>
  <return>return <expr><name>target</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if pExpr is one of the indexed expressions on pParse-&gt;pIdxEpr.
** If it is, then resolve the expression by reading from the index and
** return the register into which the value has been read.  If pExpr is
** not an indexed expression, then return negative.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>sqlite3IndexedExprLookup</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,     <comment type="block">/* The expression to potentially bypass */</comment>
  <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>       <comment type="block">/* Where to store the result of the expression */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IndexedExpr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pIENext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iDataCur</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDataCur</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDataCur</name></name><operator>!=</operator><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bMaybeNullRow</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the index is on a NULL row due to an outer join, then we
      ** cannot extract the value from the index.  The value must be
      ** computed using the original expression. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNullRow</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name>addr</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCol</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s expr-column %d"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>zIdxName</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>iIdxCol</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCol</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s expr-column %d"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>zIdxName</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>iIdxCol</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>target</name></expr>;</return>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Not found */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Generate code into the current Vdbe to evaluate the given
** expression.  Attempt to store the results in register "target".
** Return the register where results are stored.
**
** With this routine, there is no guarantee that results will
** be stored in target.  The result might be stored in some other
** register if it is convenient to do so.  The calling function
** must check the return code and move the results to the desired
** register.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeTarget</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The VM under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                   <comment type="block">/* The opcode being coded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>inReg</name> <init>= <expr><name>target</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Results stored in register inReg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* If non-zero free this temporary register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* If non-zero free this temporary register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>               <comment type="block">/* Various register numbers */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name>tempX</name></decl>;</decl_stmt>               <comment type="block">/* Temporary expression node */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p5</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>target</name><operator>&lt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>expr_code_doover</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name><operator>!=</operator><literal type="number">0</literal> 
   <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Leaf</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>r1</name> <operator>=</operator> <call><name>sqlite3IndexedExprLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>r1</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pAggInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>AggInfoColumnReg</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>useSortingIdx</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdxPTab</name></name></expr></argument>,
                              <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* No comment added */</comment>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator><literal type="string">"%s.rowid"</literal><operator>,</operator><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator><literal type="string">"%s.%s"</literal><operator>,</operator> 
              <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>zCnName</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>target</name></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* This case happens when the argument to an aggregate function
        ** is rewritten by aggregateConvertIndexedExprRefToColumn() */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>target</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Otherwise, fall thru into the TK_COLUMN case */</comment>
      <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
    </block_content>}</block>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* This COLUMN expression is really a constant due to WHERE clause
        ** constraints, and that constant is coded by the pExpr-&gt;pLeft
        ** expresssion.  However, make sure the constant has the correct
        ** datatype by applying the Affinity of the table column to the
        ** constant.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>aff</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3TableColumnAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aff</name><operator>&gt;</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zAff</name><index>[]</index></name> <init>= <expr><literal type="string">"B\000C\000D\000E"</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_AFF_BLOB</name><operator>==</operator><literal type="char">'A'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_AFF_TEXT</name><operator>==</operator><literal type="char">'B'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>zAff</name><index>[<expr><operator>(</operator><name>aff</name><operator>-</operator><literal type="char">'B'</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>iReg</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iTab</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Other columns in the same row for CHECK constraints or
          ** generated columns or for inserting into partial index.
          ** The row is unpacked into registers beginning at
          ** 0-(pParse-&gt;iSelfTab).  The rowid (if any) is in a register
          ** immediately prior to the first column.
          */</comment>
          <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iSrc</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><name>XN_ROWID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>pCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name> <operator>+</operator> <name>iCol</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>!=</operator><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iSrc</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_BUSY</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"generated column loop on \"%s\""</literal></expr></argument>,
                              <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_BUSY</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_NOTAVAIL</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3ExprCodeGeneratedColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>COLFLAG_BUSY</name><operator>|</operator><name>COLFLAG_NOTAVAIL</name><operator>)</operator></expr>;</expr_stmt>
            <return>return <expr><name>iSrc</name></expr>;</return>
          </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_GENERATED_COLUMNS */</comment>
          if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>target</name></expr>;</return>
          </block_content>}</block></if><else>else<block>{<block_content>
            <return>return <expr><name>iSrc</name></expr>;</return>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Coding an expression that is part of an index where column names
          ** in the index refer to the table to which the index belongs */</comment>
          <expr_stmt><expr><name>iTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeGetColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>,
                               <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                               <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>iReg</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codeInteger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_TRUEFALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><call><name>sqlite3ExprTruthValue</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
    <case>case <expr><name>TK_FLOAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* Make NULL the default case so that if a bug causes an illegal
      ** Expr node to be passed into this function, it will be handled
      ** sanely and not crash.  But keep the assert() to bring the problem
      ** to the attention of the developers. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NULL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_ERROR</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BLOB_LITERAL</name></cpp:ifndef>
    <case>case <expr><name>TK_BLOB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'X'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>sqlite3HexToBlob</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>TK_VARIABLE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Variable</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3VListNumToName</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVList</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal> <operator>||</operator> <operator>(</operator><name>z</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Indicate VList may no longer be enlarged */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_REGISTER</name></expr>:</case> <block>{<block_content>
      <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</return>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
    <case>case <expr><name>TK_CAST</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Expressions of the form:   CAST(pLeft AS token) */</comment>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>inReg</name><operator>!=</operator><name>target</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Cast</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                        <argument><expr><call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>inReg</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CAST */</comment>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_IS</name><operator>)</operator></expr> ?</condition><then> <expr><name>TK_EQ</name></expr> </then><else>: <expr><name>TK_NE</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>p5</name> <operator>=</operator> <name>SQLITE_NULLEQ</name></expr>;</expr_stmt>
      <comment type="block">/* fall-through */</comment>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>codeVectorCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>,
            <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>p5</name></expr></argument>,
            <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Commuted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LT</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LE</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GT</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GE</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_EQ</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_NE</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>p5</name><operator>==</operator><name>SQLITE_NULLEQ</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ZeroOrNull</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_AND</name></expr>:</case>
    <case>case <expr><name>TK_OR</name></expr>:</case>
    <case>case <expr><name>TK_PLUS</name></expr>:</case>
    <case>case <expr><name>TK_STAR</name></expr>:</case>
    <case>case <expr><name>TK_MINUS</name></expr>:</case>
    <case>case <expr><name>TK_REM</name></expr>:</case>
    <case>case <expr><name>TK_BITAND</name></expr>:</case>
    <case>case <expr><name>TK_BITOR</name></expr>:</case>
    <case>case <expr><name>TK_SLASH</name></expr>:</case>
    <case>case <expr><name>TK_LSHIFT</name></expr>:</case>
    <case>case <expr><name>TK_RSHIFT</name></expr>:</case> 
    <case>case <expr><name>TK_CONCAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_AND</name><operator>==</operator><name>OP_And</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_AND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_OR</name><operator>==</operator><name>OP_Or</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>              <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_PLUS</name><operator>==</operator><name>OP_Add</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_PLUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_MINUS</name><operator>==</operator><name>OP_Subtract</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_MINUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_REM</name><operator>==</operator><name>OP_Remainder</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_REM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITAND</name><operator>==</operator><name>OP_BitAnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_BITAND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITOR</name><operator>==</operator><name>OP_BitOr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_BITOR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_SLASH</name><operator>==</operator><name>OP_Divide</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>       <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_SLASH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LSHIFT</name><operator>==</operator><name>OP_ShiftLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_LSHIFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_RSHIFT</name><operator>==</operator><name>OP_ShiftRight</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_RSHIFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_CONCAT</name><operator>==</operator><name>OP_Concat</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_CONCAT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_UMINUS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_INTEGER</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>codeInteger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>target</name></expr>;</return>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FLOAT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>target</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>tempX</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_INTEGER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tempX</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>EP_IntValue</name><operator>|</operator><name>EP_TokenOnly</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tempX</name><operator>.</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprClearVVAProperties</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Subtract</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_BITNOT</name></expr>:</case>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITNOT</name><operator>==</operator><name>OP_BitNot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_BITNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOT</name><operator>==</operator><name>OP_Not</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>         <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_TRUTH</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isTrue</name></decl>;</decl_stmt>    <comment type="block">/* IS TRUE or IS NOT TRUE */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>bNormal</name></decl>;</decl_stmt>   <comment type="block">/* IS TRUE or IS FALSE */</comment>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>isTrue</name> <operator>=</operator> <call><name>sqlite3ExprTruthValue</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bNormal</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>==</operator><name>TK_IS</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isTrue</name> <operator>&amp;&amp;</operator> <name>bNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>!</operator><name>isTrue</name> <operator>&amp;&amp;</operator> <name>bNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsTrue</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><operator>!</operator><name>isTrue</name></expr></argument>, <argument><expr><name>isTrue</name> <operator>^</operator> <name>bNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_ISNULL</name><operator>==</operator><name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOTNULL</name><operator>==</operator><name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_AGG_FUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pInfo</name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
       <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&gt;=</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"misuse of aggregate: %#T()"</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><call><name>AggInfoFuncReg</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pFarg</name></decl>;</decl_stmt>       <comment type="block">/* List of function arguments */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nFarg</name></decl>;</decl_stmt>             <comment type="block">/* Number of function arguments */</comment>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>         <comment type="block">/* The function definition object */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl>;</decl_stmt>       <comment type="block">/* The function name */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>constMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Mask of function arguments that are constant */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The database connection */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>      <comment type="block">/* The text encoding used by this database */</comment>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* A collating sequence */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if_stmt><if>if<condition>( <expr><call><name>ConstFactorOk</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* SQL functions can be expensive. So try to avoid running them
        ** multiple times if we know they always give the same result */</comment>
        <return>return <expr><call><name>sqlite3ExprCodeRunJustOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFarg</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nFarg</name> <operator>=</operator> <ternary><condition><expr><name>pFarg</name></expr> ?</condition><then> <expr><name><name>pFarg</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zId</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>pDef</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"unknown"</literal></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>pDef</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xFinalize</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unknown function: %#T()"</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_INLINE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_UNSAFE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_DIRECT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>exprCodeInlineFunction</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFarg</name></expr></argument>,
             <argument><expr><call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_DIRECT</name><operator>|</operator><name>SQLITE_FUNC_UNSAFE</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprFunctionUsable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nFarg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">32</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>constMask</name> <operator>|=</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>pColl</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pFarg</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>constMask</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>r1</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nFarg</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* For length() and typeof() functions with a column argument,
        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG
        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data
        ** loading.
        */</comment>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_LENGTH</name><operator>|</operator><name>SQLITE_FUNC_TYPEOF</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name></type> <name>exprOp</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>exprOp</name> <operator>=</operator> <name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>exprOp</name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name>exprOp</name><operator>==</operator><name>TK_AGG_COLUMN</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_LENGTH</name><operator>==</operator><name>OPFLAG_LENGTHARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_TYPEOF</name><operator>==</operator><name>OPFLAG_TYPEOFARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>OPFLAG_LENGTHARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> 
                  <name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_LENGTHARG</name><operator>|</operator><name>OPFLAG_TYPEOFARG</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFarg</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>SQLITE_ECEL_DUP</name><operator>|</operator><name>SQLITE_ECEL_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <comment type="block">/* Possibly overload the function if the first argument is
      ** a virtual table column.
      **
      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the
      ** second argument, not the first, as the argument to test to
      ** see if it is a column in a virtual table.  This is done because
      ** the left operand of infix functions (the operand we want to
      ** control overloading) ends up as the second argument to the
      ** function.  The expression "A glob B" is equivalent to 
      ** "glob(B,A).  We want to use the A in "A glob B" to test
      ** for function overloading.  But we use the B term in "glob(B,A)".
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>nFarg</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_InfixFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3VtabOverloadFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nFarg</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3VtabOverloadFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CollSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddFunctionCall</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>constMask</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>,
                                 <argument><expr><name>pDef</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nFarg</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>constMask</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeReleaseRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name>constMask</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_EXISTS</name></expr>:</case>
    <case>case <expr><name>TK_SELECT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_SELECT</name>
             <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>nCol</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>)</operator><operator>!=</operator><literal type="number">1</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3SubselectError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_SELECT_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name> <operator>&gt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>op2</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name> <operator>||</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>n</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%d columns assigned %d values"</literal></expr></argument>,
                                <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name><name>pLeft</name><operator>-&gt;</operator><name>iTable</name></name> <operator>+</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfFalse</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfNull</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>


    <comment type="block">/*
    **    x BETWEEN y AND z
    **
    ** This is equivalent to
    **
    **    x&gt;=y AND x&lt;=z
    **
    ** X is stored in pExpr-&gt;pLeft.
    ** Y is stored in pExpr-&gt;pList-&gt;a[0].pExpr.
    ** Z is stored in pExpr-&gt;pList-&gt;a[1].pExpr.
    */</comment>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>exprCodeBetween</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_COLLATE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Collate</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>inReg</name><operator>!=</operator><name>target</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ClrSubtype</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>inReg</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
        <goto>goto <name>expr_code_doover</name>;</goto> <comment type="block">/* 2018-04-28: Prevent deep recursion. */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <case>case <expr><name>TK_SPAN</name></expr>:</case>
    <case>case <expr><name>TK_UPLUS</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      <goto>goto <name>expr_code_doover</name>;</goto> <comment type="block">/* 2018-04-28: Prevent deep recursion. OSSFuzz. */</comment>
    </block_content>}</block>

    <case>case <expr><name>TK_TRIGGER</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* If the opcode is TK_TRIGGER, then the expression is a reference
      ** to a column in the new.* or old.* pseudo-tables available to
      ** trigger programs. In this case Expr.iTable is set to 1 for the
      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn
      ** is set to the column of the pseudo-table to read, or to -1 to
      ** read the rowid field.
      **
      ** The expression is implemented using an OP_Param opcode. The p1
      ** parameter is set to 0 for an old.rowid reference, or to (i+1)
      ** to reference another column of the old.* pseudo-table, where 
      ** i is the index of the column. For a new.rowid reference, p1 is
      ** set to (n+1), where n is the number of columns in each pseudo-table.
      ** For a reference to any other column in the new.* pseudo-table, p1
      ** is set to (n+2+i), where n and i are as defined previously. For
      ** example, if the table on which triggers are being fired is
      ** declared as:
      **
      **   CREATE TABLE t1(a, b);
      **
      ** Then p1 is interpreted as follows:
      **
      **   p1==0   -&gt;    old.rowid     p1==3   -&gt;    new.rowid
      **   p1==1   -&gt;    old.a         p1==4   -&gt;    new.a
      **   p1==2   -&gt;    old.b         p1==5   -&gt;    new.b       
      */</comment>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>p1</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>*</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> 
                     <operator>+</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>&lt;</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Param</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"r[%d]=%s.%s"</literal><operator>,</operator> <name>target</name><operator>,</operator>
        <operator>(</operator><ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr> ?</condition><then> <expr><literal type="string">"new"</literal></expr> </then><else>: <expr><literal type="string">"old"</literal></expr></else></ternary><operator>)</operator><operator>,</operator>
        <operator>(</operator><ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"rowid"</literal></expr> </then><else>: <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></else></ternary><operator>)</operator>
      <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
      <comment type="block">/* If the column has REAL affinity, it may currently be stored as an
      ** integer. Use OP_RealAffinity to make sure it is really real.
      **
      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to
      ** floating point when extracting it from the record.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TK_VECTOR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"row value misused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions
    ** that derive from the right-hand table of a LEFT JOIN.  The
    ** Expr.iTable value is the table number for the right-hand table.
    ** The expression is only evaluated if that table is not currently
    ** on a LEFT JOIN NULL row.
    */</comment>
    <case>case <expr><name>TK_IF_NULL_ROW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addrINR</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name>okConstFactor</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pAggInfo</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>AggInfoColumnReg</name><argument_list>(<argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name><operator>-&gt;</operator><name>useSortingIdx</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdxPTab</name></name></expr></argument>,
                            <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr>]</index></name><operator>.</operator><name>iSorterColumn</name></expr></argument>,
                            <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>addrINR</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNullRow</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Temporarily disable factoring of constant expressions, since
      ** even though expressions may appear to be constant, they are not
      ** really constant because they originate from the right-hand side
      ** of a LEFT JOIN. */</comment>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <name>okConstFactor</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrINR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrINR</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    ** Form A:
    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form B:
    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form A is can be transformed into the equivalent form B as follows:
    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...
    **        WHEN x=eN THEN rN ELSE y END
    **
    ** X (if it exists) is in pExpr-&gt;pLeft.
    ** Y is in the last element of pExpr-&gt;x.pList if pExpr-&gt;x.pList-&gt;nExpr is
    ** odd.  The Y is also optional.  If the number of elements in x.pList
    ** is even, then Y is omitted and the "otherwise" result is NULL.
    ** Ei is in pExpr-&gt;pList-&gt;a[i*2] and Ri is pExpr-&gt;pList-&gt;a[i*2+1].
    **
    ** The result of the expression is the Ri for the first matching Ei,
    ** or if there is no matching Ei, the ELSE term Y, or if there is
    ** no ELSE term, NULL.
    */</comment>
    <case>case <expr><name>TK_CASE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>endLabel</name></decl>;</decl_stmt>                     <comment type="block">/* GOTO label for end of CASE stmt */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nextCase</name></decl>;</decl_stmt>                     <comment type="block">/* GOTO label for next WHEN clause */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name></decl>;</decl_stmt>                        <comment type="block">/* 2x number of WHEN terms */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>                 <comment type="block">/* List of WHEN terms */</comment>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>aListelem</name></decl>;</decl_stmt>  <comment type="block">/* Array of WHEN terms */</comment>
      <decl_stmt><decl><type><name>Expr</name></type> <name>opCompare</name></decl>;</decl_stmt>                   <comment type="block">/* The X==Ei expression */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>                         <comment type="block">/* The X expression */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* X==Ei (form A) or just Ei (form B) */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aListelem</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExpr</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>endLabel</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pX</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDel</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exprToRegister</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>, <argument><expr><call><name>exprCodeVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opCompare</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opCompare</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opCompare</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_EQ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opCompare</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <name>pDel</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTest</name> <operator>=</operator> <operator>&amp;</operator><name>opCompare</name></expr>;</expr_stmt>
        <comment type="block">/* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:
        ** The value in regFree1 might get SCopy-ed into the file result.
        ** So make sure that the regFree1 register is not reused for other
        ** purposes and possibly overwritten.  */</comment>
        <expr_stmt><expr><name>regFree1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nExpr</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pX</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTest</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>opCompare</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <name><name>aListelem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>pTest</name> <operator>=</operator> <name><name>aListelem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>nextCase</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTest</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTest</name></expr></argument>, <argument><expr><name>nextCase</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aListelem</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>aListelem</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nextCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nExpr</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>nExpr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setDoNotMergeFlagOnCopy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
    <case>case <expr><name>TK_RAISE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name><operator>==</operator><name>OE_Rollback</name> 
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name><operator>==</operator><name>OE_Abort</name>
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name><operator>==</operator><name>OE_Fail</name>
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name><operator>==</operator><name>OE_Ignore</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                       <argument><expr><literal type="string">"RAISE() may only be used within a trigger-program"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(
            <argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr><name>OE_Ignore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
             <argument><expr><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr> ?</condition><then> <expr><name>SQLITE_CONSTRAINT_TRIGGER</name></expr> </then><else>: <expr><name>SQLITE_ERROR</name></expr></else></ternary></expr></argument>,
             <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affExpr</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>inReg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will evaluate expression pExpr just one time
** per prepared statement execution.
**
** If the expression uses functions (that might throw an exception) then
** guard them with an OP_Once opcode to ensure that the code is only executed
** once. If no functions are involved, then factor the code out and put it at
** the end of the prepared statement in the initialization section.
**
** If regDest&gt;=0 then the result is always stored in that register and the
** result is not reusable.  If regDest&lt;0 then this routine is free to 
** store the value whereever it wants.  The register where the expression 
** is stored is returned.  When regDest&lt;0, two identical expressions might
** code to the same register, if they do not contain function calls and hence
** are factored out into the initialization section at the end of the
** prepared statement.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeRunJustOnce</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,      <comment type="block">/* The expression to code when the VDBE initializes */</comment>
  <parameter><decl><type><name>int</name></type> <name>regDest</name></decl></parameter>       <comment type="block">/* Store the value in this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ConstFactorOk</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pConstExpr</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>regDest</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pItem</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>reusable</name></name>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <return>return <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iConstExprReg</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_HasFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>regDest</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>regDest</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>regDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
       <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
       <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>reusable</name></name> <operator>=</operator> <name>regDest</name><operator>&lt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
       <if_stmt><if>if<condition>( <expr><name>regDest</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>regDest</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
       <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iConstExprReg</name></name> <operator>=</operator> <name>regDest</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pConstExpr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>regDest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to evaluate an expression and store the results
** into a register.  Return the register number where the results
** are stored.
**
** If the register is a temporary register that can be deallocated,
** then write its number into *pReg.  If the result register is not
** a temporary, then set *pReg to zero.
**
** If pExpr is a constant, then this routine might generate this
** code to fill the register in the initialization section of the
** VDBE program, in order to factor it out of the evaluation loop.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeTemp</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r2</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ConstFactorOk</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_REGISTER</name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pReg</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeRunJustOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>r2</name><operator>==</operator><name>r1</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pReg</name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>r2</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will evaluate expression pExpr and store the
** results in register target.  The results are guaranteed to appear
** in register target.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCode</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>inReg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>target</name><operator>&lt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>inReg</name><operator>!=</operator><name>target</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Subquery</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Copy</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_SCopy</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make a transient copy of expression pExpr and then code it using
** sqlite3ExprCode().  This routine works just like sqlite3ExprCode()
** except that the input expression is guaranteed to be unchanged.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeCopy</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will evaluate expression pExpr and store the
** results in register target.  The results are guaranteed to appear
** in register target.  If the expression is constant, then this routine
** might choose to code the expression at initialization time.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeFactorable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCodeRunJustOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that pushes the value of every element of the given
** expression list into a sequence of registers beginning at target.
**
** Return the number of elements evaluated.  The number returned will
** usually be pList-&gt;nExpr but might be reduced if SQLITE_ECEL_OMITREF
** is defined.
**
** The SQLITE_ECEL_DUP flag prevents the arguments from being
** filled using OP_SCopy.  OP_Copy must be used instead.
**
** The SQLITE_ECEL_FACTOR argument allows constant arguments to be
** factored out into initialization code.
**
** The SQLITE_ECEL_REF flag means that expressions in the list with
** ExprList.a[].u.x.iOrderByCol&gt;0 have already been evaluated and stored
** in registers at srcReg, and so the value can be copied from there.
** If SQLITE_ECEL_OMITREF is also set, then the values with u.x.iOrderByCol&gt;0
** are simply omitted rather than being copied from srcReg.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeExprList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,   <comment type="block">/* The expression list to be coded */</comment>
  <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>,        <comment type="block">/* Where to write results */</comment>
  <parameter><decl><type><name>int</name></type> <name>srcReg</name></decl></parameter>,        <comment type="block">/* Source registers if SQLITE_ECEL_REF */</comment>
  <parameter><decl><type><name>u8</name></type> <name>flags</name></decl></parameter>           <comment type="block">/* SQLITE_ECEL_* flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>copyOp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_DUP</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_Copy</name></expr> </then><else>: <expr><name>OP_SCopy</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Never gets this far otherwise */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ConstFactorOk</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_ECEL_FACTOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>bSorterRef</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_REF</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_OMITREF</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>copyOp</name></expr></argument>, <argument><expr><name>j</name><operator>+</operator><name>srcReg</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_FACTOR</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprCodeRunJustOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>inReg</name> <init>= <expr><call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>inReg</name><operator>!=</operator><name>target</name><operator>+</operator><name>i</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>copyOp</name><operator>==</operator><name>OP_Copy</name>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>pOp</name><operator>=</operator><call><name>sqlite3VdbeGetLastOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_Copy</name>
         <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>inReg</name>
         <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>target</name><operator>+</operator><name>i</name>
         <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr>  <comment type="block">/* The do-not-merge flag must be clear */</comment>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>copyOp</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a BETWEEN operator.
**
**    x BETWEEN y AND z
**
** The above is equivalent to 
**
**    x&gt;=y AND x&lt;=z
**
** Code it as such, taking care to do the common subexpression
** elimination of x.
**
** The xJumpIf parameter determines details:
**
**    NULL:                   Store the boolean result in reg[dest]
**    sqlite3ExprIfTrue:      Jump to dest if true
**    sqlite3ExprIfFalse:     Jump to dest if false
**
** The jumpIfNull parameter is ignored if xJumpIf is NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprCodeBetween</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,      <comment type="block">/* The BETWEEN expression */</comment>
  <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>,         <comment type="block">/* Jump destination or storage location */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xJump</name>)<parameter_list>(<parameter><decl><type><name>Parse</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Expr</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Action to take */</comment>
  <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>    <comment type="block">/* Take the jump if the BETWEEN is NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name></type> <name>exprAnd</name></decl>;</decl_stmt>     <comment type="block">/* The AND operator in  x&gt;=y AND x&lt;=z  */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name>compLeft</name></decl>;</decl_stmt>    <comment type="block">/* The  x&gt;=y  term */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name>compRight</name></decl>;</decl_stmt>   <comment type="block">/* The  x&lt;=z  term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Temporary use register */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compLeft</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compRight</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exprAnd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDel</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>exprAnd</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_AND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exprAnd</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <operator>&amp;</operator><name>compLeft</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exprAnd</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <operator>&amp;</operator><name>compRight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compLeft</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_GE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compLeft</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <name>pDel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compLeft</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compRight</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_LE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compRight</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <name>pDel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compRight</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exprToRegister</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>, <argument><expr><call><name>exprCodeVector</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>xJump</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>xJump</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprAnd</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Mark the expression is being from the ON or USING clause of a join
      ** so that the sqlite3ExprCodeTarget() routine will not attempt to move
      ** it into the Parse.pConstExpr list.  We should use a new bit for this,
      ** for clarity, but we are out of bits in the Expr.flags field so we
      ** have to reuse the EP_OuterON bit.  Bummer. */</comment>
      <expr_stmt><expr><name><name>pDel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_OuterON</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprAnd</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ensure adequate test coverage */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfTrue</name>  <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfTrue</name>  <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfTrue</name>  <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfTrue</name>  <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfFalse</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfFalse</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfFalse</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><name>sqlite3ExprIfFalse</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>xJump</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is true but execution
** continues straight thru if the expression is false.
**
** If the expression evaluates to NULL (neither true nor false), then
** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.
**
** This code depends on the fact that certain token values (ex: TK_EQ)
** are the same as opcode values (ex: OP_Eq) that implement the corresponding
** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in
** the make process cause these values to align.  Assert()s in the code
** below verify that the numbers are aligned correctly.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfTrue</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><name>SQLITE_JUMPIFNULL</name> <operator>||</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>     <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Existence of VDBE checked by caller */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* No way this can happen */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_AND</name></expr>:</case>
    <case>case <expr><name>TK_OR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pAlt</name> <init>= <expr><call><name>sqlite3ExprSimplifiedAndOr</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pAlt</name><operator>!=</operator><name>pExpr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAlt</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>d2</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>d2</name></expr></argument>,
                           <argument><expr><name>jumpIfNull</name><operator>^</operator><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_TRUTH</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isNot</name></decl>;</decl_stmt>      <comment type="block">/* IS NOT TRUE or IS NOT FALSE */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>isTrue</name></decl>;</decl_stmt>     <comment type="block">/* IS TRUE or IS NOT TRUE */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>isNot</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>==</operator><name>TK_ISNOT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>isTrue</name> <operator>=</operator> <call><name>sqlite3ExprTruthValue</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isTrue</name> <operator>&amp;&amp;</operator> <name>isNot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>!</operator><name>isTrue</name> <operator>&amp;&amp;</operator> <name>isNot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>isTrue</name> <operator>^</operator> <name>isNot</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
                          <argument><expr><ternary><condition><expr><name>isNot</name></expr> ?</condition><then> <expr><name>SQLITE_JUMPIFNULL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
                           <argument><expr><ternary><condition><expr><name>isNot</name></expr> ?</condition><then> <expr><name>SQLITE_JUMPIFNULL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_IS</name><operator>)</operator></expr> ?</condition><then> <expr><name>TK_EQ</name></expr> </then><else>: <expr><name>TK_NE</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>jumpIfNull</name> <operator>=</operator> <name>SQLITE_NULLEQ</name></expr>;</expr_stmt>
      <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>default_expr</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>, <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Commuted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LT</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LE</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GT</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GE</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_EQ</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_NE</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_ISNULL</name><operator>==</operator><name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOTNULL</name><operator>==</operator><name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeTypeofColumn</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprCodeBetween</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>sqlite3ExprIfTrue</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfFalse</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfNull</name> <init>= <expr><ternary><condition><expr><name>jumpIfNull</name></expr> ?</condition><then> <expr><name>dest</name></expr> </then><else>: <expr><name>destIfFalse</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <default>default:</default> <block>{<block_content>
    <label><name>default_expr</name>:</label>
      <if_stmt><if>if<condition>( <expr><call><name>ExprAlwaysTrue</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprAlwaysFalse</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* No-op */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is false but execution
** continues straight thru if the expression is true.
**
** If the expression evaluates to NULL (neither true nor false) then
** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull
** is 0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfFalse</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><name>SQLITE_JUMPIFNULL</name> <operator>||</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Existence of VDBE checked by caller */</comment>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>    <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Immutable</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The value of pExpr-&gt;op and op are related as follows:
  **
  **       pExpr-&gt;op            op
  **       ---------          ----------
  **       TK_ISNULL          OP_NotNull
  **       TK_NOTNULL         OP_IsNull
  **       TK_NE              OP_Eq
  **       TK_EQ              OP_Ne
  **       TK_GT              OP_Le
  **       TK_LE              OP_Gt
  **       TK_GE              OP_Lt
  **       TK_LT              OP_Ge
  **
  ** For other values of pExpr-&gt;op, op is undefined and unused.
  ** The value of TK_ and OP_ constants are arranged such that we
  ** can compute the mapping above using the following expression.
  ** Assert()s verify that the computation is correct.
  */</comment>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>+</operator><operator>(</operator><name>TK_ISNULL</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>^</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><operator>(</operator><name>TK_ISNULL</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Verify correct alignment of TK_ and OP_ constants
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ISNULL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_NOTNULL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_NE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_EQ</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_LT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_LE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_GT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_GE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_AND</name></expr>:</case>
    <case>case <expr><name>TK_OR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pAlt</name> <init>= <expr><call><name>sqlite3ExprSimplifiedAndOr</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pAlt</name><operator>!=</operator><name>pExpr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAlt</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>d2</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>d2</name></expr></argument>,
                          <argument><expr><name>jumpIfNull</name><operator>^</operator><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_TRUTH</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isNot</name></decl>;</decl_stmt>   <comment type="block">/* IS NOT TRUE or IS NOT FALSE */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>isTrue</name></decl>;</decl_stmt>  <comment type="block">/* IS TRUE or IS NOT TRUE */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>isNot</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>==</operator><name>TK_ISNOT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>isTrue</name> <operator>=</operator> <call><name>sqlite3ExprTruthValue</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isTrue</name> <operator>&amp;&amp;</operator> <name>isNot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>!</operator><name>isTrue</name> <operator>&amp;&amp;</operator> <name>isNot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>isTrue</name> <operator>^</operator> <name>isNot</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* IS TRUE and IS NOT FALSE */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
                           <argument><expr><ternary><condition><expr><name>isNot</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>SQLITE_JUMPIFNULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* IS FALSE and IS NOT TRUE */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
                          <argument><expr><ternary><condition><expr><name>isNot</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>SQLITE_JUMPIFNULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name><operator>)</operator></expr> ?</condition><then> <expr><name>TK_NE</name></expr> </then><else>: <expr><name>TK_EQ</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>jumpIfNull</name> <operator>=</operator> <name>SQLITE_NULLEQ</name></expr>;</expr_stmt>
      <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>default_expr</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>,<argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_Commuted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LT</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LE</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GT</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GE</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_EQ</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_NE</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeTypeofColumn</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprCodeBetween</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>sqlite3ExprIfFalse</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>jumpIfNull</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>destIfNull</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <default>default:</default> <block>{<block_content>
    <label><name>default_expr</name>:</label> 
      <if_stmt><if>if<condition>( <expr><call><name>ExprAlwaysFalse</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprAlwaysTrue</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* no-op */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Like sqlite3ExprIfFalse() except that a copy is made of pExpr before
** code generation, and that copy is deleted after code generation. This
** ensures that the original pExpr is unchanged.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfFalseDup</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Expression pVar is guaranteed to be an SQL variable. pExpr may be any
** type of expression.
**
** If pExpr is a simple SQL value - an integer, real, string, blob
** or NULL value - then the VDBE currently being prepared is configured
** to re-prepare each time a new value is bound to variable pVar.
**
** Additionally, if pExpr is a simple SQL value and the value is the
** same as that currently bound to variable pVar, non-zero is returned.
** Otherwise, if the values are not the same or if pExpr is not a simple
** SQL value, zero is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprCompareVariable</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pVar</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iVar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pL</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_AFF_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iVar</name> <operator>=</operator> <name><name>pVar</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetVarmask</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>iVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pL</name> <operator>=</operator> <call><name>sqlite3VdbeGetBoundValue</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pReprepare</name></name></expr></argument>, <argument><expr><name>iVar</name></expr></argument>, <argument><expr><name>SQLITE_AFF_BLOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pL</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pL</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Make sure the encoding is UTF-8 */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator>  <literal type="number">0</literal><operator>==</operator><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>pL</name></expr></argument>, <argument><expr><name>pR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do a deep comparison of two expression trees.  Return 0 if the two
** expressions are completely identical.  Return 1 if they differ only
** by a COLLATE operator at the top level.  Return 2 if there are differences
** other than the top-level COLLATE operator.
**
** If any subelement of pB has Expr.iTable==(-1) then it is allowed
** to compare equal to an equivalent element in pA with Expr.iTable==iTab.
**
** The pA side might be using TK_REGISTER.  If that is the case and pB is
** not using TK_REGISTER but is otherwise equivalent, then still return 0.
**
** Sometimes this routine will return 2 even if the two expressions
** really are equivalent.  If we cannot prove that the expressions are
** identical, we return 2 just to be safe.  So if this routine
** returns 2, then you do not really know for certain if the two
** expressions are the same.  But if you get a 0 or 1 return, then you
** can be sure the expressions are the same.  In the places where
** this routine is used, it does not hurt to get an extra 2 - that
** just might result in some slightly slower code.  But returning
** an incorrect 0 or 1 could lead to a malfunction.
**
** If pParse is not NULL then TK_VARIABLE terms in pA with bindings in
** pParse-&gt;pReprepare can be matched against literals in pB.  The 
** pParse-&gt;pVdbe-&gt;expmask bitmask is updated for each variable referenced.
** If pParse is NULL (the normal case) then any TK_VARIABLE term in 
** Argument pParse should normally be NULL. If it is not NULL and pA or
** pB causes a return value of 2.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCompare</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>combinedFlags</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>pB</name><operator>==</operator><name>pA</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pParse</name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VARIABLE</name> <operator>&amp;&amp;</operator> <call><name>exprCompareVariable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>combinedFlags</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>pB</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_IntValue</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pA</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name><name>pB</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>EP_IntValue</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name><operator>==</operator><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>op</name></name> <operator>||</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_RAISE</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,<argument><expr><name>pB</name></expr></argument>,<argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pB</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>,<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,<argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pB</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> 
     <operator>&amp;&amp;</operator> <name><name>pB</name><operator>-&gt;</operator><name>iTable</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iTab</name></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* fall through */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pB</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name> <operator>||</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name><name>pB</name><operator>-&gt;</operator><name>op</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pA</name></expr></argument>,<argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pB</name></expr></argument>,<argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pA</name></expr></argument>,<argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3WindowCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">2</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NULL</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else 
    if<condition>( <expr><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name>
     <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_COLUMN</name>
     <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pA</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>EP_Distinct</name><operator>|</operator><name>EP_Commuted</name><operator>)</operator><operator>)</operator>
     <operator>!=</operator> <operator>(</operator><name><name>pB</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>EP_Distinct</name><operator>|</operator><name>EP_Commuted</name><operator>)</operator><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><operator>(</operator><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_TokenOnly</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_xIsSelect</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_FixedCol</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_STRING</name>
     <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_TRUEFALSE</name>
     <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><operator>(</operator><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_Reduced</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op2</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRUTH</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_IN</name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>iTable</name></name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iTab</name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare two ExprList objects.  Return 0 if they are identical, 1
** if they are certainly different, or 2 if it is not possible to 
** determine if they are identical or not.
**
** If any subelement of pB has Expr.iTable==(-1) then it is allowed
** to compare equal to an equivalent element in pA with Expr.iTable==iTab.
**
** This routine might return non-zero for equivalent ExprLists.  The
** only consequence will be disabled optimizations.  But this routine
** must never return 0 if the two ExprList objects are different, or
** a malfunction will result.
**
** Two NULL pointers are considered to be the same.  But a NULL pointer
** always differs from a non-NULL pointer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprListCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pA</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExprA</name> <init>= <expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExprB</name> <init>= <expr><name><name>pB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExprA</name></expr></argument>, <argument><expr><name>pExprB</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Like sqlite3ExprCompare() except COLLATE operators at the top-level
** are ignored.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCompareSkip</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>,<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
             <argument><expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return non-zero if Expr p can only be true if pNN is not NULL.
**
** Or if seenNot is true, return non-zero if Expr p can only be
** non-NULL if pNN is not NULL
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprImpliesNotNull</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,<comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,      <comment type="block">/* The expression to be checked */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pNN</name></decl></parameter>,    <comment type="block">/* The expression that is NOT NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>,           <comment type="block">/* Table being evaluated */</comment>
  <parameter><decl><type><name>int</name></type> <name>seenNot</name></decl></parameter>         <comment type="block">/* Return true only if p can be any non-NULL value */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pNN</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>seenNot</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>seenNot</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call>
       <operator>||</operator> <call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_EQ</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case>
    <case>case <expr><name>TK_PLUS</name></expr>:</case>
    <case>case <expr><name>TK_MINUS</name></expr>:</case>
    <case>case <expr><name>TK_BITOR</name></expr>:</case>
    <case>case <expr><name>TK_LSHIFT</name></expr>:</case>
    <case>case <expr><name>TK_RSHIFT</name></expr>:</case> 
    <case>case <expr><name>TK_CONCAT</name></expr>:</case> 
      <expr_stmt><expr><name>seenNot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><name>TK_STAR</name></expr>:</case>
    <case>case <expr><name>TK_REM</name></expr>:</case>
    <case>case <expr><name>TK_BITAND</name></expr>:</case>
    <case>case <expr><name>TK_SLASH</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>seenNot</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
    </block_content>}</block>
    <case>case <expr><name>TK_SPAN</name></expr>:</case>
    <case>case <expr><name>TK_COLLATE</name></expr>:</case>
    <case>case <expr><name>TK_UPLUS</name></expr>:</case>
    <case>case <expr><name>TK_UMINUS</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>seenNot</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_TRUTH</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>seenNot</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op2</name></name><operator>!=</operator><name>TK_IS</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_BITNOT</name></expr>:</case>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pNN</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if we can prove the pE2 will always be true if pE1 is
** true.  Return false if we cannot complete the proof or if pE2 might
** be false.  Examples:
**
**     pE1: x==5       pE2: x==5             Result: true
**     pE1: x&gt;0        pE2: x==5             Result: false
**     pE1: x=21       pE2: x=21 OR y=43     Result: true
**     pE1: x!=123     pE2: x IS NOT NULL    Result: true
**     pE1: x!=?1      pE2: x IS NOT NULL    Result: true
**     pE1: x IS NULL  pE2: x IS NOT NULL    Result: false
**     pE1: x IS ?2    pE2: x IS NOT NULL    Reuslt: false
**
** When comparing TK_COLUMN nodes between pE1 and pE2, if pE2 has
** Expr.iTable&lt;0 then assume a table number given by iTab.
**
** If pParse is not NULL, then the values of bound variables in pE1 are 
** compared against literal values in pE2 and pParse-&gt;pVdbe-&gt;expmask is
** modified to record which bound variables are referenced.  If pParse 
** is NULL, then false will be returned if pE1 contains any bound variables.
**
** When in doubt, return false.  Returning true might give a performance
** improvement.  Returning false might cause a performance reduction, but
** it will always give the correct answer and is hence always safe.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprImpliesExpr</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pE1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pE2</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pE2</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_OR</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3ExprImpliesExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call>
             <operator>||</operator> <call><name>sqlite3ExprImpliesExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call> <operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pE2</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name>
   <operator>&amp;&amp;</operator> <call><name>exprImpliesNotNull</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE1</name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the Expr node callback for sqlite3ExprImpliesNonNullRow().
** If the expression node requires that the table at pWalker-&gt;iCur
** have one or more non-NULL column, then set pWalker-&gt;eCode to 1 and abort.
**
** This routine controls an optimization.  False positives (setting
** pWalker-&gt;eCode to 1 when it should not be) are deadly, but false-negatives
** (never setting pWalker-&gt;eCode) is a harmless missed optimization.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>impliesNotNullRow</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Prune</name></expr>;</return></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_OR</name></expr>:</case>
    <case>case <expr><name>TK_VECTOR</name></expr>:</case>
    <case>case <expr><name>TK_CASE</name></expr>:</case>
    <case>case <expr><name>TK_IN</name></expr>:</case>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case>
    <case>case <expr><name>TK_TRUTH</name></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_CASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRUTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iCur</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>

    <case>case <expr><name>TK_AND</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>

    <case>case <expr><name>TK_BETWEEN</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>WRC_Abort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>

    <comment type="block">/* Virtual tables are allowed to use constraints like x=NULL.  So
    ** a term of the form x=y does not prove that y is not null if x
    ** is the column of a virtual table */</comment>
    <case>case <expr><name>TK_EQ</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The y.pTab=0 assignment in wherecode.c always happens after the
      ** impliesNotNullRow() test */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>||</operator> <call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>||</operator> <call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
           <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
           <operator>&amp;&amp;</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
           <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
           <operator>&amp;&amp;</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Prune</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
    </block_content>}</block>
    <default>default:</default>
      <return>return <expr><name>WRC_Continue</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return true (non-zero) if expression p can only be true if at least
** one column of table iTab is non-null.  In other words, return true
** if expression p will always be NULL or false if every column of iTab
** is NULL.
**
** False negatives are acceptable.  In other words, it is ok to return
** zero even if expression p will never be true of every column of iTab
** is NULL.  A false negative is merely a missed optimization opportunity.
**
** False positives are not allowed, however.  A false positive may result
** in an incorrect answer.
**
** Terms of p that are marked with EP_OuterON (and hence that come from
** the ON or USING clauses of OUTER JOINS) are excluded from the analysis.
**
** This routine is used to check if a LEFT JOIN can be converted into
** an ordinary JOIN.  The p argument is the WHERE clause.  If the WHERE
** clause requires that some column of the right table of the LEFT JOIN
** be non-NULL, then the LEFT JOIN can be safely converted into an
** ordinary join.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprImpliesNonNullRow</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprImpliesNonNullRow</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>impliesNotNullRow</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>iCur</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An instance of the following structure is used by the tree walker
** to determine if an expression can be evaluated by reference to the
** index only, without having to do a search for the corresponding
** table entry.  The IdxCover.pIdx field is the index.  IdxCover.iCur
** is the cursor for the table.
*/</comment>
<struct>struct <name>IdxCover</name> <block>{
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>     <comment type="block">/* The index to be tested for coverage */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>        <comment type="block">/* Cursor number for the table corresponding to the index */</comment>
}</block>;</struct>

<comment type="block">/*
** Check to see if there are references to columns in table 
** pWalker-&gt;u.pIdxCover-&gt;iCur can be satisfied using the index
** pWalker-&gt;u.pIdxCover-&gt;pIdx.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprIdxCover</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pIdxCover</name><operator>-&gt;</operator><name>iCur</name></name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pIdxCover</name><operator>-&gt;</operator><name>pIdx</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Determine if an index pIdx on table with cursor iCur contains will
** the expression pExpr.  Return true if the index does cover the
** expression and false if the pExpr expression references table columns
** that are not found in the index pIdx.
**
** An index covering an expression means that the expression can be
** evaluated using only the index and without having to lookup the
** corresponding table entry.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCoveredByIndex</name><parameter_list>(
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,        <comment type="block">/* The index to be tested */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,           <comment type="block">/* The cursor number for the corresponding table */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>         <comment type="block">/* The index that might be used for coverage */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxCover</name></name></type> <name>xcov</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>xcov</name><operator>.</operator><name>iCur</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>xcov</name><operator>.</operator><name>pIdx</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprIdxCover</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pIdxCover</name></name> <operator>=</operator> <operator>&amp;</operator><name>xcov</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>!</operator><name><name>w</name><operator>.</operator><name>eCode</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Structure used to pass information throught the Walker in order to
** implement sqlite3ReferencesSrcList().
*/</comment>
<struct>struct <name>RefSrcList</name> <block>{
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>         <comment type="block">/* Database connection used for sqlite3DbRealloc() */</comment>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pRef</name></decl>;</decl_stmt>       <comment type="block">/* Looking for references to these tables */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nExclude</name></decl>;</decl_stmt>        <comment type="block">/* Number of tables to exclude from the search */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiExclude</name></decl>;</decl_stmt>      <comment type="block">/* Cursor IDs for tables to exclude from the search */</comment>
}</block>;</struct>

<comment type="block">/*
** Walker SELECT callbacks for sqlite3ReferencesSrcList().
**
** When entering a new subquery on the pExpr argument, add all FROM clause
** entries for that subquery to the exclude list.
**
** When leaving the subquery, remove those entries from the exclude list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>selectRefEnter</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>RefSrcList</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRefSrcList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name> <operator>+=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>piNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiExclude</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>piNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiExclude</name></name> <operator>=</operator> <name>piNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
     <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiExclude</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>selectRefLeave</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>RefSrcList</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRefSrcList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name><operator>&gt;=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name> <operator>-=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This is the Walker EXPR callback for sqlite3ReferencesSrcList().
** 
** Set the 0x01 bit of pWalker-&gt;eCode if there is a reference to any
** of the tables shown in RefSrcList.pRef.
**
** Set the 0x02 bit of pWalker-&gt;eCode if there is a reference to a
** table is in neither RefSrcList.pRef nor RefSrcList.aiExclude.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprRefToSrcList</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
   <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>RefSrcList</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRefSrcList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRef</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSrc</name> <init>= <expr><ternary><condition><expr><name>pSrc</name></expr> ?</condition><then> <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSrc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aiExclude</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nExclude</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if pExpr references any tables in pSrcList.
** Possible return values:
**
**    1         pExpr does references a table in pSrcList.
**
**    0         pExpr references some table that is not defined in either
**              pSrcList or in subqueries of pExpr itself.
**
**   -1         pExpr only references no tables at all, or it only
**              references tables defined in subqueries of pExpr itself.
**
** As currently used, pExpr is always an aggregate function call.  That
** fact is exploited for efficiency.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ReferencesSrcList</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>RefSrcList</name></name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprRefToSrcList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>selectRefEnter</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <name>selectRefLeave</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pRefSrcList</name></name> <operator>=</operator> <operator>&amp;</operator><name>x</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pRef</name></name> <operator>=</operator> <name>pSrcList</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aiExclude</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aiExclude</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>w</name><operator>.</operator><name>eCode</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is a Walker expression node callback.
**
** For Expr nodes that contain pAggInfo pointers, make sure the AggInfo
** object that is referenced does not refer directly to the Expr.  If
** it does, make a copy.  This is done because the pExpr argument is
** subject to change.
**
** The copy is stored on pParse-&gt;pConstExpr with a register number of 0.
** This will cause the expression to be deleted automatically when the
** Parse object is destroyed, but the zero register number means that it
** will not generate any code in the preamble.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>agginfoPersistExprCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iAgg</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iAgg</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iAgg</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iAgg</name></expr>]</index></name><operator>.</operator><name>pCExpr</name><operator>==</operator><name>pExpr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pExpr</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iAgg</name></expr>]</index></name><operator>.</operator><name>pCExpr</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprDeferredDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iAgg</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iAgg</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>iAgg</name></expr>]</index></name><operator>.</operator><name>pFExpr</name><operator>==</operator><name>pExpr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pExpr</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>iAgg</name></expr>]</index></name><operator>.</operator><name>pFExpr</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprDeferredDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a Walker object so that will persist AggInfo entries referenced
** by the tree that is walked.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AggInfoPersistWalkerInit</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pWalker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>xExprCallback</name></name> <operator>=</operator> <name>agginfoPersistExprCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkNoop</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add a new element to the pAggInfo-&gt;aCol[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addAggInfoColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <call><name>sqlite3ArrayAllocate</name><argument_list>(
       <argument><expr><name>db</name></expr></argument>,
       <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>,
       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
       <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>,
       <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>    

<comment type="block">/*
** Add a new element to the pAggInfo-&gt;aFunc[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addAggInfoFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aFunc</name></name> <operator>=</operator> <call><name>sqlite3ArrayAllocate</name><argument_list>(
       <argument><expr><name>db</name></expr></argument>, 
       <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr></argument>,
       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
       <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr></argument>,
       <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search the AggInfo object for an aCol[] entry that has iTable and iColumn.
** Return the index in aCol[] of the entry that describes that column. 
**
** If no prior entry is found, create a new one and return -1.  The
** new column will have an idex of pAggInfo-&gt;nColumn-1.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>findOrCreateAggInfoColumn</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name></decl></parameter>,   <comment type="block">/* The AggInfo object to search and/or modify */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>          <comment type="block">/* Expr describing the column to find or insert */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name>
     <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name>
     <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_IF_NULL_ROW</name></expr>
    )</condition><block>{<block_content>
      <goto>goto <name>fix_up_expr</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>addAggInfoColumn</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>k</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* OOM on resize */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pCExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_IF_NULL_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGB</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><name><name>pGB</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pGB</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
       <operator>&amp;&amp;</operator> <name><name>pE</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name>
       <operator>&amp;&amp;</operator> <name><name>pE</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name> <operator>=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nSortingColumn</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>fix_up_expr</name>:</label>
  <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name> <operator>=</operator> <name>pAggInfo</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_AGG_COLUMN</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>k</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is the xExprCallback for a tree walker.  It is used to
** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates
** for additional information.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>analyzeAggregate</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNC</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>uNC</name><operator>.</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_UAggInfo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>iFirstReg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <default>default:</default> <block>{<block_content>
      <decl_stmt><decl><type><name>IndexedExpr</name> <modifier>*</modifier></type><name>pIEpr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>tmp</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_InAggFunc</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>pIEpr</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr>;</init> <condition><expr><name>pIEpr</name></expr>;</condition> <incr><expr><name>pIEpr</name><operator>=</operator><name><name>pIEpr</name><operator>-&gt;</operator><name>pIENext</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name> <init>= <expr><name><name>pIEpr</name><operator>-&gt;</operator><name>iDataCur</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>iDataCur</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pIEpr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pIEpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><operator>!</operator><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* If we reach this point, it means that expression pExpr can be
      ** translated into a reference to an index column as described by
      ** pIEpr.
      */</comment>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_AGG_COLUMN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>iTable</name></name> <operator>=</operator> <name><name>pIEpr</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>iColumn</name></name> <operator>=</operator> <name><name>pIEpr</name><operator>-&gt;</operator><name>iIdxCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>findOrCreateAggInfoColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>tmp</name><operator>.</operator><name>iAgg</name></name></expr>]</index></name><operator>.</operator><name>pCExpr</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name> <operator>=</operator> <name>pAggInfo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>iAgg</name></name></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_IF_NULL_ROW</name></expr>:</case>
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:</case>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Check to see if the column is in one of the tables in the FROM
      ** clause of the aggregate query */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pSrcList</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pSrcList</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>findOrCreateAggInfoColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt> <comment type="block">/* endif pExpr-&gt;iTable==pItem-&gt;iCursor */</comment>
        </block_content>}</block></for> <comment type="block">/* end loop over pSrcList */</comment>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_AGG_FUNCTION</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_InAggFunc</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>walkerDepth</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* Check to see if pExpr is a duplicate of another aggregate 
        ** function that is already in the pAggInfo structure
        */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_func</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pFExpr</name></name><operator>==</operator><name>pExpr</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pFExpr</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* pExpr is original.  Make a new entry in pAggInfo-&gt;aFunc[]
          */</comment>
          <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>addAggInfoFunc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pFExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseUToken</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
                   <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, 
                   <argument><expr><ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> ?</condition><then> <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Distinct</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iDistinct</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iDistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Make pExpr point to the appropriate pAggInfo-&gt;aFunc[] entry
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name> <operator>=</operator> <name>pAggInfo</name></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Prune</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Analyze the pExpr expression looking for aggregate functions and
** for variables that need to be added to AggInfo object that pNC-&gt;pAggInfo
** points to.  Additional entries are made on the AggInfo object as
** necessary.
**
** This routine should only be called after the expression has been
** analyzed by sqlite3ResolveExprNames().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAnalyzeAggregates</name><parameter_list>(<parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>analyzeAggregate</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3WalkerDepthIncrease</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <name>sqlite3WalkerDepthDecrease</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>walkerDepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pNC</name></name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Call sqlite3ExprAnalyzeAggregates() for every expression in an
** expression list.  Return the number of errors.
**
** If an error is found, the analysis is cut short.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAnalyzeAggList</name><parameter_list>(<parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggregates</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a single new register for use to hold some intermediate result.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetTempReg</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name><index>[<expr><operator>--</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate a register, making available for reuse for some other
** purpose.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ReleaseTempReg</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iReg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeReleaseRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate or deallocate a block of nReg consecutive registers.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetTempRange</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>&lt;=</operator><name>n</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name> <operator>+=</operator> <name>nReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>-=</operator> <name>nReg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nReg</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3ReleaseTempRange</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeReleaseRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>=</operator> <name>nReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark all temporary registers as being unavailable for reuse.
**
** Always invoke this procedure after coding a subroutine or co-routine
** that might be invoked from other parts of the code, to ensure that
** the sub/co-routine does not use registers in common with the code that
** invokes the sub/co-routine.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ClearTempRegCache</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Validate that no temporary register falls within the range of
** iFirst..iLast, inclusive.  This routine is only call from within assert()
** statements.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<function><type><name>int</name></type> <name>sqlite3NoTempsInRange</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iFirst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name><operator>&gt;</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name><operator>+</operator><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>&gt;</operator> <name>iFirst</name>
   <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name> <operator>&lt;=</operator> <name>iLast</name></expr>
  )</condition><block>{<block_content>
     <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><name>iFirst</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><name>iLast</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
</unit>
