<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/window.c"><comment type="block">/*
** 2018 May 08
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>

<comment type="block">/*
** SELECT REWRITING
**
**   Any SELECT statement that contains one or more window functions in
**   either the select list or ORDER BY clause (the only two places window
**   functions may be used) is transformed by function sqlite3WindowRewrite()
**   in order to support window function processing. For example, with the
**   schema:
**
**     CREATE TABLE t1(a, b, c, d, e, f, g);
**
**   the statement:
**
**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM t1 ORDER BY e;
**
**   is transformed to:
**
**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM (
**         SELECT a, e, c, d, b FROM t1 ORDER BY c, d
**     ) ORDER BY e;
**
**   The flattening optimization is disabled when processing this transformed
**   SELECT statement. This allows the implementation of the window function
**   (in this case max()) to process rows sorted in order of (c, d), which
**   makes things easier for obvious reasons. More generally:
**
**     * FROM, WHERE, GROUP BY and HAVING clauses are all moved to 
**       the sub-query.
**
**     * ORDER BY, LIMIT and OFFSET remain part of the parent query.
**
**     * Terminals from each of the expression trees that make up the 
**       select-list and ORDER BY expressions in the parent query are
**       selected by the sub-query. For the purposes of the transformation,
**       terminals are column references and aggregate functions.
**
**   If there is more than one window function in the SELECT that uses
**   the same window declaration (the OVER bit), then a single scan may
**   be used to process more than one window function. For example:
**
**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), 
**            min(e) OVER (PARTITION BY c ORDER BY d) 
**     FROM t1;
**
**   is transformed in the same way as the example above. However:
**
**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), 
**            min(e) OVER (PARTITION BY a ORDER BY b) 
**     FROM t1;
**
**   Must be transformed to:
**
**     SELECT max(b) OVER (PARTITION BY c ORDER BY d) FROM (
**         SELECT e, min(e) OVER (PARTITION BY a ORDER BY b), c, d, b FROM
**           SELECT a, e, c, d, b FROM t1 ORDER BY a, b
**         ) ORDER BY c, d
**     ) ORDER BY e;
**
**   so that both min() and max() may process rows in the order defined by
**   their respective window declarations.
**
** INTERFACE WITH SELECT.C
**
**   When processing the rewritten SELECT statement, code in select.c calls
**   sqlite3WhereBegin() to begin iterating through the results of the
**   sub-query, which is always implemented as a co-routine. It then calls
**   sqlite3WindowCodeStep() to process rows and finish the scan by calling
**   sqlite3WhereEnd().
**
**   sqlite3WindowCodeStep() generates VM code so that, for each row returned
**   by the sub-query a sub-routine (OP_Gosub) coded by select.c is invoked.
**   When the sub-routine is invoked:
**
**     * The results of all window-functions for the row are stored
**       in the associated Window.regResult registers.
**
**     * The required terminal values are stored in the current row of
**       temp table Window.iEphCsr.
**
**   In some cases, depending on the window frame and the specific window
**   functions invoked, sqlite3WindowCodeStep() caches each entire partition
**   in a temp table before returning any rows. In other cases it does not.
**   This detail is encapsulated within this file, the code generated by
**   select.c is the same in either case.
**
** BUILT-IN WINDOW FUNCTIONS
**
**   This implementation features the following built-in window functions:
**
**     row_number()
**     rank()
**     dense_rank()
**     percent_rank()
**     cume_dist()
**     ntile(N)
**     lead(expr [, offset [, default]])
**     lag(expr [, offset [, default]])
**     first_value(expr)
**     last_value(expr)
**     nth_value(expr, N)
**   
**   These are the same built-in window functions supported by Postgres. 
**   Although the behaviour of aggregate window functions (functions that
**   can be used as either aggregates or window funtions) allows them to
**   be implemented using an API, built-in window functions are much more
**   esoteric. Additionally, some window functions (e.g. nth_value()) 
**   may only be implemented by caching the entire partition in memory.
**   As such, some built-in window functions use the same API as aggregate
**   window functions and some are implemented directly using VDBE 
**   instructions. Additionally, for those functions that use the API, the
**   window frame is sometimes modified before the SELECT statement is
**   rewritten. For example, regardless of the specified window frame, the
**   row_number() function always uses:
**
**     ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
**
**   See sqlite3WindowUpdate() for details.
**
**   As well as some of the built-in window functions, aggregate window
**   functions min() and max() are implemented using VDBE instructions if
**   the start of the window frame is declared as anything other than 
**   UNBOUNDED PRECEDING.
*/</comment>

<comment type="block">/*
** Implementation of built-in window function row_number(). Assumes that the
** window frame has been coerced to:
**
**   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>row_numberStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>row_numberValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Context object type used by rank(), dense_rank(), percent_rank() and
** cume_dist().
*/</comment>
<struct>struct <name>CallCount</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>nValue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nStep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nTotal</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Implementation of built-in window function dense_rank(). Assumes that
** the window frame has been set to:
**
**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dense_rankStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dense_rankValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of built-in window function nth_value(). This
** implementation is used in "slow mode" only - when the EXCLUDE clause
** is not set to the default value "NO OTHERS".
*/</comment>
<struct>struct <name>NthValueCtx</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>nStep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nth_valueStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>NthValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>NthValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name></decl>;</decl_stmt>
    <switch>switch<condition>( <expr><call><name>sqlite3_value_numeric_type</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>fVal</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>fVal</name><operator>)</operator><operator>!=</operator><name>fVal</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iVal</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>fVal</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default>
        <goto>goto <name>error_out</name>;</goto>
    </block_content>}</block></switch>
    <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>

 <label><name>error_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(
      <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"second argument to nth_value must be a positive integer"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nth_valueFinalizeFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>NthValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>NthValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nth_valueInvFunc</name></cpp:macro> <cpp:value>noopStepFunc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nth_valueValueFunc</name></cpp:macro> <cpp:value>noopValueFunc</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>first_valueStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>NthValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>NthValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pValue</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>first_valueFinalizeFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>NthValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>NthValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>first_valueInvFunc</name></cpp:macro> <cpp:value>noopStepFunc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>first_valueValueFunc</name></cpp:macro> <cpp:value>noopValueFunc</cpp:value></cpp:define>

<comment type="block">/*
** Implementation of built-in window function rank(). Assumes that
** the window frame has been set to:
**
**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rankStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nStep</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rankValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of built-in window function percent_rank(). Assumes that
** the window frame has been set to:
**
**   GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>percent_rankStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>percent_rankInvFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>percent_rankValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nStep</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nValue</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>percent_rankFinalizeFunc</name></cpp:macro> <cpp:value>percent_rankValueFunc</cpp:value></cpp:define>

<comment type="block">/*
** Implementation of built-in window function cume_dist(). Assumes that
** the window frame has been set to:
**
**   GROUPS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cume_distStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cume_distInvFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cume_distValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CallCount</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>CallCount</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nStep</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cume_distFinalizeFunc</name></cpp:macro> <cpp:value>cume_distValueFunc</cpp:value></cpp:define>

<comment type="block">/*
** Context object for ntile() window function.
*/</comment>
<struct>struct <name>NtileCtx</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>nTotal</name></decl>;</decl_stmt>                     <comment type="block">/* Total rows in partition */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nParam</name></decl>;</decl_stmt>                     <comment type="block">/* Parameter passed to ntile(N) */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRow</name></decl>;</decl_stmt>                       <comment type="block">/* Current row */</comment>
}</block>;</struct>

<comment type="block">/*
** Implementation of ntile(). This assumes that the window frame has
** been coerced to:
**
**   ROWS CURRENT ROW AND UNBOUNDED FOLLOWING
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ntileStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>NtileCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>NtileCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nParam</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nParam</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(
            <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"argument of ntile must be a positive integer"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ntileInvFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>NtileCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>NtileCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRow</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ntileValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>NtileCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>NtileCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nParam</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSize</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name> <operator>/</operator> <name><name>p</name><operator>-&gt;</operator><name>nParam</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iRow</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>nLarge</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nParam</name></name><operator>*</operator><name>nSize</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>iSmall</name> <init>= <expr><name>nLarge</name><operator>*</operator><operator>(</operator><name>nSize</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>iRow</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iRow</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nLarge</name><operator>*</operator><operator>(</operator><name>nSize</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nParam</name></name><operator>-</operator><name>nLarge</name><operator>)</operator><operator>*</operator><name>nSize</name><operator>)</operator><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nTotal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>iRow</name><operator>&lt;</operator><name>iSmall</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>iRow</name><operator>/</operator><operator>(</operator><name>nSize</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>nLarge</name> <operator>+</operator> <operator>(</operator><name>iRow</name><operator>-</operator><name>iSmall</name><operator>)</operator><operator>/</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ntileFinalizeFunc</name></cpp:macro> <cpp:value>ntileValueFunc</cpp:value></cpp:define>

<comment type="block">/*
** Context object for last_value() window function.
*/</comment>
<struct>struct <name>LastValueCtx</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Implementation of last_value().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>last_valueStepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>LastValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>LastValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>last_valueInvFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>LastValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>LastValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>last_valueValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>LastValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>LastValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pVal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>last_valueFinalizeFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>LastValueCtx</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>LastValueCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pVal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Static names for the built-in window function names.  These static
** names are used, rather than string literals, so that FuncDef objects
** can be associated with a particular window function by direct
** comparison of the zName pointer.  Example:
**
**       if( pFuncDef-&gt;zName==row_valueName ){ ... }
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>row_numberName</name><index>[]</index></name> <init>=   <expr><literal type="string">"row_number"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dense_rankName</name><index>[]</index></name> <init>=   <expr><literal type="string">"dense_rank"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>rankName</name><index>[]</index></name> <init>=         <expr><literal type="string">"rank"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>percent_rankName</name><index>[]</index></name> <init>= <expr><literal type="string">"percent_rank"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>cume_distName</name><index>[]</index></name> <init>=    <expr><literal type="string">"cume_dist"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ntileName</name><index>[]</index></name> <init>=        <expr><literal type="string">"ntile"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>last_valueName</name><index>[]</index></name> <init>=   <expr><literal type="string">"last_value"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>nth_valueName</name><index>[]</index></name> <init>=    <expr><literal type="string">"nth_value"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>first_valueName</name><index>[]</index></name> <init>=  <expr><literal type="string">"first_value"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>leadName</name><index>[]</index></name> <init>=         <expr><literal type="string">"lead"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>lagName</name><index>[]</index></name> <init>=          <expr><literal type="string">"lag"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** No-op implementations of xStep() and xFinalize().  Used as place-holders
** for built-in window functions that never call those interfaces.
**
** The noopValueFunc() is called but is expected to do nothing.  The
** noopStepFunc() is never called, and so it is marked with NO_TEST to
** let the test coverage routine know not to expect this function to be
** invoked.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>noopStepFunc</name><parameter_list>(    <comment type="block">/*NO_TEST*/</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,        <comment type="block">/*NO_TEST*/</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                     <comment type="block">/*NO_TEST*/</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>a</name></decl></parameter>          <comment type="block">/*NO_TEST*/</comment>
)</parameter_list><block>{<block_content>                           <comment type="block">/*NO_TEST*/</comment>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/*NO_TEST*/</comment>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/*NO_TEST*/</comment>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/*NO_TEST*/</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="block">/*NO_TEST*/</comment>
</block_content>}</block></function>                            <comment type="block">/*NO_TEST*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>noopValueFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content> <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*no-op*/</comment> </block_content>}</block></function>

<comment type="block">/* Window functions that use all window interfaces: xStep, xFinal,
** xValue, and xInverse */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOWFUNCALL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>nArg</name></type></parameter>,<parameter><type><name>extra</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                                   \
  nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  \
  name ## StepFunc, name ## FinalizeFunc, name ## ValueFunc,               \
  name ## InvFunc, name ## Name, {0}                                       \
}</cpp:value></cpp:define>

<comment type="block">/* Window functions that are implemented using bytecode and thus have
** no-op routines for their methods */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOWFUNCNOOP</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>nArg</name></type></parameter>,<parameter><type><name>extra</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                                  \
  nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  \
  noopStepFunc, noopValueFunc, noopValueFunc,                              \
  noopStepFunc, name ## Name, {0}                                          \
}</cpp:value></cpp:define>

<comment type="block">/* Window functions that use all window interfaces: xStep, the
** same routine for xFinalize and xValue and which never call
** xInverse. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOWFUNCX</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>nArg</name></type></parameter>,<parameter><type><name>extra</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                                     \
  nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  \
  name ## StepFunc, name ## ValueFunc, name ## ValueFunc,                  \
  noopStepFunc, name ## Name, {0}                                          \
}</cpp:value></cpp:define>


<comment type="block">/*
** Register those built-in window functions that are not also aggregates.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowFunctions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>FuncDef</name></type> <name><name>aWindowFuncs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>WINDOWFUNCX</name><argument_list>(<argument><expr><name>row_number</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCX</name><argument_list>(<argument><expr><name>dense_rank</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCX</name><argument_list>(<argument><expr><name>rank</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCALL</name><argument_list>(<argument><expr><name>percent_rank</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCALL</name><argument_list>(<argument><expr><name>cume_dist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCALL</name><argument_list>(<argument><expr><name>ntile</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCALL</name><argument_list>(<argument><expr><name>last_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCALL</name><argument_list>(<argument><expr><name>nth_value</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCALL</name><argument_list>(<argument><expr><name>first_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCNOOP</name><argument_list>(<argument><expr><name>lead</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCNOOP</name><argument_list>(<argument><expr><name>lead</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCNOOP</name><argument_list>(<argument><expr><name>lead</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCNOOP</name><argument_list>(<argument><expr><name>lag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCNOOP</name><argument_list>(<argument><expr><name>lag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>WINDOWFUNCNOOP</name><argument_list>(<argument><expr><name>lag</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3InsertBuiltinFuncs</name><argument_list>(<argument><expr><name>aWindowFuncs</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aWindowFuncs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Window</name> <modifier>*</modifier></type><name>windowFind</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such window: %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called immediately after resolving the function name
** for a window function within a SELECT statement. Argument pList is a
** linked list of WINDOW definitions for the current SELECT statement.
** Argument pFunc is the function definition just resolved and pWin
** is the Window object representing the associated OVER clause. This
** function updates the contents of pWin as follows:
**
**   * If the OVER clause refered to a named window (as in "max(x) OVER win"),
**     search list pList for a matching WINDOW definition, and update pWin
**     accordingly. If no such WINDOW clause can be found, leave an error
**     in pParse.
**
**   * If the function is a built-in window function that requires the
**     window to be coerced (see "BUILT-IN WINDOW FUNCTIONS" at the top
**     of this file), pWin is updated here.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowUpdate</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,                  <comment type="block">/* List of named windows for this SELECT */</comment>
  <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl></parameter>,                   <comment type="block">/* Window frame to update */</comment>
  <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name></decl></parameter>                  <comment type="block">/* Window function definition */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>zName</name></name> <operator>&amp;&amp;</operator> <name><name>pWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>windowFind</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pStart</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pEnd</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eStart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eEnd</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eEnd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eFrmType</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eFrmType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eExclude</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eExclude</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WindowChain</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWin</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWin</name><operator>-&gt;</operator><name>pStart</name></name> <operator>||</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pEnd</name></name><operator>)</operator> 
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_WINDOW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr><literal type="string">"FILTER clause may only be used with aggregate window functions"</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <struct>struct <name>WindowUpdate</name> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eFrmType</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eStart</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eEnd</name></decl>;</decl_stmt>
      }</block> <decl><name><name>aUp</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><name>row_numberName</name></expr>,   <expr><name>TK_ROWS</name></expr>,   <expr><name>TK_UNBOUNDED</name></expr>, <expr><name>TK_CURRENT</name></expr> }</block></expr>, 
        <expr><block>{ <expr><name>dense_rankName</name></expr>,   <expr><name>TK_RANGE</name></expr>,  <expr><name>TK_UNBOUNDED</name></expr>, <expr><name>TK_CURRENT</name></expr> }</block></expr>, 
        <expr><block>{ <expr><name>rankName</name></expr>,         <expr><name>TK_RANGE</name></expr>,  <expr><name>TK_UNBOUNDED</name></expr>, <expr><name>TK_CURRENT</name></expr> }</block></expr>, 
        <expr><block>{ <expr><name>percent_rankName</name></expr>, <expr><name>TK_GROUPS</name></expr>, <expr><name>TK_CURRENT</name></expr>,   <expr><name>TK_UNBOUNDED</name></expr> }</block></expr>, 
        <expr><block>{ <expr><name>cume_distName</name></expr>,    <expr><name>TK_GROUPS</name></expr>, <expr><name>TK_FOLLOWING</name></expr>, <expr><name>TK_UNBOUNDED</name></expr> }</block></expr>, 
        <expr><block>{ <expr><name>ntileName</name></expr>,        <expr><name>TK_ROWS</name></expr>,   <expr><name>TK_CURRENT</name></expr>,   <expr><name>TK_UNBOUNDED</name></expr> }</block></expr>, 
        <expr><block>{ <expr><name>leadName</name></expr>,         <expr><name>TK_ROWS</name></expr>,   <expr><name>TK_UNBOUNDED</name></expr>, <expr><name>TK_UNBOUNDED</name></expr> }</block></expr>, 
        <expr><block>{ <expr><name>lagName</name></expr>,          <expr><name>TK_ROWS</name></expr>,   <expr><name>TK_UNBOUNDED</name></expr>, <expr><name>TK_CURRENT</name></expr> }</block></expr>, 
      }</block></expr></init></decl>;</struct>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aUp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zFunc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pEnd</name></name> <operator>=</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eFrmType</name></name> <operator>=</operator> <name><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eFrmType</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name> <operator>=</operator> <name><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eStart</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eEnd</name></name> <operator>=</operator> <name><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eEnd</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eExclude</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pStart</name></name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name> <operator>=</operator> <name>pFunc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Context object passed through sqlite3WalkExprList() to
** selectWindowRewriteExprCb() by selectWindowRewriteEList().
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>WindowRewrite</name></name></type> <name>WindowRewrite</name>;</typedef>
<struct>struct <name>WindowRewrite</name> <block>{
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pSub</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSubSelect</name></decl>;</decl_stmt>             <comment type="block">/* Current sub-select, if any */</comment>
}</block>;</struct>

<comment type="block">/*
** Callback function used by selectWindowRewriteEList(). If necessary,
** this function appends to the output expression-list and updates 
** expression (*ppExpr) in place.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>selectWindowRewriteExprCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>WindowRewrite</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRewrite</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this function is being called from within a scalar sub-select
  ** that used by the SELECT statement being processed, only process
  ** TK_COLUMN expressions that refer to it (the outer SELECT). Do
  ** not process aggregates or window functions at all, as they belong
  ** to the scalar sub-select.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSubSelect</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Continue</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nSrc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSrc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nSrc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>

    <case>case <expr><name>TK_FUNCTION</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name><operator>==</operator><name>pWin</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name><operator>==</operator><name>pExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>WRC_Prune</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
      <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>

    <case>case <expr><name>TK_AGG_FUNCTION</name></expr>:</case>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSub</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pSub</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSub</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDup</name> <init>= <expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pDup</name> <operator>&amp;&amp;</operator> <name><name>pDup</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pDup</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_FUNCTION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSub</name></name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSub</name></name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSub</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Static</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_COLUMN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pSub</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><name>iCol</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default> <comment type="block">/* no-op */</comment>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>selectWindowRewriteSelectCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>WindowRewrite</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRewrite</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSave</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSubSelect</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSave</name><operator>==</operator><name>pSelect</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Continue</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSubSelect</name></name> <operator>=</operator> <name>pSelect</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSubSelect</name></name> <operator>=</operator> <name>pSave</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>WRC_Prune</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Iterate through each expression in expression-list pEList. For each:
**
**   * TK_COLUMN,
**   * aggregate function, or
**   * window function with a Window object that is not a member of the 
**     Window list passed as the second argument (pWin).
**
** Append the node to output expression-list (*ppSub). And replace it
** with a TK_COLUMN that reads the (N-1)th element of table 
** pWin-&gt;iEphCsr, where N is the number of elements in (*ppSub) after
** appending the new one.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>selectWindowRewriteEList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl></parameter>,
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,               <comment type="block">/* Rewrite expressions in this list */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSub</name></decl></parameter>                <comment type="block">/* IN/OUT: Sub-select expression-list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WindowRewrite</name></type> <name>sRewrite</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWin</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Walker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRewrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WindowRewrite</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sRewrite</name><operator>.</operator><name>pSub</name></name> <operator>=</operator> <operator>*</operator><name>ppSub</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sRewrite</name><operator>.</operator><name>pWin</name></name> <operator>=</operator> <name>pWin</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sRewrite</name><operator>.</operator><name>pSrc</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sRewrite</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>selectWindowRewriteExprCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>selectWindowRewriteSelectCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pRewrite</name></name> <operator>=</operator> <operator>&amp;</operator><name>sRewrite</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppSub</name> <operator>=</operator> <name><name>sRewrite</name><operator>.</operator><name>pSub</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Append a copy of each expression in expression-list pAppend to
** expression list pList. Return a pointer to the result list.
*/</comment>
<function><type><specifier>static</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>exprListAppendList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to append. Might be NULL */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pAppend</name></decl></parameter>,      <comment type="block">/* List of values to append. Might be NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>bIntToNull</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pAppend</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nInit</name> <init>= <expr><ternary><condition><expr><name>pList</name></expr> ?</condition><then> <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAppend</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDup</name> <init>= <expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pAppend</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bIntToNull</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iDummy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pSub</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pSub</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pSub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EP_IntValue</name><operator>|</operator><name>EP_IsTrue</name><operator>|</operator><name>EP_IsFalse</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>nInit</name><operator>+</operator><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>=</operator> <name><name>pAppend</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When rewriting a query, if the new subquery in the FROM clause
** contains TK_AGG_FUNCTION nodes that refer to an outer query,
** then we have to increase the Expr-&gt;op2 values of those nodes
** due to the extra subquery layer that was added.
**
** See also the incrAggDepth() routine in resolve.c
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3WindowExtraAggFuncDepth</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>&gt;=</operator><name><name>pWalker</name><operator>-&gt;</operator><name>walkerDepth</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>disallowAggregatesInOrderByCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>,
         <argument><expr><literal type="string">"misuse of aggregate: %s()"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the SELECT statement passed as the second argument does not invoke
** any SQL window functions, this function is a no-op. Otherwise, it 
** rewrites the SELECT statement so that window function xStep functions
** are invoked in the correct order as described under "SELECT REWRITING"
** at the top of this file.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WindowRewrite</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_WinRewrite</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><operator>!</operator><name>IN_RENAME_OBJECT</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* The subquery */</comment>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGroupBy</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pHaving</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pSort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pSublist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Expression list for sub-query */</comment>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Main window object */</comment>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>                 <comment type="block">/* Window object iterator */</comment>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>u32</name></type> <name>selFlags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>sqlite3ErrorToParser</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3AggInfoPersistWalkerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>disallowAggregatesInOrderByCb</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_Aggregate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_WinRewrite</name></expr>;</expr_stmt>

    <comment type="block">/* Create the ORDER BY clause for the sub-select. This is the concatenation
    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it
    ** redundant, remove the ORDER BY from the parent SELECT.  */</comment>
    <expr_stmt><expr><name>pSort</name> <operator>=</operator> <call><name>exprListAppendList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSort</name> <operator>=</operator> <call><name>exprListAppendList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSort</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&lt;=</operator><name><name>pSort</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nSave</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name>pSort</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>=</operator> <name>nSave</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Assign a cursor number for the ephemeral table used to buffer rows.
    ** The OpenEphemeral instruction is coded later, after it is known how
    ** many columns the table will have.  */</comment>
    <expr_stmt><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>selectWindowRewriteEList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pMWin</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>selectWindowRewriteEList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pMWin</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMWin</name><operator>-&gt;</operator><name>nBufferCol</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pSublist</name></expr> ?</condition><then> <expr><name><name>pSublist</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Append the PARTITION BY and ORDER BY expressions to the to the 
    ** sub-select expression list. They are required to figure out where 
    ** boundaries for partitions and sets of peer rows lie.  */</comment>
    <expr_stmt><expr><name>pSublist</name> <operator>=</operator> <call><name>exprListAppendList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSublist</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSublist</name> <operator>=</operator> <call><name>exprListAppendList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSublist</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Append the arguments passed to each window function to the
    ** sub-select expression list. Also allocate two registers for each
    ** window function - one for the accumulator, another for interim
    ** results.  */</comment>
    <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pArgs</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pArgs</name> <operator>=</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_SUBTYPE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>selectWindowRewriteEList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pMWin</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pArgs</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pSublist</name></expr> ?</condition><then> <expr><name><name>pSublist</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>bExprArgs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pSublist</name></expr> ?</condition><then> <expr><name><name>pSublist</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>pSublist</name> <operator>=</operator> <call><name>exprListAppendList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSublist</name></expr></argument>, <argument><expr><name>pArgs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pFilter</name> <init>= <expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pSublist</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSublist</name></expr></argument>, <argument><expr><name>pFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If there is no ORDER BY or PARTITION BY clause, and the window
    ** function accepts zero arguments, and there are no other columns
    ** selected (e.g. "SELECT row_number() OVER () FROM t1"), it is possible
    ** that pSublist is still NULL here. Add a constant expression here to 
    ** keep everything legal in this case. 
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pSublist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pSublist</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
        <argument><expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pSub</name> <operator>=</operator> <call><name>sqlite3SelectNew</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSublist</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><name>pHaving</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TREETRACE</name><argument_list>(<argument><expr><literal type="number">0x40</literal></expr></argument>,<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pSub</name></expr></argument>,
       <argument><expr><operator>(</operator><literal type="string">"New window-function subquery in FROM clause of (%u/%p)\n"</literal><operator>,</operator>
       <name><name>p</name><operator>-&gt;</operator><name>selId</name></name><operator>,</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSub</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Due to db-&gt;mallocFailed test inside
                                     ** of sqlite3DbMallocRawNN() called from
                                     ** sqlite3SrcListAppend() */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name> <operator>=</operator> <name>pSub</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SrcListAssignCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Expanded</name><operator>|</operator><name>SF_OrderByReqd</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab2</name> <operator>=</operator> <call><name>sqlite3ResultSetOfSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <operator>(</operator><name>selFlags</name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTab2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Might actually be some other kind of error, but in that case
        ** pParse-&gt;nErr will be set, so if SQLITE_NOMEM is set, we will get
        ** the correct error message regardless. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pTab2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Ephemeral</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name>pTab2</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>sqlite3WindowExtraAggFuncDepth</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3WalkerDepthIncrease</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <name>sqlite3WalkerDepthDecrease</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Defer deleting the temporary table pTab because if an error occurred,
    ** there could still be references to that table embedded in the
    ** result-set or ORDER BY clause of the SELECT statement p.  */</comment>
    <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>sqlite3DbFree</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Unlink the Window object from the Select to which it is attached,
** if it is attached.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowUnlinkFromSelect</name><parameter_list>(<parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>ppThis</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>ppThis</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNextWin</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNextWin</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNextWin</name><operator>-&gt;</operator><name>ppThis</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ppThis</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ppThis</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free the Window object passed as the second argument.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WindowUnlinkFromSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free the linked list of Window objects starting at the second argument.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowListDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3WindowDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** The argument expression is an PRECEDING or FOLLOWING offset.  The
** value should be a non-negative integer.  If the value is not a
** constant, change it to NULL.  The fact that it is then a non-negative
** integer will be caught later.  But it is important not to leave
** variable values in the expression tree.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>sqlite3WindowOffsetExpr</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>IN_RENAME_OBJECT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3RenameExprUnmap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a new Window object describing a Window Definition.
*/</comment>
<function><type><name>Window</name> <modifier>*</modifier></type><name>sqlite3WindowAlloc</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>,        <comment type="block">/* Frame type. TK_RANGE, TK_ROWS, TK_GROUPS, or 0 */</comment>
  <parameter><decl><type><name>int</name></type> <name>eStart</name></decl></parameter>,       <comment type="block">/* Start type: CURRENT, PRECEDING, FOLLOWING, UNBOUNDED */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pStart</name></decl></parameter>,     <comment type="block">/* Start window size if TK_PRECEDING or FOLLOWING */</comment>
  <parameter><decl><type><name>int</name></type> <name>eEnd</name></decl></parameter>,         <comment type="block">/* End type: CURRENT, FOLLOWING, TK_UNBOUNDED, PRECEDING */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,       <comment type="block">/* End window size if TK_FOLLOWING or PRECEDING */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eExclude</name></decl></parameter>       <comment type="block">/* EXCLUDE clause */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bImplicitFrame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Parser assures the following: */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eType</name><operator>==</operator><name>TK_RANGE</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>TK_ROWS</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>TK_GROUPS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eStart</name><operator>==</operator><name>TK_CURRENT</name> <operator>||</operator> <name>eStart</name><operator>==</operator><name>TK_PRECEDING</name>
           <operator>||</operator> <name>eStart</name><operator>==</operator><name>TK_UNBOUNDED</name> <operator>||</operator> <name>eStart</name><operator>==</operator><name>TK_FOLLOWING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eEnd</name><operator>==</operator><name>TK_CURRENT</name> <operator>||</operator> <name>eEnd</name><operator>==</operator><name>TK_FOLLOWING</name>
           <operator>||</operator> <name>eEnd</name><operator>==</operator><name>TK_UNBOUNDED</name> <operator>||</operator> <name>eEnd</name><operator>==</operator><name>TK_PRECEDING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>eStart</name><operator>==</operator><name>TK_PRECEDING</name> <operator>||</operator> <name>eStart</name><operator>==</operator><name>TK_FOLLOWING</name><operator>)</operator><operator>==</operator><operator>(</operator><name>pStart</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>eEnd</name><operator>==</operator><name>TK_FOLLOWING</name> <operator>||</operator> <name>eEnd</name><operator>==</operator><name>TK_PRECEDING</name><operator>)</operator><operator>==</operator><operator>(</operator><name>pEnd</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bImplicitFrame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>TK_RANGE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Additionally, the
  ** starting boundary type may not occur earlier in the following list than
  ** the ending boundary type:
  **
  **   UNBOUNDED PRECEDING
  **   &lt;expr&gt; PRECEDING
  **   CURRENT ROW
  **   &lt;expr&gt; FOLLOWING
  **   UNBOUNDED FOLLOWING
  **
  ** The parser ensures that "UNBOUNDED PRECEDING" cannot be used as an ending
  ** boundary, and than "UNBOUNDED FOLLOWING" cannot be used as a starting
  ** frame boundary.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eStart</name><operator>==</operator><name>TK_CURRENT</name> <operator>&amp;&amp;</operator> <name>eEnd</name><operator>==</operator><name>TK_PRECEDING</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>eStart</name><operator>==</operator><name>TK_FOLLOWING</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>eEnd</name><operator>==</operator><name>TK_PRECEDING</name> <operator>||</operator> <name>eEnd</name><operator>==</operator><name>TK_CURRENT</name><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unsupported frame specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>windowAllocErr</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pWin</name> <operator>=</operator> <operator>(</operator><name>Window</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Window</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pWin</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>windowAllocErr</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eFrmType</name></name> <operator>=</operator> <name>eType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name> <operator>=</operator> <name>eStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eEnd</name></name> <operator>=</operator> <name>eEnd</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eExclude</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_WindowFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eExclude</name> <operator>=</operator> <name>TK_NO</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>eExclude</name></name> <operator>=</operator> <name>eExclude</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>bImplicitFrame</name></name> <operator>=</operator> <name>bImplicitFrame</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pEnd</name></name> <operator>=</operator> <call><name>sqlite3WindowOffsetExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pStart</name></name> <operator>=</operator> <call><name>sqlite3WindowOffsetExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pWin</name></expr>;</return>

<label><name>windowAllocErr</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attach PARTITION and ORDER BY clauses pPartition and pOrderBy to window
** pWin. Also, if parameter pBase is not NULL, set pWin-&gt;zBase to the
** equivalent nul-terminated string.
*/</comment>
<function><type><name>Window</name> <modifier>*</modifier></type><name>sqlite3WindowAssemble</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl></parameter>, 
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pPartition</name></decl></parameter>, 
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>, 
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pBase</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pWin</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name> <operator>=</operator> <name>pPartition</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBase</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>zBase</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pBase</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pBase</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pPartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pWin</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Window *pWin has just been created from a WINDOW clause. Tokne pBase
** is the base window. Earlier windows from the same WINDOW clause are
** stored in the linked list starting at pWin-&gt;pNextWin. This function
** either updates *pWin according to the base specification, or else
** leaves an error in pParse.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowChain</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>zBase</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pExist</name> <init>= <expr><call><name>windowFind</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pExist</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Check for errors */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"PARTITION clause"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExist</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>&amp;&amp;</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"ORDER BY clause"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExist</name><operator>-&gt;</operator><name>bImplicitFrame</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"frame specification"</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
            <argument><expr><literal type="string">"cannot override %s of window: %s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExist</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pExist</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExist</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>zBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attach window object pWin to expression p.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowAttach</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name> <operator>=</operator> <name>pWin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_WinFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Distinct</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name>TK_FILTER</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
          <argument><expr><literal type="string">"DISTINCT is not supported for window functions"</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WindowDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Possibly link window pWin into the list at pSel-&gt;pWin (window functions
** to be processed as part of SELECT statement pSel). The window is linked
** in if either (a) there are no other windows already linked to this
** SELECT, or (b) the windows already linked use a compatible window frame.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowLink</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pSel</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name></name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3WindowCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name></name></expr></argument>, <argument><expr><name>pWin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name> <operator>=</operator> <name><name>pSel</name><operator>-&gt;</operator><name>pWin</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name><operator>-&gt;</operator><name>ppThis</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name></name> <operator>=</operator> <name>pWin</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>ppThis</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_MultiPart</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return 0 if the two window objects are identical, 1 if they are
** different, or 2 if it cannot be determined if the objects are identical
** or not. Identical window objects can be processed in a single scan.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WindowCompare</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Window</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Window</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bFilter</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p1</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name>p2</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name><name>p2</name><operator>-&gt;</operator><name>eFrmType</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>eStart</name></name><operator>!=</operator><name><name>p2</name><operator>-&gt;</operator><name>eStart</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>eEnd</name></name><operator>!=</operator><name><name>p2</name><operator>-&gt;</operator><name>eEnd</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>eExclude</name></name><operator>!=</operator><name><name>p2</name><operator>-&gt;</operator><name>eExclude</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>res</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>res</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bFilter</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This is called by code in select.c before it calls sqlite3WhereBegin()
** to begin iterating through the sub-query results. It is used to allocate
** and initialize registers and cursors used by sqlite3WindowCodeStep().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowCodeInit</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nEphExpr</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>, <argument><expr><name>nEphExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate registers to use for PARTITION BY values, if any. Initialize
  ** said registers to NULL.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name> <init>= <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regPart</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regPart</name></name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regPart</name></name><operator>+</operator><name>nExpr</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regOne</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regOne</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regEndRowid</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMWin</name><operator>-&gt;</operator><name>csrApp</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regEndRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>!=</operator><name>TK_UNBOUNDED</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The inline versions of min() and max() require a single ephemeral
      ** table and 3 registers. The registers are used as follows:
      **
      **   regApp+0: slot to copy min()/max() argument to for MakeRecord
      **   regApp+1: integer value used to ensure keys are unique
      **   regApp+2: output of MakeRecord
      */</comment>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name> <operator>&amp;&amp;</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name><operator>-&gt;</operator><name>zName</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'i'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>KEYINFO_ORDER_DESC</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>nth_valueName</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>first_valueName</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Allocate two registers at pWin-&gt;regApp. These will be used to
      ** store the start and end index of the current frame.  */</comment>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>leadName</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>lagName</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenDup</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_STARTING_INT</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_ENDING_INT</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_NTH_VALUE_INT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_STARTING_NUM</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_ENDING_NUM</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
** A "PRECEDING &lt;expr&gt;" (eCond==0) or "FOLLOWING &lt;expr&gt;" (eCond==1) or the
** value of the second argument to nth_value() (eCond==2) has just been
** evaluated and the result left in register reg. This function generates VM
** code to check that the value is a non-negative integer and throws an
** exception if it is not.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowCheckValue</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eCond</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azErr</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"frame starting offset must be a non-negative integer"</literal></expr>,
    <expr><literal type="string">"frame ending offset must be a non-negative integer"</literal></expr>,
    <expr><literal type="string">"second argument to nth_value must be a positive integer"</literal></expr>,
    <expr><literal type="string">"frame starting offset must be a non-negative number"</literal></expr>,
    <expr><literal type="string">"frame ending offset must be a non-negative number"</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>aOp</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OP_Ge</name></expr>, <expr><name>OP_Ge</name></expr>, <expr><name>OP_Gt</name></expr>, <expr><name>OP_Ge</name></expr>, <expr><name>OP_Ge</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regZero</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eCond</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eCond</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azErr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eCond</name><operator>&gt;=</operator><name>WINDOW_STARTING_NUM</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regString</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regString</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name>regString</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name><operator>|</operator><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eCond</name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <name>eCond</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eCond</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eCond</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eCond</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aOp</name><index>[<expr><name>eCond</name></expr>]</index></name></expr></argument>, <argument><expr><name>regZero</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverageNeverNullIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* NULL case captured by */</comment>
  <expr_stmt><expr><call><name>VdbeCoverageNeverNullIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*   the OP_MustBeInt */</comment>
  <expr_stmt><expr><call><name>VdbeCoverageNeverNullIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverageNeverNullIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* NULL case caught by */</comment>
  <expr_stmt><expr><call><name>VdbeCoverageNeverNullIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCond</name><operator>==</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*   the OP_Ge */</comment>
  <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>azErr</name><index>[<expr><name>eCond</name></expr>]</index></name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of arguments passed to the window-function associated
** with the object passed as the only argument to this function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>windowArgCount</name><parameter_list>(<parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>pList</name></expr> ?</condition><then> <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>WindowCodeArg</name></name></type> <name>WindowCodeArg</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>WindowCsrAndReg</name></name></type> <name>WindowCsrAndReg</name>;</typedef>

<comment type="block">/*
** See comments above struct WindowCodeArg.
*/</comment>
<struct>struct <name>WindowCsrAndReg</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>csr</name></decl>;</decl_stmt>                        <comment type="block">/* Cursor number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>reg</name></decl>;</decl_stmt>                        <comment type="block">/* First in array of peer values */</comment>
}</block>;</struct>

<comment type="block">/*
** A single instance of this structure is allocated on the stack by 
** sqlite3WindowCodeStep() and a pointer to it passed to the various helper
** routines. This is to reduce the number of arguments required by each
** helper function.
**
** regArg:
**   Each window function requires an accumulator register (just as an
**   ordinary aggregate function does). This variable is set to the first
**   in an array of accumulator registers - one for each window function
**   in the WindowCodeArg.pMWin list.
**
** eDelete:
**   The window functions implementation sometimes caches the input rows
**   that it processes in a temporary table. If it is not zero, this
**   variable indicates when rows may be removed from the temp table (in
**   order to reduce memory requirements - it would always be safe just
**   to leave them there). Possible values for eDelete are:
**
**      WINDOW_RETURN_ROW:
**        An input row can be discarded after it is returned to the caller.
**
**      WINDOW_AGGINVERSE:
**        An input row can be discarded after the window functions xInverse()
**        callbacks have been invoked in it.
**
**      WINDOW_AGGSTEP:
**        An input row can be discarded after the window functions xStep()
**        callbacks have been invoked in it.
**
** start,current,end
**   Consider a window-frame similar to the following:
**
**     (ORDER BY a, b GROUPS BETWEEN 2 PRECEDING AND 2 FOLLOWING)
**
**   The windows functions implmentation caches the input rows in a temp
**   table, sorted by "a, b" (it actually populates the cache lazily, and
**   aggressively removes rows once they are no longer required, but that's
**   a mere detail). It keeps three cursors open on the temp table. One
**   (current) that points to the next row to return to the query engine
**   once its window function values have been calculated. Another (end)
**   points to the next row to call the xStep() method of each window function
**   on (so that it is 2 groups ahead of current). And a third (start) that
**   points to the next row to call the xInverse() method of each window
**   function on.
**
**   Each cursor (start, current and end) consists of a VDBE cursor
**   (WindowCsrAndReg.csr) and an array of registers (starting at
**   WindowCodeArg.reg) that always contains a copy of the peer values 
**   read from the corresponding cursor.
**
**   Depending on the window-frame in question, all three cursors may not
**   be required. In this case both WindowCodeArg.csr and reg are set to
**   0.
*/</comment>
<struct>struct <name>WindowCodeArg</name> <block>{
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>             <comment type="block">/* Parse context */</comment>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name></decl>;</decl_stmt>             <comment type="block">/* First in list of functions being processed */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name></decl>;</decl_stmt>               <comment type="block">/* VDBE object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrGosub</name></decl>;</decl_stmt>             <comment type="block">/* OP_Gosub to this address to return one row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regGosub</name></decl>;</decl_stmt>              <comment type="block">/* Register used with OP_Gosub(addrGosub) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regArg</name></decl>;</decl_stmt>                <comment type="block">/* First in array of accumulator registers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eDelete</name></decl>;</decl_stmt>               <comment type="block">/* See above */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>WindowCsrAndReg</name></type> <name>start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WindowCsrAndReg</name></type> <name>current</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WindowCsrAndReg</name></type> <name>end</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Generate VM code to read the window frames peer values from cursor csr into
** an array of registers starting at reg.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowReadPeerValues</name><parameter_list>(
  <parameter><decl><type><name>WindowCodeArg</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>csr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMWin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pPart</name> <init>= <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iColOff</name> <init>= <expr><name><name>pMWin</name><operator>-&gt;</operator><name>nBufferCol</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>pPart</name></expr> ?</condition><then> <expr><name><name>pPart</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>iColOff</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate VM code to invoke either xStep() (if bInverse is 0) or 
** xInverse (if bInverse is non-zero) for each window function in the 
** linked list starting at pMWin. Or, for built-in window functions
** that do not use the standard function API, generate the required
** inline VM code.
**
** If argument csr is greater than or equal to 0, then argument reg is
** the first register in an array of registers guaranteed to be large
** enough to hold the array of arguments for each function. In this case
** the arguments are extracted from the current row of csr into the
** array of registers before invoking OP_AggStep or OP_AggInverse
**
** Or, if csr is less than zero, then the array of registers at reg is
** already populated with all columns from the current row of the sub-query.
**
** If argument regPartSize is non-zero, then it is a register containing the
** number of rows in the current partition.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowAggStep</name><parameter_list>(
  <parameter><decl><type><name>WindowCodeArg</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name></decl></parameter>,                  <comment type="block">/* Linked list of window functions */</comment>
  <parameter><decl><type><name>int</name></type> <name>csr</name></decl></parameter>,                        <comment type="block">/* Read arguments from this cursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>bInverse</name></decl></parameter>,                   <comment type="block">/* True to invoke xInverse instead of xStep */</comment>
  <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>                         <comment type="block">/* Array of registers */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regArg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><ternary><condition><expr><name><name>pWin</name><operator>-&gt;</operator><name>bExprArgs</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>windowArgCount</name><argument_list>(<argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bInverse</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>!=</operator><name>TK_UNBOUNDED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* All OVER clauses in the same window function aggregate step must
    ** be the same. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWin</name><operator>==</operator><name>pMWin</name> <operator>||</operator> <call><name>sqlite3WindowCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pWin</name></expr></argument>,<argument><expr><name>pMWin</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><name>nth_valueName</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>regArg</name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>!=</operator><name>TK_UNBOUNDED</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addrIsNull</name> <init>= <expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bInverse</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekGE</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regArg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageNeverTaken</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrIsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>nth_valueName</name>
           <operator>||</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>first_valueName</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bInverse</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bInverse</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>bInverse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>xSFunc</name></name><operator>!=</operator><name>noopStepFunc</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addrIf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>regTmp</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>bExprArgs</name></name> <operator>||</operator> <operator>!</operator><name>nArg</name> <operator>||</operator><name>nArg</name><operator>==</operator><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>bExprArgs</name></name> <operator>||</operator> <name>nArg</name>  <operator>||</operator><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>regTmp</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name><operator>+</operator><name>nArg</name></expr></argument>,<argument><expr><name>regTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addrIf</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>regTmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      
      <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>bExprArgs</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iOp</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nArg</name> <operator>=</operator> <name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>regArg</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for<control>(<init><expr><name>iEnd</name><operator>=</operator><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>iOp</name><operator>&lt;</operator><name>iEnd</name></expr>;</condition> <incr><expr><name>iOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Column</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>csr</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CollSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bInverse</name></expr>?</condition><then> <expr><name>OP_AggInverse</name></expr> </then><else>: <expr><name>OP_AggStep</name></expr></else></ternary></expr></argument>, 
                        <argument><expr><name>bInverse</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>bExprArgs</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>addrIf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrIf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Values that may be passed as the second argument to windowCodeOp().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_RETURN_ROW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_AGGINVERSE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_AGGSTEP</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
** Generate VM code to invoke either xValue() (bFin==0) or xFinalize()
** (bFin==1) for each window function in the linked list starting at
** pMWin. Or, for built-in window-functions that do not use the standard
** API, generate the equivalent VM code.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowAggFinal</name><parameter_list>(<parameter><decl><type><name>WindowCodeArg</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bFin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMWin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>!=</operator><name>TK_UNBOUNDED</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Last</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><call><name>windowArgCount</name><argument_list>(<argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>bFin</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AggFinal</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AggValue</name></expr></argument>,<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>,<argument><expr><name>nArg</name></expr></argument>,<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to calculate the current values of all window functions in the
** p-&gt;pMWin list by doing a full scan of the current window frame. Store the
** results in the Window.regResult registers, ready to return the upper
** layer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowFullScan</name><parameter_list>(<parameter><decl><type><name>WindowCodeArg</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMWin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>regCRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Current rowid value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regCPeer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Current peer values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* AggStep rowid value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regPeer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* AggStep peer values */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nPeer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lblNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lblBrk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addrNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>csr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"windowFullScan begin"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMWin</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>csr</name> <operator>=</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPeer</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> ?</condition><then> <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>lblNext</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lblBrk</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>regCRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPeer</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regCPeer</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regPeer</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>, <argument><expr><name>regCRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>windowReadPeerValues</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>, <argument><expr><name>regCPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekGE</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>lblBrk</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrNext</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gt</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regEndRowid</name></name></expr></argument>, <argument><expr><name>lblBrk</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverageNeverNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>==</operator><name>TK_CURRENT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regCRowid</name></expr></argument>, <argument><expr><name>lblNext</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageNeverNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>!=</operator><name>TK_NO</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrEq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>==</operator><name>TK_TIES</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrEq</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regCRowid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageNeverNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>windowReadPeerValues</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>, <argument><expr><name>regCPeer</name></expr></argument>, <argument><expr><name>nPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>lblNext</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageEqNe</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lblNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>addrEq</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>windowAggStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pMWin</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>regArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lblNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>addrNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrNext</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrNext</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPeer</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>, <argument><expr><name>nPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCPeer</name></expr></argument>, <argument><expr><name>nPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>windowAggFinal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"windowFullScan end"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the sub-routine at regGosub (generated by code in select.c) to
** return the current row of Window.iEphCsr. If all window functions are
** aggregate window functions that use the standard API, a single
** OP_Gosub instruction is all that this routine generates. Extra VM code
** for per-row processing is only generated for the following built-in window
** functions:
**
**   nth_value()
**   first_value()
**   lag()
**   lead()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowReturnOneRow</name><parameter_list>(<parameter><decl><type><name>WindowCodeArg</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMWin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>windowFullScan</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>nth_valueName</name>
       <operator>||</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>first_valueName</name></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>csr</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>lbl</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tmpReg</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
        <if_stmt><if>if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>nth_valueName</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>,<argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></argument>,<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>windowCheckValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Add</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gt</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>lbl</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageNeverNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekRowid</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageNeverTaken</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>leadName</name> <operator>||</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>lagName</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>pOwner</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>csr</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>lbl</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tmpReg</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iEph</name> <init>= <expr><name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr></init></decl>;</decl_stmt>
  
        <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>,<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>leadName</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>leadName</name></expr> ?</condition><then> <expr><name>OP_Add</name></expr> </then><else>: <expr><name>OP_Subtract</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>tmpReg2</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tmpReg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>tmpReg2</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>tmpReg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
  
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekRowid</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>iArgCol</name></name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>tmpReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>regGosub</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>addrGosub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to set the accumulator register for each window function
** in the linked list passed as the second argument to NULL. And perform
** any equivalent initialization required by any built-in window functions
** in the list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>windowInitAccum</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regAccum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nArg</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>, <argument><expr><call><name>windowArgCount</name><argument_list>(<argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>nth_valueName</name> <operator>||</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>first_valueName</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>!=</operator><name>TK_UNBOUNDED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetSorter</name></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>csrApp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>regApp</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>regArg</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nArg</name></expr>;</expr_stmt>
  <return>return <expr><name>regArg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return true if the current frame should be cached in the ephemeral table,
** even if there are no xInverse() calls required.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>windowCacheFrame</name><parameter_list>(<parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>pMWin</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name> <init>= <expr><name><name>pWin</name><operator>-&gt;</operator><name>pWFunc</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>nth_valueName</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>first_valueName</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>leadName</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><name>lagName</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** regOld and regNew are each the first register in an array of size
** pOrderBy-&gt;nExpr. This function generates code to compare the two
** arrays of registers using the collation sequences and other comparison
** parameters specified by pOrderBy. 
**
** If the two arrays are not equal, the contents of regNew is copied to 
** regOld and control falls through. Otherwise, if the contents of the arrays
** are equal, an OP_Goto is executed. The address of the OP_Goto is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowIfNewPeer</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>regNew</name></decl></parameter>,                     <comment type="block">/* First in array of new values */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOld</name></decl></parameter>,                     <comment type="block">/* First in array of old values */</comment>
  <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>                        <comment type="block">/* Jump here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>regOld</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, 
      <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageEqNe</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>, <argument><expr><name>regOld</name></expr></argument>, <argument><expr><name>nVal</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as part of generating VM programs for RANGE
** offset PRECEDING/FOLLOWING frame boundaries. Assuming "ASC" order for
** the ORDER BY term in the window, and that argument op is OP_Ge, it generates
** code equivalent to:
**
**   if( csr1.peerVal + regVal &gt;= csr2.peerVal ) goto lbl;
**
** The value of parameter op may also be OP_Gt or OP_Le. In these cases the
** operator in the above pseudo-code is replaced with "&gt;" or "&lt;=", respectively.
**
** If the sort-order for the ORDER BY term in the window is DESC, then the
** comparison is reversed. Instead of adding regVal to csr1.peerVal, it is
** subtracted. And the comparison operator is inverted to - "&gt;=" becomes "&lt;=",
** "&gt;" becomes "&lt;", and so on. So, with DESC sort order, if the argument op
** is OP_Ge, the generated code is equivalent to:
**
**   if( csr1.peerVal - regVal &lt;= csr2.peerVal ) goto lbl;
**
** A special type of arithmetic is used such that if csr1.peerVal is not
** a numeric type (real or integer), then the result of the addition
** or subtraction is a a copy of csr1.peerVal.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>windowCodeRangeTest</name><parameter_list>(
  <parameter><decl><type><name>WindowCodeArg</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                         <comment type="block">/* OP_Ge, OP_Gt, or OP_Le */</comment>
  <parameter><decl><type><name>int</name></type> <name>csr1</name></decl></parameter>,                       <comment type="block">/* Cursor number for cursor 1 */</comment>
  <parameter><decl><type><name>int</name></type> <name>regVal</name></decl></parameter>,                     <comment type="block">/* Register containing non-negative number */</comment>
  <parameter><decl><type><name>int</name></type> <name>csr2</name></decl></parameter>,                       <comment type="block">/* Cursor number for cursor 2 */</comment>
  <parameter><decl><type><name>int</name></type> <name>lbl</name></decl></parameter>                         <comment type="block">/* Jump destination if condition is true */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* ORDER BY clause for window */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>reg1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* Reg. for csr1.peerVal+regVal */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>reg2</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* Reg. for csr2.peerVal */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regString</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Reg. for constant value '' */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>arith</name> <init>= <expr><name>OP_Add</name></expr></init></decl>;</decl_stmt>                       <comment type="block">/* OP_Add or OP_Subtract */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrGe</name></decl>;</decl_stmt>                               <comment type="block">/* Jump destination */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrDone</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* Address past OP_Ge */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>

  <comment type="block">/* Read the peer-value from each cursor into a register */</comment>
  <expr_stmt><expr><call><name>windowReadPeerValues</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>csr1</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>windowReadPeerValues</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>csr2</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Gt</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name> <operator>&amp;&amp;</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OP_Ge</name></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Le</name></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>OP_Gt</name></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Lt</name></expr>;</expr_stmt> <break>break;</break>
      <default>default:</default> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Ge</name></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>arith</name> <operator>=</operator> <name>OP_Subtract</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"CodeRangeTest: if( R%d %s R%d %s R%d ) goto lbl"</literal><operator>,</operator>
      <name>reg1</name><operator>,</operator> <operator>(</operator><ternary><condition><expr><name>arith</name><operator>==</operator><name>OP_Add</name></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary><operator>)</operator><operator>,</operator> <name>regVal</name><operator>,</operator>
      <operator>(</operator><ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>OP_Ge</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"&gt;="</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>OP_Le</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"&lt;="</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>OP_Gt</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"&gt;"</literal></expr> </then><else>: <expr><literal type="string">"&lt;"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary><operator>)</operator><operator>,</operator> <name>reg2</name>
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the BIGNULL flag is set for the ORDER BY, then it is required to 
  ** consider NULL values to be larger than all other values, instead of 
  ** the usual smaller. The VDBE opcodes OP_Ge and so on do not handle this
  ** (and adding that capability causes a performance regression), so
  ** instead if the BIGNULL flag is set then cases where either reg1 or
  ** reg2 are NULL are handled separately in the following block. The code
  ** generated is equivalent to:
  **
  **   if( reg1 IS NULL ){
  **     if( op==OP_Ge ) goto lbl;
  **     if( op==OP_Gt &amp;&amp; reg2 IS NOT NULL ) goto lbl;
  **     if( op==OP_Le &amp;&amp; reg2 IS NULL ) goto lbl;
  **   }else if( reg2 IS NULL ){
  **     if( op==OP_Le ) goto lbl;
  **   }
  **
  ** Additionally, if either reg1 or reg2 are NULL but the jump to lbl is 
  ** not taken, control jumps over the comparison operator coded below this
  ** block.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This block runs if reg1 contains a NULL. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OP_Ge</name></expr>:</case> 
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
      <case>case <expr><name>OP_Gt</name></expr>:</case> 
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
      <case>case <expr><name>OP_Le</name></expr>:</case> 
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
      <default>default:</default> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no-op */</comment> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This block runs if reg1 is not NULL, but reg2 is. */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>,
                      <argument><expr><ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>OP_Gt</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Ge</name><operator>)</operator></expr> ?</condition><then> <expr><name>addrDone</name></expr> </then><else>: <expr><name>lbl</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).
  ** This block adds (or subtracts for DESC) the numeric value in regVal
  ** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),
  ** then leave reg1 as it is. In pseudo-code, this is implemented as:
  **
  **   if( reg1&gt;='' ) goto addrGe;
  **   reg1 = reg1 +/- regVal
  **   addrGe:
  **
  ** Since all strings and blobs are greater-than-or-equal-to an empty string,
  ** the add/subtract is skipped for these, as required. If reg1 is a NULL,
  ** then the arithmetic is performed, but since adding or subtracting from
  ** NULL is always NULL anyway, this case is handled as required too.  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regString</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrGe</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name>regString</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op</name><operator>==</operator><name>OP_Ge</name> <operator>&amp;&amp;</operator> <name>arith</name><operator>==</operator><name>OP_Add</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>op</name><operator>==</operator><name>OP_Le</name> <operator>&amp;&amp;</operator> <name>arith</name><operator>==</operator><name>OP_Subtract</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>arith</name></expr></argument>, <argument><expr><name>regVal</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrGe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compare registers reg2 and reg1, taking the jump if required. Note that
  ** control skips over this test if the BIGNULL flag is set and either
  ** reg1 or reg2 contain a NULL value.  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Gt</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Lt</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"CodeRangeTest: end"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Helper function for sqlite3WindowCodeStep(). Each call to this function
** generates VM code for a single RETURN_ROW, AGGSTEP or AGGINVERSE 
** operation. Refer to the header comment for sqlite3WindowCodeStep() for
** details.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>windowCodeOp</name><parameter_list>(
 <parameter><decl><type><name>WindowCodeArg</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                <comment type="block">/* Context object */</comment>
 <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                          <comment type="block">/* WINDOW_RETURN_ROW, AGGSTEP or AGGINVERSE */</comment>
 <parameter><decl><type><name>int</name></type> <name>regCountdown</name></decl></parameter>,                <comment type="block">/* Register for OP_IfPos countdown */</comment>
 <parameter><decl><type><name>int</name></type> <name>jumpOnEof</name></decl></parameter>                    <comment type="block">/* Jump here if stepped cursor reaches EOF */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>csr</name></decl>, <decl><type ref="prev"/><name>reg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMWin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addrContinue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bPeer</name> <init>= <expr><operator>(</operator><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name>TK_ROWS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>lblDone</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addrNextRange</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Special case - WINDOW_AGGINVERSE is always a no-op if the frame
  ** starts with UNBOUNDED PRECEDING. */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WINDOW_AGGINVERSE</name> <operator>&amp;&amp;</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_UNBOUNDED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regCountdown</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpOnEof</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>regCountdown</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrNextRange</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>WINDOW_AGGINVERSE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>WINDOW_AGGSTEP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WINDOW_AGGINVERSE</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>windowCodeRangeTest</name><argument_list>(
              <argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Le</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regCountdown</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>windowCodeRangeTest</name><argument_list>(
              <argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regCountdown</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>windowCodeRangeTest</name><argument_list>(
            <argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Gt</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>end</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regCountdown</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>regCountdown</name></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WINDOW_RETURN_ROW</name> <operator>&amp;&amp;</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>windowAggFinal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>addrContinue</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a (RANGE BETWEEN a FOLLOWING AND b FOLLOWING) or
  ** (RANGE BETWEEN b PRECEDING AND a PRECEDING) frame, ensure the 
  ** start cursor does not advance past the end cursor within the 
  ** temporary table. It otherwise might, if (a&gt;b). Also ensure that,
  ** if the input cursor is still finding new rows, that the end
  ** cursor does not go past it to EOF. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name> <operator>&amp;&amp;</operator> <name>regCountdown</name>
   <operator>&amp;&amp;</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regRowid1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regRowid2</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WINDOW_AGGINVERSE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regRowid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>end</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regRowid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name>regRowid2</name></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>, <argument><expr><name>regRowid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>regRowid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>end</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regRowid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>regRowid</name></name></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>, <argument><expr><name>regRowid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageNeverNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_PRECEDING</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>WINDOW_RETURN_ROW</name></expr>:</case>
      <expr_stmt><expr><name>csr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>current</name><operator>.</operator><name>csr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>current</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>windowReturnOneRow</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>WINDOW_AGGINVERSE</name></expr>:</case>
      <expr_stmt><expr><name>csr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>csr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regEndRowid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>windowAggStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pMWin</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>regArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>

    <default>default:</default>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>WINDOW_AGGSTEP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>csr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name><operator>.</operator><name>csr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regEndRowid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regEndRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>windowAggStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pMWin</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>regArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>eDelete</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_SAVEPOSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>jumpOnEof</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>bPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bPeer</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bPeer</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nReg</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> ?</condition><then> <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regTmp</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>nReg</name></expr> ?</condition><then> <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>windowReadPeerValues</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>regTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>windowIfNewPeer</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>regTmp</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>addrContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regTmp</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>addrNextRange</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrNextRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lblDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Allocate and return a duplicate of the Window object indicated by the
** third argument. Set the Window.pOwner field of the new object to
** pOwner.
*/</comment>
<function><type><name>Window</name> <modifier>*</modifier></type><name>sqlite3WindowDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOwner</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Window</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zBase</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pFilter</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWFunc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWFunc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPartition</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eFrmType</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eFrmType</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eEnd</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eEnd</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eStart</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eStart</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eExclude</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eExclude</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>regResult</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>regResult</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>regAccum</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>regAccum</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iArgCol</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iArgCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iEphCsr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bExprArgs</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>bExprArgs</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pStart</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pEnd</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pOwner</name></name> <operator>=</operator> <name>pOwner</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bImplicitFrame</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>bImplicitFrame</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a copy of the linked list of Window objects passed as the
** second argument.
*/</comment>
<function><type><name>Window</name> <modifier>*</modifier></type><name>sqlite3WindowListDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Window</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pWin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>&amp;</operator><name>pRet</name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pWin</name><operator>=</operator><name>p</name></expr>;</init> <condition><expr><name>pWin</name></expr>;</condition> <incr><expr><name>pWin</name><operator>=</operator><name><name>pWin</name><operator>-&gt;</operator><name>pNextWin</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <call><name>sqlite3WindowDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNextWin</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if it can be determined at compile time that expression 
** pExpr evaluates to a value that, when cast to an integer, is greater 
** than zero. False otherwise.
**
** If an OOM error occurs, this function sets the Parse.db.mallocFailed 
** flag and returns zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>windowExprGtZero</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVal</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** sqlite3WhereBegin() has already been called for the SELECT statement 
** passed as the second argument when this function is invoked. It generates
** code to populate the Window.regResult register for each window function 
** and invoke the sub-routine at instruction addrGosub once for each row.
** sqlite3WhereEnd() is always called before returning. 
**
** This function handles several different types of window frames, which
** require slightly different processing. The following pseudo code is
** used to implement window frames of the form:
**
**   ROWS BETWEEN &lt;expr1&gt; PRECEDING AND &lt;expr2&gt; FOLLOWING
**
** Other window frame types use variants of the following:
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       
**       if( first row of partition ){
**         // Rewind three cursors, all open on the eph table.
**         Rewind(csrEnd);
**         Rewind(csrStart);
**         Rewind(csrCurrent);
**       
**         regEnd = &lt;expr2&gt;          // FOLLOWING expression
**         regStart = &lt;expr1&gt;        // PRECEDING expression
**       }else{
**         // First time this branch is taken, the eph table contains two 
**         // rows. The first row in the partition, which all three cursors
**         // currently point to, and the following row.
**         AGGSTEP
**         if( (regEnd--)&lt;=0 ){
**           RETURN_ROW
**           if( (regStart--)&lt;=0 ){
**             AGGINVERSE
**           }
**         }
**       }
**     }
**     flush:
**       AGGSTEP
**       while( 1 ){
**         RETURN ROW
**         if( csrCurrent is EOF ) break;
**         if( (regStart--)&lt;=0 ){
**           AggInverse(csrStart)
**           Next(csrStart)
**         }
**       }
**
** The pseudo-code above uses the following shorthand:
**
**   AGGSTEP:    invoke the aggregate xStep() function for each window function
**               with arguments read from the current row of cursor csrEnd, then
**               step cursor csrEnd forward one row (i.e. sqlite3BtreeNext()).
**
**   RETURN_ROW: return a row to the caller based on the contents of the 
**               current row of csrCurrent and the current state of all 
**               aggregates. Then step cursor csrCurrent forward one row.
**
**   AGGINVERSE: invoke the aggregate xInverse() function for each window 
**               functions with arguments read from the current row of cursor
**               csrStart. Then step csrStart forward one row.
**
** There are two other ROWS window frames that are handled significantly
** differently from the above - "BETWEEN &lt;expr&gt; PRECEDING AND &lt;expr&gt; PRECEDING"
** and "BETWEEN &lt;expr&gt; FOLLOWING AND &lt;expr&gt; FOLLOWING". These are special 
** cases because they change the order in which the three cursors (csrStart,
** csrCurrent and csrEnd) iterate through the ephemeral table. Cases that
** use UNBOUNDED or CURRENT ROW are much simpler variations on one of these
** three.
**
**   ROWS BETWEEN &lt;expr1&gt; PRECEDING AND &lt;expr2&gt; PRECEDING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = &lt;expr2&gt;
**         regStart = &lt;expr1&gt;
**       }else{
**         if( (regEnd--)&lt;=0 ){
**           AGGSTEP
**         }
**         RETURN_ROW
**         if( (regStart--)&lt;=0 ){
**           AGGINVERSE
**         }
**       }
**     }
**     flush:
**       if( (regEnd--)&lt;=0 ){
**         AGGSTEP
**       }
**       RETURN_ROW
**
**
**   ROWS BETWEEN &lt;expr1&gt; FOLLOWING AND &lt;expr2&gt; FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**       regEnd = &lt;expr2&gt;
**       regStart = regEnd - &lt;expr1&gt;
**     }else{
**       AGGSTEP
**       if( (regEnd--)&lt;=0 ){
**         RETURN_ROW
**       }
**       if( (regStart--)&lt;=0 ){
**         AGGINVERSE
**       }
**     }
**   }
**   flush:
**     AGGSTEP
**     while( 1 ){
**       if( (regEnd--)&lt;=0 ){
**         RETURN_ROW
**         if( eof ) break;
**       }
**       if( (regStart--)&lt;=0 ){
**         AGGINVERSE
**         if( eof ) break
**       }
**     }
**     while( !eof csrCurrent ){
**       RETURN_ROW
**     }
**
** For the most part, the patterns above are adapted to support UNBOUNDED by
** assuming that it is equivalent to "infinity PRECEDING/FOLLOWING" and
** CURRENT ROW by assuming that it is equivilent to "0 PRECEDING/FOLLOWING".
** This is optimized of course - branches that will never be taken and
** conditions that are always true are omitted from the VM code. The only
** exceptional case is:
**
**   ROWS BETWEEN &lt;expr1&gt; FOLLOWING AND UNBOUNDED FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**       regStart = &lt;expr1&gt;
**     }else{
**       AGGSTEP
**     }
**   }
**   flush:
**     AGGSTEP
**     while( 1 ){
**       if( (regStart--)&lt;=0 ){
**         AGGINVERSE
**         if( eof ) break
**       }
**       RETURN_ROW
**     }
**     while( !eof csrCurrent ){
**       RETURN_ROW
**     }
**
** Also requiring special handling are the cases:
**
**   ROWS BETWEEN &lt;expr1&gt; PRECEDING AND &lt;expr2&gt; PRECEDING
**   ROWS BETWEEN &lt;expr1&gt; FOLLOWING AND &lt;expr2&gt; FOLLOWING
**
** when (expr1 &lt; expr2). This is detected at runtime, not by this function.
** To handle this case, the pseudo-code programs depicted above are modified
** slightly to be:
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**       regEnd = &lt;expr2&gt;
**       regStart = &lt;expr1&gt;
**       if( regEnd &lt; regStart ){
**         RETURN_ROW
**         delete eph table contents
**         continue
**       }
**     ...
**
** The new "continue" statement in the above jumps to the next iteration
** of the outer loop - the one started by sqlite3WhereBegin().
**
** The various GROUPS cases are implemented using the same patterns as
** ROWS. The VM code is modified slightly so that:
**
**   1. The else branch in the main loop is only taken if the row just
**      added to the ephemeral table is the start of a new group. In
**      other words, it becomes:
**
**         ... loop started by sqlite3WhereBegin() ...
**         if( new partition ){
**           Gosub flush
**         }
**         Insert new row into eph table.
**         if( first row of partition ){
**           Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**           regEnd = &lt;expr2&gt;
**           regStart = &lt;expr1&gt;
**         }else if( new group ){
**           ... 
**         }
**       }
**
**   2. Instead of processing a single row, each RETURN_ROW, AGGSTEP or 
**      AGGINVERSE step processes the current row of the relevant cursor and
**      all subsequent rows belonging to the same group.
**
** RANGE window frames are a little different again. As for GROUPS, the 
** main loop runs once per group only. And RETURN_ROW, AGGSTEP and AGGINVERSE
** deal in groups instead of rows. As for ROWS and GROUPS, there are three
** basic cases:
**
**   RANGE BETWEEN &lt;expr1&gt; PRECEDING AND &lt;expr2&gt; FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = &lt;expr2&gt;
**         regStart = &lt;expr1&gt;
**       }else{
**         AGGSTEP
**         while( (csrCurrent.key + regEnd) &lt; csrEnd.key ){
**           RETURN_ROW
**           while( csrStart.key + regStart) &lt; csrCurrent.key ){
**             AGGINVERSE
**           }
**         }
**       }
**     }
**     flush:
**       AGGSTEP
**       while( 1 ){
**         RETURN ROW
**         if( csrCurrent is EOF ) break;
**           while( csrStart.key + regStart) &lt; csrCurrent.key ){
**             AGGINVERSE
**           }
**         }
**       }
**
** In the above notation, "csr.key" means the current value of the ORDER BY 
** expression (there is only ever 1 for a RANGE that uses an &lt;expr&gt; FOLLOWING
** or &lt;expr PRECEDING) read from cursor csr.
**
**   RANGE BETWEEN &lt;expr1&gt; PRECEDING AND &lt;expr2&gt; PRECEDING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = &lt;expr2&gt;
**         regStart = &lt;expr1&gt;
**       }else{
**         while( (csrEnd.key + regEnd) &lt;= csrCurrent.key ){
**           AGGSTEP
**         }
**         while( (csrStart.key + regStart) &lt; csrCurrent.key ){
**           AGGINVERSE
**         }
**         RETURN_ROW
**       }
**     }
**     flush:
**       while( (csrEnd.key + regEnd) &lt;= csrCurrent.key ){
**         AGGSTEP
**       }
**       while( (csrStart.key + regStart) &lt; csrCurrent.key ){
**         AGGINVERSE
**       }
**       RETURN_ROW
**
**   RANGE BETWEEN &lt;expr1&gt; FOLLOWING AND &lt;expr2&gt; FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = &lt;expr2&gt;
**         regStart = &lt;expr1&gt;
**       }else{
**         AGGSTEP
**         while( (csrCurrent.key + regEnd) &lt; csrEnd.key ){
**           while( (csrCurrent.key + regStart) &gt; csrStart.key ){
**             AGGINVERSE
**           }
**           RETURN_ROW
**         }
**       }
**     }
**     flush:
**       AGGSTEP
**       while( 1 ){
**         while( (csrCurrent.key + regStart) &gt; csrStart.key ){
**           AGGINVERSE
**           if( eof ) break "while( 1 )" loop.
**         }
**         RETURN_ROW
**       }
**       while( !eof csrCurrent ){
**         RETURN_ROW
**       }
**
** The text above leaves out many details. Refer to the code and comments
** below for a more complete picture.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WindowCodeStep</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                      <comment type="block">/* Rewritten SELECT statement */</comment>
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,              <comment type="block">/* Context returned by sqlite3WhereBegin() */</comment>
  <parameter><decl><type><name>int</name></type> <name>regGosub</name></decl></parameter>,                   <comment type="block">/* Register for OP_Gosub */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrGosub</name></decl></parameter>                   <comment type="block">/* OP_Gosub here to return each row */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Window</name> <modifier>*</modifier></type><name>pMWin</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pWin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>csrWrite</name></decl>;</decl_stmt>                   <comment type="block">/* Cursor used to write to eph. table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>csrInput</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Cursor of sub-select */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nInput</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of cols returned by sub */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iInput</name></decl>;</decl_stmt>                               <comment type="block">/* To iterate through sub cols */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrNe</name></decl>;</decl_stmt>                     <comment type="block">/* Address of OP_Ne */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrGosubFlush</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Address of OP_Gosub to flush: */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrInteger</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Address of OP_Integer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrEmpty</name></decl>;</decl_stmt>                  <comment type="block">/* Address of OP_Rewind in flush: */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regNew</name></decl>;</decl_stmt>                     <comment type="block">/* Array of registers holding new input row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name></decl>;</decl_stmt>                  <comment type="block">/* regNew array in record form */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regNewPeer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Peer values for new row (part of regNew) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regPeer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Peer values for current row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFlushPart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Register for "Gosub flush_partition" */</comment>
  <decl_stmt><decl><type><name>WindowCodeArg</name></type> <name>s</name></decl>;</decl_stmt>                <comment type="block">/* Context object for sub-routines */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lblWhereEnd</name></decl>;</decl_stmt>                <comment type="block">/* Label just before sqlite3WhereEnd() code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Value of &lt;expr&gt; PRECEDING */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Value of &lt;expr&gt; FOLLOWING */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_PRECEDING</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_CURRENT</name> 
       <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_UNBOUNDED</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_FOLLOWING</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_CURRENT</name> 
       <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_UNBOUNDED</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_PRECEDING</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>==</operator><name>TK_CURRENT</name>
       <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>==</operator><name>TK_GROUP</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>==</operator><name>TK_TIES</name>
       <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eExclude</name></name><operator>==</operator><name>TK_NO</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>lblWhereEnd</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fill in the context object */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WindowCodeArg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>pMWin</name></name> <operator>=</operator> <name>pMWin</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>pVdbe</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>regGosub</name></name> <operator>=</operator> <name>regGosub</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>addrGosub</name></name> <operator>=</operator> <name>addrGosub</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name> <operator>=</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>iEphCsr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>csrWrite</name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>start</name><operator>.</operator><name>csr</name></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>end</name><operator>.</operator><name>csr</name></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name><operator>+</operator><literal type="number">3</literal></expr>;</expr_stmt>

  <comment type="block">/* Figure out when rows may be deleted from the ephemeral table. There
  ** are four options - they may never be deleted (eDelete==0), they may 
  ** be deleted as soon as they are no longer part of the window frame
  ** (eDelete==WINDOW_AGGINVERSE), they may be deleted as after the row 
  ** has been returned to the caller (WINDOW_RETURN_ROW), or they may
  ** be deleted after they enter the frame (WINDOW_AGGSTEP). */</comment>
  <switch>switch<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_FOLLOWING</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name>TK_RANGE</name>
       <operator>&amp;&amp;</operator> <call><name>windowExprGtZero</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>eDelete</name></name> <operator>=</operator> <name>WINDOW_RETURN_ROW</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>TK_UNBOUNDED</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><call><name>windowCacheFrame</name><argument_list>(<argument><expr><name>pMWin</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_PRECEDING</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name>TK_RANGE</name>
           <operator>&amp;&amp;</operator> <call><name>windowExprGtZero</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>)</argument_list></call></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>.</operator><name>eDelete</name></name> <operator>=</operator> <name>WINDOW_AGGSTEP</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>.</operator><name>eDelete</name></name> <operator>=</operator> <name>WINDOW_RETURN_ROW</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name><name>s</name><operator>.</operator><name>eDelete</name></name> <operator>=</operator> <name>WINDOW_AGGINVERSE</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Allocate registers for the array of values from the sub-query, the
  ** samve values in record form, and the rowid used to insert said record
  ** into the ephemeral table.  */</comment>
  <expr_stmt><expr><name>regNew</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nInput</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRecord</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>regRowid</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>

  <comment type="block">/* If the window frame contains an "&lt;expr&gt; PRECEDING" or "&lt;expr&gt; FOLLOWING"
  ** clause, allocate registers to store the results of evaluating each
  ** &lt;expr&gt;.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_PRECEDING</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regStart</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_PRECEDING</name> <operator>||</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regEnd</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is not a "ROWS BETWEEN ..." frame, then allocate arrays of
  ** registers to store copies of the ORDER BY expressions (peer values) 
  ** for the main loop, and for each cursor (start, current and end). */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name>TK_ROWS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nPeer</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>pOrderBy</name></expr> ?</condition><then> <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>regNewPeer</name> <operator>=</operator> <name>regNew</name> <operator>+</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>nBufferCol</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>regNewPeer</name> <operator>+=</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>regPeer</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>       <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPeer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>.</operator><name>start</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>   <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPeer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPeer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>.</operator><name>end</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>     <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPeer</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Load the column values for the row returned by the sub-select
  ** into an array of registers starting at regNew. Assemble them into
  ** a record in register regRecord. */</comment>
  <for>for<control>(<init><expr><name>iInput</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iInput</name><operator>&lt;</operator><name>nInput</name></expr>;</condition> <incr><expr><name>iInput</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>csrInput</name></expr></argument>, <argument><expr><name>iInput</name></expr></argument>, <argument><expr><name>regNew</name><operator>+</operator><name>iInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>, <argument><expr><name>nInput</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* An input row has just been read into an array of registers starting
  ** at regNew. If the window has a PARTITION clause, this block generates 
  ** VM code to check if the input row is the start of a new partition.
  ** If so, it does an OP_Gosub to an address to be filled in later. The
  ** address of the OP_Gosub is stored in local variable addrGosubFlush. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pPart</name> <init>= <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nPart</name> <init>= <expr><name><name>pPart</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regNewPart</name> <init>= <expr><name>regNew</name> <operator>+</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>nBufferCol</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><call><name>sqlite3KeyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>regFlushPart</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>regNewPart</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regPart</name></name></expr></argument>, <argument><expr><name>nPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>addr</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>addr</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>addr</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageEqNe</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrGosubFlush</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regFlushPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"call flush_partition"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regNewPart</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regPart</name></name></expr></argument>, <argument><expr><name>nPart</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Insert the new row into the ephemeral table */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>csrWrite</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>regRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>csrWrite</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>regRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrNe</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ne</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regOne</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>regRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverageNeverNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This block is run for the first row of each partition */</comment>
  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>regArg</name></name> <operator>=</operator> <call><name>windowInitAccum</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pMWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>regStart</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pStart</name></name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>windowCheckValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name></expr>?</condition><then><expr><literal type="number">3</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>regEnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>windowCheckValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name></expr>?</condition><then><expr><literal type="number">3</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name>TK_RANGE</name> <operator>&amp;&amp;</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name> <operator>&amp;&amp;</operator> <name>regStart</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_Ge</name></expr> </then><else>: <expr><name>OP_Le</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrGe</name> <init>= <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageNeverNullIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* NeverNull because bound &lt;expr&gt; */</comment>
    <expr_stmt><expr><call><name>VdbeCoverageNeverNullIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*   values previously checked */</comment>
    <expr_stmt><expr><call><name>windowAggFinal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageNeverTaken</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>windowReturnOneRow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetSorter</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lblWhereEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrGe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name> <operator>&amp;&amp;</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>!=</operator><name>TK_RANGE</name> <operator>&amp;&amp;</operator> <name>regEnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Subtract</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>!=</operator><name>TK_UNBOUNDED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>start</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageNeverTaken</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverageNeverTaken</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>end</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverageNeverTaken</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>regPeer</name> <operator>&amp;&amp;</operator> <name>pOrderBy</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regNewPeer</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>start</name><operator>.</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>end</name><operator>.</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lblWhereEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrNe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Beginning of the block executed for the second and subsequent rows. */</comment>
  <if_stmt><if>if<condition>( <expr><name>regPeer</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>windowIfNewPeer</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>regNewPeer</name></expr></argument>, <argument><expr><name>regPeer</name></expr></argument>, <argument><expr><name>lblWhereEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGSTEP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>!=</operator><name>TK_UNBOUNDED</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>lbl</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>addrNext</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>windowCodeRangeTest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>end</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_PRECEDING</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bRPS</name> <init>= <expr><operator>(</operator><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_PRECEDING</name> <operator>&amp;&amp;</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGSTEP</name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bRPS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bRPS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGSTEP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>!=</operator><name>TK_UNBOUNDED</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>lbl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>regEnd</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>lbl</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>windowCodeRangeTest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>end</name><operator>.</operator><name>csr</name></name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>regEnd</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>regEnd</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>regEnd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* End of the main input loop */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lblWhereEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fall through */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addrInteger</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regFlushPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrGosubFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>s</name><operator>.</operator><name>regRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrEmpty</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>csrWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_PRECEDING</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bRPS</name> <init>= <expr><operator>(</operator><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_PRECEDING</name> <operator>&amp;&amp;</operator> <name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGSTEP</name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bRPS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eStart</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addrStart</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrBreak1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrBreak2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrBreak3</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGSTEP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eFrmType</name></name><operator>==</operator><name>TK_RANGE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrStart</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrBreak2</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrBreak1</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_UNBOUNDED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrStart</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrBreak1</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrBreak2</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>eEnd</name></name><operator>==</operator><name>TK_FOLLOWING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrStart</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrBreak1</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><name>regEnd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrBreak2</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrStart</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrBreak3</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addrBreak</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrStart</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGSTEP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrStart</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrBreak</name> <operator>=</operator> <call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_RETURN_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>windowCodeOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>WINDOW_AGGINVERSE</name></expr></argument>, <argument><expr><name>regStart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetSorter</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>current</name><operator>.</operator><name>csr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regStartRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pMWin</name><operator>-&gt;</operator><name>regEndRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInteger</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regFlushPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>
</unit>
