<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/test_func.c"><comment type="block">/*
** 2008 March 19
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Code for testing all sorts of SQLite interfaces.  This code
** implements new SQL functions used by the test scripts.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_SQLITE_TCL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"sqlite_tcl.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"tcl.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Allocate nByte bytes of space using sqlite3_malloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>testContextMalloc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>z</name> <operator>&amp;&amp;</operator> <name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function generates a string of random characters.  Used for
** generating test data.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>randStr</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>zSrc</name><index>[]</index></name> <init>= 
     <expr><literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
     <literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal>
     <literal type="string">"0123456789"</literal>
     <literal type="string">".-!,:*^+=_|?/&lt;&gt; "</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMin</name></decl>, <decl><type ref="prev"/><name>iMax</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* It used to be possible to call randstr() with any number of arguments,
  ** but now it is registered with SQLite as requiring exactly 2.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iMin</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iMin</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iMin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iMin</name><operator>&gt;=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iMin</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iMax</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iMax</name><operator>&lt;</operator><name>iMin</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name>iMin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iMax</name><operator>&gt;=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iMax</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>iMin</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iMax</name><operator>&gt;</operator><name>iMin</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>r</name><operator>%</operator><operator>(</operator><name>iMax</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>iMin</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zSrc</name><index>[<expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>%</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following two SQL functions are used to test returning a text
** result with a destructor. Function 'test_destructor' takes one argument
** and returns the same argument interpreted as TEXT. A destructor is
** passed with the sqlite3_result_text() call.
**
** SQL function 'test_destructor_count' returns the number of outstanding 
** allocations made by 'test_destructor';
**
** WARNING: Not threadsafe.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>test_destructor_count_var</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>destructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zVal</name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>test_destructor_count_var</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_destructor</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>test_destructor_count_var</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zVal</name></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zVal</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>destructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_destructor16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>test_destructor_count_var</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3_value_bytes16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zVal</name></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zVal</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text16</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>destructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_destructor_count</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>test_destructor_count_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following aggregate function, test_agg_errmsg16(), takes zero 
** arguments. It returns the text value returned by the sqlite3_errmsg16()
** API function.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_UNTESTABLE</name></cpp:ifndef>
<function_decl><type><name>void</name></type> <name>sqlite3BeginBenignMalloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3EndBenignMalloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3BeginBenignMalloc</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3EndBenignMalloc</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_agg_errmsg16_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_agg_errmsg16_final</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type> <name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">2048</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_errmsg16</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text16</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Routines for testing the sqlite3_get_auxdata() and sqlite3_set_auxdata()
** interface.
**
** The test_auxdata() SQL function attempts to register each of its arguments
** as auxiliary data.  If there are no prior registrations of aux data for
** that argument (meaning the argument is not a constant or this is its first
** call) then the result for that argument is 0.  If there is a prior
** registration, the result for that argument is 1.  The overall result
** is the individual argument results separated by spaces.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>free_test_auxdata</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content><expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_auxdata</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nArg</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zRet</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nArg</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAux</name> <init>= <expr><call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zAux</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'1'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zAux</name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else <block>{<block_content>
        <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zAux</name> <operator>=</operator> <call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zAux</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zAux</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_set_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zAux</name></expr></argument>, <argument><expr><name>free_test_auxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>free_test_auxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** A function to test error reporting from user functions. This function
** returns a copy of its first argument as the error message.  If the
** second argument exists, it becomes the error code.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_error</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the counter(X) function.  If X is an integer
** constant, then the first invocation will return X.  The second X+1.
** and so forth.  Can be used (for example) to provide a sequence number
** in a result set.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>counterFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,   <comment type="block">/* Function context */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                <comment type="block">/* Number of function arguments */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>     <comment type="block">/* Values for all function arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pCounter</name> <init>= <expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCounter</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pCounter</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCounter</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCounter</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pCounter</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_set_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pCounter</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>++</operator><operator>*</operator><name>pCounter</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>*</operator><name>pCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This function takes two arguments.  It performance UTF-8/16 type
** conversions on the first argument then returns a copy of the second
** argument.
**
** This function is used in cases such as the following:
**
**      SELECT test_isolation(x,x) FROM t1;
**
** We want to verify that the type conversions that occur on the
** first argument do not invalidate the second argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_isolation</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke an SQL statement recursively.  The function result is the 
** first column of the first row of the result set.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_eval</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"sqlite3_prepare_v2() error: %s"</literal></expr></argument>,<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** convert one character from hex to binary
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testHexChar</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'f'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'F'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert hex to binary.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testHexToBin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zOut</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><call><name>testHexChar</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>testHexChar</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
**      hex_to_utf16be(HEX)
**
** Convert the input string from HEX into binary.  Then return the
** result using sqlite3_result_text16le().
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testHexToUtf16be</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testHexToBin</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text16be</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
**      hex_to_utf8(HEX)
**
** Convert the input string from HEX into binary.  Then return the
** result using sqlite3_result_text16le().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testHexToUtf8</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testHexToBin</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
**      hex_to_utf16le(HEX)
**
** Convert the input string from HEX into binary.  Then return the
** result using sqlite3_result_text16le().
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testHexToUtf16le</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testHexToBin</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text16le</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** SQL function:   real2hex(X)
**
** If argument X is a real number, then convert it into a string which is
** the big-endian hexadecimal representation of the ieee754 encoding of
** that number.  If X is not a real number, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>real2hex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <union>union <block>{
    <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  }</block> <decl><name>v</name></decl>;</union>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zOut</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bigEndian</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>v</name><operator>.</operator><name>i</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>bigEndian</name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>.</operator><name>r</name></name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bigEndian</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name>   <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><name><name>v</name><operator>.</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;&gt;</operator><literal type="number">4</literal></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><name><name>v</name><operator>.</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">14</literal><operator>-</operator><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name>   <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><name><name>v</name><operator>.</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;&gt;</operator><literal type="number">4</literal></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">14</literal><operator>-</operator><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><name><name>v</name><operator>.</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
**     test_extract(record, field)
**
** This function implements an SQL user-function that accepts a blob
** containing a formatted database record as the first argument. The
** second argument is the index of the field within that record to
** extract and return.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_extract</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEndHdr</name></decl>;</decl_stmt>                    <comment type="block">/* Points to one byte past record header */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pHdr</name></decl>;</decl_stmt>                       <comment type="block">/* Current point in record header */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pBody</name></decl>;</decl_stmt>                      <comment type="block">/* Current point in record data */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nHdr</name></decl>;</decl_stmt>                       <comment type="block">/* Bytes in record header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name></decl>;</decl_stmt>                       <comment type="block">/* Required field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Current field */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRec</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iIdx</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pHdr</name> <operator>=</operator> <name>pRec</name> <operator>+</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBody</name> <operator>=</operator> <name>pEndHdr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pRec</name><index>[<expr><name>nHdr</name></expr>]</index></name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>iCurrent</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>pHdr</name><operator>&lt;</operator><name>pEndHdr</name> <operator>&amp;&amp;</operator> <name>iCurrent</name><operator>&lt;=</operator><name>iIdx</name></expr>;</condition> <incr><expr><name>iCurrent</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>iSerialType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name></type> <name>mem</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mem</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mem</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pHdr</name> <operator>+=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>pHdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSerialType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><name>pBody</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>iSerialType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBody</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>iSerialType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iCurrent</name><operator>==</operator><name>iIdx</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>mem</name><operator>.</operator><name>szMalloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
**      test_decode(record)
**
** This function implements an SQL user-function that accepts a blob
** containing a formatted database record as its only argument. It returns
** a tcl list (type SQLITE_TEXT) containing each of the values stored
** in the record.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_decode</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEndHdr</name></decl>;</decl_stmt>                    <comment type="block">/* Points to one byte past record header */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pHdr</name></decl>;</decl_stmt>                       <comment type="block">/* Current point in record header */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pBody</name></decl>;</decl_stmt>                      <comment type="block">/* Current point in record data */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nHdr</name></decl>;</decl_stmt>                       <comment type="block">/* Bytes in record header */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>                  <comment type="block">/* Return value */</comment>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRec</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pHdr</name> <operator>=</operator> <name>pRec</name> <operator>+</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBody</name> <operator>=</operator> <name>pEndHdr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pRec</name><index>[<expr><name>nHdr</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pHdr</name><operator>&lt;</operator><name>pEndHdr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>iSerialType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name></type> <name>mem</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mem</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mem</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pHdr</name> <operator>+=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>pHdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSerialType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><name>pBody</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>iSerialType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBody</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>iSerialType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_TEXT</name></expr>:</case>
        <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>hexdigit</name><index>[]</index></name> <init>= <expr><block>{
          <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, <expr><literal type="char">'6'</literal></expr>, <expr><literal type="char">'7'</literal></expr>,
          <expr><literal type="char">'8'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'f'</literal></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"x'"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>hex</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>hex</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>hexdigit</name><index>[<expr><operator>(</operator><operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hex</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>hexdigit</name><index>[<expr><operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hex</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>Tcl_AppendStringsToObj</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>Tcl_AppendStringsToObj</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
        <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>Tcl_NewDoubleObj</name><argument_list>(<argument><expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
        <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>mem</name><operator>.</operator><name>szMalloc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
**       test_zeroblob(N)
**
** The implementation of scalar SQL function "test_zeroblob()". This is
** similar to the built-in zeroblob() function, except that it does not
** check that the integer parameter is within range before passing it
** to sqlite3_result_zeroblob().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_zeroblob</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nZero</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_zeroblob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>nZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*         test_getsubtype(V)
**
** Return the subtype for value V.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_getsubtype</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3_value_subtype</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*         test_frombind(A,B,C,...)
**
** Return an integer bitmask that has a bit set for every argument
** (up to the first 63 arguments) that originates from a bind a parameter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_frombind</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">63</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_frombind</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*         test_setsubtype(V, T)
**
** Return the value V with its subtype changed to T
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_setsubtype</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>registerTestFunctions</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pThunk</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
     <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>nArg</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>eTextRep</name></decl>;</decl_stmt> <comment type="block">/* 1: UTF-16.  0: UTF-8 */</comment>
     <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aFuncs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"randstr"</literal></expr>,               <expr><literal type="number">2</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>randStr</name></expr>    }</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_destructor"</literal></expr>,       <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_destructor</name></expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
    <expr><block>{ <expr><literal type="string">"test_destructor16"</literal></expr>,     <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_destructor16</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"hex_to_utf16be"</literal></expr>,        <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>testHexToUtf16be</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"hex_to_utf16le"</literal></expr>,        <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>testHexToUtf16le</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{ <expr><literal type="string">"hex_to_utf8"</literal></expr>,           <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>testHexToUtf8</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_destructor_count"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_destructor_count</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_auxdata"</literal></expr>,         <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_auxdata</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_error"</literal></expr>,            <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_error</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_error"</literal></expr>,            <expr><literal type="number">2</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_error</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_eval"</literal></expr>,             <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_eval</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_isolation"</literal></expr>,        <expr><literal type="number">2</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_isolation</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_counter"</literal></expr>,          <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>counterFunc</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"real2hex"</literal></expr>,              <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>real2hex</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_decode"</literal></expr>,           <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_decode</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_extract"</literal></expr>,          <expr><literal type="number">2</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_extract</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_zeroblob"</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr>, <expr><name>test_zeroblob</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_getsubtype"</literal></expr>,       <expr><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_getsubtype</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_setsubtype"</literal></expr>,       <expr><literal type="number">2</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_setsubtype</name></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"test_frombind"</literal></expr>,        <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_frombind</name></expr>}</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFuncs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFuncs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>,
        <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eTextRep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"test_agg_errmsg16"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_ANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
      <argument><expr><name>test_agg_errmsg16_step</name></expr></argument>, <argument><expr><name>test_agg_errmsg16_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** TCLCMD:  autoinstall_test_functions
**
** Invoke this TCL command to use sqlite3_auto_extension() to cause
** the standard set of test functions to be loaded into each new
** database connection.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>autoinstall_test_funcs</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Md5_Register</name><argument_list>(<argument><expr><name>sqlite3</name> <operator>*</operator></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>sqlite3_api_routines</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>registerTestFunctions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>Md5_Register</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A bogus step function and finalizer function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content/>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tFinal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content/>}</block></function>


<comment type="block">/*
** tclcmd:  abuse_create_function
**
** Make various calls to sqlite3_create_function that do not have valid
** parameters.  Verify that the error condition is detected and reported.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>abuse_create_function</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>getDbPointer</name><argument_list>(<argument><expr><name>Tcl_Interp</name><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxArg</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>getDbPointer</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>,<argument><expr><name>tStep</name></expr></argument>,<argument><expr><name>tFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"funcxx"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal></expr></argument>,
       <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_MISUSE</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* This last function registration should actually work.  Generate
  ** a no-op function (that always returns NULL) and which has the
  ** maximum-length function name and the maximum number of parameters.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_limit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr></argument>, <argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxArg</name> <operator>=</operator> <call><name>sqlite3_limit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"nullx"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal>
       <literal type="string">"_123456789_123456789_123456789_123456789_123456789"</literal></expr></argument>,
       <argument><expr><name>mxArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abuse_err</name>;</goto></block_content></block></if></if_stmt>
                                
  <return>return <expr><name>TCL_OK</name></expr>;</return>

<label><name>abuse_err</name>:</label>
  <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"sqlite3_create_function abused test failed"</literal></expr></argument>, 
                   <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_ERROR</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** SQLite user defined function to use with matchinfo() to calculate the
** relevancy of an FTS match. The value returned is the relevancy score
** (a real value greater than or equal to zero). A larger value indicates 
** a more relevant document.
**
** The overall relevancy returned is the sum of the relevancies of each 
** column value in the FTS table. The relevancy of a column value is the
** sum of the following for each reportable phrase in the FTS query:
**
**   (&lt;hit count&gt; / &lt;global hit count&gt;) * &lt;column weight&gt;
**
** where &lt;hit count&gt; is the number of instances of the phrase in the
** column value of the current row and &lt;global hit count&gt; is the number
** of instances of the phrase in the same column of all rows in the FTS
** table. The &lt;column weight&gt; is a weighting factor assigned to each
** column by the caller (see below).
**
** The first argument to this function must be the return value of the FTS 
** matchinfo() function. Following this must be one argument for each column 
** of the FTS table containing a numeric weight factor for the corresponding 
** column. Example:
**
**     CREATE VIRTUAL TABLE documents USING fts3(title, content)
**
** The following query returns the docids of documents that match the full-text
** query &lt;query&gt; sorted from most to least relevant. When calculating
** relevance, query term instances in the 'title' column are given twice the
** weighting of those in the 'content' column.
**
**     SELECT docid FROM documents 
**     WHERE documents MATCH &lt;query&gt; 
**     ORDER BY rank(matchinfo(documents), 1.0, 0.5) DESC
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rankfunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aMatchinfo</name></decl>;</decl_stmt>                <comment type="block">/* Return value of matchinfo() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMatchinfo</name></decl>;</decl_stmt>                 <comment type="block">/* Number of elements in aMatchinfo[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPhrase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of phrases in the query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPhrase</name></decl>;</decl_stmt>                    <comment type="block">/* Current phrase */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Value to return */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that the number of arguments passed to this function is correct.
  ** If not, jump to wrong_number_args. Set aMatchinfo to point to the array
  ** of unsigned integer values returned by FTS function matchinfo. Set
  ** nPhrase to contain the number of reportable phrases in the users full-text
  ** query, and nCol to the number of columns in the table. Then check that the
  ** size of the matchinfo blob is as expected. Return an error if it is not.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>wrong_number_args</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aMatchinfo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMatchinfo</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMatchinfo</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPhrase</name> <operator>=</operator> <name><name>aMatchinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMatchinfo</name><operator>!=</operator><operator>(</operator><literal type="number">2</literal><operator>+</operator><literal type="number">3</literal><operator>*</operator><name>nCol</name><operator>*</operator><name>nPhrase</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>,
        <argument><expr><literal type="string">"invalid matchinfo blob passed to function rank()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>!=</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><name>nCol</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>wrong_number_args</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Iterate through each phrase in the users query. */</comment>
  <for>for<control>(<init><expr><name>iPhrase</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPhrase</name><operator>&lt;</operator><name>nPhrase</name></expr>;</condition> <incr><expr><name>iPhrase</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                     <comment type="block">/* Current column */</comment>

    <comment type="block">/* Now iterate through each column in the users query. For each column,
    ** increment the relevancy score by:
    **
    **   (&lt;hit count&gt; / &lt;global hit count&gt;) * &lt;column weight&gt;
    **
    ** aPhraseinfo[] points to the start of the data for phrase iPhrase. So
    ** the hit count and global hit counts for each column are found in 
    ** aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
    */</comment>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aPhraseinfo</name> <init>= <expr><operator>&amp;</operator><name><name>aMatchinfo</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>iPhrase</name><operator>*</operator><name>nCol</name><operator>*</operator><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nHitCount</name> <init>= <expr><name><name>aPhraseinfo</name><index>[<expr><literal type="number">3</literal><operator>*</operator><name>iCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nGlobalHitCount</name> <init>= <expr><name><name>aPhraseinfo</name><index>[<expr><literal type="number">3</literal><operator>*</operator><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>weight</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nHitCount</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>score</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>nHitCount</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>nGlobalHitCount</name><operator>)</operator> <operator>*</operator> <name>weight</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>

  <comment type="block">/* Jump here if the wrong number of arguments are passed to this function */</comment>
<label><name>wrong_number_args</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"wrong number of arguments to function rank()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>install_fts3_rank_function</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>getDbPointer</name><argument_list>(<argument><expr><name>Tcl_Interp</name><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"DB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>getDbPointer</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"rank"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rankfunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Register commands with the TCL interpreter.
*/</comment>
<function><type><name>int</name></type> <name>Sqlitetest_func_Init</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> struct <block>{
     <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Tcl_ObjCmdProc</name> <modifier>*</modifier></type><name>xProc</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aObjCmd</name><index>[]</index></name> <init>= <expr><block>{
     <expr><block>{ <expr><literal type="string">"autoinstall_test_functions"</literal></expr>,    <expr><name>autoinstall_test_funcs</name></expr> }</block></expr>,
     <expr><block>{ <expr><literal type="string">"abuse_create_function"</literal></expr>,         <expr><name>abuse_create_function</name></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"install_fts3_rank_function"</literal></expr>,    <expr><name>install_fts3_rank_function</name></expr>  }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Md5_Register</name><argument_list>(<argument><expr><name>sqlite3</name> <operator>*</operator></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>sqlite3_api_routines</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aObjCmd</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aObjCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>aObjCmd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aObjCmd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xProc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>registerTestFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>Md5_Register</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
