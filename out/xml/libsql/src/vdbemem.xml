<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/vdbemem.c"><comment type="block">/*
** 2004 May 26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code use to manipulate "Mem" structure.  A "Mem"
** stores a single value in the VDBE.  Mem is an opaque structure visible
** only within the VDBE.  Interface routines refer to a Mem using the
** name sqlite_value
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/* True if X is a power of two.  0 is considered a power of two here.
** In other words, return true if X has at most one bit set.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISPOWEROF2</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((X)&amp;((X)-1))==0)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Check invariants on a Mem object.
**
** This routine is intended for use inside of assert() statements, like
** this:    assert( sqlite3VdbeCheckMemInvariants(pMem) );
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCheckMemInvariants</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* If MEM_Dyn is set then Mem.xDel!=0.  
  ** Mem.xDel might not be initialized if MEM_Dyn is clear.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* MEM_Dyn may only be set if Mem.szMalloc==0.  In this way we
  ** ensure that if Mem.szMalloc&gt;0 then it is safe to do
  ** Mem.z = Mem.zMalloc without having to check Mem.flags&amp;MEM_Dyn.
  ** That saves a few cycles in inner loops. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Cannot have more than one of MEM_Int, MEM_Real, or MEM_IntReal */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ISPOWEROF2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Cannot be both MEM_Null and some other type */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Agg</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If MEM_Null is set, then either the value is a pure NULL (the usual
    ** case) or it is a pointer set using sqlite3_bind_pointer() or
    ** sqlite3_result_pointer().  If a pointer, then MEM_Term must also be
    ** set.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Subtype</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Subtype</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* This is a pointer type.  There may be a flag to indicate what to
      ** do with the pointer. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
              <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Ephem</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
              <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Static</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* No other bits set */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Subtype</name><operator>|</operator><name>MEM_FromBind</name>
                           <operator>|</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Ephem</name><operator>|</operator><name>MEM_Static</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* A pure NULL might have other flags, such as MEM_Static, MEM_Dyn,
      ** MEM_Ephem, MEM_Cleared, or MEM_Subtype */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The MEM_Cleared bit is only allowed on NULLs */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Cleared</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The szMalloc field holds the correct memory allocation size */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Undefined</name> 
           <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&lt;=</operator><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call><operator>)</operator>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If p holds a string or blob, the Mem.z must point to exactly
  ** one of the following:
  **
  **   (1) Memory in Mem.zMalloc and managed by the Mem object
  **   (2) Memory to be freed using Mem.xDel
  **   (3) An ephemeral string or blob
  **   (4) A static string or blob
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( 
      <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
      <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
      <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Ephem</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
      <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Static</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Render a Mem object which is one of MEM_Int, MEM_Real, or MEM_IntReal
** into a buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeMemRenderNum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>&gt;</operator><literal type="number">22</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">7000000</literal></expr></cpp:if>
    <comment type="block">/* Work-around for GCC bug
    ** https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96270 */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>u</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Int64ToText</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>sqlite3Int64ToText</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>, <argument><expr><literal type="string">"%!.15g"</literal></expr></argument>, 
         <argument><expr><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>double</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>acc</name><operator>.</operator><name>zText</name></name><operator>==</operator><name>zBuf</name> <operator>&amp;&amp;</operator> <name><name>acc</name><operator>.</operator><name>mxAlloc</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name><name>acc</name><operator>.</operator><name>nChar</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Fast version of sqlite3StrAccumFinish(&amp;acc) */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Validity checks on pMem.  pMem holds a string.
**
** (1) Check that string value of pMem agrees with its integer or real value.
** (2) Check that the string is correctly zero terminated
**
** A single int or real value always converts to the same strings.  But
** many different strings can be converted into the same int or real.
** If a table contains a numeric value and an index is based on the
** corresponding string value, then it is important that the string be
** derived from the numeric value, not the other way around, to ensure
** that the index and table are consistent.  See ticket
** https://www.sqlite.org/src/info/343634942dd54ab (2018-01-31) for
** an example.
**
** This routine looks at pMem to verify that if it has both a numeric
** representation and a string representation then the string rep has
** been derived from the numeric and not the other way around.  It returns
** true if everything is ok and false if there is a problem.
**
** This routine is for use inside of assert() statements only.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemValidStrRep</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>incr</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Term</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Insure that the string is properly zero-terminated.  Pay particular
    ** attention to the case where p-&gt;n is odd */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>&gt;=</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>!=</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>vdbeMemRenderNum</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>!=</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16BE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>zBuf</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>!=</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>incr</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block">/*
** If pMem is an object with a valid string representation, this routine
** ensures the internal encoding for the string representation is
** 'desiredEnc', one of SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE.
**
** If pMem is not a string object, or the encoding of the string
** representation is already stored using the requested encoding, then this
** routine is a no-op.
**
** SQLITE_OK is returned if the conversion is successful (or not required).
** SQLITE_NOMEM may be returned if a malloc() fails during conversion
** between formats.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeChangeEncoding</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>desiredEnc</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF16LE</name>
           <operator>||</operator> <name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Str</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>desiredEnc</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>desiredEnc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifdef>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

  <comment type="block">/* MemTranslate() may return SQLITE_OK or SQLITE_NOMEM. If NOMEM is returned,
  ** then the encoding of the value may not have changed.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemTranslate</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>desiredEnc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name>    <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name>    <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>!=</operator><name>desiredEnc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>desiredEnc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Make sure pMem-&gt;z points to a writable allocation of at least n bytes.
**
** If the bPreserve argument is true, then copy of the content of
** pMem-&gt;z into the new allocation.  pMem must be either a string or
** blob if bPreserve is true.  If bPreserve is false, any prior content
** in pMem-&gt;z is discarded.
*/</comment>
<function><type><name>SQLITE_NOINLINE</name> <name>int</name></type> <name>sqlite3VdbeMemGrow</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bPreserve</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the bPreserve flag is set to true, then the memory cell must already
  ** contain a valid string or blob value.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bPreserve</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bPreserve</name> <operator>&amp;&amp;</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Undefined</name> 
           <operator>&amp;&amp;</operator> <name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&lt;=</operator><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call><operator>)</operator>
       <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bPreserve</name> <operator>&amp;&amp;</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <call><name>sqlite3Realloc</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>bPreserve</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bPreserve</name> <operator>&amp;&amp;</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>xDel</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pMem</name><operator>-&gt;</operator><name>xDel</name></name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pMem</name><operator>-&gt;</operator><name>xDel</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Ephem</name><operator>|</operator><name>MEM_Static</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the pMem-&gt;zMalloc allocation to be at least szNew bytes.
** If pMem-&gt;zMalloc already meets or exceeds the requested size, this
** routine is a no-op.
**
** Any prior string or blob content in the pMem object may be discarded.
** The pMem-&gt;xDel destructor is called, if it exists.  Though MEM_Str
** and MEM_Blob values may be discarded, MEM_Int, MEM_Real, MEM_IntReal,
** and MEM_Null values are preserved.
**
** Return SQLITE_OK on success or an error code (probably SQLITE_NOMEM)
** if unable to complete the resizing.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemClearAndResize</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>szNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <name>szNew</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&lt;</operator><name>szNew</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>szNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** It is already known that pMem contains an unterminated string.
** Add the zero terminator.
**
** Three bytes of zero are added.  In this way, there is guaranteed
** to be a double-zero byte at an even byte boundary in order to
** terminate a UTF16 string, even if the initial size of the buffer
** is an odd number of bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>vdbeMemAddTerminator</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Term</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change pMem so that its MEM_Str or MEM_Blob value is stored in
** MEM.zMalloc, where it can be safely written.
**
** Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemMakeWriteable</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>vdbeMemAddTerminator</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Ephem</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the given Mem* has a zero-filled tail, turn it into an ordinary
** blob stored in dynamically allocated space.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3VdbeMemExpandBlob</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Blob</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>MemNullNochng</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>sqlite3_value_nochange</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set nByte to the number of bytes required to store the expanded blob. */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Zero</name><operator>|</operator><name>MEM_Term</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Make sure the given Mem is \u0000 terminated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemNulTerminate</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>!=</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>   <comment type="block">/* Nothing to do */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>vdbeMemAddTerminator</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add MEM_Str to the set of representations for the given Mem.  This
** routine is only called if pMem is a number of some kind, not a NULL
** or a BLOB.
**
** Existing representations MEM_Int, MEM_Real, or MEM_IntReal are invalidated
** if bForce is true but are retained if bForce is false.
**
** A MEM_Null value will never be passed to this function. This function is
** used for converting values to text for returning to the user (i.e. via
** sqlite3_value_text()), or for ensuring that values to be used as btree
** keys are strings. In the former case a NULL pointer is returned the
** user and the latter is an internal programming error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemStringify</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>bForce</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Zero</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>


  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>vdbeMemRenderNum</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30NN</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bForce</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Memory cell pMem contains the context of an aggregate function.
** This routine calls the finalize method for that function.  The
** result of the aggregate is stored back into pMem.
**
** Return SQLITE_ERROR if the finalizer reports an error.  SQLITE_OK
** otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemFinalize</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFunc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>xFinalize</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pFunc</name><operator>==</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pDef</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pOut</name></name> <operator>=</operator> <operator>&amp;</operator><name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pMem</name></name> <operator>=</operator> <name>pMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pFunc</name></name> <operator>=</operator> <name>pFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pFunc</name><operator>-&gt;</operator><name>xFinalize</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IMP: R-24505-23230 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>ctx</name><operator>.</operator><name>isError</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Memory cell pAccum contains the context of an aggregate function.
** This routine calls the xValue method for that function and stores
** the results in memory cell pMem.
**
** SQLITE_ERROR is returned if xValue() reports an error. SQLITE_OK 
** otherwise.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3VdbeMemAggValue</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pAccum</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>ctx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFunc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>xValue</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pAccum</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pFunc</name><operator>==</operator><name><name>pAccum</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pDef</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pOut</name></name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pMem</name></name> <operator>=</operator> <name>pAccum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pFunc</name></name> <operator>=</operator> <name>pFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name><name>pAccum</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pFunc</name><operator>-&gt;</operator><name>xValue</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>ctx</name><operator>.</operator><name>isError</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WINDOWFUNC */</comment>

<comment type="block">/*
** If the memory cell contains a value that must be freed by
** invoking the external callback in Mem.xDel, then this routine
** will free that value.  It also sets Mem.flags to MEM_Null.
**
** This is a helper routine for sqlite3VdbeMemSetNull() and
** for sqlite3VdbeMemRelease().  Use those other routines as the
** entry point for releasing Mem resources.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>vdbeMemClearExternAndSetNull</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Agg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pDef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Agg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><operator>!=</operator><name>SQLITE_DYNAMIC</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release memory held by the Mem p, both external memory cleared
** by p-&gt;xDel and memory in p-&gt;zMalloc.
**
** This is a helper routine invoked by sqlite3VdbeMemRelease() in
** the unusual case where there really is memory in p that needs
** to be freed.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>vdbeMemClear</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMemClearExternAndSetNull</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release any memory resources held by the Mem.  Both the memory that is
** free by Mem.xDel and the Mem.zMalloc allocation are freed.
**
** Use this routine prior to clean up prior to abandoning a Mem, or to
** reset a Mem back to its minimum memory utilization.
**
** Use sqlite3VdbeMemSetNull() to release just the Mem.xDel space
** prior to inserting new content into the Mem.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemRelease</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMemClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Like sqlite3VdbeMemRelease() but faster for cases where we
** know in advance that the Mem is not MEM_Dyn or MEM_Agg.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemReleaseMalloc</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>vdbeMemClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert a 64-bit IEEE double into a 64-bit signed integer.
** If the double is out of range of a 64-bit signed integer then
** return the closest available 64-bit signed integer.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>i64</name></type> <name>doubleToInt64</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
  <comment type="block">/* When floating-point is omitted, double and int64 are the same thing */</comment>
  <return>return <expr><name>r</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/*
  ** Many compilers we encounter do not define constants for the
  ** minimum and maximum 64-bit integers, or they define them
  ** inconsistently.  And many do not understand the "LL" notation.
  ** So we define our own static constants here using nothing
  ** larger than a 32-bit integer constant.
  */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>i64</name></type> <name>maxInt</name> <init>= <expr><name>LARGEST_INT64</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>i64</name></type> <name>minInt</name> <init>= <expr><name>SMALLEST_INT64</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;=</operator><operator>(</operator><name>double</name><operator>)</operator><name>minInt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>minInt</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>r</name><operator>&gt;=</operator><operator>(</operator><name>double</name><operator>)</operator><name>maxInt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>maxInt</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><name>r</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return some kind of integer value which is the best we can do
** at representing the value that *pMem describes as an integer.
** If pMem is an integer, then the value is exact.  If pMem is
** a floating-point then the value returned is the integer part.
** If pMem is a string or blob, then we make an attempt to convert
** it into an integer and return that.  If pMem represents an
** an SQL-NULL value, return 0.
**
** If pMem represents a string value, its encoding might be changed.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>i64</name></type> <name>memIntValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>i64</name></type> <name>sqlite3VdbeIntValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>doubleToInt64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>memIntValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the best representation of pMem that we can get into a
** double.  If pMem is already a double or an integer, return its
** value.  If it is a string or blob, try to convert it to a double.
** If it is a NULL, return 0.0.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>double</name></type> <name>memRealValue</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>sqlite3VdbeRealValue</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>double</name><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>memRealValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */</comment>
    <return>return <expr><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return 1 if pMem represents true, and return 0 if pMem represents false.
** Return the value ifNull if pMem is NULL.  
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeBooleanValue</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ifNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>ifNull</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0.0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The MEM structure is already a MEM_Real.  Try to also make it a
** MEM_Int if we can.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeIntegerAffinity</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>ix</name> <operator>=</operator> <call><name>doubleToInt64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only mark the value as an integer if
  **
  **    (1) the round-trip conversion real-&gt;int-&gt;real is a no-op, and
  **    (2) The integer is neither the largest nor the smallest
  **        possible integer (ticket #3922)
  **
  ** The second and third terms in the following conditional enforces
  ** the second condition under the assumption that addition overflow causes
  ** values to wrap around.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name><operator>==</operator><name>ix</name> <operator>&amp;&amp;</operator> <name>ix</name><operator>&gt;</operator><name>SMALLEST_INT64</name> <operator>&amp;&amp;</operator> <name>ix</name><operator>&lt;</operator><name>LARGEST_INT64</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>ix</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert pMem to type integer.  Invalidate any prior representations.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemIntegerify</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert pMem so that it is of type MEM_Real.
** Invalidate any prior representations.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemRealify</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare a floating point value to an integer.  Return true if the two
** values are the same within the precision of the floating point value.
**
** This function assumes that i was obtained by assignment from r1.
**
** For some versions of GCC on 32-bit machines, if you do the more obvious
** comparison of "r1==(double)i" you sometimes get an answer of false even
** though the r1 and (double)i values are bit-for-bit the same.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3RealSameAsInt</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>r1</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>r2</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name>i</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>r1</name><operator>==</operator><literal type="number">0.0</literal>
      <operator>||</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">2251799813685248LL</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <literal type="number">2251799813685248LL</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a floating point value to its closest integer.  Do so in
** a way that avoids 'outside the range of representable values' warnings
** from UBSAN.
*/</comment>
<function><type><name>i64</name></type> <name>sqlite3RealToI64</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;=</operator><operator>(</operator><name>double</name><operator>)</operator><name>SMALLEST_INT64</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SMALLEST_INT64</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;=</operator><operator>(</operator><name>double</name><operator>)</operator><name>LARGEST_INT64</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>LARGEST_INT64</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert pMem so that it has type MEM_Real or MEM_Int.
** Invalidate any prior representations.
**
** Every effort is made to force the conversion, even if the input
** is a string that does not look completely like a number.  Convert
** as much of the string as we can and ignore the rest.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemNumerify</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Null</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>ix</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>==</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">1</literal><operator>)</operator>
     <operator>||</operator> <call><name>sqlite3RealSameAsInt</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ix</name> <operator>=</operator> <call><name>sqlite3RealToI64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>ix</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Null</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Zero</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Cast the datatype of the value in pMem according to the affinity
** "aff".  Casting is different from applying affinity in that a cast
** is forced.  In other words, the value is converted into the desired
** affinity even if that results in loss of data.  This routine is
** used (for example) to implement the SQL "cast()" operator.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemCast</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>aff</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>encoding</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name>aff</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_AFF_BLOB</name></expr>:</case> <block>{<block_content>   <comment type="block">/* Really a cast to BLOB */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>SQLITE_AFF_TEXT</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_TypeMask</name><operator>&amp;</operator><operator>~</operator><name>MEM_Blob</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_AFF_NUMERIC</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemNumerify</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_AFF_INTEGER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_AFF_REAL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemRealify</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aff</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MEM_Str</name><operator>==</operator><operator>(</operator><name>MEM_Blob</name><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Blob</name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>SQLITE_AFF_TEXT</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Zero</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>encoding</name><operator>!=</operator><name>SQLITE_UTF8</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize bulk memory to be a consistent Mem object.
**
** The minimum amount of initialization feasible is performed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemInit</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>MEM_TypeMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Delete any previous value and set the value stored in *pMem to NULL.
**
** This routine calls the Mem.xDel destructor to dispose of values that
** require the destructor.  But it preserves the Mem.zMalloc memory allocation.
** To free all resources, use sqlite3VdbeMemRelease(), which both calls this
** routine to invoke the destructor and deallocates Mem.zMalloc.
**
** Use this routine to reset the Mem prior to insert a new value.
**
** Use sqlite3VdbeMemRelease() to complete erase the Mem prior to abandoning it.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetNull</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMemClearExternAndSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3ValueSetNull</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<comment type="block">/*
** Delete any previous value and set the value to be a BLOB of length
** n containing all zeros.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetZeroBlob</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name><operator>|</operator><name>MEM_Zero</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>int</name></type> <name>sqlite3VdbeMemSetZeroBlob</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><ternary><condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>?</condition><then><expr><name>n</name></expr></then><else>:<expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call><operator>&gt;=</operator><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <ternary><condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>?</condition><then><expr><name>n</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The pMem is known to contain content that needs to be destroyed prior
** to a value change.  So invoke the destructor, then set the value to
** a 64-bit integer.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>vdbeReleaseAndSetInt64</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Delete any previous value and set the value stored in *pMem to val,
** manifest type INTEGER.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetInt64</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeReleaseAndSetInt64</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* A no-op destructor */</comment>
<function><type><name>void</name></type> <name>sqlite3NoopDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content> <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<comment type="block">/*
** Set the value stored in *pMem should already be a NULL.
** Also store a pointer to go with it.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetPointer</name><parameter_list>(
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPType</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestructor</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdbeMemClear</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zPType</name></name> <operator>=</operator> <ternary><condition><expr><name>zPType</name></expr> ?</condition><then> <expr><name>zPType</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name>pPtr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name><operator>|</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Subtype</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>eSubtype</name></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <ternary><condition><expr><name>xDestructor</name></expr> ?</condition><then> <expr><name>xDestructor</name></expr> </then><else>: <expr><name>sqlite3NoopDestructor</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** Delete any previous value and set the value stored in *pMem to val,
** manifest type REAL.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetDouble</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Return true if the Mem holds a RowSet object.  This routine is intended
** for use inside of assert() statements.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemIsRowSet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator>
         <operator>&amp;&amp;</operator> <name><name>pMem</name><operator>-&gt;</operator><name>xDel</name></name><operator>==</operator><name>sqlite3RowSetDelete</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Delete any previous value and set the value of pMem to be an
** empty boolean index.
**
** Return SQLITE_OK on success and SQLITE_NOMEM if a memory allocation
** error occurs.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemSetRowSet</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3RowSetInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name><operator>|</operator><name>MEM_Dyn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <name>sqlite3RowSetDelete</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the Mem object contains a TEXT or BLOB that is
** too large - whose size exceeds SQLITE_MAX_LENGTH.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemTooBig</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>n</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** This routine prepares a memory cell for modification by breaking
** its link to a shallow copy and by marking any current shallow
** copies of this cell as invalid.
**
** This is used for testing and debugging only - to help ensure that shallow
** copies (created by OP_SCopy) are not misused.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemAboutToChange</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>pX</name><operator>=</operator><name><name>pVdbe</name><operator>-&gt;</operator><name>aMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pVdbe</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pX</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>pScopyFrom</name></name><operator>==</operator><name>pMem</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u16</name></type> <name>mFlags</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pVdbe</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"Invalidate R[%d] due to change in R[%d]\n"</literal></expr></argument>,
          <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pX</name> <operator>-</operator> <name><name>pVdbe</name><operator>-&gt;</operator><name>aMem</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pMem</name> <operator>-</operator> <name><name>pVdbe</name><operator>-&gt;</operator><name>aMem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* If pX is marked as a shallow copy of pMem, then try to verify that
      ** no significant changes have been made to pX since the OP_SCopy.
      ** A significant change would indicated a missed call to this
      ** function for pX.  Minor changes, such as adding or removing a
      ** dual type, are allowed, as long as the underlying value is the
      ** same. */</comment>
      <expr_stmt><expr><name>mFlags</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>mScopyFlags</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>mFlags</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* pMem is the register that is changing.  But also mark pX as
      ** undefined so that we can quickly detect the shallow-copy error */</comment>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block">/*
** Make an shallow copy of pFrom into pTo.  Prior contents of
** pTo are freed.  The pFrom-&gt;z field is not duplicated.  If
** pFrom-&gt;z is used, then pTo-&gt;z points to the same thing as pFrom-&gt;z
** and flags gets srcType (either MEM_Ephem or MEM_Static).
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>vdbeClrCopy</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>vdbeMemClearExternAndSetNull</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeMemShallowCopy</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name><name>pFrom</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>vdbeClrCopy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>,<argument><expr><name>pFrom</name></expr></argument>,<argument><expr><name>srcType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return;</return> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>MEMCELLSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Static</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>srcType</name><operator>==</operator><name>MEM_Ephem</name> <operator>||</operator> <name>srcType</name><operator>==</operator><name>MEM_Static</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>srcType</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make a full copy of pFrom into pTo.  Prior contents of pTo are
** freed before the copy is made.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemCopy</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>vdbeMemClearExternAndSetNull</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>MEMCELLSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Dyn</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Static</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Ephem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Transfer the contents of pFrom to pTo. Any existing value in pTo is
** freed. If pFrom contains ephemeral data, a copy is made.
**
** pFrom contains an SQL NULL when this routine returns.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemMove</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name><name>pTo</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the value of a Mem to be a string or a BLOB.
**
** The memory management strategy depends on the value of the xDel
** parameter. If the value passed is SQLITE_TRANSIENT, then the 
** string is copied into a (possibly existing) buffer managed by the 
** Mem structure. Otherwise, any existing buffer is freed and the
** pointer copied.
**
** If the string is too large (if it exceeds the SQLITE_LIMIT_LENGTH
** size limit) then no memory allocation occurs.  If the string can be
** stored without allocating memory, then it is.  If a memory allocation
** is required to store the string, then value of pMem is unchanged.  In
** either case, SQLITE_TOOBIG is returned.
**
** The "enc" parameter is the text encoding for the string, or zero
** to store a blob.
**
** If n is negative, then the string consists of all bytes up to but
** excluding the first zero character.  The n parameter must be
** non-negative for blobs.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemSetStr</name><parameter_list>(
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>,          <comment type="block">/* Memory cell to set to string value */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,      <comment type="block">/* String pointer */</comment>
  <parameter><decl><type><name>i64</name></type> <name>n</name></decl></parameter>,              <comment type="block">/* Bytes in string, or negative */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,             <comment type="block">/* Encoding of z.  0 for BLOBs */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> <comment type="block">/* Destructor function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* New value for pMem-&gt;n */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name></decl>;</decl_stmt>         <comment type="block">/* Maximum allowed string or blob size */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>          <comment type="block">/* New value for pMem-&gt;flags */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>n</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If z is a NULL pointer, set pMem to contain an SQL NULL. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>z</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iLimit</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iLimit</name> <operator>=</operator> <name>SQLITE_MAX_LENGTH</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <for>for<control>(<init><expr><name>nByte</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>nByte</name><operator>&lt;=</operator><name>iLimit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><name>nByte</name></expr>]</index></name> <operator>|</operator> <name><name>z</name><index>[<expr><name>nByte</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</condition> <incr><expr><name>nByte</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>flags</name><operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>enc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>MEM_Str</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><name>iLimit</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>xDel</name> <operator>&amp;&amp;</operator> <name>xDel</name><operator>!=</operator><name>SQLITE_TRANSIENT</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>xDel</name><operator>==</operator><name>SQLITE_DYNAMIC</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>xDel</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3ErrorToParser</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The following block sets the new values of Mem.z and Mem.xDel. It
  ** also sets a flag in local variable "flags" to indicate the memory
  ** management (one of MEM_Dyn or MEM_Static).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>xDel</name><operator>==</operator><name>SQLITE_TRANSIENT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nAlloc</name> <init>= <expr><name>nByte</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>MEM_Term</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nAlloc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nAlloc</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nAlloc</name><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>MAX</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>,<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>z</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>xDel</name><operator>==</operator><name>SQLITE_DYNAMIC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <name>xDel</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>xDel</name><operator>==</operator><name>SQLITE_STATIC</name><operator>)</operator></expr>?</condition><then><expr><name>MEM_Static</name></expr></then><else>:<expr><name>MEM_Dyn</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>nByte</name> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>&gt;</operator><name>SQLITE_UTF8</name> <operator>&amp;&amp;</operator> <call><name>sqlite3VdbeMemHandleBom</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Move data out of a btree key or data field and into a Mem structure.
** The data is payload from the entry that pCur is currently pointing
** to.  offset and amt determine what portion of the data or key to retrieve.
** The result is written into the pMem element.
**
** The pMem object must have been initialized.  This routine will use
** pMem-&gt;zMalloc to hold the content from the btree, if possible.  New
** pMem-&gt;zMalloc space will be allocated if necessary.  The calling routine
** is responsible for making sure that the pMem object is eventually
** destroyed.
**
** If this routine fails for any reason (malloc returns NULL or unable
** to read from the disk) then the pMem is left in an inconsistent state.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemFromBtree</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,   <comment type="block">/* Cursor pointing at record to retrieve. */</comment>
  <parameter><decl><type><name>u32</name></type> <name>offset</name></decl></parameter>,       <comment type="block">/* Offset from the start of data to return bytes from. */</comment>
  <parameter><decl><type><name>u32</name></type> <name>amt</name></decl></parameter>,          <comment type="block">/* Number of bytes to return. */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>         <comment type="block">/* OUT: Return data in this Mem structure. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeMaxRecordSize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call><operator>&lt;</operator><name>offset</name><operator>+</operator><name>amt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>amt</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreePayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>amt</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* Overrun area used when reading malformed records */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>amt</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeMemFromBtreeZeroOffset</name><parameter_list>(
  <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,   <comment type="block">/* Cursor pointing at record to retrieve. */</comment>
  <parameter><decl><type><name>u32</name></type> <name>amt</name></decl></parameter>,          <comment type="block">/* Number of bytes to return. */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>         <comment type="block">/* OUT: Return data in this Mem structure. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>available</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of bytes available on the local btree page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Note: the calls to BtreeKeyFetch() and DataFetch() below assert() 
  ** that both the BtShared and database handle mutexes are held. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3BtreePayloadFetch</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>available</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>amt</name><operator>&lt;=</operator><name>available</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name><operator>|</operator><name>MEM_Ephem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>amt</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The pVal argument is known to be a value other than NULL.
** Convert it into a string with encoding enc and return a pointer
** to a zero-terminated version of that string.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>valueToText</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier></type> <name>pVal</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVal</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>enc</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>enc</name><operator>&amp;</operator><operator>~</operator><name>SQLITE_UTF16_ALIGNED</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Null</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Str</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>enc</name></name> <operator>!=</operator> <operator>(</operator><name>enc</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_UTF16_ALIGNED</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_UTF16_ALIGNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>enc</name> <operator>&amp;</operator> <name>SQLITE_UTF16_ALIGNED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">1</literal><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Ephem</name><operator>|</operator><name>MEM_Static</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemNulTerminate</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IMP: R-31275-44060 */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><operator>(</operator><name>enc</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_UTF16_ALIGNED</name><operator>)</operator> <operator>||</operator> <name><name>pVal</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal>
              <operator>||</operator> <name><name>pVal</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><operator>(</operator><name>enc</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_UTF16_ALIGNED</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeMemValidStrRep</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pVal</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is only available internally, it is not part of the
** external API. It works in a similar way to sqlite3_value_text(),
** except the data returned is in the encoding specified by the second
** parameter, which must be one of SQLITE_UTF16BE, SQLITE_UTF16LE or
** SQLITE_UTF8.
**
** (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.
** If that is the case, then the result must be aligned on an even byte
** boundary.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3ValueText</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier></type> <name>pVal</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVal</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>enc</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>enc</name><operator>&amp;</operator><operator>~</operator><name>SQLITE_UTF16_ALIGNED</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Term</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Term</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pVal</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>enc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeMemValidStrRep</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pVal</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>valueToText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new sqlite3_value object.
*/</comment>
<function><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>sqlite3ValueNew</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Context object passed by sqlite3Stat4ProbeSetValue() through to 
** valueNew(). See comments above valueNew() for details.
*/</comment>
<struct>struct <name>ValueNewStat4Ctx</name> <block>{
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Allocate and return a pointer to a new sqlite3_value object. If
** the second argument to this function is NULL, the object is allocated
** by calling sqlite3ValueNew().
**
** Otherwise, if the second argument is non-zero, then this function is 
** being called indirectly by sqlite3Stat4ProbeSetValue(). If it has not
** already been allocated, allocate the UnpackedRecord structure that 
** that function will return to its caller here. Then return a pointer to
** an sqlite3_value within the UnpackedRecord.a[] array.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_value</name> <modifier>*</modifier></type><name>valueNew</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ValueNewStat4Ctx</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>ppRec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>pRec</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pIdx</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Index being probed */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                  <comment type="block">/* Bytes of space to allocate */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Counter variable */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Number of index columns including rowid */</comment>
  
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nCol</name> <operator>+</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnpackedRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRec</name> <operator>=</operator> <operator>(</operator><name>UnpackedRecord</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRec</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <call><name>sqlite3KeyInfoOfIndex</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name><operator>==</operator><name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pRec</name> <operator>+</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnpackedRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pRec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRec</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ppRec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iVal</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>&amp;</operator><name><name>pRec</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iVal</name></name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_ENABLE_STAT4) */</comment>
  <return>return <expr><call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The expression object indicated by the second argument is guaranteed
** to be a scalar SQL function. If
**
**   * all function arguments are SQL literals,
**   * one of the SQLITE_FUNC_CONSTANT or _SLOCHNG function flags is set, and
**   * the SQLITE_FUNC_NEEDCOLL function flag is not set,
**
** then this routine attempts to invoke the SQL function. Assuming no
** error occurs, output parameter (*ppVal) is set to point to a value 
** object containing the result before returning SQLITE_OK.
**
** Affinity aff is applied to the result of the function before returning.
** If the result is a text value, the sqlite3_value object uses encoding 
** enc.
**
** If the conditions above are not met, this function returns SQLITE_OK
** and sets (*ppVal) to NULL. Or, if an error occurs, (*ppVal) is set to
** NULL and an SQLite error code returned.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>valueFromFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* The database connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                  <comment type="block">/* The expression to evaluate */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,                         <comment type="block">/* Encoding to use */</comment>
  <parameter><decl><type><name>u8</name></type> <name>aff</name></decl></parameter>,                         <comment type="block">/* Affinity to use */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>,          <comment type="block">/* Write the new value here */</comment>
  <parameter><decl><type><name><name>struct</name> <name>ValueNewStat4Ctx</name></name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>   <comment type="block">/* Second argument for valueNew() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>ctx</name></decl>;</decl_stmt>            <comment type="block">/* Context object for function invocation */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Function arguments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Size of apVal[] array */</comment>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Function definition */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* New value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Function arguments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCtx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_TokenOnly</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFunc</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFunc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_CONSTANT</name><operator>|</operator><name>SQLITE_FUNC_SLOCHNG</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
   <operator>||</operator> <operator>(</operator><name><name>pFunc</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>apVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>apVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>value_from_function_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>value_from_function_out</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>valueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>value_from_function_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pOut</name></name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pFunc</name></name> <operator>=</operator> <name>pFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pFunc</name><operator>-&gt;</operator><name>xSFunc</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>apVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>ctx</name><operator>.</operator><name>isError</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>isError</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>

 <label><name>value_from_function_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>apVal</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>apVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>valueFromFunction</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_ENABLE_STAT4) */</comment>

<comment type="block">/*
** Extract a value from the supplied expression in the manner described
** above sqlite3ValueFromExpr(). Allocate the sqlite3_value object
** using valueNew().
**
** If pCtx is NULL and an error occurs after the sqlite3_value object
** has been allocated, it is freed before returning. Or, if pCtx is not
** NULL, it is assumed that the caller will free any allocated object
** in all cases.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>valueFromExpr</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* The database connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,              <comment type="block">/* The expression to evaluate */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,                         <comment type="block">/* Encoding to use */</comment>
  <parameter><decl><type><name>u8</name></type> <name>affinity</name></decl></parameter>,                    <comment type="block">/* Affinity to use */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>,          <comment type="block">/* Write the new value here */</comment>
  <parameter><decl><type><name><name>struct</name> <name>ValueNewStat4Ctx</name></name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>   <comment type="block">/* Second argument for valueNew() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>negInt</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNeg</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>)</operator><operator>==</operator><name>TK_UPLUS</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_SPAN</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Compressed expressions only appear when parsing the DEFAULT clause
  ** on a table column definition, and hence only when pCtx==0.  This
  ** check ensures that an EP_TokenOnly expression is never passed down
  ** into valueFromFunction(). */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_TokenOnly</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_CAST</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>aff</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>valueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>ppVal</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>ppVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemCast</name><argument_list>(<argument><expr><operator>*</operator><name>ppVal</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><operator>*</operator><name>ppVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Handle negative integers in a single step.  This is needed in the
  ** case when the value is -9223372036854775808.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_UMINUS</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_INTEGER</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FLOAT</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>negInt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zNeg</name> <operator>=</operator> <literal type="string">"-"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_STRING</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_FLOAT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_INTEGER</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>valueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name><operator>*</operator><name>negInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>zNeg</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_INTEGER</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_FLOAT</name> <operator>)</operator> <operator>&amp;&amp;</operator> <name>affinity</name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Real</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Str</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>enc</name><operator>!=</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_UMINUS</name></expr> )</condition> <block>{<block_content>
    <comment type="block">/* This branch happens for multiple negative signs.  Ex: -(-5) */</comment>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>valueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,<argument><expr><name>enc</name></expr></argument>,<argument><expr><name>affinity</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>,<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <name>pVal</name><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemNumerify</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>-</operator><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
        <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>double</name><operator>)</operator><name>SMALLEST_INT64</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>LARGEST_INT64</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>-</operator><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>valueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BLOB_LITERAL</name></cpp:ifndef>
  <if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_BLOB</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'X'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>valueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVal</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nVal</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zVal</name><index>[<expr><name>nVal</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><call><name>sqlite3HexToBlob</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nVal</name><operator>/</operator><literal type="number">2</literal></expr></argument>,
                         <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_FUNCTION</name> <operator>&amp;&amp;</operator> <name>pCtx</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>valueFromFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_TRUEFALSE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>valueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>

<label><name>no_mem</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppVal</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new sqlite3_value object, containing the value of pExpr.
**
** This only works for very simple expressions that consist of one constant
** token (i.e. "5", "5.1", "'a string'"). If the expression can
** be converted directly into a value, then the value is allocated and
** a pointer written to *ppVal. The caller is responsible for deallocating
** the value by passing it to sqlite3ValueFree() later on. If the expression
** cannot be converted to a value, then *ppVal is set to NULL.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ValueFromExpr</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* The database connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,        <comment type="block">/* The expression to evaluate */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,                   <comment type="block">/* Encoding to use */</comment>
  <parameter><decl><type><name>u8</name></type> <name>affinity</name></decl></parameter>,              <comment type="block">/* Affinity to use */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>     <comment type="block">/* Write the new value here */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>pExpr</name></expr> ?</condition><then> <expr><call><name>valueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>ppVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Attempt to extract a value from pExpr and use it to construct *ppVal.
**
** If pAlloc is not NULL, then an UnpackedRecord object is created for
** pAlloc if one does not exist and the new value is added to the
** UnpackedRecord object.
**
** A value is extracted in the following cases:
**
**  * (pExpr==0). In this case the value is assumed to be an SQL NULL,
**
**  * The expression is a bound variable, and this is a reprepare, or
**
**  * The expression is a literal value.
**
** On success, *ppVal is made to point to the extracted value.  The caller
** is responsible for ensuring that the value is eventually freed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stat4ValueFromExpr</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                    <comment type="block">/* The expression to extract a value from */</comment>
  <parameter><decl><type><name>u8</name></type> <name>affinity</name></decl></parameter>,                    <comment type="block">/* Affinity to use */</comment>
  <parameter><decl><type><name><name>struct</name> <name>ValueNewStat4Ctx</name></name> <modifier>*</modifier></type><name>pAlloc</name></decl></parameter>,<comment type="block">/* How to allocate space.  Or NULL */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>           <comment type="block">/* OUT: New value object (or NULL) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Skip over any TK_COLLATE nodes */</comment>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_REGISTER</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>!=</operator><name>TK_VARIABLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pExpr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>valueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VARIABLE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_EnableQPSG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBindVar</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetVarmask</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>iBindVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pReprepare</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>valueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>iBindVar</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>valueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><name>pAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVal</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pVal</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to allocate and populate UnpackedRecord 
** structures intended to be compared against sample index keys stored 
** in the sqlite_stat4 table.
**
** A single call to this function populates zero or more fields of the
** record starting with field iVal (fields are numbered from left to
** right starting with 0). A single field is populated if:
**
**  * (pExpr==0). In this case the value is assumed to be an SQL NULL,
**
**  * The expression is a bound variable, and this is a reprepare, or
**
**  * The sqlite3ValueFromExpr() function is able to extract a value 
**    from the expression (i.e. the expression is a literal value).
**
** Or, if pExpr is a TK_VECTOR, one field is populated for each of the
** vector components that match either of the two latter criteria listed
** above.
**
** Before any value is appended to the record, the affinity of the 
** corresponding column within index pIdx is applied to it. Before
** this function returns, output parameter *pnExtract is set to the
** number of values appended to the record.
**
** When this function is called, *ppRec must either point to an object
** allocated by an earlier call to this function, or must be NULL. If it
** is NULL and a value can be successfully extracted, a new UnpackedRecord
** is allocated (and *ppRec set to point to it) before returning.
**
** Unless an error is encountered, SQLITE_OK is returned. It is not an
** error if a value cannot be extracted from pExpr. If an error does
** occur, an SQLite error code is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Stat4ProbeSetValue</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                    <comment type="block">/* Index being probed */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRec</name></decl></parameter>,         <comment type="block">/* IN/OUT: Probe record */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                    <comment type="block">/* The expression to extract a value from */</comment>
  <parameter><decl><type><name>int</name></type> <name>nElem</name></decl></parameter>,                      <comment type="block">/* Maximum number of values to append */</comment>
  <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>,                       <comment type="block">/* Array element to populate */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnExtract</name></decl></parameter>                  <comment type="block">/* OUT: Values appended to the record */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtract</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>ValueNewStat4Ctx</name></name></type> <name>alloc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>alloc</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>alloc</name><operator>.</operator><name>pIdx</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>alloc</name><operator>.</operator><name>ppRec</name></name> <operator>=</operator> <name>ppRec</name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nElem</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pElem</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>pExpr</name></expr> ?</condition><then> <expr><call><name>sqlite3VectorFieldSubexpr</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name>aff</name> <init>= <expr><call><name>sqlite3IndexColumnAffinity</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iVal</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>alloc</name><operator>.</operator><name>iVal</name></name> <operator>=</operator> <name>iVal</name><operator>+</operator><name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>stat4ValueFromExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pElem</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVal</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nExtract</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnExtract</name> <operator>=</operator> <name>nExtract</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to extract a value from expression pExpr using the methods
** as described for sqlite3Stat4ProbeSetValue() above. 
**
** If successful, set *ppVal to point to a new value object and return 
** SQLITE_OK. If no value can be extracted, but no other error occurs
** (e.g. OOM), return SQLITE_OK and set *ppVal to NULL. Or, if an error
** does occur, return an SQLite error code. The final value of *ppVal
** is undefined in this case.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Stat4ValueFromExpr</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                    <comment type="block">/* The expression to extract a value from */</comment>
  <parameter><decl><type><name>u8</name></type> <name>affinity</name></decl></parameter>,                    <comment type="block">/* Affinity to use */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>           <comment type="block">/* OUT: New value object (or NULL) */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>stat4ValueFromExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Extract the iCol-th column from the nRec-byte record in pRec.  Write
** the column value into *ppVal.  If *ppVal is initially NULL then a new
** sqlite3_value object is allocated.
**
** If *ppVal is initially NULL then the caller is responsible for 
** ensuring that the value written into *ppVal is eventually freed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Stat4Column</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>,               <comment type="block">/* Pointer to buffer containing record */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRec</name></decl></parameter>,                       <comment type="block">/* Size of buffer pRec in bytes */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Column to extract */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>           <comment type="block">/* OUT: Extracted value */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* a column type code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHdr</name></decl>;</decl_stmt>                       <comment type="block">/* Size of the header in the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iHdr</name></decl>;</decl_stmt>                       <comment type="block">/* Next unread header byte */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iField</name></decl>;</decl_stmt>                     <comment type="block">/* Next unread data byte */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Size of the current data field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Column index */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pRec</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Typecast byte array */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>*</operator><name>ppVal</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Write result into this Mem object */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iHdr</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nHdr</name><operator>&gt;</operator><name>nRec</name> <operator>||</operator> <name>iHdr</name><operator>&gt;=</operator><name>nHdr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iField</name> <operator>=</operator> <name>nHdr</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>iHdr</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iHdr</name></expr>]</index></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iHdr</name><operator>==</operator><name>nHdr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iHdr</name><operator>==</operator><name>nHdr</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iHdr</name><operator>&gt;</operator><name>nHdr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>szField</name> <operator>=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iField</name> <operator>+=</operator> <name>szField</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iField</name><operator>==</operator><name>nRec</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iField</name><operator>==</operator><name>nRec</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iField</name><operator>&gt;</operator><name>nRec</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pMem</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>*</operator><name>ppVal</name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pMem</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iField</name><operator>-</operator><name>szField</name></expr>]</index></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Unless it is NULL, the argument must be an UnpackedRecord object returned
** by an earlier call to sqlite3Stat4ProbeSetValue(). This call deletes
** the object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Stat4ProbeFree</name><parameter_list>(<parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pRec</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><name><name>pRec</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>aMem</name> <init>= <expr><name><name>pRec</name><operator>-&gt;</operator><name>aMem</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>db</name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef SQLITE_ENABLE_STAT4 */</comment>

<comment type="block">/*
** Change the string value of an sqlite3_value object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ValueSetStr</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,     <comment type="block">/* Value to be set */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                <comment type="block">/* Length of string z */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,        <comment type="block">/* Text of the new string */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,               <comment type="block">/* Encoding to use */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>   <comment type="block">/* Destructor for the string */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free an sqlite3_value object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ValueFree</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>v</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>v</name><operator>)</operator><operator>-&gt;</operator><name>db</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The sqlite3ValueBytes() routine returns the number of bytes in the
** sqlite3_value object assuming that it uses the encoding "enc".
** The valueBytes() routine is a helper function.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>valueBytes</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><call><name>valueToText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pVal</name><operator>-&gt;</operator><name>n</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3ValueBytes</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pVal</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>enc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>enc</name><operator>!=</operator><name>SQLITE_UTF8</name> <operator>&amp;&amp;</operator> <name><name>pVal</name><operator>-&gt;</operator><name>enc</name></name><operator>!=</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>valueBytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
