<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/where.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This module contains C code that generates VDBE code used to process
** the WHERE clause of SQL statements.  This module is responsible for
** generating the code that loops through a table looking for applicable
** rows.  Indices are selected and used to speed the search when doing
** so is applicable.  Because this module is responsible for selecting
** indices, you might also think of this module as the "query optimizer".
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"whereInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Extra information appended to the end of sqlite3_index_info but not
** visible to the xBestIndex function, at least not directly.  The
** sqlite3_vtab_collation() interface knows how to reach it, however.
**
** This object is not an API and can be changed from one release to the
** next.  As long as allocateIndexInfo() and sqlite3_vtab_collation()
** agree on the structure, all will be well.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>HiddenIndexInfo</name></name></type> <name>HiddenIndexInfo</name>;</typedef>
<struct>struct <name>HiddenIndexInfo</name> <block>{
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>        <comment type="block">/* The Where clause being analyzed */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>           <comment type="block">/* The parsing context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eDistinct</name></decl>;</decl_stmt>           <comment type="block">/* Value to return from sqlite3_vtab_distinct() */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mIn</name></decl>;</decl_stmt>                 <comment type="block">/* Mask of terms that are &lt;col&gt; IN (...) */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mHandleIn</name></decl>;</decl_stmt>           <comment type="block">/* Terms that vtab will handle as &lt;col&gt; IN (...) */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name><name>aRhs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* RHS values for constraints. MUST BE LAST
                           ** because extra space is allocated to hold up
                           ** to nTerm such values */</comment>
}</block>;</struct>

<comment type="block">/* Forward declaration of methods */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopResize</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>WhereLoop</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Return the estimated number of output rows from a WHERE clause
*/</comment>
<function><type><name>LogEst</name></type> <name>sqlite3WhereOutputRowCount</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return one of the WHERE_DISTINCT_xxxxx values to indicate how this
** WHERE clause returns outputs for DISTINCT processing.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereIsDistinct</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of ORDER BY terms that are satisfied by the
** WHERE clause.  A return of 0 means that the output must be
** completely sorted.  A return equal to the number of ORDER BY
** terms means that no sorting is needed at all.  A return that
** is positive but less than the number of ORDER BY terms means that
** block sorting is required.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereIsOrdered</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** In the ORDER BY LIMIT optimization, if the inner-most loop is known
** to emit rows in increasing order, and if the last row emitted by the
** inner-most loop did not fit within the sorter, then we can skip all
** subsequent rows for the current iteration of the inner loop (because they
** will not fit in the sorter either) and continue with the second inner
** loop - the loop immediately outside the inner-most.
**
** When a row does not fit in the sorter (because the sorter already
** holds LIMIT+OFFSET rows that are smaller), then a jump is made to the
** label returned by this function.
**
** If the ORDER BY LIMIT optimization applies, the jump destination should
** be the continuation for the second-inner-most loop.  If the ORDER BY
** LIMIT optimization does not apply, then the jump destination should
** be the continuation for the inner-most loop.
**
** It is always safe for this routine to return the continuation of the
** inner-most loop, in the sense that a correct answer will result.  
** Returning the continuation the second inner loop is an optimization
** that might make the code run a little faster, but should not change
** the final answer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereOrderByLimitOptLabel</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pInner</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>bOrderedInnerLoop</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The ORDER BY LIMIT optimization does not apply.  Jump to the 
    ** continuation of the inner-most loop. */</comment>
    <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pInner</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInner</name><operator>-&gt;</operator><name>addrNxt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name><name>pInner</name><operator>-&gt;</operator><name>pRJ</name></name></expr> ?</condition><then> <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name></expr> </then><else>: <expr><name><name>pInner</name><operator>-&gt;</operator><name>addrNxt</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** While generating code for the min/max optimization, after handling
** the aggregate-step call to min() or max(), check to see if any
** additional looping is required.  If the output order is such that
** we are certain that the correct answer has already been found, then
** code an OP_Goto to by pass subsequent processing.
**
** Any extra OP_Goto that is coded here is an optimization.  The
** correct answer should be obtained regardless.  This OP_Goto just
** makes the answer appear faster.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereMinMaxOptEarlyOut</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pInner</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>bOrderedInnerLoop</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pInner</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pInner</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_IN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pInner</name><operator>-&gt;</operator><name>addrNxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the VDBE address or label to jump to in order to continue
** immediately with the next row of a WHERE clause.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereContinueLabel</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the VDBE address or label to jump to in order to break
** out of a WHERE loop.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereBreakLabel</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return ONEPASS_OFF (0) if an UPDATE or DELETE statement is unable to
** operate directly on the rowids returned by a WHERE clause.  Return
** ONEPASS_SINGLE (1) if the statement can operation directly because only
** a single row is to be changed.  Return ONEPASS_MULTI (2) if the one-pass
** optimization can be used on multiple 
**
** If the ONEPASS optimization is used (if this routine returns true)
** then also write the indices of open cursors used by ONEPASS
** into aiCur[0] and aiCur[1].  iaCur[0] gets the cursor of the data
** table and iaCur[1] gets the cursor used by an auxiliary index.
** Either value may be -1, indicating that cursor is not used.
** Any cursors returned will have been opened for writing.
**
** aiCur[0] and aiCur[1] both get -1 if the where-clause logic is
** unable to use the ONEPASS optimization.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereOkOnePass</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aiCur</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"%s cursors: %d %d\n"</literal></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_SINGLE</name></expr> ?</condition><then> <expr><literal type="string">"ONEPASS_SINGLE"</literal></expr> </then><else>: <expr><literal type="string">"ONEPASS_MULTI"</literal></expr></else></ternary></expr></argument>,
         <argument><expr><name><name>aiCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aiCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the WHERE loop uses the OP_DeferredSeek opcode to move
** the data cursor to the row selected by the index cursor.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereUsesDeferredSeek</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>bDeferredSeek</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Move the content of pSrc into pDest
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereOrMove</name><parameter_list>(<parameter><decl><type><name>WhereOrSet</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>WhereOrSet</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>n</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Try to insert a new prerequisite/cost entry into the WhereOrSet pSet.
**
** The new entry might overwrite an existing entry, or it might be
** appended, or it might be discarded.  Do whatever is the right thing
** so that pSet keeps the N_OR_COST best entries seen so far.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereOrInsert</name><parameter_list>(
  <parameter><decl><type><name>WhereOrSet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>,      <comment type="block">/* The WhereOrSet to be updated */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>prereq</name></decl></parameter>,        <comment type="block">/* Prerequisites of the new entry */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>rRun</name></decl></parameter>,           <comment type="block">/* Run-cost of the new entry */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nOut</name></decl></parameter>            <comment type="block">/* Number of outputs for the new entry */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereOrCost</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pSet</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rRun</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>prereq</name> <operator>&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name>prereq</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>whereOrInsert_done</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&lt;=</operator><name>rRun</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name>prereq</name><operator>)</operator><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;</operator><name>N_OR_COST</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pSet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pSet</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&gt;</operator><name><name>pSet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rRun</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pSet</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&lt;=</operator><name>rRun</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>whereOrInsert_done</name>:</label>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>prereq</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name>rRun</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;</operator><name>nOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the bitmask for the given cursor number.  Return 0 if
** iCursor is not in the set.
*/</comment>
<function><type><name>Bitmask</name></type> <name>sqlite3WhereGetMask</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Bitmask</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCursor</name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate memory that is automatically freed when pWInfo is freed.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3WhereMalloc</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereMemBlock</name> <modifier>*</modifier></type><name>pBlock</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pBlock</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pBlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBlock</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pMemToFree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pMemToFree</name></name> <operator>=</operator> <name>pBlock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBlock</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pBlock</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3WhereRealloc</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3WhereMalloc</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>&amp;&amp;</operator> <name>pOld</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WhereMemBlock</name> <modifier>*</modifier></type><name>pOldBlk</name> <init>= <expr><operator>(</operator><name>WhereMemBlock</name><operator>*</operator><operator>)</operator><name>pOld</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOldBlk</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOldBlk</name><operator>-&gt;</operator><name>sz</name></name><operator>&lt;</operator><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><name><name>pOldBlk</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new mask for cursor iCursor.
**
** There is one cursor per table in the FROM clause.  The number of
** tables in the FROM clause is limited by a test early in the
** sqlite3WhereBegin() routine.  So we know that the pMaskSet-&gt;ix[]
** array will never overflow.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createMask</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name> <operator>&lt;</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name><index>[<expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iCursor</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If the right-hand branch of the expression is a TK_COLUMN, then return
** a pointer to the right-hand branch.  Otherwise, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>whereRightSubexprIsColumn</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>p</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance to the next WhereTerm that matches according to the criteria
** established when the pScan object was initialized by whereScanInit().
** Return NULL if there are no more matching WhereTerms.
*/</comment>
<function><type><specifier>static</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>whereScanNext</name><parameter_list>(<parameter><decl><type><name>WhereScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>            <comment type="block">/* The cursor on the LHS of the term */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>iColumn</name></decl>;</decl_stmt>         <comment type="block">/* The column on the LHS of the term.  -1 for IPK */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>            <comment type="block">/* An expression being tested */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>    <comment type="block">/* Shorthand for pScan-&gt;pWC */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>    <comment type="block">/* The term being tested */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>k</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Where to start scanning */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>&lt;=</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pWC</name></name></expr>;</expr_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name>k</name></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCur</name>
         <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name><operator>==</operator><name>iColumn</name>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>iColumn</name><operator>!=</operator><name>XN_EXPR</name>
             <operator>||</operator> <call><name>sqlite3ExprCompareSkip</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,
                                       <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name></expr></argument>,<argument><expr><name>iCur</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>&lt;=</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQUIV</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name></name></expr></argument>)</argument_list></call>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>pX</name> <operator>=</operator> <call><name>whereRightSubexprIsColumn</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name>
               <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
                  <break>break;</break>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>opMask</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <comment type="block">/* Verify the affinity and collating sequence match */</comment>
            <if_stmt><if>if<condition>( <expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ISNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IndexAffinityOk</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>idxaff</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
                <continue>continue;</continue>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>pColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
                <continue>continue;</continue>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>pX</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>,</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>pX</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>
             <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
             <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
             <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pWC</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
            <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x20000</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"SCAN-TERM %p: nEquiv=%d"</literal></expr></argument>,
                 <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" {%d:%d}"</literal></expr></argument>,
                   <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></for>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><name>pTerm</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>pOuter</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>pWC</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
    <if_stmt><if>if<condition>( <expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>&gt;=</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pOrigWC</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is whereScanInit() for the case of an index on an expression.
** It is factored out into a separate tail-recursion subroutine so that
** the normal whereScanInit() routine, which is a high-runner, does not
** need to push registers onto the stack as part of its prologue.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>WhereTerm</name> <modifier>*</modifier></type><name>whereScanInitIndexExpr</name><parameter_list>(<parameter><decl><type><name>WhereScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>idxaff</name></name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>whereScanNext</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a WHERE clause scanner object.  Return a pointer to the
** first match.  Return NULL if there are no matches.
**
** The scanner will be searching the WHERE clause pWC.  It will look
** for terms of the form "X &lt;op&gt; &lt;expr&gt;" where X is column iColumn of table
** iCur.   Or if pIdx!=0 then X is column iColumn of index pIdx.  pIdx
** must be one of the indexes of table iCur.
**
** The &lt;op&gt; must be one of the operators described by opMask.
**
** If the search is for X and the WHERE clause contains terms of the
** form X=Y then this routine might also return terms of the form
** "Y &lt;op&gt; &lt;expr&gt;".  The number of levels of transitivity is limited,
** but is enough to handle most commonly occurring SQL statements.
**
** If X is not the INTEGER PRIMARY KEY then X must be compatible with
** index pIdx.
*/</comment>
<function><type><specifier>static</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>whereScanInit</name><parameter_list>(
  <parameter><decl><type><name>WhereScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,       <comment type="block">/* The WhereScan object being initialized */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,       <comment type="block">/* The WHERE clause to be scanned */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,               <comment type="block">/* Cursor to scan for */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,            <comment type="block">/* Column to scan for */</comment>
  <parameter><decl><type><name>u32</name></type> <name>opMask</name></decl></parameter>,             <comment type="block">/* Operator(s) to scan for */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>             <comment type="block">/* Must be compatible with this index */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pOrigWC</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pWC</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>idxaff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>opMask</name></name> <operator>=</operator> <name>opMask</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdx</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>iColumn</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name>XN_ROWID</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>idxaff</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iColumn</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iColumn</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>XN_EXPR</name></expr>;</expr_stmt>
      <return>return <expr><call><name>whereScanInitIndexExpr</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iColumn</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
  <return>return <expr><call><name>whereScanNext</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search for a term in the WHERE clause that is of the form "X &lt;op&gt; &lt;expr&gt;"
** where X is a reference to the iColumn of table iCur or of index pIdx
** if pIdx!=0 and &lt;op&gt; is one of the WO_xx operator codes specified by
** the op parameter.  Return a pointer to the term.  Return 0 if not found.
**
** If pIdx!=0 then it must be one of the indexes of table iCur.  
** Search for terms matching the iColumn-th column of pIdx
** rather than the iColumn-th column of table iCur.
**
** The term returned might by Y=&lt;expr&gt; if there is another constraint in
** the WHERE clause that specifies that X=Y.  Any such constraints will be
** identified by the WO_EQUIV bit in the pTerm-&gt;eOperator field.  The
** aiCur[]/iaColumn[] arrays hold X and all its equivalents. There are 11
** slots in aiCur[]/aiColumn[] so that means we can look for X plus up to 10
** other equivalent values.  Hence a search for X will return &lt;expr&gt; if X=A1
** and A1=A2 and A2=A3 and ... and A9=A10 and A10=&lt;expr&gt;.
**
** If there are multiple terms in the WHERE clause of the form "X &lt;op&gt; &lt;expr&gt;"
** then try for the one with no dependencies on &lt;expr&gt; - in other words where
** &lt;expr&gt; is a constant expression of some kind.  Only return entries of
** the form "X &lt;op&gt; Y" where Y is a column in another table if no terms of
** the form "X &lt;op&gt; &lt;const-expr&gt;" exist.   If no terms with a constant RHS
** exist, try to return a term that does not use WO_EQUIV.
*/</comment>
<function><type><name>WhereTerm</name> <modifier>*</modifier></type><name>sqlite3WhereFindTerm</name><parameter_list>(
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,     <comment type="block">/* The WHERE clause to be searched */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,             <comment type="block">/* Cursor number of LHS */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,          <comment type="block">/* Column number of LHS */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>,     <comment type="block">/* RHS must not overlap with this mask */</comment>
  <parameter><decl><type><name>u32</name></type> <name>op</name></decl></parameter>,               <comment type="block">/* Mask of WO_xx values describing operator */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>           <comment type="block">/* Must be compatible with this index, if not NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereScan</name></type> <name>scan</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>whereScanInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>&amp;=</operator> <name>WO_EQ</name><operator>|</operator><name>WO_IS</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>notReady</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>prereqRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>eOperator</name></name><operator>&amp;</operator><name>op</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pResult</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pResult</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>whereScanNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function searches pList for an entry that matches the iCol-th column
** of index pIdx.
**
** If such an expression is found, its index in pList-&gt;a[] is returned. If
** no expression is found, -1 is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findIndexCol</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,                <comment type="block">/* Expression list to search */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBase</name></decl></parameter>,                      <comment type="block">/* Cursor for table associated with pIdx */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                    <comment type="block">/* Index to match column of */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>                        <comment type="block">/* Column of index to match */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name><operator>)</operator>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iCol</name></expr>]</index></name>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iBase</name></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name>i</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the iCol-th column of index pIdx is NOT NULL
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexColumnNotNull</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>notNull</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>j</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Assume an indexed expression can always yield a NULL */</comment>

  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the DISTINCT expression-list passed as the third argument
** is redundant.
**
** A DISTINCT list is redundant if any subset of the columns in the
** DISTINCT list are collectively unique and individually non-null.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isDistinctRedundant</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,            <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,        <comment type="block">/* The FROM clause */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,         <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pDistinct</name></decl></parameter>       <comment type="block">/* The result set that needs to be DISTINCT */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          
  <decl_stmt><decl><type><name>int</name></type> <name>iBase</name></decl>;</decl_stmt>

  <comment type="block">/* If there is more than one table or sub-select in the FROM clause of
  ** this query, then it will not be possible to show that the DISTINCT 
  ** clause is redundant. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iBase</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>

  <comment type="block">/* If any of the expressions is an IPK column on table iBase, then return 
  ** true. Note: The (p-&gt;iTable==iBase) part of this test may be false if the
  ** current SELECT is a correlated sub-query.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDistinct</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pDistinct</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iBase</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Loop through all indices on the table, checking each to see if it makes
  ** the DISTINCT qualifier redundant. It does so if:
  **
  **   1. The index is itself UNIQUE, and
  **
  **   2. All of the columns in the index are either part of the pDistinct
  **      list, or else the WHERE clause contains a term of the form "col=X",
  **      where X is a constant value. The collation sequences of the
  **      comparison and select-list expressions must match those of the index.
  **
  **   3. All of those index columns for which the WHERE clause does not
  **      contain a "col=X" term are subject to a NOT NULL constraint.
  */</comment>
  <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iBase</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>WO_EQ</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>findIndexCol</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDistinct</name></expr></argument>, <argument><expr><name>iBase</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>indexColumnNotNull</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This index implies that the DISTINCT qualifier is redundant. */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Estimate the logarithm of the input value to base 2.
*/</comment>
<function><type><specifier>static</specifier> <name>LogEst</name></type> <name>estLog</name><parameter_list>(<parameter><decl><type><name>LogEst</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>N</name><operator>&lt;=</operator><literal type="number">10</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">33</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert OP_Column opcodes to OP_Copy in previously generated code.
**
** This routine runs over generated VDBE code and translates OP_Column
** opcodes into OP_Copy when the table is being accessed via co-routine 
** instead of via table lookup.
**
** If the iAutoidxCur is not zero, then any OP_Rowid instructions on
** cursor iTabCur are transformed into OP_Sequence opcode for the
** iAutoidxCur cursor, in order to generate unique rowids for the
** automatic index being generated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>translateColumnToCopy</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>,         <comment type="block">/* Translate from this opcode to the end */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>,        <comment type="block">/* OP_Column/OP_Rowid references to this table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRegister</name></decl></parameter>,      <comment type="block">/* The first column is in this register */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAutoidxCur</name></decl></parameter>     <comment type="block">/* If non-zero, cursor of autoindex being generated */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>iStart</name><operator>&lt;</operator><name>iEnd</name></expr>;</condition> <incr><expr><name>iStart</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name>iTabCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Column</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Copy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>+</operator> <name>iRegister</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* Cause the MEM_Subtype flag to be cleared */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Rowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Sequence</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iAutoidxCur</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ALLOW_ROWID_IN_VIEW</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>iAutoidxCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Two routines for printing the content of an sqlite3_index_info
** structure.  Used for testing and debugging only.  If neither
** SQLITE_TEST or SQLITE_DEBUG are defined, then these routines
** are no-ops.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WHERETRACE_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereTraceIndexInfoInputs</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x10</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
       <argument><expr><literal type="string">"  constraint[%d]: col=%d termid=%d op=%d usabled=%d collseq=%s\n"</literal></expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iTermOffset</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>usable</name></expr></argument>,
       <argument><expr><call><name>sqlite3_vtab_collation</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOrderBy</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  orderby[%d]: col=%d desc=%d\n"</literal></expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereTraceIndexInfoOutputs</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x10</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  usage[%d]: argvIdx=%d omit=%d\n"</literal></expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  idxNum=%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>idxNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  idxStr=%s\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  orderByConsumed=%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>orderByConsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  estimatedCost=%g\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>estimatedCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  estimatedRows=%lld\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>estimatedRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>whereTraceIndexInfoInputs</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>whereTraceIndexInfoOutputs</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We know that pSrc is an operand of an outer join.  Return true if
** pTerm is a constraint that is compatible with that join.
**
** pTerm must be EP_OuterON if pSrc is the right operand of an
** outer join.  pTerm can be either EP_OuterON or EP_InnerON if pSrc
** is the left operand of a RIGHT join.
**
** See https://sqlite.org/forum/forumpost/206d99a16dd9212f
** for an example of a WHERE clause constraints that may not be used on
** the right table of a RIGHT JOIN because the constraint implies a
** not-NULL condition on the left table of the RIGHT JOIN.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>constraintCompatibleWithOuterJoin</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>,       <comment type="block">/* WHERE clause term to check */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>           <comment type="block">/* Table we are trying to access */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name><operator>&amp;</operator><operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* By caller */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>==</operator><name>JT_LEFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>==</operator><name>JT_LTORJ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>testcase</name><argument_list>( <argument>ExprHasProperty(pTerm-&gt;pExpr, EP_OuterON)</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call>
   <operator>||</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name> <operator>!=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
 


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
<comment type="block">/*
** Return TRUE if the WHERE clause term pTerm is of a form where it
** could be used with an index to access pSrc, assuming an appropriate
** index existed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>termCanDriveIndex</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>,        <comment type="block">/* WHERE clause term to check */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,           <comment type="block">/* Table we are trying to access */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Bitmask</name></type> <name>notReady</name></decl></parameter>         <comment type="block">/* Tables in outer loops of the join */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>!</operator><call><name>constraintCompatibleWithOuterJoin</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>,<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* See https://sqlite.org/forum/forumpost/51e6959f61 */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>notReady</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aff</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IndexAffinityOk</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
<comment type="block">/*
** Generate code to construct the Index object for an automatic index
** and to set up the WhereLevel object pLevel so that the code generator
** makes use of the automatic index.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>constructAutomaticIndex</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,              <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,     <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,        <comment type="block">/* The FROM clause term to get the next index */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Bitmask</name></type> <name>notReady</name></decl></parameter>,     <comment type="block">/* Mask of cursors that are not available */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>          <comment type="block">/* Write new index here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nKeyCol</name></decl>;</decl_stmt>                <comment type="block">/* Number of columns in the constructed index */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>           <comment type="block">/* A single term of the WHERE clause */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pWCEnd</name></decl>;</decl_stmt>          <comment type="block">/* End of pWC-&gt;a[] */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                <comment type="block">/* Object describing the transient index */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                    <comment type="block">/* Prepared statement under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrInit</name></decl>;</decl_stmt>               <comment type="block">/* Address of the initialization bypass jump */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl>;</decl_stmt>              <comment type="block">/* The table being indexed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>                <comment type="block">/* Top of the index fill loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name></decl>;</decl_stmt>              <comment type="block">/* Register holding an index record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                      <comment type="block">/* Column counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxBitCol</name></decl>;</decl_stmt>               <comment type="block">/* Maximum column in pSrc-&gt;colUsed */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>             <comment type="block">/* Collating sequence to on a column */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>           <comment type="block">/* The Loop object */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNotUsed</name></decl>;</decl_stmt>             <comment type="block">/* Extra space on the end of pIdx */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>idxCols</name></decl>;</decl_stmt>            <comment type="block">/* Bitmap of columns used for indexing */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>extraCols</name></decl>;</decl_stmt>          <comment type="block">/* Bitmap of additional columns */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>sentWarning</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* True if a warnning has been issued */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pPartial</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Partial Index Expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iContinue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Jump here to skip excluded rows */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name></decl>;</decl_stmt>          <comment type="block">/* FROM clause term being indexed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Address where integer counter is initialized */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                <comment type="block">/* Array of registers where record is assembled */</comment>

  <comment type="block">/* Generate code to skip over the creation and initialization of the
  ** transient index on 2nd and subsequent iterations of the loop. */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrInit</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Count the number of columns that will be added to the index
  ** and used to match WHERE clause constraints */</comment>
  <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWCEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>idxCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Make the automatic index a partial index if there are terms in the
    ** WHERE clause (or the ON clause of a LEFT join) that constrain which
    ** rows of the target table (pSrc) that can be used. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsTableConstraint</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>pPartial</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPartial</name></expr></argument>,
                                <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>termCanDriveIndex</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>cMask</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cMask</name> <operator>=</operator> <ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><name>BMS</name></expr> ?</condition><then> <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>sentWarning</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING_AUTOINDEX</name></expr></argument>,
            <argument><expr><literal type="string">"automatic index on %s(%s)"</literal></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
            <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sentWarning</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxCols</name> <operator>&amp;</operator> <name>cMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pLoop</name></expr></argument>, <argument><expr><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <goto>goto <name>end_auto_index_create</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>nKeyCol</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxCols</name> <operator>|=</operator> <name>cMask</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKeyCol</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>nKeyCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_COLUMN_EQ</name> <operator>|</operator> <name>WHERE_IDX_ONLY</name> <operator>|</operator> <name>WHERE_INDEXED</name>
                     <operator>|</operator> <name>WHERE_AUTO_INDEX</name></expr>;</expr_stmt>

  <comment type="block">/* Count the number of additional columns needed to create a
  ** covering index.  A "covering index" is an index that contains all
  ** columns that are needed by the query.  With a covering index, the
  ** original table never needs to be accessed.  Automatic indices must
  ** be a covering index because the index will not be updated if the
  ** original table changes and the index and table cannot both be used
  ** if they go out of sync.
  */</comment>
  <expr_stmt><expr><name>extraCols</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>idxCols</name> <operator>|</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxBitCol</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mxBitCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>extraCols</name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKeyCol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nKeyCol</name> <operator>+=</operator> <name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name> <operator>-</operator> <name>BMS</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Construct the Index object to describe this index */</comment>
  <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <call><name>sqlite3AllocateIndexObject</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zNotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_auto_index_create</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <literal type="string">"auto-index"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name> <operator>=</operator> <name>pTable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>idxCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>termCanDriveIndex</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>cMask</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cMask</name> <operator>=</operator> <ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><name>BMS</name></expr> ?</condition><then> <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxCols</name> <operator>&amp;</operator> <name>cMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>idxCols</name> <operator>|=</operator> <name>cMask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pColl</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* TH3 collate01.800 */</comment>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>pColl</name></expr> ?</condition><then> <expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><name>sqlite3StrBINARY</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>n</name><operator>==</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add additional columns needed to make the automatic index into
  ** a covering index */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mxBitCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>extraCols</name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name>nKeyCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>XN_ROWID</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>

  <comment type="block">/* Create the automatic index */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenAutoindex</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"for %s"</literal><operator>,</operator> <name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_BloomFilter</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr><literal type="number">10000</literal></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Fill the automatic index with content */</comment>
  <expr_stmt><expr><name>pTabItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regYield</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>addrCounter</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrTop</name> <operator>=</operator>  <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"next row of %s"</literal><operator>,</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPartial</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iContinue</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPartial</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_PARTIALIDX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>regRecord</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regBase</name> <operator>=</operator> <call><name>sqlite3GenerateIndexKey</name><argument_list>(
      <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FilterAdd</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                         <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPartial</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCounter</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>translateColumnToCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>,
                          <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><name>addrTop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_AUTOINDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Jump here when skipping the initialization */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end_auto_index_create</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pPartial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOMATIC_INDEX */</comment>

<comment type="block">/*
** Generate bytecode that will initialize a Bloom filter that is appropriate
** for pLevel.
**
** If there are inner loops within pLevel that have the WHERE_BLOOMFILTER
** flag set, initialize a Bloomfilter for them as well.  Except don't do
** this recursive initialization if the SQLITE_BloomPulldown optimization has
** been turned off.
**
** When the Bloom filter is initialized, the WHERE_BLOOMFILTER flag is cleared
** from the loop, but the regFilter value is set to a register that implements
** the Bloom filter.  When regFilter is positive, the
** sqlite3WhereCodeOneLoopStart() will generate code to test the Bloom filter
** and skip the subsequence B-Tree seek if the Bloom filter indicates that
** no matching rows exist.
**
** This routine may only be called if it has previously been determined that
** the loop would benefit from a Bloom filter, and the WHERE_BLOOMFILTER bit
** is set.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>sqlite3ConstructBloomFilter</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,    <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,           <comment type="block">/* Index in pWInfo-&gt;a[] that is pLevel */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,   <comment type="block">/* Make a Bloom filter for this FROM term */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>      <comment type="block">/* Loops that are not ready */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOnce</name></decl>;</decl_stmt>                        <comment type="block">/* Address of opening OP_Once */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>                         <comment type="block">/* Address of OP_Rewind */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name></decl>;</decl_stmt>                        <comment type="block">/* Jump here to skip a row */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>              <comment type="block">/* For looping over WHERE clause terms */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>pWCEnd</name></decl>;</decl_stmt>             <comment type="block">/* Last WHERE clause term */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* VDBE under construction */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The loop being coded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>                            <comment type="block">/* Cursor for table getting the filter */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLoop</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BLOOMFILTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>addrOnce</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>sz</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereExplainBloomFilter</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrCont</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>

    <comment type="block">/* The Bloom filter is a Blob held in a register.  Initialize it
    ** to zero-filled blob of at least 80K bits, but maybe more if the
    ** estimated size of the table is larger.  We could actually
    ** measure the size of the table at run-time using OP_Count with
    ** P3==1 and use that value to initialize the blob.  But that makes
    ** testing complicated.  By basing the blob size on the value in the
    ** sqlite_stat1 table, testing is much easier.
    */</comment>
    <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&lt;</operator><literal type="number">10000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>sz</name><operator>&gt;</operator><literal type="number">10000000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">10000000</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWCEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name><operator>.</operator><name>a</name><index>[<expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name><operator>.</operator><name>nTerm</name></name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name><operator>.</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsTableConstraint</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FilterAdd</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>jj</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name><operator>==</operator><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>,<argument><expr><name>r1</name><operator>+</operator><name>jj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FilterAdd</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regFilter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><name>addrTop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_BLOOMFILTER</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_BloomPulldown</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><operator>++</operator><name>iLevel</name> <operator>&lt;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pLevel</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTabItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pLoop</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name>notReady</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_BLOOMFILTER</name><operator>|</operator><name>WHERE_COLUMN_IN</name><operator>)</operator><operator>)</operator>
                 <operator>==</operator><name>WHERE_BLOOMFILTER</name></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* This is a candidate for bloom-filter pull-down (early evaluation).
        ** The test that WHERE_COLUMN_IN is omitted is important, as we are
        ** not able to do early evaluation of bloom filters that make use of
        ** the IN operator */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block>while<condition>( <expr><name>iLevel</name> <operator>&lt;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr> )</condition>;</do>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Allocate and populate an sqlite3_index_info structure. It is the 
** responsibility of the caller to eventually release the structure
** by passing the pointer returned by this function to freeIndexInfo().
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_index_info</name> <modifier>*</modifier></type><name>allocateIndexInfo</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,              <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,               <comment type="block">/* The WHERE clause being analyzed */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mUnusable</name></decl></parameter>,              <comment type="block">/* Ignore terms with these prereqs */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,                  <comment type="block">/* The FROM clause term that is the vtab */</comment>
  <parameter><decl><type><name>u16</name> <modifier>*</modifier></type><name>pmNoOmit</name></decl></parameter>                   <comment type="block">/* Mask of terms not to omit */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pIdxCons</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_orderby</name></name> <modifier>*</modifier></type><name>pIdxOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint_usage</name></name> <modifier>*</modifier></type><name>pUsage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>HiddenIndexInfo</name></name> <modifier>*</modifier></type><name>pHidden</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mNoOmit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eDistinct</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find all WHERE clause constraints referring to this virtual table.
  ** Mark each term with the TERM_OK flag.  Set nTerm to the number of
  ** terms found.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nTerm</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TERM_OK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>!=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>mUnusable</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsPowerOfTwo</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>~</operator><name>WO_EQUIV</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ALL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>WO_EQUIV</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name><operator>&gt;=</operator><name>XN_ROWID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>constraintCompatibleWithOuterJoin</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>,<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nTerm</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_OK</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If the ORDER BY clause contains only columns in the current 
  ** virtual table then allocate space for the aOrderBy part of
  ** the sqlite3_index_info structure.
  */</comment>
  <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name></decl>;</decl_stmt>

      <comment type="block">/* Skip over constant terms in the ORDER BY clause */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Virtual tables are unable to deal with NULLS FIRST */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* First case - a direct column references without a COLLATE operator */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><name>XN_ROWID</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* 2nd case - a column reference with a COLLATE operator.  Only match
      ** of the COLLATE operator matches the collation of the column. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>pE2</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator><operator>-&gt;</operator><name>op</name><operator>==</operator><name>TK_COLUMN</name>
       <operator>&amp;&amp;</operator> <name><name>pE2</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>  <comment type="block">/* The collating sequence name */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><name>XN_ROWID</name> <operator>&amp;&amp;</operator> <name><name>pE2</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name><name>pE2</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pE2</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Collseq does not matter for rowid */</comment>
        <expr_stmt><expr><name>zColl</name> <operator>=</operator> <call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pE2</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColl</name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* No matches cause a break out of the loop */</comment>
      <break>break;</break>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>n</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eDistinct</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_SORTBYGROUP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_GROUPBY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eDistinct</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate the sqlite3_index_info structure
  */</comment>
  <expr_stmt><expr><name>pIdxInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pIdxInfo</name></expr></argument>)</argument_list></sizeof>
                           <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pIdxCons</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pUsage</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><name>nTerm</name>
                           <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pIdxOrderBy</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nOrderBy</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pHidden</name></expr></argument>)</argument_list></sizeof>
                           <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdxInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pHidden</name> <operator>=</operator> <operator>(</operator>struct <name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxCons</name> <operator>=</operator> <operator>(</operator>struct <name>sqlite3_index_constraint</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pHidden</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>nTerm</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxOrderBy</name> <operator>=</operator> <operator>(</operator>struct <name>sqlite3_index_orderby</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxCons</name><index>[<expr><name>nTerm</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pUsage</name> <operator>=</operator> <operator>(</operator>struct <name>sqlite3_index_constraint_usage</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxOrderBy</name><index>[<expr><name>nOrderBy</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name> <operator>=</operator> <name>pIdxCons</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name></name> <operator>=</operator> <name>pIdxOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name></name> <operator>=</operator> <name>pUsage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>pWC</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>eDistinct</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>mIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>op</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iColumn</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iTermOffset</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ALL</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WO_IN</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_SLICE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>mIn</name></name> <operator>|=</operator> <call><name>SMASKBIT32</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name>WO_EQ</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WO_AUX</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name> <operator>&amp;</operator> <operator>(</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WO_ISNULL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>SQLITE_INDEX_CONSTRAINT_ISNULL</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>SQLITE_INDEX_CONSTRAINT_IS</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
      <comment type="block">/* The direct assignment in the previous line is possible only because
      ** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The
      ** following asserts verify this fact. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_EQ</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_LT</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_LE</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_GT</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_GE</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>&amp;</operator><operator>(</operator><name>WO_IN</name><operator>|</operator><name>WO_EQ</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>|</operator><name>WO_AUX</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>op</name> <operator>&amp;</operator> <operator>(</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsVector</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>j</name><operator>!=</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">16</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mNoOmit</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WO_LT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>WO_LE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WO_GT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>WO_GE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><name>nTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
         <operator>||</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
              <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>iColumn</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxOrderBy</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iColumn</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxOrderBy</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>desc</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pmNoOmit</name> <operator>=</operator> <name>mNoOmit</name></expr>;</expr_stmt>
  <return>return <expr><name>pIdxInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an sqlite3_index_info structure allocated by allocateIndexInfo()
** and possibly modified by xBestIndex methods.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeIndexInfo</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HiddenIndexInfo</name> <modifier>*</modifier></type><name>pHidden</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdxInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pHidden</name> <operator>=</operator> <operator>(</operator><name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pHidden</name><operator>-&gt;</operator><name>pParse</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pHidden</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>pHidden</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IMP: R-14553-25174 */</comment>
    <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The table object reference passed as the second argument to this function
** must represent a virtual table. This function invokes the xBestIndex()
** method of the virtual table with the sqlite3_index_info object that
** comes in as the 3rd argument to this function.
**
** If an error occurs, pParse is populated with an error message and an
** appropriate error code is returned.  A return of SQLITE_CONSTRAINT from
** xBestIndex is not considered an error.  SQLITE_CONSTRAINT indicates that
** the current configuration of "unusable" flags in sqlite3_index_info can
** not result in a valid plan.
**
** Whether or not an error is returned, it is the responsibility of the
** caller to eventually free p-&gt;idxStr if p-&gt;needToFreeIdxStr indicates
** that this is required.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vtabBestIndex</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>whereTraceIndexInfoInputs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nSchemaLock</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xBestIndex</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nSchemaLock</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereTraceIndexInfoOutputs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_CONSTRAINT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIRTUALTABLE) */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Estimate the location of a particular key among all keys in an
** index.  Store the results in aStat as follows:
**
**    aStat[0]      Est. number of rows less than pRec
**    aStat[1]      Est. number of rows equal to pRec
**
** Return the index of the sample that is the smallest sample that
** is greater than or equal to pRec. Note that this index is not an index
** into the aSample[] array - it is an index into a virtual set of samples
** based on the contents of aSample[] and the number of fields in record 
** pRec. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereKeyStats</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,              <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                <comment type="block">/* Index to consider domain of */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>,       <comment type="block">/* Vector of values to consider */</comment>
  <parameter><decl><type><name>int</name></type> <name>roundUp</name></decl></parameter>,                <comment type="block">/* Round up if true.  Round down if false */</comment>
  <parameter><decl><type><name>tRowcnt</name> <modifier>*</modifier></type><name>aStat</name></decl></parameter>              <comment type="block">/* OUT: stats written here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IndexSample</name> <modifier>*</modifier></type><name>aSample</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aSample</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                   <comment type="block">/* Index of required stats in anEq[] etc. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Index of first sample &gt;= pRec */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSample</name></decl>;</decl_stmt>                <comment type="block">/* Smallest sample larger than or equal to pRec */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Smallest sample not yet tested */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTest</name></decl>;</decl_stmt>                  <comment type="block">/* Next sample to test */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>                    <comment type="block">/* Result of comparison operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>                 <comment type="block">/* Number of fields in pRec */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iLower</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* anLt[] + anEq[] of largest sample pRec is &gt; */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifndef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>( <argument><expr><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRec</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do a binary search to find the first sample greater than or equal
  ** to pRec. If pRec contains a single field, the set of samples to search
  ** is simply the aSample[] array. If the samples in aSample[] contain more
  ** than one fields, all fields following the first are ignored.
  **
  ** If pRec contains N fields, where N is more than one, then as well as the
  ** samples in aSample[] (truncated to N fields), the search also has to
  ** consider prefixes of those samples. For example, if the set of samples
  ** in aSample is:
  **
  **     aSample[0] = (a, 5) 
  **     aSample[1] = (a, 10) 
  **     aSample[2] = (b, 5) 
  **     aSample[3] = (c, 100) 
  **     aSample[4] = (c, 105)
  **
  ** Then the search space should ideally be the samples above and the 
  ** unique prefixes [a], [b] and [c]. But since that is hard to organize, 
  ** the code actually searches this set:
  **
  **     0: (a) 
  **     1: (a, 5) 
  **     2: (a, 10) 
  **     3: (a, 10) 
  **     4: (b) 
  **     5: (b, 5) 
  **     6: (c) 
  **     7: (c, 100) 
  **     8: (c, 105)
  **     9: (c, 105)
  **
  ** For each sample in the aSample[] array, N samples are present in the
  ** effective sample array. In the above, samples 0 and 1 are based on 
  ** sample aSample[0]. Samples 2 and 3 on aSample[1] etc.
  **
  ** Often, sample i of each block of N effective samples has (i+1) fields.
  ** Except, each sample may be extended to ensure that it is greater than or
  ** equal to the previous sample in the array. For example, in the above, 
  ** sample 2 is the first sample of a block of N samples, so at first it 
  ** appears that it should be 1 field in size. However, that would make it 
  ** smaller than sample 1, so the binary search would not work. As a result, 
  ** it is extended to two fields. The duplicates that this creates do not 
  ** cause any problems.
  */</comment>
  <expr_stmt><expr><name>nField</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSample</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name> <operator>*</operator> <name>nField</name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSamp</name></decl>;</decl_stmt>                    <comment type="block">/* Index in aSample[] of test sample */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                        <comment type="block">/* Number of fields in test sample */</comment>

    <expr_stmt><expr><name>iTest</name> <operator>=</operator> <operator>(</operator><name>iMin</name><operator>+</operator><name>iSample</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSamp</name> <operator>=</operator> <name>iTest</name> <operator>/</operator> <name>nField</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iSamp</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The proposed effective sample is a prefix of sample aSample[iSamp].
      ** Specifically, the shortest prefix of at least (1 + iTest%nField) 
      ** fields that is greater than the previous effective sample.  */</comment>
      <for>for<control>(<init><expr><name>n</name><operator>=</operator><operator>(</operator><name>iTest</name> <operator>%</operator> <name>nField</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nField</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aSample</name><index>[<expr><name>iSamp</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name>iTest</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anEq</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iTest</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>nField</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iTest</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iSample</name> <operator>=</operator> <name>iTest</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>res</name> <operator>&amp;&amp;</operator> <name>iMin</name><operator>&lt;</operator><name>iSample</name></expr> )</condition>;</do>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name>iSample</name> <operator>/</operator> <name>nField</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* The following assert statements check that the binary search code
  ** above found the right answer. This block serves no purpose other
  ** than to invoke the asserts.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If (res==0) is true, then pRec must be equal to sample i. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>nField</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call> 
           <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> 
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Unless i==pIdx-&gt;nSample, indicating that pRec is larger than
      ** all samples in the aSample[] array, pRec must be smaller than the
      ** (iCol+1) field prefix of sample i.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>iCol</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name> 
           <operator>||</operator> <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal>
           <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* if i==0 and iCol==0, then record pRec is smaller than all samples
      ** in the aSample[] array. Otherwise, if (iCol&gt;0) then pRec must
      ** be greater than or equal to the (iCol) field prefix of sample i.
      ** If (i&gt;0), then pRec must also be greater than sample (i-1).  */</comment>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal>
             <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal>
             <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef SQLITE_DEBUG */</comment>

  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Record pRec is equal to sample i */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>nField</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>anEq</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* At this point, the (iCol+1) field prefix of aSample[i] is the first 
    ** sample that is greater than pRec. Or, if i==pIdx-&gt;nSample then pRec
    ** is larger than all samples in the array. */</comment>
    <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iUpper</name></decl>, <decl><type ref="prev"/><name>iGap</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nRowEst0</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iLower</name><operator>&gt;=</operator><name>iUpper</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <name>iUpper</name> <operator>-</operator> <name>iLower</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>roundUp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <operator>(</operator><name>iGap</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <name>iGap</name><operator>/</operator><literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iLower</name> <operator>+</operator> <name>iGap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aAvgEq</name><index>[<expr><name>nField</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Restore the pRec-&gt;nField value before returning.  */</comment>
  <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT4 */</comment>

<comment type="block">/*
** If it is not NULL, pTerm is a term that provides an upper or lower
** bound on a range scan. Without considering pTerm, it is estimated 
** that the scan will visit nNew rows. This function returns the number
** estimated to be visited after taking pTerm into account.
**
** If the user explicitly specified a likelihood() value for this term,
** then the return value is the likelihood multiplied by the number of
** input rows. Otherwise, this function assumes that an "IS NOT NULL" term
** has a likelihood of 0.50, and any other term a likelihood of 0.25.
*/</comment>
<function><type><specifier>static</specifier> <name>LogEst</name></type> <name>whereRangeAdjust</name><parameter_list>(<parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>LogEst</name></type> <name>nNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>nRet</name> <init>= <expr><name>nNew</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTerm</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRet</name> <operator>+=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRet</name> <operator>-=</operator> <literal type="number">20</literal></expr>;</expr_stmt>        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">20</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Return the affinity for a single column of an index.
*/</comment>
<function><type><name>char</name></type> <name>sqlite3IndexColumnAffinity</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_AFF_BLOB</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
<comment type="block">/* 
** This function is called to estimate the number of rows visited by a
** range-scan on a skip-scan index. For example:
**
**   CREATE INDEX i1 ON t1(a, b, c);
**   SELECT * FROM t1 WHERE a=? AND c BETWEEN ? AND ?;
**
** Value pLoop-&gt;nOut is currently set to the estimated number of rows 
** visited for scanning (a=? AND b=?). This function reduces that estimate 
** by some factor to account for the (c BETWEEN ? AND ?) expression based
** on the stat4 data for the index. this scan will be peformed multiple 
** times (once for each (a,b) combination that matches a=?) is dealt with 
** by the caller.
**
** It does this by scanning through all stat4 samples, comparing values
** extracted from pLower and pUpper with the corresponding column in each
** sample. If L and U are the number of samples found to be less than or
** equal to the values extracted from pLower and pUpper respectively, and
** N is the total number of samples, the pLoop-&gt;nOut value is adjusted
** as follows:
**
**   nOut = nOut * ( min(U - L, 1) / N )
**
** If pLower is NULL, or a value cannot be extracted from the term, L is
** set to zero. If pUpper is NULL, or a value cannot be extracted from it,
** U is set to N.
**
** Normally, this function sets *pbDone to 1 before returning. However,
** if no value can be extracted from either pLower or pUpper (and so the
** estimate of the number of rows delivered remains unchanged), *pbDone
** is left as is.
**
** If an error occurs, an SQLite error code is returned. Otherwise, 
** SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereRangeSkipScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pLower</name></decl></parameter>,   <comment type="block">/* Lower bound on the range. ex: "x&gt;123" Might be NULL */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pUpper</name></decl></parameter>,   <comment type="block">/* Upper bound on the range. ex: "x&lt;455" Might be NULL */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>,    <comment type="block">/* Update the .nOut value of this loop */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbDone</name></decl></parameter>          <comment type="block">/* Set to true if at least one expr. value extracted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLower</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUpper</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>aff</name> <init>= <expr><call><name>sqlite3IndexColumnAffinity</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Value extracted from pLower */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Value extracted from pUpper */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Value extracted from record */</comment>

  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>nEq</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pLower</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ValueFromExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pLower</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLower</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUpper</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ValueFromExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pUpper</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nUpper</name> <operator>=</operator> <ternary><condition><expr><name>p2</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>p1</name> <operator>||</operator> <name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDiff</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4Column</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p1</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nLower</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p2</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nUpper</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>nDiff</name> <operator>=</operator> <operator>(</operator><name>nUpper</name> <operator>-</operator> <name>nLower</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nDiff</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nDiff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If there is both an upper and lower bound specified, and the 
    ** comparisons indicate that they are close together, use the fallback
    ** method (assume that the scan visits 1/64 of the rows) for estimating
    ** the number of rows visited. Otherwise, estimate the number of rows
    ** using the method described in the header comment for this function. */</comment>
    <if_stmt><if>if<condition>( <expr><name>nDiff</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <name>pUpper</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pLower</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nAdjust</name> <init>= <expr><operator>(</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>nDiff</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nAdjust</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pbDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"range skip-scan regions: %u..%u  adjust=%d est=%d\n"</literal><operator>,</operator>
                           <name>nLower</name><operator>,</operator> <name>nUpper</name><operator>,</operator> <name>nAdjust</name><operator>*</operator><operator>-</operator><literal type="number">1</literal><operator>,</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbDone</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT4 */</comment>

<comment type="block">/*
** This function is used to estimate the number of rows that will be visited
** by scanning an index for a range of values. The range may have an upper
** bound, a lower bound, or both. The WHERE clause terms that set the upper
** and lower bounds are represented by pLower and pUpper respectively. For
** example, assuming that index p is on t1(a):
**
**   ... FROM t1 WHERE a &gt; ? AND a &lt; ? ...
**                    |_____|   |_____|
**                       |         |
**                     pLower    pUpper
**
** If either of the upper or lower bound is not present, then NULL is passed in
** place of the corresponding WhereTerm.
**
** The value in (pBuilder-&gt;pNew-&gt;u.btree.nEq) is the number of the index
** column subject to the range constraint. Or, equivalently, the number of
** equality constraints optimized by the proposed index scan. For example,
** assuming index p is on t1(a, b), and the SQL query is:
**
**   ... FROM t1 WHERE a = ? AND b &gt; ? AND b &lt; ? ...
**
** then nEq is set to 1 (as the range restricted column, b, is the second 
** left-most column of the index). Or, if the query is:
**
**   ... FROM t1 WHERE a &gt; ? AND a &lt; ? ...
**
** then nEq is set to 0.
**
** When this function is called, *pnOut is set to the sqlite3LogEst() of the
** number of rows that the index scan is expected to visit without 
** considering the range constraints. If nEq is 0, then *pnOut is the number of 
** rows in the index. Assuming no error occurs, *pnOut is adjusted (reduced)
** to account for the range constraints pLower and pUpper.
** 
** In the absence of sqlite_stat4 ANALYZE data, or if such data cannot be
** used, a single range inequality reduces the search space by a factor of 4. 
** and a pair of constraints (x&gt;? AND x&lt;?) reduces the expected number of
** rows visited by a factor of 64.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereRangeScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pLower</name></decl></parameter>,   <comment type="block">/* Lower bound on the range. ex: "x&gt;123" Might be NULL */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pUpper</name></decl></parameter>,   <comment type="block">/* Upper bound on the range. ex: "x&lt;455" Might be NULL */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>     <comment type="block">/* Modify the .nOut and maybe .rRun fields */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>nNew</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>nEq</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSampleCol</name></name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_Stat4</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>==</operator><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tRowcnt</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nBtm</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nTop</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Variable iLower will be set to the estimate of the number of rows in 
      ** the index that are less than the lower bound of the range query. The
      ** lower bound being the concatenation of $P and $L, where $P is the
      ** key-prefix formed by the nEq values matched against the nEq left-most
      ** columns of the index, and $L is the value in pLower.
      **
      ** Or, if pLower is NULL or $L cannot be extracted from it (because it
      ** is not a simple variable or literal value), the lower bound of the
      ** range is $P. Due to a quirk in the way whereKeyStats() works, even
      ** if $L is available, whereKeyStats() is called for both ($P) and 
      ** ($P:$L) and the larger of the two returned values is used.
      **
      ** Similarly, iUpper is to be set to the estimate of the number of rows
      ** less than the upper bound of the range query. Where the upper bound
      ** is either ($P) or ($P:$U). Again, even if $U is available, both values
      ** of iUpper are requested of whereKeyStats() and the smaller used.
      **
      ** The number of rows between the two bounds is then just iUpper-iLower.
      */</comment>
      <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iLower</name></decl>;</decl_stmt>     <comment type="block">/* Rows less than the lower bound */</comment>
      <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iUpper</name></decl>;</decl_stmt>     <comment type="block">/* Rows less than the upper bound */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iLwrIdx</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* aSample[] for the lower bound */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iUprIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* aSample[] for the upper bound */</comment>

      <if_stmt><if>if<condition>( <expr><name>pRec</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name><operator>!=</operator><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Determine iLower and iUpper using ($P) only. */</comment>
      <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iLower</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nRowEst0</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Note: this call could be optimized away - since the same values must 
        ** have been requested when testing key $P in whereEqualScanEst().  */</comment>
        <expr_stmt><expr><call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLower</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pLower</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pUpper</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pUpper</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSortOrder</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The roles of pLower and pUpper are swapped for a DESC index */</comment>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>WhereTerm</name><operator>*</operator></expr></argument>, <argument><expr><name>pLower</name></expr></argument>, <argument><expr><name>pUpper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>nBtm</name></expr></argument>, <argument><expr><name>nTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If possible, improve on the iLower estimate using ($P:$L). */</comment>
      <if_stmt><if>if<condition>( <expr><name>pLower</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                    <comment type="block">/* Values extracted from pExpr */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pLower</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ProbeSetValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRec</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>nBtm</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>n</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iNew</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u16</name></type> <name>mask</name> <init>= <expr><name>WO_GT</name><operator>|</operator><name>WO_LE</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><name>WO_LE</name><operator>|</operator><name>WO_LT</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>iLwrIdx</name> <operator>=</operator> <call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iNew</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pLower</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&gt;</operator><name>iLower</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nOut</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pLower</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If possible, improve on the iUpper estimate using ($P:$U). */</comment>
      <if_stmt><if>if<condition>( <expr><name>pUpper</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                    <comment type="block">/* Values extracted from pExpr */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pUpper</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ProbeSetValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRec</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>nTop</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>n</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iNew</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u16</name></type> <name>mask</name> <init>= <expr><name>WO_GT</name><operator>|</operator><name>WO_LE</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><name>WO_LE</name><operator>|</operator><name>WO_LT</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>iUprIdx</name> <operator>=</operator> <call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iNew</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pUpper</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&lt;</operator><name>iUpper</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nOut</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pUpper</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iUpper</name><operator>&gt;</operator><name>iLower</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>iUpper</name> <operator>-</operator> <name>iLower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* TUNING:  If both iUpper and iLower are derived from the same
          ** sample, then assume they are 4x more selective.  This brings
          ** the estimated selectivity more in line with what it would be
          ** if estimated without the use of STAT4 tables. */</comment>
          <if_stmt><if>if<condition>( <expr><name>iLwrIdx</name><operator>==</operator><name>iUprIdx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>-=</operator> <literal type="number">20</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">20</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">10</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nOut</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"STAT4 range scan: %u..%u  est=%d\n"</literal><operator>,</operator>
                           <operator>(</operator><name>u32</name><operator>)</operator><name>iLower</name><operator>,</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iUpper</name><operator>,</operator> <name>nOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereRangeSkipScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLower</name></expr></argument>, <argument><expr><name>pUpper</name></expr></argument>, <argument><expr><name>pLoop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bDone</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLower</name> <operator>||</operator> <name>pUpper</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pUpper</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pUpper</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>whereRangeAdjust</name><argument_list>(<argument><expr><name>pLower</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>whereRangeAdjust</name><argument_list>(<argument><expr><name>pUpper</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* TUNING: If there is both an upper and lower limit and neither limit
  ** has an application-defined likelihood(), assume the range is
  ** reduced by an additional 75%. This means that, by default, an open-ended
  ** range query (e.g. col &gt; ?) is assumed to match 1/4 of the rows in the
  ** index. While a closed range (e.g. col BETWEEN ? AND ?) is estimated to
  ** match 1/64 of the index. */</comment> 
  <if_stmt><if>if<condition>( <expr><name>pLower</name> <operator>&amp;&amp;</operator> <name><name>pLower</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pUpper</name> <operator>&amp;&amp;</operator> <name><name>pUpper</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nNew</name> <operator>-=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nOut</name> <operator>-=</operator> <operator>(</operator><name>pLower</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>pUpper</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WHERETRACE_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;</operator><name>nOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Range scan lowers nOut from %d to %d\n"</literal><operator>,</operator>
                    <name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>,</operator> <name>nOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>)</operator><name>nOut</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Estimate the number of rows that will be returned based on
** an equality constraint x=VALUE and where that VALUE occurs in
** the histogram data.  This only works when x is the left-most
** column of an index and sqlite_stat4 histogram data is available
** for that index.  When pExpr==NULL that means the constraint is
** "x IS NULL" instead of "x=VALUE".
**
** Write the estimated row count into *pnRow and return SQLITE_OK. 
** If unable to make an estimate, leave *pnRow unchanged and return
** non-zero.
**
** This routine can fail if it is unable to load a collating sequence
** required for string comparison, or if unable to allocate memory
** for a UTF conversion required for comparison.  The error is stored
** in the pParse structure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereEqualScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,         <comment type="block">/* Expression for VALUE in the x=VALUE constraint */</comment>
  <parameter><decl><type><name>tRowcnt</name> <modifier>*</modifier></type><name>pnRow</name></decl></parameter>       <comment type="block">/* Write the revised row estimate here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                   <comment type="block">/* Subfunction return code */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Statistics */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bOk</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEq</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEq</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name><operator>&lt;</operator><name>nEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If values are not available for all fields of the index to the left
  ** of this one, no estimate can be made. Return SQLITE_NOTFOUND. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name><operator>&lt;</operator><operator>(</operator><name>nEq</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This is an optimization only. The call to sqlite3Stat4ProbeSetValue()
  ** below would return the same value.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnRow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ProbeSetValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRec</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nEq</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bOk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"equality scan regions %s(%d): %d\n"</literal><operator>,</operator>
                   <name><name>p</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name>nEq</name><operator>-</operator><literal type="number">1</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnRow</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT4 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Estimate the number of rows that will be returned based on
** an IN constraint where the right-hand side of the IN operator
** is a list of values.  Example:
**
**        WHERE x IN (1,2,3,4)
**
** Write the estimated row count into *pnRow and return SQLITE_OK. 
** If unable to make an estimate, leave *pnRow unchanged and return
** non-zero.
**
** This routine can fail if it is unable to load a collating sequence
** required for string comparison, or if unable to allocate memory
** for a UTF conversion required for comparison.  The error is stored
** in the pParse structure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereInScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,     <comment type="block">/* The value list on the RHS of "x IN (v1,v2,v3,...)" */</comment>
  <parameter><decl><type><name>tRowcnt</name> <modifier>*</modifier></type><name>pnRow</name></decl></parameter>       <comment type="block">/* Write the revised row estimate here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nRow0</name> <init>= <expr><call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRecValid</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Subfunction return code */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name>nEst</name></decl>;</decl_stmt>           <comment type="block">/* Number of rows for a single term */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name>nRowEst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* New estimate of the number of rows */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                  <comment type="block">/* Loop counter */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nEst</name> <operator>=</operator> <name>nRow0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereEqualScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nEst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRowEst</name> <operator>+=</operator> <name>nEst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <name>nRecValid</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nRowEst</name> <operator>&gt;</operator> <name>nRow0</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nRowEst</name> <operator>=</operator> <name>nRow0</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnRow</name> <operator>=</operator> <name>nRowEst</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x20</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"IN row estimate: est=%d\n"</literal><operator>,</operator> <name>nRowEst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name><operator>==</operator><name>nRecValid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT4 */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/*
** Print the content of a WhereTerm object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereTermPrint</name><parameter_list>(<parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"TERM-%-3d NULL\n"</literal></expr></argument>, <argument><expr><name>iTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zType</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zLeft</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><literal type="string">"...."</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'V'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQUIV</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zType</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'E'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zType</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'L'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zType</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'C'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_SINGLE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLeft</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zLeft</name></expr></argument>,<argument><expr><literal type="string">"left={%d:%d}"</literal></expr></argument>,
                       <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_OR</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLeft</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zLeft</name></expr></argument>,<argument><expr><literal type="string">"indexable=0x%llx"</literal></expr></argument>, 
                       <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name><operator>-&gt;</operator><name>indexable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLeft</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zLeft</name></expr></argument>,<argument><expr><literal type="string">"left=%d"</literal></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
       <argument><expr><literal type="string">"TERM-%-3d %p %s %-12s op=%03x wtFlags=%04x"</literal></expr></argument>,
       <argument><expr><name>iTerm</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>zLeft</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The 0x10000 .wheretrace flag causes extra information to be
    ** shown about each Term */</comment>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" prob=%-3d prereq=%llx,%llx"</literal></expr></argument>,
        <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" iField=%d"</literal></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" iParent=%d"</literal></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/*
** Show the complete content of a WhereClause
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereClausePrint</name><parameter_list>(<parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WhereTermPrint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/*
** Print a WhereLoop object for debugging purposes
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereLoopPrint</name><parameter_list>(<parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nb</name> <init>= <expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>+</operator><literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>iTab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mAll</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><name>nb</name><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"%c%2d.%0*llx.%0*llx"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cId</name></name></expr></argument>,
                     <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>maskSelf</name></name></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name>mAll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" %12s"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> ?</condition><then> <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>zName</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_autoindex_"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>( <expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'_'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>zName</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">".%-16s %2d"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"%20s"</literal></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"(%d,\"%s\",%#x)"</literal></expr></argument>,
                <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"(%d,%x)"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" %-19s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_SKIPSCAN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" f %06x %d-%d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSkip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" f %06x N %d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" cost %d,%d,%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4000</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereTermPrint</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Convert bulk memory into a valid WhereLoop that can be passed
** to whereLoopClear harmlessly.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopInit</name><parameter_list>(<parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name> <operator>=</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear the WhereLoop.u union.  Leave WhereLoop.pLTerm intact.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopClearUnion</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_VIRTUALTABLE</name><operator>|</operator><name>WHERE_AUTO_INDEX</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zColAff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate internal memory used by a WhereLoop object.  Leave the
** object in an initialized state, as if it had been newly allocated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopClear</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name> <operator>=</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>whereLoopClearUnion</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Increase the memory allocation for pLoop-&gt;aLTerm[] to be at least n.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopResize</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier><modifier>*</modifier></type><name>paNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name><operator>&gt;=</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">7</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>paNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>paNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>paNew</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name> <operator>=</operator> <name>paNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Transfer content from the second pLoop into the first.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopXfer</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>whereLoopClearUnion</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>&gt;</operator> <name><name>pTo</name><operator>-&gt;</operator><name>nLSlot</name></name>
   <operator>&amp;&amp;</operator> <call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WHERE_LOOP_XFER_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>WHERE_LOOP_XFER_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a WhereLoop object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereLoopClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free a WhereInfo structure
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereInfoFree</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereClauseClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereLoopDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pMemToFree</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WhereMemBlock</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pMemToFree</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pMemToFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pMemToFree</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3DbNNFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if all of the following are true:
**
**   (1)  X has the same or lower cost, or returns the same or fewer rows, 
**        than Y.
**   (2)  X uses fewer WHERE clause terms than Y
**   (3)  Every WHERE clause term used by X is also used by Y
**   (4)  X skips at least as many columns as Y
**   (5)  If X is a covering index, than Y is too
**
** Conditions (2) and (3) mean that X is a "proper subset" of Y.
** If X is a proper subset of Y then Y is a better choice and ought
** to have a lower cost.  This routine returns TRUE when that cost 
** relationship is inverted and needs to be adjusted.  Constraint (4)
** was added because if X uses skip-scan less than Y it still might
** deserve a lower cost even if it is a proper subset of Y.  Constraint (5)
** was added because a covering index probably deserves to have a lower cost
** than a non-covering index even if it is a proper subset.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopCheaperProperSubset</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>,       <comment type="block">/* First WhereLoop to compare */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>pY</name></decl></parameter>        <comment type="block">/* Compare against this WhereLoop */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><name><name>pX</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>&gt;=</operator> <name><name>pY</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><name><name>pY</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* X is not a subset of Y */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>rRun</name></name><operator>&gt;</operator><name><name>pY</name><operator>-&gt;</operator><name>rRun</name></name> <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;</operator><name><name>pY</name><operator>-&gt;</operator><name>nOut</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pY</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>&gt;</operator> <name><name>pX</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pY</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pY</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* X not a subset of Y since term X[i] not used by Y */</comment>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_IDX_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pY</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Constraint (5) */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* All conditions meet */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Try to adjust the cost and number of output rows of WhereLoop pTemplate
** upwards or downwards so that:
**
**   (1) pTemplate costs less than any other WhereLoops that are a proper
**       subset of pTemplate
**
**   (2) pTemplate costs more than any other WhereLoops for which pTemplate
**       is a proper subset.
**
** To say "WhereLoop X is a proper subset of Y" means that X uses fewer
** WHERE clause terms than Y and that every WHERE clause term used by X is
** also used by Y.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopAdjustCost</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pTemplate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name><operator>!=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>iTab</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>whereLoopCheaperProperSubset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Adjust pTemplate cost downward so that it is cheaper than its 
      ** subset p. */</comment>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x80</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"subset cost adjustment %d,%d to %d,%d\n"</literal><operator>,</operator>
                       <name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name><operator>,</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name><operator>,</operator> 
                       <call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                       <call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>whereLoopCheaperProperSubset</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Adjust pTemplate cost upward so that it is costlier than p since
      ** pTemplate is a proper subset of p */</comment>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x80</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"subset cost adjustment %d,%d to %d,%d\n"</literal><operator>,</operator>
                       <name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name><operator>,</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name><operator>,</operator> 
                       <call><name>MAX</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                       <call><name>MAX</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Search the list of WhereLoops in *ppPrev looking for one that can be
** replaced by pTemplate.
**
** Return NULL if pTemplate does not belong on the WhereLoop list.
** In other words if pTemplate ought to be dropped from further consideration.
**
** If pX is a WhereLoop that pTemplate can replace, then return the
** link that points to pX.
**
** If pTemplate cannot replace any existing element of the list but needs
** to be added to the list as a new entry, then return a pointer to the
** tail of the list.
*/</comment>
<function><type><specifier>static</specifier> <name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>whereLoopFindLesser</name><parameter_list>(
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPrev</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>pTemplate</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><operator>(</operator><operator>*</operator><name>ppPrev</name><operator>)</operator></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>ppPrev</name><operator>=</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><operator>*</operator><name>ppPrev</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name><operator>!=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>iTab</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iSortIdx</name></name><operator>!=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>iSortIdx</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If either the iTab or iSortIdx values for two WhereLoop are different
      ** then those WhereLoops need to be considered separately.  Neither is
      ** a candidate to replace the other. */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* In the current implementation, the rSetup value is either zero
    ** or the cost of building an automatic index (NlogN) and the NlogN
    ** is the same for compatible WhereLoops. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name><operator>==</operator><literal type="number">0</literal> 
                 <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>==</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* whereLoopAddBtree() always generates and inserts the automatic index
    ** case first.  Hence compatible candidate WhereLoops never have a larger
    ** rSetup. Call this SETUP-INVARIANT */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Any loop using an appliation-defined index (or PRIMARY KEY or
    ** UNIQUE constraint) with one or more == constraints is better
    ** than an automatic index. Unless it is a skip-scan. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>nSkip</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_EQ</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name></expr>
    )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If existing WhereLoop p is better than pTemplate, pTemplate can be
    ** discarded.  WhereLoop p is better if:
    **   (1)  p has no more dependencies than pTemplate, and
    **   (2)  p has an equal or lower cost than pTemplate
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name>    <comment type="block">/* (1)  */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>&lt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name>                  <comment type="block">/* (2a) */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&lt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name>                      <comment type="block">/* (2b) */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>&lt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr>                      <comment type="block">/* (2c) */</comment>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Discard pTemplate */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If pTemplate is always better than p, then cause p to be overwritten
    ** with pTemplate.  pTemplate is better than p if:
    **   (1)  pTemplate has no more dependences than p, and
    **   (2)  pTemplate has an equal or lower cost than p.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name>   <comment type="block">/* (1)  */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name>                             <comment type="block">/* (2a) */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr>                             <comment type="block">/* (2b) */</comment>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* SETUP-INVARIANT above */</comment>
      <break>break;</break>   <comment type="block">/* Cause p to be overwritten by pTemplate */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>ppPrev</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert or replace a WhereLoop entry using the template supplied.
**
** An existing WhereLoop entry might be overwritten if the new template
** is better and has fewer dependencies.  Or the template will be ignored
** and no insert will occur if an existing WhereLoop is faster and has
** fewer dependencies than the template.  Otherwise a new WhereLoop is
** added based on the template.
**
** If pBuilder-&gt;pOrSet is not NULL then we care about only the
** prerequisites and rRun and nOut costs of the N best loops.  That
** information is gathered in the pBuilder-&gt;pOrSet object.  This special
** processing mode is used only for OR clause processing.
**
** When accumulating multiple loops (when pBuilder-&gt;pOrSet is NULL) we
** still might overwrite similar loops with the new template if the
** new template is better.  Loops may be overwritten if the following 
** conditions are met:
**
**    (1)  They have the same iTab.
**    (2)  They have the same iSortIdx.
**    (3)  The template has same or fewer dependencies than the current loop
**    (4)  The template has the same or lower cost than the current loop
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopInsert</name><parameter_list>(<parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pTemplate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPrev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Stop the search once we hit the query planner search limit */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>iPlanLimit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"=== query planner search limit reached ===\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>iPlanLimit</name></name><operator>--</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>whereLoopAdjustCost</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pBuilder-&gt;pOrSet is defined, then only keep track of the costs
  ** and prereqs.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nLTerm</name></name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if>
      <decl_stmt><decl><type><name>u16</name></type> <name>n</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr><call><name>whereOrInsert</name><argument_list>(<argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>,
                                    <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
      <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><ternary><condition><expr><name>x</name></expr>?</condition><then><expr><literal type="string">"   or-%d:  "</literal></expr></then><else>:<expr><literal type="string">"   or-X:  "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Look for an existing WhereLoop to replace with pTemplate
  */</comment>
  <expr_stmt><expr><name>ppPrev</name> <operator>=</operator> <call><name>whereLoopFindLesser</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>ppPrev</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* There already exists a WhereLoop on the list that is better
    ** than pTemplate, so just ignore pTemplate */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"   skip: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>  
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>ppPrev</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If we reach this point it means that either p[] should be overwritten
  ** with pTemplate[] if p[] exists, or if p==NULL then allocate a new
  ** WhereLoop and insert it.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"replace: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"   with: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"    add: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Allocate a new WhereLoop to add to the end of the list */</comment>
    <expr_stmt><expr><operator>*</operator><name>ppPrev</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>whereLoopInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* We will be overwriting WhereLoop p[].  But before we do, first
    ** go through the rest of the list and delete any other entries besides
    ** p[] that are also supplated by pTemplate */</comment>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTail</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pToDel</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>ppTail</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ppTail</name> <operator>=</operator> <call><name>whereLoopFindLesser</name><argument_list>(<argument><expr><name>ppTail</name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>ppTail</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pToDel</name> <operator>=</operator> <operator>*</operator><name>ppTail</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pToDel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppTail</name> <operator>=</operator> <name><name>pToDel</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
      <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" delete: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name>pToDel</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>whereLoopDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopXfer</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIndex</name> <operator>&amp;&amp;</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>idxType</name></name><operator>==</operator><name>SQLITE_IDXTYPE_IPK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Adjust the WhereLoop.nOut value downward to account for terms of the
** WHERE clause that reference the loop but which are not used by an
** index.
*
** For every WHERE clause term that is not used by the index
** and which has a truth probability assigned by one of the likelihood(),
** likely(), or unlikely() SQL functions, reduce the estimated number
** of output rows by the probability specified.
**
** TUNING:  For every WHERE clause term that is not used by the index
** and which does not have an assigned truth probability, heuristics
** described below are used to try to estimate the truth probability.
** TODO --&gt; Perhaps this is something that could be improved by better
** table statistics.
**
** Heuristic 1:  Estimate the truth probability as 93.75%.  The 93.75%
** value corresponds to -1 in LogEst notation, so this means decrement
** the WhereLoop.nOut field for every such WHERE clause term.
**
** Heuristic 2:  If there exists one or more WHERE clause terms of the
** form "x==EXPR" and EXPR is not a constant 0 or 1, then make sure the
** final output row estimate is no greater than 1/4 of the total number
** of rows in the table.  In other words, assume that x==EXPR will filter
** out at least 3 out of 4 rows.  If EXPR is -1 or 0 or 1, then maybe the
** "x" column is boolean or else -1 or 0 or 1 is a common default value
** on the "x" column and so in that case only cap the output row estimate
** at 1/2 instead of 1/4.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopOutputAdjust</name><parameter_list>(
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,      <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>,      <comment type="block">/* The loop to adjust downward */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nRow</name></decl></parameter>            <comment type="block">/* Number of rows in the entire table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>notAllowed</name> <init>= <expr><operator>~</operator><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>prereq</name></name><operator>|</operator><name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>iReduce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* pLoop-&gt;nOut should not exceed nRow-iReduce */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name>notAllowed</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><name>pTerm</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>iParent</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pX</name><operator>-&gt;</operator><name>iParent</name></name></expr>]</index></name><operator>)</operator><operator>==</operator><name>pTerm</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>==</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If there are extra terms in the WHERE clause not used by an index
        ** that depend only on the table being scanned, and that will tend to
        ** cause many rows to be omitted, then mark that table as
        ** "self-culling".
        **
        ** 2022-03-24:  Self-culling only applies if either the extra terms
        ** are straight comparison operators that are non-true with NULL
        ** operand, or if the loop is not an OUTER JOIN.
        */</comment>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>||</operator> <operator>(</operator><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name>
                  <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_SELFCULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If a truth probability is specified using the likelihood() hints,
        ** then use the probability provided by the application. */</comment>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* In the absence of explicit truth probabilities, use heuristics to
        ** guess a reasonable truth probability. */</comment>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>&amp;</operator><operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_HIGHTRUTH</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>  <comment type="block">/* tag-20200224-1 */</comment>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>k</name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>k</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iReduce</name><operator>&lt;</operator><name>k</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_HEURTRUTH</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>iReduce</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>&gt;</operator> <name>nRow</name><operator>-</operator><name>iReduce</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nRow</name> <operator>-</operator> <name>iReduce</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Term pTerm is a vector range comparison operation. The first comparison
** in the vector can be optimized using column nEq of the index. This
** function returns the total number of vector elements that can be used
** as part of the range comparison.
**
** For example, if the query is:
**
**   WHERE a = ? AND (b, c, d) &gt; (?, ?, ?)
**
** and the index:
**
**   CREATE INDEX ... ON (a, b, c, d, e)
**
** then this function would be invoked with nEq=1. The value returned in
** this case is 3.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereRangeVectorLen</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,            <comment type="block">/* Cursor open on pIdx */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,         <comment type="block">/* The index to be used for a inequality constraint */</comment>
  <parameter><decl><type><name>int</name></type> <name>nEq</name></decl></parameter>,             <comment type="block">/* Number of prior equality constraints on same index */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>     <comment type="block">/* The vector inequality constraint */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name> <init>= <expr><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nCmp</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>nCmp</name></expr></argument>, <argument><expr><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>-</operator> <name>nEq</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCmp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* Test if comparison i of pTerm is compatible with column (i+nEq) 
    ** of the index. If not, exit the loop.  */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>                     <comment type="block">/* Comparison affinity */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>idxaff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Indexed columns affinity */</comment>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>               <comment type="block">/* Comparison collation sequence */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLhs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pRhs</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLhs</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRhs</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pRhs</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRhs</name> <operator>=</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pRhs</name> <operator>=</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Check that the LHS of the comparison is a column reference to
    ** the right column of the right source table. And that the sort
    ** order of the index column is the same as the sort order of the
    ** leftmost index column.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLhs</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> 
     <operator>||</operator> <name><name>pLhs</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iCur</name> 
     <operator>||</operator> <name><name>pLhs</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name><operator>+</operator><name>nEq</name></expr>]</index></name> 
     <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name><operator>+</operator><name>nEq</name></expr>]</index></name><operator>!=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name></expr>
    )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pLhs</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>XN_ROWID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pRhs</name></expr></argument>, <argument><expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pLhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idxaff</name> <operator>=</operator> <call><name>sqlite3TableColumnAffinity</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>, <argument><expr><name><name>pLhs</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aff</name><operator>!=</operator><name>idxaff</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLhs</name></expr></argument>, <argument><expr><name>pRhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name><operator>+</operator><name>nEq</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Adjust the cost C by the costMult facter T.  This only occurs if
** compiled with -DSQLITE_ENABLE_COSTMULT
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COSTMULT</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ApplyCostMultiplier</name><parameter_list>(<parameter><type><name>C</name></type></parameter>,<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>C += T</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ApplyCostMultiplier</name><parameter_list>(<parameter><type><name>C</name></type></parameter>,<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We have so far matched pBuilder-&gt;pNew-&gt;u.btree.nEq terms of the 
** index pIndex. Try to match one more.
**
** When this function is called, pBuilder-&gt;pNew-&gt;nOut contains the 
** number of rows expected to be visited by filtering using the nEq 
** terms only. If it is modified, this value is restored before this 
** function returns.
**
** If pProbe-&gt;idxType==SQLITE_IDXTYPE_IPK, that means pIndex is 
** a fake index used for the INTEGER PRIMARY KEY.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddBtreeIndex</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,     <comment type="block">/* The WhereLoop factory */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,                  <comment type="block">/* FROM clause term being analyzed */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pProbe</name></decl></parameter>,                  <comment type="block">/* An index on pSrc */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nInMul</name></decl></parameter>                   <comment type="block">/* log(Number of iterations due to IN) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* WHERE analyse context */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database connection malloc context */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>                <comment type="block">/* Template WhereLoop under construction */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>               <comment type="block">/* A WhereTerm under consideration */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>opMask</name></decl>;</decl_stmt>                     <comment type="block">/* Valid operators for constraints */</comment>
  <decl_stmt><decl><type><name>WhereScan</name></type> <name>scan</name></decl>;</decl_stmt>                 <comment type="block">/* Iterator for WHERE terms */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>saved_prereq</name></decl>;</decl_stmt>           <comment type="block">/* Original value of pNew-&gt;prereq */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nLTerm</name></decl>;</decl_stmt>               <comment type="block">/* Original value of pNew-&gt;nLTerm */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nEq</name></decl>;</decl_stmt>                  <comment type="block">/* Original value of pNew-&gt;u.btree.nEq */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nBtm</name></decl>;</decl_stmt>                 <comment type="block">/* Original value of pNew-&gt;u.btree.nBtm */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nTop</name></decl>;</decl_stmt>                 <comment type="block">/* Original value of pNew-&gt;u.btree.nTop */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nSkip</name></decl>;</decl_stmt>                <comment type="block">/* Original value of pNew-&gt;nSkip */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>saved_wsFlags</name></decl>;</decl_stmt>              <comment type="block">/* Original value of pNew-&gt;wsFlags */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>saved_nOut</name></decl>;</decl_stmt>              <comment type="block">/* Original value of pNew-&gt;nOut */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rSize</name></decl>;</decl_stmt>                   <comment type="block">/* Number of rows in the table */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rLogSize</name></decl>;</decl_stmt>                <comment type="block">/* Logarithm of table size */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pBtm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Top and bottom range constraints */</comment>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"BEGIN %s.addBtreeIdx(%s), nEq=%d, nSkip=%d, rRun=%d\n"</literal><operator>,</operator>
                     <name><name>pProbe</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator><name><name>pProbe</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator>
                     <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>,</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name><operator>,</operator> <name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>opMask</name> <operator>=</operator> <name>WO_LT</name><operator>|</operator><name>WO_LE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opMask</name> <operator>=</operator> <name>WO_EQ</name><operator>|</operator><name>WO_IN</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>|</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>bUnordered</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opMask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name>
       <operator>||</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>idxType</name></name><operator>!=</operator><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>saved_nEq</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nBtm</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nTop</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nSkip</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nLTerm</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_wsFlags</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_prereq</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nOut</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>saved_nEq</name></expr></argument>,
                        <argument><expr><name>opMask</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rSize</name> <operator>=</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rLogSize</name> <operator>=</operator> <call><name>estLog</name><argument_list>(<argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>eOp</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Shorthand for pTerm-&gt;eOperator */</comment>
    <decl_stmt><decl><type><name>LogEst</name></type> <name>rCostIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogEst</name></type> <name>nOutUnadjusted</name></decl>;</decl_stmt>        <comment type="block">/* nOut before IN() and WHERE adjustments */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>nRecValid</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name><operator>==</operator><name>WO_ISNULL</name> <operator>||</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name><operator>&amp;</operator><name>TERM_VNULL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <call><name>indexColumnNotNull</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name>saved_nEq</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <continue>continue;</continue> <comment type="block">/* ignore IS [NOT] NULL constraints on NOT NULL columns */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* Do not allow the upper bound of a LIKE optimization range constraint
    ** to mix with a lower range bound from some other source */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name> <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_LT</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>constraintCompatibleWithOuterJoin</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>,<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>saved_nEq</name><operator>==</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>bldFlags1</name></name> <operator>|=</operator> <name>SQLITE_BLDF1_UNIQUE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>bldFlags1</name></name> <operator>|=</operator> <name>SQLITE_BLDF1_INDEXED</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>saved_wsFlags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>saved_nEq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name> <operator>=</operator> <name>saved_nBtm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name> <operator>=</operator> <name>saved_nTop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>saved_nLTerm</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>&gt;=</operator><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name>
     <operator>&amp;&amp;</operator> <call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
       <break>break;</break> <comment type="block">/* OOM while trying to enlarge the pNew-&gt;aLTerm array */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <operator>(</operator><name>saved_prereq</name> <operator>|</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nInMul</name><operator>==</operator><literal type="number">0</literal>
        <operator>||</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_NULL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
        <operator>||</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_IN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
        <operator>||</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_SKIPSCAN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* "x IN (SELECT ...)":  TUNING: the SELECT returns 25 rows */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>nIn</name> <operator>=</operator> <literal type="number">46</literal></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">46</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The expression may actually be of the form (x, y) IN (SELECT...).
        ** In this case there is a separate term for each of (x) and (y).
        ** However, the nIn multiplier should only be applied once, not once
        ** for each such term. The following loop checks that pTerm is the
        ** first such term in use, and sets nIn back to 0 if it is not. */</comment>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pExpr</name><operator>==</operator><name>pExpr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* "x IN (value, value, ...)" */</comment>
        <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>hasStat1</name></name> <operator>&amp;&amp;</operator> <name>rLogSize</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>LogEst</name></type> <name>M</name></decl>, <decl><type ref="prev"/><name>logK</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
        <comment type="block">/* Let:
        **   N = the total number of rows in the table
        **   K = the number of entries on the RHS of the IN operator
        **   M = the number of rows in the table that match terms to the 
        **       to the left in the same index.  If the IN operator is on
        **       the left-most index column, M==N.
        **
        ** Given the definitions above, it is better to omit the IN operator
        ** from the index lookup and instead do a scan of the M elements,
        ** testing each scanned row against the IN operator separately, if:
        **
        **        M*log(K) &lt; K*log(N)
        **
        ** Our estimates for M, K, and N might be inaccurate, so we build in
        ** a safety margin of 2 (LogEst: 10) that favors using the IN operator
        ** with the index, as using an index has better worst-case behavior.
        ** If we do not have real sqlite_stat1 data, always prefer to use
        ** the index.  Do not bother with this optimization on very small
        ** tables (less than 2 rows) as it is pointless in that case.
        */</comment>
        <expr_stmt><expr><name>M</name> <operator>=</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>saved_nEq</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>logK</name> <operator>=</operator> <call><name>estLog</name><argument_list>(<argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* TUNING      v-----  10 to bias toward indexed IN */</comment>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>M</name> <operator>+</operator> <name>logK</name> <operator>+</operator> <literal type="number">10</literal> <operator>-</operator> <operator>(</operator><name>nIn</name> <operator>+</operator> <name>rLogSize</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x40</literal></expr></argument>,
            <argument><expr><operator>(</operator><literal type="string">"IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d) "</literal>
             <literal type="string">"prefers indexed lookup\n"</literal><operator>,</operator>
             <name>saved_nEq</name><operator>,</operator> <name>M</name><operator>,</operator> <name>logK</name><operator>,</operator> <name>nIn</name><operator>,</operator> <name>rLogSize</name><operator>,</operator> <name>x</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nInMul</name><operator>&lt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_SeekScan</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x40</literal></expr></argument>,
            <argument><expr><operator>(</operator><literal type="string">"IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d"</literal>
             <literal type="string">" nInMul=%d) prefers skip-scan\n"</literal><operator>,</operator>
             <name>saved_nEq</name><operator>,</operator> <name>M</name><operator>,</operator> <name>logK</name><operator>,</operator> <name>nIn</name><operator>,</operator> <name>rLogSize</name><operator>,</operator> <name>x</name><operator>,</operator> <name>nInMul</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_IN_SEEKSCAN</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x40</literal></expr></argument>,
            <argument><expr><operator>(</operator><literal type="string">"IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d"</literal>
             <literal type="string">" nInMul=%d) prefers normal scan\n"</literal><operator>,</operator>
             <name>saved_nEq</name><operator>,</operator> <name>M</name><operator>,</operator> <name>logK</name><operator>,</operator> <name>nIn</name><operator>,</operator> <name>rLogSize</name><operator>,</operator> <name>x</name><operator>,</operator> <name>nInMul</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_IN</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pProbe</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>saved_nEq</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_EQ</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>saved_nEq</name><operator>==</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name>XN_ROWID</name> 
       <operator>||</operator> <operator>(</operator><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nInMul</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>saved_nEq</name><operator>==</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name>XN_ROWID</name> <operator>||</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>uniqNotNull</name></name> 
         <operator>||</operator> <operator>(</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>onError</name></name> <operator>&amp;&amp;</operator> <name>eOp</name><operator>==</operator><name>WO_EQ</name><operator>)</operator></expr> 
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_ONEROW</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_UNQ_WANTED</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>scan</name><operator>.</operator><name>iEquiv</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_TRANSCONS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nVecLen</name> <init>= <expr><call><name>whereRangeVectorLen</name><argument_list>(
          <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name>saved_nEq</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>
      )</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_RANGE</name><operator>|</operator><name>WHERE_BTM_LIMIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name> <operator>=</operator> <name>nVecLen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pBtm</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Range constraints that come from the LIKE optimization are
          ** always used in pairs. */</comment>
          <expr_stmt><expr><name>pTop</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTerm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pTop</name><operator>-</operator><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>a</name></name><operator>)</operator><operator>)</operator><operator>&lt;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTop</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTop</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* OOM */</comment>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pTop</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_TOP_LIMIT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_RANGE</name><operator>|</operator><name>WHERE_TOP_LIMIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name> <operator>=</operator> <name>nVecLen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTop</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pBtm</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then>
                       <expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* At this point pNew-&gt;nOut is set to the number of rows expected to
    ** be visited by the index scan before considering term pTerm, or the
    ** values of nIn and nInMul. In other words, assuming that all 
    ** "x IN(...)" terms are replaced with "x = ?". This block updates
    ** the value of pNew-&gt;nOut to account for pTerm (but not nIn/nInMul).  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name><operator>==</operator><name>saved_nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_RANGE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Adjust nOut using stat4 data. Or, if there is no stat4
      ** data, using some other estimate.  */</comment>
      <expr_stmt><expr><call><name>whereRangeScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pBtm</name></expr></argument>, <argument><expr><name>pTop</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><operator>++</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_EQ</name><operator>|</operator><name>WO_IN</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name><operator>==</operator><name>saved_nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>saved_nEq</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator> <operator>||</operator> <name>nIn</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nIn</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
        <decl_stmt><decl><type><name>tRowcnt</name></type> <name>nOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nInMul</name><operator>==</operator><literal type="number">0</literal> 
         <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>nSample</name></name> 
         <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;=</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nSampleCol</name></name></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>ExprUseXList</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call><operator>)</operator>
         <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_Stat4</name></expr></argument>)</argument_list></call></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereEqualScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereInScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOTFOUND</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>          <comment type="block">/* Jump out of the pTerm loop */</comment>
          <if_stmt><if>if<condition>( <expr><name>nOut</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>==</operator><literal type="number">1</literal>
             <comment type="block">/* TUNING: Mark terms as "low selectivity" if they seem likely
             ** to be true for half or more of the rows in the table.
             ** See tag-202002240-1 */</comment>
             <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name><operator>+</operator><literal type="number">10</literal> <operator>&gt;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>
            )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x01 */</comment>
              <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x20</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
                   <argument><expr><literal type="string">"STAT4 determines term has low selectivity:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sqlite3WhereTermPrint</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_HIGHTRUTH</name></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_HEURTRUTH</name></expr> )</condition><block>{<block_content>
                <comment type="block">/* If the term has previously been used with an assumption of
                ** higher selectivity, then set the flag to rerun the
                ** loop computations. */</comment>
                <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>bldFlags2</name></name> <operator>|=</operator> <name>SQLITE_BLDF2_2NDPASS</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;</operator><name>saved_nOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nIn</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <operator>(</operator><name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>nEq</name></expr>]</index></name> <operator>-</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>nEq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* TUNING: If there is no likelihood() value, assume that a 
            ** "col IS NULL" expression matches twice as many rows 
            ** as (col=?). */</comment>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set rCostIdx to the cost of visiting selected rows in index. Add
    ** it to pNew-&gt;rRun, which is currently set to the cost of the index
    ** seek only. Then, if this is a non-covering index, add the cost of
    ** visiting the rows in the main table.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rCostIdx</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">15</literal><operator>*</operator><name><name>pProbe</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>)</operator><operator>/</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rLogSize</name></expr></argument>, <argument><expr><name>rCostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_IDX_ONLY</name><operator>|</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_EXPRIDX</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pProbe</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nOutUnadjusted</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>+=</operator> <name>nInMul</name> <operator>+</operator> <name>nIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <name>nInMul</name> <operator>+</operator> <name>nIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereLoopOutputAdjust</name><argument_list>(<argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_RANGE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nOutUnadjusted</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nColumn</name></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name> <operator>||</operator>
           <name><name>pProbe</name><operator>-&gt;</operator><name>idxType</name></name><operator>!=</operator><name>SQLITE_IDXTYPE_PRIMARYKEY</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>whereLoopAddBtreeIndex</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name>nInMul</name><operator>+</operator><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <name>nRecValid</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>saved_prereq</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>saved_nEq</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name> <operator>=</operator> <name>saved_nBtm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name> <operator>=</operator> <name>saved_nTop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <name>saved_nSkip</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>saved_wsFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>saved_nLTerm</name></expr>;</expr_stmt>

  <comment type="block">/* Consider using a skip-scan if there are no WHERE clause constraints
  ** available for the left-most terms of the index, and if the average
  ** number of repeats in the left-most terms is at least 18. 
  **
  ** The magic number 18 is selected on the basis that scanning 17 rows
  ** is almost always quicker than an index seek (even though if the index
  ** contains fewer than 2^17 rows we assume otherwise in other parts of
  ** the code). And, even if it is not, it should not be too much slower. 
  ** On the other hand, the extra seeks could end up being significantly
  ** more expensive.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">42</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>saved_nEq</name><operator>==</operator><name>saved_nSkip</name>
   <operator>&amp;&amp;</operator> <name>saved_nEq</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name>
   <operator>&amp;&amp;</operator> <name>saved_nEq</name><operator>==</operator><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name>
   <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>noSkipScan</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>hasStat1</name></name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_SkipScan</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>saved_nEq</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">42</literal>  <comment type="block">/* TUNING: Minimum for skip-scan */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LogEst</name></type> <name>nIter</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_SKIPSCAN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nIter</name> <operator>=</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>saved_nEq</name></expr>]</index></name> <operator>-</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>saved_nEq</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nIter</name></expr>;</expr_stmt>
    <comment type="block">/* TUNING:  Because uncertainties in the estimates for skip-scan queries,
    ** add a 1.375 fudge factor to make skip-scan slightly less likely. */</comment>
    <expr_stmt><expr><name>nIter</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereLoopAddBtreeIndex</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name>nIter</name> <operator>+</operator> <name>nInMul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>saved_nEq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <name>saved_nSkip</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>saved_wsFlags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"END %s.addBtreeIdx(%s), nEq=%d, rc=%d\n"</literal><operator>,</operator>
                      <name><name>pProbe</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name>saved_nEq</name><operator>,</operator> <name>rc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return True if it is possible that pIndex might be useful in
** implementing the ORDER BY clause in pBuilder.
**
** Return False if pBuilder does not contain an ORDER BY clause or
** if there is no way for pIndex to be useful in implementing that
** ORDER BY clause.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexMightHelpWithOrderBy</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOB</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>aColExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>bUnordered</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pOB</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pOB</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pOB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>jj</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>aColExpr</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>jj</name></expr>]</index></name><operator>!=</operator><name>XN_EXPR</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompareSkip</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,<argument><expr><name>iCursor</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check to see if a partial index with pPartIndexWhere can be used
** in the current query.  Return true if it can be and false if not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereUsablePartialIndex</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>,             <comment type="block">/* The table for which we want an index */</comment>
  <parameter><decl><type><name>u8</name></type> <name>jointype</name></decl></parameter>,          <comment type="block">/* The JT_* flags on the join */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,     <comment type="block">/* The WHERE clause of the query */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>          <comment type="block">/* The WHERE clause from the partial index */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>jointype</name> <operator>&amp;</operator> <name>JT_LTORJ</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pWhere</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>whereUsablePartialIndex</name><argument_list>(<argument><expr><name>iTab</name></expr></argument>,<argument><expr><name>jointype</name></expr></argument>,<argument><expr><name>pWC</name></expr></argument>,<argument><expr><name><name>pWhere</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <name><name>pWhere</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_EnableQPSG</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pParse</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name><operator>==</operator><name>iTab</name><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>jointype</name> <operator>&amp;</operator> <name>JT_OUTER</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call><operator>)</operator>
     <operator>&amp;&amp;</operator> <call><name>sqlite3ExprImpliesExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pIdx is an index containing expressions.  Check it see if any of the
** expressions in the index match the pExpr expression.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprIsCoveredByIndex</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>XN_EXPR</name>
     <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Structure passed to the whereIsCoveringIndex Walker callback.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>CoveringIndexCheck</name></name></type> <name>CoveringIndexCheck</name>;</typedef>
<struct>struct <name>CoveringIndexCheck</name> <block>{
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>       <comment type="block">/* The index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTabCur</name></decl>;</decl_stmt>       <comment type="block">/* Cursor number for the corresponding table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bExpr</name></decl>;</decl_stmt>          <comment type="block">/* Uses an indexed expression */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bUnidx</name></decl>;</decl_stmt>         <comment type="block">/* Uses an unindexed column not within an indexed expr */</comment>
}</block>;</struct>

<comment type="block">/*
** Information passed in is pWalk-&gt;u.pCovIdxCk.  Call it pCk.
**
** If the Expr node references the table with cursor pCk-&gt;iTabCur, then
** make sure that column is covered by the index pCk-&gt;pIdx.  We know that
** all columns less than 63 (really BMS-1) are covered, so we don't need
** to check them.  But we do need to check any column at 63 or greater.
**
** If the index does not cover the column, then set pWalk-&gt;eCode to 
** non-zero and return WRC_Abort to stop the search.
**
** If this node does not disprove that the index can be a covering index,
** then just return WRC_Continue, to continue the search.
**
** If pCk-&gt;pIdx contains indexed expressions and one of those expressions
** matches pExpr, then prune the search.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereIsCoveringIndexWalkCallback</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalk</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>        <comment type="block">/* The index of interest */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>i16</name> <modifier>*</modifier></type><name>aiColumn</name></decl>;</decl_stmt>      <comment type="block">/* Columns contained in the index */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nColumn</name></decl>;</decl_stmt>              <comment type="block">/* Number of columns in the index */</comment>
  <decl_stmt><decl><type><name>CoveringIndexCheck</name> <modifier>*</modifier></type><name>pCk</name></decl>;</decl_stmt>  <comment type="block">/* Info about this search */</comment>

  <expr_stmt><expr><name>pCk</name> <operator>=</operator> <name><name>pWalk</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCovIdxCk</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pCk</name><operator>-&gt;</operator><name>pIdx</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* if( pExpr-&gt;iColumn&lt;(BMS-1) &amp;&amp; pIdx-&gt;bHasExpr==0 ) return WRC_Continue;*/</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name><name>pCk</name><operator>-&gt;</operator><name>iTabCur</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pWalk</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCovIdxCk</name><operator>-&gt;</operator><name>pIdx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aiColumn</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Continue</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pCk</name><operator>-&gt;</operator><name>bUnidx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>bHasExpr</name></name>
         <operator>&amp;&amp;</operator> <call><name>exprIsCoveredByIndex</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pWalk</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCovIdxCk</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCk</name><operator>-&gt;</operator><name>bExpr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** pIdx is an index that covers all of the low-number columns used by
** pWInfo-&gt;pSelect (columns from 0 through 62) or an index that has
** expressions terms.  Hence, we cannot determine whether or not it is
** a covering index by using the colUsed bitmasks.  We have to do a search
** to see if the index is covering.  This routine does that search.
**
** The return value is one of these:
**
**      0                The index is definitely not a covering index
**
**      WHERE_IDX_ONLY   The index is definitely a covering index
**
**      WHERE_EXPRIDX    The index is likely a covering index, but it is
**                       difficult to determine precisely because of the
**                       expressions that are indexed.  Score it as a
**                       covering index, but still keep the main table open
**                       just in case we need it.
**
** This routine is an optimization.  It is always safe to return zero.
** But returning one of the other two values when zero should have been
** returned can lead to incorrect bytecode and assertion faults.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>u32</name></type> <name>whereIsCoveringIndex</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,     <comment type="block">/* The WHERE clause context */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,           <comment type="block">/* Index that is being tested */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>            <comment type="block">/* Cursor for the table being indexed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>CoveringIndexCheck</name></name></type> <name>ck</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* We don't have access to the full query, so we cannot check to see
    ** if pIdx is covering.  Assume it is not. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>bHasExpr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pIdx does not index any columns greater than 62, but we know from
      ** colMask that columns greater than 62 are used, so this is not a
      ** covering index */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>ck</name><operator>.</operator><name>pIdx</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ck</name><operator>.</operator><name>iTabCur</name></name> <operator>=</operator> <name>iTabCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ck</name><operator>.</operator><name>bExpr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ck</name><operator>.</operator><name>bUnidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>whereIsCoveringIndexWalkCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pCovIdxCk</name></name> <operator>=</operator> <operator>&amp;</operator><name>ck</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>ck</name><operator>.</operator><name>bUnidx</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>ck</name><operator>.</operator><name>bExpr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WHERE_EXPRIDX</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WHERE_IDX_ONLY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add all WhereLoop objects for a single table of the join where the table
** is identified by pBuilder-&gt;pNew-&gt;iTab.  That table is guaranteed to be
** a b-tree table, not a virtual table.
**
** The costs (WhereLoop.rRun) of the b-tree loops added by this function
** are calculated as follows:
**
** For a full scan, assuming the table (or index) contains nRow rows:
**
**     cost = nRow * 3.0                    // full-table scan
**     cost = nRow * K                      // scan of covering index
**     cost = nRow * (K+3.0)                // scan of non-covering index
**
** where K is a value between 1.1 and 3.0 set based on the relative 
** estimated average size of the index and table records.
**
** For an index scan, where nVisit is the number of index rows visited
** by the scan, and nSeek is the number of seek operations required on 
** the index b-tree:
**
**     cost = nSeek * (log(nRow) + K * nVisit)          // covering index
**     cost = nSeek * (log(nRow) + (K+3.0) * nVisit)    // non-covering index
**
** Normally, nSeek is 1. nSeek values greater than 1 come about if the 
** WHERE clause includes "x IN (....)" terms used in place of "x=?". Or when 
** implicit "x IN (SELECT x FROM tbl)" terms are added for skip-scans.
**
** The estimated values (nRow, nVisit, nSeek) often contain a large amount
** of uncertainty.  For this reason, scoring is designed to pick plans that
** "do the least harm" if the estimates are inaccurate.  For example, a
** log(nRow) factor is omitted from a non-covering index scan in order to
** bias the scoring in favor of using an index, since the worst-case
** performance of using an index is far better than the worst-case performance
** of a full table scan.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddBtree</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>, <comment type="block">/* WHERE clause information */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mPrereq</name></decl></parameter>             <comment type="block">/* Extra prerequesites for using this table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>          <comment type="block">/* WHERE analysis context */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pProbe</name></decl>;</decl_stmt>              <comment type="block">/* An index we are evaluating */</comment>
  <decl_stmt><decl><type><name>Index</name></type> <name>sPk</name></decl>;</decl_stmt>                  <comment type="block">/* A fake index object for the primary key */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name><name>aiRowEstPk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* The aiRowLogEst[] value for the sPk index */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>aiColumnPk</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* The aColumn[] value for the sPk index */</comment>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl>;</decl_stmt>          <comment type="block">/* The FROM clause */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>              <comment type="block">/* The FROM clause btree term to add */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>            <comment type="block">/* Template WhereLoop object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSortIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Index number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>                      <comment type="block">/* A boolean value */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rSize</name></decl>;</decl_stmt>               <comment type="block">/* number of rows in the table */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>           <comment type="block">/* The parsed WHERE clause */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                <comment type="block">/* Table being queried */</comment>
  
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCte</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* An INDEXED BY clause specifies a particular index to use */</comment>
    <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>pIBIndex</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* There is no INDEXED BY clause.  Create a fake Index object in local
    ** variable sPk to represent the rowid primary key index.  Make this
    ** fake index the first in a chain of Index objects with all of the real
    ** indices to follow */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>                  <comment type="block">/* First of real indices on the table */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sPk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>nKeyCol</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>nColumn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>aiColumn</name></name> <operator>=</operator> <operator>&amp;</operator><name>aiColumnPk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>aiRowLogEst</name></name> <operator>=</operator> <name>aiRowEstPk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>onError</name></name> <operator>=</operator> <name>OE_Replace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>pTable</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>szIdxRow</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>idxType</name></name> <operator>=</operator> <name>SQLITE_IDXTYPE_IPK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aiRowEstPk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aiRowEstPk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The real indices of the table are only considered if the
      ** NOT INDEXED qualifier is omitted from the FROM clause */</comment>
      <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name>pFirst</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <operator>&amp;</operator><name>sPk</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rSize</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
  <comment type="block">/* Automatic indexes */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name></name>      <comment type="block">/* Not part of an OR optimization */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_RIGHT_JOIN</name><operator>|</operator><name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_AutoIndex</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name>  <comment type="block">/* Has no INDEXED BY clause */</comment>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name>   <comment type="block">/* Has no NOT INDEXED clause */</comment>
   <operator>&amp;&amp;</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>         <comment type="block">/* Not WITHOUT ROWID table. (FIXME: Why not?) */</comment>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name> <comment type="block">/* Not a correlated subquery */</comment>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name>  <comment type="block">/* Not a recursive common table expression. */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> <comment type="block">/* Not the right tab of a RIGHT JOIN */</comment>
  )</condition><block>{<block_content>
    <comment type="block">/* Generate auto-index WhereLoops */</comment>
    <decl_stmt><decl><type><name>LogEst</name></type> <name>rLogSize</name></decl>;</decl_stmt>         <comment type="block">/* Logarithm of the number of rows in the table */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pWCEnd</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rLogSize</name> <operator>=</operator> <call><name>estLog</name><argument_list>(<argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>termCanDriveIndex</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
        <comment type="block">/* TUNING: One-time cost for computing the automatic index is
        ** estimated to be X*N*log2(N) where N is the number of rows in
        ** the table being indexed and where X is 7 (LogEst=28) for normal
        ** tables or 0.5 (LogEst=-10) for views and subqueries.  The value
        ** of X is smaller for views and subqueries so that the query planner
        ** will be more aggressive about generating automatic indexes for
        ** those objects, since there is no opportunity to add schema
        ** indexes on subqueries and views. */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <name>rLogSize</name> <operator>+</operator> <name>rSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>+=</operator> <literal type="number">28</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>-=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* TUNING: Each index lookup yields 20 rows in the table.  This
        ** is more than the usual guess of 10 rows, since we have no way
        ** of knowing how selective the index will ultimately be.  It would
        ** not be unreasonable to make this value much larger. */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <literal type="number">43</literal></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">43</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rLogSize</name></expr></argument>,<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_AUTO_INDEX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>mPrereq</name> <operator>|</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOMATIC_INDEX */</comment>

  <comment type="block">/* Loop over all indices. If there was an INDEXED BY clause, then only 
  ** consider index pProbe.  */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pProbe</name></expr>;</condition> 
      <incr><expr><name>pProbe</name><operator>=</operator><operator>(</operator><ternary><condition><expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>pProbe</name><operator>-&gt;</operator><name>pNext</name></name></expr></else></ternary><operator>)</operator></expr><operator>,</operator> <expr><name>iSortIdx</name><operator>++</operator></expr></incr>
  )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>whereUsablePartialIndex</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>,
                                 <argument><expr><name><name>pProbe</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See ticket [98d973b8f5] */</comment>
      <continue>continue;</continue>  <comment type="block">/* Partial index inappropriate for this query */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>bNoQuery</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rSize</name> <operator>=</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nBtm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nTop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>mPrereq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>rSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <name>pProbe</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>indexMightHelpWithOrderBy</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The ONEPASS_DESIRED flags never occurs together with ORDER BY */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>b</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>idxType</name></name><operator>==</operator><name>SQLITE_IDXTYPE_IPK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Integer primary key index */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_IPK</name></expr>;</expr_stmt>

      <comment type="block">/* Full table scan */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <ternary><condition><expr><name>b</name></expr> ?</condition><then> <expr><name>iSortIdx</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <comment type="block">/* TUNING: Cost of full table scan is 3.0*N.  The 3.0 factor is an
      ** extra cost designed to discourage the use of full table scans,
      ** since index lookups have better worst-case performance if our
      ** stat guesses are wrong.  Reduce the 3.0 penalty slightly
      ** (to 2.75) if we have valid STAT4 information for the table.
      ** At 2.75, a full table scan is preferred over using an index on
      ** a column with just two distinct values where each value has about
      ** an equal number of appearances.  Without STAT4 data, we still want
      ** to use an index in that case, since the constraint might be for
      ** the scarcer of the two values, and in that case an index lookup is
      ** better.
      */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name>rSize</name> <operator>+</operator> <literal type="number">16</literal> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStat4</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name>rSize</name> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_VIEWSCAN</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLoopOutputAdjust</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>rSize</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>isCovering</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_IDX_ONLY</name> <operator>|</operator> <name>WHERE_INDEXED</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>colNotIdxed</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_INDEXED</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>m</name><operator>==</operator><name>TOPBIT</name> <operator>||</operator> <operator>(</operator><name><name>pProbe</name><operator>-&gt;</operator><name>bHasExpr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pProbe</name><operator>-&gt;</operator><name>bHasVCol</name></name> <operator>&amp;&amp;</operator> <name>m</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u32</name></type> <name>isCov</name> <init>= <expr><call><name>whereIsCoveringIndex</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>isCov</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>,
               <argument><expr><operator>(</operator><literal type="string">"-&gt; %s is not a covering index"</literal>
                <literal type="string">" according to whereIsCoveringIndex()\n"</literal><operator>,</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>m</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>isCov</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>isCov</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>,
                 <argument><expr><operator>(</operator><literal type="string">"-&gt; %s is a covering expression index"</literal>
                  <literal type="string">" according to whereIsCoveringIndex()\n"</literal><operator>,</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isCov</name><operator>==</operator><name>WHERE_EXPRIDX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>,
                 <argument><expr><operator>(</operator><literal type="string">"-&gt; %s might be a covering expression index"</literal>
                  <literal type="string">" according to whereIsCoveringIndex()\n"</literal><operator>,</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>m</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>,
             <argument><expr><operator>(</operator><literal type="string">"-&gt; %s a covering index according to bitmasks\n"</literal><operator>,</operator>
             <name><name>pProbe</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <ternary><condition><expr><name>m</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"is"</literal></expr> </then><else>: <expr><literal type="string">"is not"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_IDX_ONLY</name> <operator>|</operator> <name>WHERE_INDEXED</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Full scan via index */</comment>
      <if_stmt><if>if<condition>( <expr><name>b</name>
       <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>
       <operator>||</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>!=</operator><literal type="number">0</literal>
       <operator>||</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name>
       <operator>||</operator> <operator>(</operator> <name>m</name><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>bUnordered</name></name><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pProbe</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bUseCis</name></name>
         <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_CoverIdxScan</name></expr></argument>)</argument_list></call>
          <operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <ternary><condition><expr><name>b</name></expr> ?</condition><then> <expr><name>iSortIdx</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* The cost of visiting the index rows is N*K, where K is
        ** between 1.1 and 3.0, depending on the relative sizes of the
        ** index and table rows. */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name>rSize</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">15</literal><operator>*</operator><name><name>pProbe</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>)</operator><operator>/</operator><name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>m</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* If this is a non-covering index scan, add in the cost of
          ** doing table lookups.  The cost will be 3x the number of
          ** lookups.  Take into account WHERE clause terms that can be
          ** satisfied using just the index, and that do not require a
          ** table lookup. */</comment>
          <decl_stmt><decl><type><name>LogEst</name></type> <name>nLookup</name> <init>= <expr><name>rSize</name> <operator>+</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Base cost:  N*3 */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> <init>= <expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC2</name> <init>= <expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pWC2</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><operator>&amp;</operator><name><name>pWC2</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3ExprCoveredByIndex</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* pTerm can be evaluated using just the index.  So reduce
            ** the expected number of table lookups accordingly */</comment>
            <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>nLookup</name> <operator>+=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>nLookup</name><operator>--</operator></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nLookup</name> <operator>-=</operator> <literal type="number">19</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>
          
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name>nLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereLoopOutputAdjust</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aColExpr</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Do not do an SCAN of a index-on-expression in a RIGHT JOIN
          ** because the cursor used to access the index might not be
          ** positioned to the correct row during the right-join no-match
          ** loop. */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>rSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>bldFlags1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddBtreeIndex</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>bldFlags1</name></name><operator>==</operator><name>SQLITE_BLDF1_INDEXED</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If a non-unique index is used, or if a prefix of the key for
      ** unique index is used (making the index functionally non-unique)
      ** then the sqlite_stat1 data becomes important for scoring the
      ** plan */</comment>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_StatsUsed</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3Stat4ProbeFree</name><argument_list>(<argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Return true if pTerm is a virtual table LIMIT or OFFSET term.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isLimitTerm</name><parameter_list>(<parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_AUX</name> <operator>||</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name><operator>&gt;=</operator><name>SQLITE_INDEX_CONSTRAINT_LIMIT</name> 
      <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name><operator>&lt;=</operator><name>SQLITE_INDEX_CONSTRAINT_OFFSET</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument pIdxInfo is already populated with all constraints that may
** be used by the virtual table identified by pBuilder-&gt;pNew-&gt;iTab. This
** function marks a subset of those constraints usable, invokes the
** xBestIndex method and adds the returned plan to pBuilder.
**
** A constraint is marked usable if:
**
**   * Argument mUsable indicates that its prerequisites are available, and
**
**   * It is not one of the operators specified in the mExclude mask passed
**     as the fourth argument (which in practice is either WO_IN or 0).
**
** Argument mPrereq is a mask of tables that must be scanned before the
** virtual table in question. These are added to the plans prerequisites
** before it is added to pBuilder.
**
** Output parameter *pbIn is set to true if the plan added to pBuilder
** uses one or more WO_IN terms, or false otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddVirtualOne</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>Bitmask</name></type> <name>mPrereq</name></decl></parameter>,                <comment type="block">/* Mask of tables that must be used. */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mUsable</name></decl></parameter>,                <comment type="block">/* Mask of usable tables */</comment>
  <parameter><decl><type><name>u16</name></type> <name>mExclude</name></decl></parameter>,                   <comment type="block">/* Exclude terms using these operators */</comment>
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>,   <comment type="block">/* Populated object for xBestIndex */</comment>
  <parameter><decl><type><name>u16</name></type> <name>mNoOmit</name></decl></parameter>,                    <comment type="block">/* Do not omit these constraints */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbIn</name></decl></parameter>,                      <comment type="block">/* OUT: True if plan uses an IN(...) op */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbRetryLimit</name></decl></parameter>               <comment type="block">/* OUT: Retry without LIMIT/OFFSET */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HiddenIndexInfo</name> <modifier>*</modifier></type><name>pHidden</name> <init>= <expr><operator>(</operator><name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pIdxCons</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint_usage</name></name> <modifier>*</modifier></type><name>pUsage</name> <init>= <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name> <init>= <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>mUsable</name> <operator>&amp;</operator> <name>mPrereq</name><operator>)</operator><operator>==</operator><name>mPrereq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pbIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>mPrereq</name></expr>;</expr_stmt>

  <comment type="block">/* Set the usable flag on the subset of constraints identified by 
  ** arguments mUsable and mExclude. */</comment>
  <expr_stmt><expr><name>pIdxCons</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>sqlite3_index_constraint</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pIdxCons</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>iTermOffset</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>mUsable</name><operator>)</operator><operator>==</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>mExclude</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>pbRetryLimit</name> <operator>||</operator> <operator>!</operator><call><name>isLimitTerm</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Initialize the output fields of the sqlite3_index_info structure */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pUsage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pUsage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <name>SQLITE_BIG_DBL</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>mHandleIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Invoke the virtual table xBestIndex() method */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vtabBestIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>, <argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the xBestIndex method returns SQLITE_CONSTRAINT, that means
      ** that the particular combination of parameters provided is unusable.
      ** Make no entries in the loop table.
      */</comment>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"  ^^^^--- non-viable plan rejected!\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>mxTerm</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name><operator>&gt;=</operator><name>nConstraint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nConstraint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxCons</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>sqlite3_index_constraint</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pIdxCons</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iTerm</name> <operator>=</operator> <name><name>pUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>iTermOffset</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iTerm</name><operator>&gt;=</operator><name>nConstraint</name>
       <operator>||</operator> <name>j</name><operator>&lt;</operator><literal type="number">0</literal>
       <operator>||</operator> <name>j</name><operator>&gt;=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name>
       <operator>||</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal>
       <operator>||</operator> <name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><literal type="string">"%s.xBestIndex malfunction"</literal></expr></argument>,<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iTerm</name><operator>==</operator><name>nConstraint</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>|=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTerm</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>iTerm</name></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iTerm</name><operator>&gt;</operator><name>mxTerm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxTerm</name> <operator>=</operator> <name>iTerm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iTerm</name><operator>==</operator><literal type="number">15</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iTerm</name><operator>==</operator><literal type="number">16</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">16</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>i</name><operator>)</operator><operator>&amp;</operator><name>mNoOmit</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>!=</operator><name>iTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>iTerm</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>!=</operator><name>iTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_OFFSET</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>bOmitOffset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>SMASKBIT32</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>pHidden</name><operator>-&gt;</operator><name>mHandleIn</name></name></expr> )</condition><block>{<block_content> 
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>mHandleIn</name></name> <operator>|=</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>iTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* A virtual table that is constrained by an IN clause may not
        ** consume the ORDER BY clause because (1) the order of IN terms
        ** is not necessarily related to the order of output terms and
        ** (2) Multiple outputs from a single IN value will not merge
        ** together.  */</comment>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_INDEX_SCAN_UNIQUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pbIn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>mExclude</name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbRetryLimit</name> <operator>||</operator> <operator>!</operator><call><name>isLimitTerm</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>isLimitTerm</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>pbIn</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If there is an IN(...) term handled as an == (separate call to
        ** xFilter for each value on the RHS of the IN) and a LIMIT or
        ** OFFSET term handled as well, the plan is unusable. Set output
        ** variable *pbRetryLimit to true to tell the caller to retry with
        ** LIMIT and OFFSET disabled. */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>pbRetryLimit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>mxTerm</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>mxTerm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The non-zero argvIdx values must be contiguous.  Raise an
      ** error if they are not */</comment>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><literal type="string">"%s.xBestIndex malfunction"</literal></expr></argument>,<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>&lt;=</operator><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>isOrdered</name></name> <operator>=</operator> <operator>(</operator><name>i8</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name></expr> ?</condition><then>
      <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstFromDouble</name><argument_list>(<argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the WHERE_ONEROW flag if the xBestIndex() method indicated
  ** that the scan will visit at most one row. Clear it otherwise. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>&amp;</operator> <name>SQLITE_INDEX_SCAN_UNIQUE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_ONEROW</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_ONEROW</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"  bIn=%d prereqIn=%04llx prereqOut=%04llx\n"</literal><operator>,</operator>
                      <operator>*</operator><name>pbIn</name><operator>,</operator> <operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>mPrereq</name><operator>,</operator>
                      <operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <operator>~</operator><name>mPrereq</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the collating sequence for a constraint passed into xBestIndex.
**
** pIdxInfo must be an sqlite3_index_info structure passed into xBestIndex.
** This routine depends on there being a HiddenIndexInfo structure immediately
** following the sqlite3_index_info structure.
**
** Return a pointer to the collation name:
**
**    1. If there is an explicit COLLATE operator on the constaint, return it.
**
**    2. Else, if the column has an alternative collation, return that.
**
**    3. Otherwise, return "BINARY".
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_vtab_collation</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCons</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HiddenIndexInfo</name> <modifier>*</modifier></type><name>pHidden</name> <init>= <expr><operator>(</operator><name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCons</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCons</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name> <init>= <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>iCons</name></expr>]</index></name><operator>.</operator><name>iTermOffset</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><name><name>pHidden</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pC</name> <operator>=</operator> <call><name>sqlite3ExprCompareCollSeq</name><argument_list>(<argument><expr><name><name>pHidden</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pC</name></expr> ?</condition><then> <expr><name><name>pC</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><name>sqlite3StrBINARY</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if constraint iCons is really an IN(...) constraint, or
** false otherwise. If iCons is an IN(...) constraint, set (if bHandle!=0)
** or clear (if bHandle==0) the flag to handle it using an iterator.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_in</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCons</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bHandle</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HiddenIndexInfo</name> <modifier>*</modifier></type><name>pHidden</name> <init>= <expr><operator>(</operator><name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>m</name> <init>= <expr><call><name>SMASKBIT32</name><argument_list>(<argument><expr><name>iCons</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>m</name> <operator>&amp;</operator> <name><name>pHidden</name><operator>-&gt;</operator><name>mIn</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bHandle</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>mHandleIn</name></name> <operator>&amp;=</operator> <operator>~</operator><name>m</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bHandle</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pHidden</name><operator>-&gt;</operator><name>mHandleIn</name></name> <operator>|=</operator> <name>m</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This interface is callable from within the xBestIndex callback only.
**
** If possible, set (*ppVal) to point to an object containing the value 
** on the right-hand-side of constraint iCons.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_rhs_value</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>,   <comment type="block">/* Copy of first argument to xBestIndex */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCons</name></decl></parameter>,                      <comment type="block">/* Constraint for which RHS is wanted */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVal</name></decl></parameter>           <comment type="block">/* Write value extracted here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HiddenIndexInfo</name> <modifier>*</modifier></type><name>pH</name> <init>= <expr><operator>(</operator><name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCons</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iCons</name><operator>&gt;=</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt> <comment type="block">/* EV: R-30545-25046 */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pH</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>iCons</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><operator>&amp;</operator><name><name>pH</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>iCons</name></expr>]</index></name><operator>.</operator><name>iTermOffset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ValueFromExpr</name><argument_list>(
          <argument><expr><name><name>pH</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name><name>pH</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>SQLITE_AFF_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pH</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>iCons</name></expr>]</index></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <name><name>pH</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>iCons</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVal</name> <operator>=</operator> <name>pVal</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>  <comment type="block">/* IMP: R-19933-32160 */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>          <comment type="block">/* IMP: R-36424-56542 */</comment>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if ORDER BY clause may be handled as DISTINCT.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_distinct</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HiddenIndexInfo</name> <modifier>*</modifier></type><name>pHidden</name> <init>= <expr><operator>(</operator><name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pHidden</name><operator>-&gt;</operator><name>eDistinct</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pHidden</name><operator>-&gt;</operator><name>eDistinct</name></name><operator>&lt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pHidden</name><operator>-&gt;</operator><name>eDistinct</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_DBPAGE_VTAB</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call><operator>)</operator> \
    <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Cause the prepared statement that is associated with a call to
** xBestIndex to potentiall use all schemas.  If the statement being
** prepared is read-only, then just start read transactions on all
** schemas.  But if this is a write operation, start writes on all
** schemas.
**
** This is used by the (built-in) sqlite_dbpage virtual table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabUsesAllSchemas</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HiddenIndexInfo</name> <modifier>*</modifier></type><name>pHidden</name> <init>= <expr><operator>(</operator><name>HiddenIndexInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pHidden</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDb</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>writeMask</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDb</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Add all WhereLoop objects for a table of the join identified by
** pBuilder-&gt;pNew-&gt;iTab.  That table is guaranteed to be a virtual table.
**
** If there are no LEFT or CROSS JOIN joins in the query, both mPrereq and
** mUnusable are set to 0. Otherwise, mPrereq is a mask of all FROM clause
** entries that occur before the virtual table in the FROM clause and are
** separated from it by at least one LEFT or CROSS JOIN. Similarly, the
** mUnusable mask contains all FROM clause entries that occur after the
** virtual table and are separated from it by at least one LEFT or 
** CROSS JOIN. 
**
** For example, if the query were:
**
**   ... FROM t1, t2 LEFT JOIN t3, t4, vt CROSS JOIN t5, t6;
**
** then mPrereq corresponds to (t1, t2) and mUnusable to (t5, t6).
**
** All the tables in mPrereq must be scanned before the current virtual 
** table. So any terms for which all prerequisites are satisfied by 
** mPrereq may be specified as "usable" in all calls to xBestIndex. 
** Conversely, all tables in mUnusable must be scanned after the current
** virtual table, so any terms for which the prerequisites overlap with
** mUnusable should always be configured as "not-usable" for xBestIndex.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddVirtual</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,  <comment type="block">/* WHERE clause information */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mPrereq</name></decl></parameter>,             <comment type="block">/* Tables that must be scanned before this one */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mUnusable</name></decl></parameter>            <comment type="block">/* Tables that must be scanned after this one */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>           <comment type="block">/* WHERE analysis context */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>               <comment type="block">/* The parsing context */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>            <comment type="block">/* The WHERE clause */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>               <comment type="block">/* The FROM clause term to search */</comment>
  <decl_stmt><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>       <comment type="block">/* Object to pass to xBestIndex() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name></decl>;</decl_stmt>             <comment type="block">/* Number of constraints in p */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIn</name></decl>;</decl_stmt>                     <comment type="block">/* True if plan uses IN(...) operator */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mBest</name></decl>;</decl_stmt>               <comment type="block">/* Tables used by best possible plan */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>mNoOmit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bRetry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* True to retry with LIMIT/OFFSET disabled */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>mPrereq</name> <operator>&amp;</operator> <name>mUnusable</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>allocateIndexInfo</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mNoOmit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_VIRTUALTABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nConstraint</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>freeIndexInfo</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* First call xBestIndex() with all constraints usable. */</comment>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"BEGIN %s.addVirtual()\n"</literal><operator>,</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"  VirtualOne: all usable\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtualOne</name><argument_list>(
      <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>ALLBITS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mNoOmit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bRetry</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bRetry</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtualOne</name><argument_list>(
        <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>ALLBITS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mNoOmit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the call to xBestIndex() with all terms enabled produced a plan
  ** that does not require any source tables (IOW: a plan with mBest==0)
  ** and does not use an IN(...) operator, then there is no point in making 
  ** any further calls to xBestIndex() since they will all return the same
  ** result (if the xBestIndex() implementation is sane). */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>mBest</name> <operator>=</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <operator>~</operator><name>mPrereq</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>bIn</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>seenZero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if a plan with no prereqs seen */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>seenZeroNoIN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Plan with no prereqs and no IN(...) seen */</comment>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>mPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>mBestNoIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the plan produced by the earlier call uses an IN(...) term, call
    ** xBestIndex again, this time with IN(...) terms disabled. */</comment>
    <if_stmt><if>if<condition>( <expr><name>bIn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"  VirtualOne: all usable w/o IN\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtualOne</name><argument_list>(
          <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>ALLBITS</name></expr></argument>, <argument><expr><name>WO_IN</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mNoOmit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bIn</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mBestNoIn</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <operator>~</operator><name>mPrereq</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>mBestNoIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>seenZero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>seenZeroNoIN</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Call xBestIndex once for each distinct value of (prereqRight &amp; ~mPrereq) 
    ** in the set of terms that apply to the current virtual table.  */</comment>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>mNext</name> <init>= <expr><name>ALLBITS</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mNext</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>mThis</name> <init>= <expr><operator>(</operator>
            <name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iTermOffset</name></expr>]</index></name><operator>.</operator><name>prereqRight</name> <operator>&amp;</operator> <operator>~</operator><name>mPrereq</name>
        <operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>mThis</name><operator>&gt;</operator><name>mPrev</name> <operator>&amp;&amp;</operator> <name>mThis</name><operator>&lt;</operator><name>mNext</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mNext</name> <operator>=</operator> <name>mThis</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>mPrev</name> <operator>=</operator> <name>mNext</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>mNext</name><operator>==</operator><name>ALLBITS</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>mNext</name><operator>==</operator><name>mBest</name> <operator>||</operator> <name>mNext</name><operator>==</operator><name>mBestNoIn</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"  VirtualOne: mPrev=%04llx mNext=%04llx\n"</literal><operator>,</operator>
                       <operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>mPrev</name><operator>,</operator> <operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><name>mNext</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtualOne</name><argument_list>(
          <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>mNext</name><operator>|</operator><name>mPrereq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mNoOmit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name><operator>==</operator><name>mPrereq</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>seenZero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seenZeroNoIN</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* If the calls to xBestIndex() in the above loop did not find a plan
    ** that requires no source tables at all (i.e. one guaranteed to be
    ** usable), make a call here with all source tables disabled */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>seenZero</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"  VirtualOne: all disabled\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtualOne</name><argument_list>(
          <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mNoOmit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seenZeroNoIN</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the calls to xBestIndex() have so far failed to find a plan
    ** that requires no source tables at all and does not use an IN(...)
    ** operator, make a final call to obtain one here.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>seenZeroNoIN</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"  VirtualOne: all disabled and w/o IN\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtualOne</name><argument_list>(
          <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>WO_IN</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mNoOmit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>freeIndexInfo</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x800</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"END %s.addVirtual(), rc=%d\n"</literal><operator>,</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name>rc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Add WhereLoop entries to handle OR terms.  This works for either
** btrees or virtual tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddOr</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>, 
  <parameter><decl><type><name>Bitmask</name></type> <name>mPrereq</name></decl></parameter>, 
  <parameter><decl><type><name>Bitmask</name></type> <name>mUnusable</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pWCEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name></type> <name>tempWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoopBuilder</name></type> <name>sSubBuild</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereOrSet</name></type> <name>sSum</name></decl>, <decl><type ref="prev"/><name>sCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWCEnd</name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sSum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>

  <comment type="block">/* The multi-index OR optimization does not work for RIGHT and FULL JOIN */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_OR</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name><operator>-&gt;</operator><name>indexable</name></name> <operator>&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pOrWC</name> <init>= <expr><operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name><operator>-&gt;</operator><name>wc</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pOrWCEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pOrWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pOrWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOrTerm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>once</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    
      <expr_stmt><expr><name>sSubBuild</name> <operator>=</operator> <operator>*</operator><name>pBuilder</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSubBuild</name><operator>.</operator><name>pOrSet</name></name> <operator>=</operator> <operator>&amp;</operator><name>sCur</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x400</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Begin processing OR-clause %p\n"</literal><operator>,</operator> <name>pTerm</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pOrTerm</name><operator>=</operator><name><name>pOrWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pOrTerm</name><operator>&lt;</operator><name>pOrWCEnd</name></expr>;</condition> <incr><expr><name>pOrTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_AND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>sSubBuild</name><operator>.</operator><name>pWC</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pAndInfo</name><operator>-&gt;</operator><name>wc</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCur</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>pWInfo</name></name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>pOuter</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_AND</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>nTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>nBase</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>pOrTerm</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sSubBuild</name><operator>.</operator><name>pWC</name></name> <operator>=</operator> <operator>&amp;</operator><name>tempWC</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>sCur</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x400</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"OR-term %d of %p has %d subterms:\n"</literal><operator>,</operator> 
                   <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOrTerm</name><operator>-</operator><name><name>pOrWC</name><operator>-&gt;</operator><name>a</name></name><operator>)</operator><operator>,</operator> <name>pTerm</name><operator>,</operator> <name><name>sSubBuild</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x20000</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3WhereClausePrint</name><argument_list>(<argument><expr><name><name>sSubBuild</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSubBuild</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddBtree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSubBuild</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddOr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSubBuild</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_DONE</name> <operator>||</operator> <name><name>sCur</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal>
                <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>&amp;&amp;</operator> <name><name>sCur</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sCur</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>sSum</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>once</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>whereOrMove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>once</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>WhereOrSet</name></type> <name>sPrev</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>whereOrMove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sPrev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sSum</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sPrev</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>sCur</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><call><name>whereOrInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>, <argument><expr><name><name>sPrev</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prereq</name> <operator>|</operator> <name><name>sCur</name><operator>.</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>prereq</name></expr></argument>,
                            <argument><expr><call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>sPrev</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rRun</name></expr></argument>, <argument><expr><name><name>sCur</name><operator>.</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>rRun</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>sPrev</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nOut</name></expr></argument>, <argument><expr><name><name>sCur</name><operator>.</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nOut</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_MULTI_OR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>sSum</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <comment type="block">/* TUNING: Currently sSum.a[i].rRun is set to the sum of the costs
        ** of all sub-scans required by the OR-scan. However, due to rounding
        ** errors, it may be that the cost of the OR-scan is equal to its
        ** most expensive sub-scan. Add the smallest possible penalty 
        ** (equivalent to multiplying the cost by 1.07) to ensure that 
        ** this does not happen. Otherwise, for WHERE clauses such as the
        ** following where there is an index on "y":
        **
        **     WHERE likelihood(x=?, 0.99) OR y=?
        **
        ** the planner may elect to "OR" together a full-table scan and an
        ** index lookup. And other similarly odd results.  */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name><name>sSum</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rRun</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name><name>sSum</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nOut</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name><name>sSum</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prereq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x400</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"End processing OR-clause %p\n"</literal><operator>,</operator> <name>pTerm</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add all WhereLoop objects for all tables 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddAll</name><parameter_list>(<parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mPrereq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mPrior</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bFirstPastRJ</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasRightJoin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>


  <comment type="block">/* Loop over the tables in the join, from left to right */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>

  <comment type="block">/* Verify that pNew has already been initialized */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name><operator>&gt;=</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>iPlanLimit</name></name> <operator>=</operator> <name>SQLITE_QUERY_PLANNER_LIMIT</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iTab</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pItem</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>iTab</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>mUnusable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>iPlanLimit</name></name> <operator>+=</operator> <name>SQLITE_QUERY_PLANNER_LIMIT_INCR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name> <operator>=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bFirstPastRJ</name> 
     <operator>||</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_OUTER</name><operator>|</operator><name>JT_CROSS</name><operator>|</operator><name>JT_LTORJ</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* Add prerequisites to prevent reordering of FROM clause terms
      ** across CROSS joins and outer joins.  The bFirstPastRJ boolean
      ** prevents the right operand of a RIGHT JOIN from being swapped with
      ** other elements even further to the right.
      **
      ** The JT_LTORJ case and the hasRightJoin flag work together to
      ** prevent FROM-clause terms from moving from the right side of
      ** a LEFT JOIN over to the left side of that join if the LEFT JOIN
      ** is itself on the left side of a RIGHT JOIN.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasRightJoin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>mPrereq</name> <operator>|=</operator> <name>mPrior</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bFirstPastRJ</name> <operator>=</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name>hasRightJoin</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>mPrereq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><operator>&amp;</operator><name><name>pItem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>p</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>mUnusable</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_OUTER</name><operator>|</operator><name>JT_CROSS</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mUnusable</name> <operator>|=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtual</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
    <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddBtree</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>hasOr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddOr</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mPrereq</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>mPrior</name> <operator>|=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* We hit the query planner search limit set by iPlanLimit */</comment>
        <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"abbreviated query algorithm search"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>whereLoopClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Examine a WherePath (with the addition of the extra WhereLoop of the 6th
** parameters) to see if it outputs rows in the requested ORDER BY
** (or GROUP BY) without requiring a separate sort operation.  Return N:
** 
**   N&gt;0:   N terms of the ORDER BY clause are satisfied
**   N==0:  No terms of the ORDER BY clause are satisfied
**   N&lt;0:   Unknown yet how many terms of ORDER BY might be satisfied.   
**
** Note that processing for WHERE_GROUPBY and WHERE_DISTINCTBY is not as
** strict.  With GROUP BY and DISTINCT the only requirement is that
** equivalent rows appear immediately adjacent to one another.  GROUP BY
** and DISTINCT do not require rows to appear in any particular order as long
** as equivalent rows are grouped together.  Thus for GROUP BY and DISTINCT
** the pOrderBy terms can be matched in any order.  With ORDER BY, the 
** pOrderBy terms must be matched in strict left-to-right order.
*/</comment>
<function><type><specifier>static</specifier> <name>i8</name></type> <name>wherePathSatisfiesOrderBy</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,    <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* ORDER BY or GROUP BY or DISTINCT clause to check */</comment>
  <parameter><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pPath</name></decl></parameter>,     <comment type="block">/* The WherePath to check */</comment>
  <parameter><decl><type><name>u16</name></type> <name>wctrlFlags</name></decl></parameter>,       <comment type="block">/* WHERE_GROUPBY or _DISTINCTBY or _ORDERBY_LIMIT */</comment>
  <parameter><decl><type><name>u16</name></type> <name>nLoop</name></decl></parameter>,            <comment type="block">/* Number of entries in pPath-&gt;aLoop[] */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>,     <comment type="block">/* Add this WhereLoop to the end of pPath-&gt;aLoop[] */</comment>
  <parameter><decl><type><name>Bitmask</name> <modifier>*</modifier></type><name>pRevMask</name></decl></parameter>     <comment type="block">/* OUT: Mask of WhereLoops to run in reverse order */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>revSet</name></decl>;</decl_stmt>            <comment type="block">/* True if rev is known */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>rev</name></decl>;</decl_stmt>               <comment type="block">/* Composite sort order */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>revIdx</name></decl>;</decl_stmt>            <comment type="block">/* Index sort order */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isOrderDistinct</name></decl>;</decl_stmt>   <comment type="block">/* All prior WhereLoops are order-distinct */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>distinctColumns</name></decl>;</decl_stmt>   <comment type="block">/* True if the loop has UNIQUE NOT NULL columns */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isMatch</name></decl>;</decl_stmt>           <comment type="block">/* iColumn matches a term of the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>eqOpMask</name></decl>;</decl_stmt>         <comment type="block">/* Allowed equality operators */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nKeyCol</name></decl>;</decl_stmt>          <comment type="block">/* Number of key columns in pIndex */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nColumn</name></decl>;</decl_stmt>          <comment type="block">/* Total number of ordered columns in the index */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nOrderBy</name></decl>;</decl_stmt>         <comment type="block">/* Number terms in the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLoop</name></decl>;</decl_stmt>            <comment type="block">/* Index of WhereLoop in pPath being processed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>             <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>             <comment type="block">/* Cursor number for current WhereLoop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>          <comment type="block">/* A column number within table iCur */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Current WhereLoop being processed. */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>     <comment type="block">/* A single term of the WHERE clause */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOBExpr</name></decl>;</decl_stmt>        <comment type="block">/* An expression from the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>       <comment type="block">/* COLLATE function from an ORDER BY clause term */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>        <comment type="block">/* The index associated with pLoop */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>obSat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Mask of ORDER BY terms satisfied so far */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>obDone</name></decl>;</decl_stmt>       <comment type="block">/* Mask of all ORDER BY terms */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>orderDistinctMask</name></decl>;</decl_stmt>  <comment type="block">/* Mask of all well-ordered loops */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>ready</name></decl>;</decl_stmt>              <comment type="block">/* Mask of inner loops */</comment>

  <comment type="block">/*
  ** We say the WhereLoop is "one-row" if it generates no more than one
  ** row of output.  A WhereLoop is one-row if all of the following are true:
  **  (a) All index columns match with WHERE_COLUMN_EQ.
  **  (b) The index is unique
  ** Any WhereLoop with an WHERE_COLUMN_EQ constraint on the rowid is one-row.
  ** Every one-row WhereLoop will have the WHERE_ONEROW bit set in wsFlags.
  **
  ** We say the WhereLoop is "order-distinct" if the set of columns from
  ** that WhereLoop that are in the ORDER BY clause are different for every
  ** row of the WhereLoop.  Every one-row WhereLoop is automatically
  ** order-distinct.   A WhereLoop that has no columns in the ORDER BY clause
  ** is not order-distinct. To be order-distinct is not quite the same as being
  ** UNIQUE since a UNIQUE column or index can have multiple rows that 
  ** are NULL and NULL values are equivalent for the purpose of order-distinct.
  ** To be order-distinct, the columns must be UNIQUE and NOT NULL.
  **
  ** The rowid for a table is always UNIQUE and NOT NULL so whenever the
  ** rowid appears in the ORDER BY clause, the corresponding WhereLoop is
  ** automatically order-distinct.
  */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nLoop</name> <operator>&amp;&amp;</operator> <call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OrderByIdxJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nOrderBy</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOrderBy</name><operator>&gt;</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Cannot optimize overly large ORDER BYs */</comment>
  <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>obDone</name> <operator>=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>nOrderBy</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>orderDistinctMask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ready</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>eqOpMask</name> <operator>=</operator> <name>WO_EQ</name> <operator>|</operator> <name>WO_IS</name> <operator>|</operator> <name>WO_ISNULL</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_ORDERBY_LIMIT</name><operator>|</operator><name>WHERE_ORDERBY_MAX</name><operator>|</operator><name>WHERE_ORDERBY_MIN</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eqOpMask</name> <operator>|=</operator> <name>WO_IN</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>iLoop</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>isOrderDistinct</name> <operator>&amp;&amp;</operator> <name>obSat</name><operator>&lt;</operator><name>obDone</name> <operator>&amp;&amp;</operator> <name>iLoop</name><operator>&lt;=</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>iLoop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ready</name> <operator>|=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iLoop</name><operator>&lt;</operator><name>nLoop</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pPath</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>iLoop</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ORDERBY_LIMIT</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name>pLast</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>isOrdered</name></name> 
       <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>wctrlFlags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_DISTINCTBY</name><operator>|</operator><name>WHERE_SORTBYGROUP</name><operator>)</operator><operator>)</operator><operator>!=</operator><name>WHERE_DISTINCTBY</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>obSat</name> <operator>=</operator> <name>obDone</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nDistinctCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>

    <comment type="block">/* Mark off any ORDER BY term X that is a column in the table of
    ** the current loop for which there is term in the WHERE
    ** clause of the form X IS NULL or X=? that reference only outer
    ** loops.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>obSat</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pOBExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pOBExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pOBExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>,
                       <argument><expr><operator>~</operator><name>ready</name></expr></argument>, <argument><expr><name>eqOpMask</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_IN</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* IN terms are only valid for sorting in the ORDER BY LIMIT 
        ** optimization, and then only if they are actually used
        ** by the query plan */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wctrlFlags</name> <operator>&amp;</operator> 
               <operator>(</operator><name>WHERE_ORDERBY_LIMIT</name><operator>|</operator><name>WHERE_ORDERBY_MIN</name><operator>|</operator><name>WHERE_ORDERBY_MAX</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>&amp;&amp;</operator> <name>pTerm</name><operator>!=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>&amp;</operator><operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOBExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl1</name> <init>= <expr><call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl2</name> <init>= <expr><call><name>sqlite3ExprCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pColl1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pColl2</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl1</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pColl2</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>obSat</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEROW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>pIndex</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>bUnordered</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nColumn</name><operator>==</operator><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>XN_ROWID</name>
                          <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* All relevant terms of the index must also be non-NULL in order
        ** for isOrderDistinct to be true.  So the isOrderDistint value
        ** computed here might be a false positive.  Corrections will be
        ** made at tag-20210426-1 below */</comment>
        <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call>
                          <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_SKIPSCAN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Loop through all columns of the index and deal with the ones
      ** that are not constrained by == or IN.
      */</comment>
      <expr_stmt><expr><name>rev</name> <operator>=</operator> <name>revSet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>distinctColumns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>bOnce</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True to run the ORDER BY search loop */</comment>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&gt;=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> 
            <operator>||</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name><operator>)</operator></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>&amp;&amp;</operator> <name>j</name><operator>&gt;=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u16</name></type> <name>eOp</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>eOperator</name></expr></init></decl>;</decl_stmt>

          <comment type="block">/* Skip over == and IS and ISNULL terms.  (Also skip IN terms when
          ** doing WHERE_ORDERBY_LIMIT processing).  Except, IS and ISNULL
          ** terms imply that the index is not UNIQUE NOT NULL in which case
          ** the loop need to be marked as not order-distinct because it can
          ** have repeated NULL rows.
          **
          ** If the current term is a column of an ((?,?) IN (SELECT...)) 
          ** expression for which the SELECT returns more than one column,
          ** check that it is the only column used by this loop. Otherwise,
          ** if it is one of two or more, none of the columns can be
          ** considered to match an ORDER BY term.
          */</comment>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <name>eqOpMask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isOrderDistinct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>  
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <comment type="block">/* ALWAYS() justification: eOp is an equality operator due to the
            ** j&lt;pLoop-&gt;u.btree.nEq constraint above.  Any equality other
            ** than WO_IN is captured by the previous "if".  So this one
            ** always has to be WO_IN. */</comment>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pExpr</name><operator>==</operator><name>pX</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>eOperator</name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bOnce</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Get the column number in the table (iColumn) and sort order
        ** (revIdx) for the j-th column of the index.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>pIndex</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>revIdx</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name>XN_ROWID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name>XN_ROWID</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>revIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* An unconstrained column that might be NULL means that this
        ** WhereLoop is not well-ordered.  tag-20210426-1
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>isOrderDistinct</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&gt;=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <name>j</name><operator>&gt;=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name>
           <operator>&amp;&amp;</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iColumn</name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt> 

        <comment type="block">/* Find the ORDER BY term that corresponds to the j-th column
        ** of the index and mark that ORDER BY term off 
        */</comment>
        <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>bOnce</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>obSat</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>pOBExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_GROUPBY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pOBExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_GROUPBY</name><operator>|</operator><name>WHERE_DISTINCTBY</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bOnce</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&gt;=</operator><name>XN_ROWID</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pOBExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name>iColumn</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pIxExpr</name> <init>= <expr><name><name>pIndex</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompareSkip</name><argument_list>(<argument><expr><name>pOBExpr</name></expr></argument>, <argument><expr><name>pIxExpr</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>!=</operator><name>XN_ROWID</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprNNCollSeq</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nDistinctCol</name></name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>isMatch</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_GROUPBY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Make sure the sort order is compatible in an ORDER BY clause.
          ** Sort order is irrelevant for a GROUP BY clause. */</comment>
          <if_stmt><if>if<condition>( <expr><name>revSet</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rev</name> <operator>^</operator> <name>revIdx</name><operator>)</operator> 
                           <operator>!=</operator> <operator>(</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name><operator>&amp;</operator><name>KEYINFO_ORDER_DESC</name><operator>)</operator></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rev</name> <operator>=</operator> <name>revIdx</name> <operator>^</operator> <operator>(</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rev</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRevMask</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>iLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>revSet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isMatch</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_BIGNULL_SORT</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isMatch</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name>XN_ROWID</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>distinctColumns</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>distinctColumns</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>obSat</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* No match found */</comment>
          <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>j</name><operator>&lt;</operator><name>nKeyCol</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isOrderDistinct</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for> <comment type="block">/* end Loop over all index columns */</comment>
      <if_stmt><if>if<condition>( <expr><name>distinctColumns</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isOrderDistinct</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt> <comment type="block">/* end-if not one-row */</comment>

    <comment type="block">/* Mark off any other ORDER BY terms that reference pLoop */</comment>
    <if_stmt><if>if<condition>( <expr><name>isOrderDistinct</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>orderDistinctMask</name> <operator>|=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>mTerm</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>obSat</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mTerm</name> <operator>=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>mTerm</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mTerm</name><operator>&amp;</operator><operator>~</operator><name>orderDistinctMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>obSat</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for> <comment type="block">/* End the loop over all WhereLoops from outer-most down to inner-most */</comment>
  <if_stmt><if>if<condition>( <expr><name>obSat</name><operator>==</operator><name>obDone</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>i8</name><operator>)</operator><name>nOrderBy</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isOrderDistinct</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nOrderBy</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><ternary><condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>i</name><operator>&lt;</operator><name>BMS</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>obSat</name><operator>&amp;</operator><name>m</name><operator>)</operator><operator>==</operator><name>m</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** If the WHERE_GROUPBY flag is set in the mask passed to sqlite3WhereBegin(),
** the planner assumes that the specified pOrderBy list is actually a GROUP
** BY clause - and so any order that groups rows as required satisfies the
** request.
**
** Normally, in this case it is not possible for the caller to determine
** whether or not the rows are really being delivered in sorted order, or
** just in some other order that provides the required grouping. However,
** if the WHERE_SORTBYGROUP flag is also passed to sqlite3WhereBegin(), then
** this function may be called on the returned WhereInfo object. It returns
** true if the rows really will be sorted in the specified order, or false
** otherwise.
**
** For example, assuming:
**
**   CREATE INDEX i1 ON t1(x, Y);
**
** then
**
**   SELECT * FROM t1 GROUP BY x,y ORDER BY x,y;   -- IsSorted()==1
**   SELECT * FROM t1 GROUP BY y,x ORDER BY y,x;   -- IsSorted()==0
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereIsSorted</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_GROUPBY</name><operator>|</operator><name>WHERE_DISTINCTBY</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_SORTBYGROUP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sorted</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/* For debugging use only: */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wherePathName</name><parameter_list>(<parameter><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pPath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLoop</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zName</name><index>[<expr><literal type="number">65</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pPath</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>cId</name></expr>;</expr_stmt> </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pLast</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zName</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pLast</name><operator>-&gt;</operator><name>cId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the cost of sorting nRow rows, assuming that the keys have 
** nOrderby columns and that the first nSorted columns are already in
** order.
*/</comment>
<function><type><specifier>static</specifier> <name>LogEst</name></type> <name>whereSortingCost</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,
  <parameter><decl><type><name>LogEst</name></type> <name>nRow</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nOrderBy</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nSorted</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <comment type="block">/* TUNING: Estimated cost of a full external sort, where N is 
  ** the number of rows to sort is:
  **
  **   cost = (3.0 * N * log(N)).
  ** 
  ** Or, if the order-by clause has X terms but only the last Y 
  ** terms are out of order, then block-sorting will reduce the 
  ** sorting cost to:
  **
  **   cost = (3.0 * N * log(N)) * (Y/X)
  **
  ** The (Y/X) term is implemented using stack variable rScale
  ** below.
  */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rScale</name></decl>, <decl><type ref="prev"/><name>rSortCost</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOrderBy</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">66</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rScale</name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>nOrderBy</name><operator>-</operator><name>nSorted</name><operator>)</operator><operator>*</operator><literal type="number">100</literal><operator>/</operator><name>nOrderBy</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">66</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rSortCost</name> <operator>=</operator> <name>nRow</name> <operator>+</operator> <name>rScale</name> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>

  <comment type="block">/* Multiple by log(M) where M is the number of output rows.
  ** Use the LIMIT for M if it is smaller.  Or if this sort is for
  ** a DISTINCT operator, M will be the number of distinct output
  ** rows, so fudge it downwards a bit.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_USE_LIMIT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>iLimit</name></name><operator>&lt;</operator><name>nRow</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nRow</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>iLimit</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* TUNING: In the sort for a DISTINCT operator, assume that the DISTINCT
    ** reduces the number of output rows by a factor of 2 */</comment>
    <if_stmt><if>if<condition>( <expr><name>nRow</name><operator>&gt;</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>nRow</name> <operator>-=</operator> <literal type="number">10</literal></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">10</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rSortCost</name> <operator>+=</operator> <call><name>estLog</name><argument_list>(<argument><expr><name>nRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rSortCost</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the list of WhereLoop objects at pWInfo-&gt;pLoops, this routine
** attempts to find the lowest cost path that visits each WhereLoop
** once.  This path is then loaded into the pWInfo-&gt;a[].pWLoop fields.
**
** Assume that the total number of output rows that will need to be sorted
** will be nRowEst (in the 10*log2 representation).  Or, ignore sorting
** costs if nRowEst==0.
**
** Return SQLITE_OK on success or SQLITE_NOMEM of a memory allocation
** error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>wherePathSolver</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>, <parameter><decl><type><name>LogEst</name></type> <name>nRowEst</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>mxChoice</name></decl>;</decl_stmt>             <comment type="block">/* Maximum number of simultaneous paths tracked */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLoop</name></decl>;</decl_stmt>                <comment type="block">/* Number of terms in the join */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>            <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLoop</name></decl>;</decl_stmt>                <comment type="block">/* Loop counter over the terms of the join */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>               <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Index of next entry to replace */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name></decl>;</decl_stmt>             <comment type="block">/* Number of ORDER BY clause terms */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>mxCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Maximum cost of a set of paths */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>mxUnsorted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Maximum unsorted cost of a set of path */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTo</name></decl>, <decl><type ref="prev"/><name>nFrom</name></decl>;</decl_stmt>           <comment type="block">/* Number of valid entries in aTo[] and aFrom[] */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>aFrom</name></decl>;</decl_stmt>         <comment type="block">/* All nFrom paths at the previous level */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>aTo</name></decl>;</decl_stmt>           <comment type="block">/* The nTo best paths at the current level */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pFrom</name></decl>;</decl_stmt>         <comment type="block">/* An element of aFrom[] that we are working on */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pTo</name></decl>;</decl_stmt>           <comment type="block">/* An element of aTo[] that we are working on */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pWLoop</name></decl>;</decl_stmt>        <comment type="block">/* One of the WhereLoop objects */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>           <comment type="block">/* Used to divy up the pSpace memory */</comment>
  <decl_stmt><decl><type><name>LogEst</name> <modifier>*</modifier></type><name>aSortCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Sorting and partial sorting costs */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pSpace</name></decl>;</decl_stmt>             <comment type="block">/* Temporary memory used by this routine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name></decl>;</decl_stmt>               <comment type="block">/* Bytes of space allocated at pSpace */</comment>

  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nLoop</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</expr_stmt>
  <comment type="block">/* TUNING: For simple queries, only the best path is tracked.
  ** For 2-way joins, the 5 best paths are followed.
  ** For joins of 3 or more tables, track the 10 best paths */</comment>
  <expr_stmt><expr><name>mxChoice</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nLoop</name><operator>&lt;=</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>nLoop</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nLoop</name><operator>&lt;=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x002</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"---- begin solver.  (nRowEst=%d)\n"</literal><operator>,</operator> <name>nRowEst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If nRowEst is zero and there is an ORDER BY clause, ignore it. In this
  ** case the purpose of this call is to estimate the number of rows returned
  ** by the overall query. Once this estimate has been obtained, the caller
  ** will invoke this function a second time, passing the estimate as the
  ** nRowEst parameter.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nRowEst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Allocate and initialize space for aTo, aFrom and aSortCost[] */</comment>
  <expr_stmt><expr><name>nSpace</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WherePath</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nLoop</name><operator>)</operator><operator>*</operator><name>mxChoice</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSpace</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSpace</name> <operator>=</operator> <call><name>sqlite3StackAllocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSpace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aTo</name> <operator>=</operator> <operator>(</operator><name>WherePath</name><operator>*</operator><operator>)</operator><name>pSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aFrom</name> <operator>=</operator> <name>aTo</name><operator>+</operator><name>mxChoice</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aFrom</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pX</name> <operator>=</operator> <operator>(</operator><name>WhereLoop</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>aFrom</name><operator>+</operator><name>mxChoice</name><operator>)</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>mxChoice</name><operator>*</operator><literal type="number">2</literal></expr><operator>,</operator> <expr><name>pFrom</name><operator>=</operator><name>aTo</name></expr>;</init> <condition><expr><name>ii</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>ii</name><operator>--</operator></expr><operator>,</operator> <expr><name>pFrom</name><operator>++</operator></expr><operator>,</operator> <expr><name>pX</name> <operator>+=</operator> <name>nLoop</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>nOrderBy</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is an ORDER BY clause and it is not being ignored, set up
    ** space for the aSortCost[] array. Each element of the aSortCost array
    ** is either zero - meaning it has not yet been initialized - or the
    ** cost of sorting nRowEst rows of data where the first X terms of
    ** the ORDER BY clause are already in order, where X is the array 
    ** index.  */</comment>
    <expr_stmt><expr><name>aSortCost</name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>*</operator><operator>)</operator><name>pX</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSortCost</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aSortCost</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>&amp;</operator><name><name>pSpace</name><index>[<expr><name>nSpace</name></expr>]</index></name><operator>==</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aSortCost</name><index>[<expr><name>nOrderBy</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aSortCost</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>&amp;</operator><name><name>pSpace</name><index>[<expr><name>nSpace</name></expr>]</index></name><operator>==</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Seed the search with a single WherePath containing zero WhereLoops.
  **
  ** TUNING: Do not let the number of iterations go above 28.  If the cost
  ** of computing an automatic index is not paid back within the first 28
  ** rows, then do not use the automatic index. */</comment>
  <expr_stmt><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nRow</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name></expr></argument>, <argument><expr><literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">48</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFrom</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isOrdered</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOrderBy</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If nLoop is zero, then there are no FROM terms in the query. Since
    ** in this case the query may return a maximum of one row, the results
    ** are already in the requested order. Set isOrdered to nOrderBy to
    ** indicate this. Or, if nLoop is greater than zero, set isOrdered to
    ** -1, indicating that the result set may or may not be ordered, 
    ** depending on the loops added to the current plan.  */</comment>
    <expr_stmt><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isOrdered</name> <operator>=</operator> <ternary><condition><expr><name>nLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>nOrderBy</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute successively longer WherePaths using the previous generation
  ** of WherePaths as the basis for the next.  Keep track of the mxChoice
  ** best paths at each generation */</comment>
  <for>for<control>(<init><expr><name>iLoop</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLoop</name><operator>&lt;</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>iLoop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nTo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pFrom</name><operator>=</operator><name>aFrom</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nFrom</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>pFrom</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>pWLoop</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr>;</init> <condition><expr><name>pWLoop</name></expr>;</condition> <incr><expr><name>pWLoop</name><operator>=</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>LogEst</name></type> <name>nOut</name></decl>;</decl_stmt>                      <comment type="block">/* Rows visited by (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>LogEst</name></type> <name>rCost</name></decl>;</decl_stmt>                     <comment type="block">/* Cost of path (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>LogEst</name></type> <name>rUnsorted</name></decl>;</decl_stmt>                 <comment type="block">/* Unsorted cost of (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>i8</name></type> <name>isOrdered</name></decl>;</decl_stmt>                     <comment type="block">/* isOrdered for (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>maskNew</name></decl>;</decl_stmt>                  <comment type="block">/* Mask of src visited by (..) */</comment>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>revMask</name></decl>;</decl_stmt>                  <comment type="block">/* Mask of rev-order loops for (..) */</comment>

        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>maskSelf</name></name> <operator>&amp;</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>nRow</name></name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Do not use an automatic index if the this loop is expected
          ** to run less than 1.25 times.  It is tempting to also exclude
          ** automatic index usage on an outer loop, but sometimes an automatic
          ** index is useful in the outer loop of a correlated subquery. */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">10</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* At this point, pWLoop is a candidate to be the next loop. 
        ** Compute its cost */</comment>
        <expr_stmt><expr><name>rUnsorted</name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>pWLoop</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument>,<argument><expr><name><name>pWLoop</name><operator>-&gt;</operator><name>rRun</name></name> <operator>+</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rUnsorted</name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rUnsorted</name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>rUnsorted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>nRow</name></name> <operator>+</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>maskNew</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name> <operator>|</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>isOrdered</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>isOrdered</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>isOrdered</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>revMask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOrdered</name> <operator>=</operator> <call><name>wherePathSatisfiesOrderBy</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>,
                       <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name></expr></argument>,
                       <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>revMask</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>revLoop</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isOrdered</name><operator>&lt;</operator><name>nOrderBy</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name> <operator>=</operator> <call><name>whereSortingCost</name><argument_list>(
                <argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>nRowEst</name></expr></argument>, <argument><expr><name>nOrderBy</name></expr></argument>, <argument><expr><name>isOrdered</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* TUNING:  Add a small extra penalty (5) to sorting as an
          ** extra encouragment to the query planner to select a plan
          ** where the rows emerge in the correct order without any sorting
          ** required. */</comment>
          <expr_stmt><expr><name>rCost</name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rUnsorted</name></expr></argument>, <argument><expr><name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x002</literal></expr></argument>,
              <argument><expr><operator>(</operator><literal type="string">"---- sort cost=%-3d (%d/%d) increases cost %3d to %-3d\n"</literal><operator>,</operator>
               <name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name><operator>,</operator> <operator>(</operator><name>nOrderBy</name><operator>-</operator><name>isOrdered</name><operator>)</operator><operator>,</operator> <name>nOrderBy</name><operator>,</operator> 
               <name>rUnsorted</name><operator>,</operator> <name>rCost</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rCost</name> <operator>=</operator> <name>rUnsorted</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rUnsorted</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* TUNING:  Slight bias in favor of no-sort plans */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* TUNING:  A full-scan of a VIEW or subquery in the outer loop
        ** is not so bad. */</comment>
        <if_stmt><if>if<condition>( <expr><name>iLoop</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIEWSCAN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rCost</name> <operator>+=</operator> <operator>-</operator><literal type="number">10</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>nOut</name> <operator>+=</operator> <operator>-</operator><literal type="number">30</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check to see if pWLoop should be added to the set of
        ** mxChoice best-so-far paths.
        **
        ** First look for an existing path among best-so-far paths
        ** that covers the same set of loops and has the same isOrdered
        ** setting as the current path candidate.
        **
        ** The term "((pTo-&gt;isOrdered^isOrdered)&amp;0x80)==0" is equivalent
        ** to (pTo-&gt;isOrdered==(-1))==(isOrdered==(-1))" for the range
        ** of legal values for isOrdered, -1..64.
        */</comment>
        <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTo</name><operator>=</operator><name>aTo</name></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nTo</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTo</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>maskLoop</name></name><operator>==</operator><name>maskNew</name>
           <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>^</operator><name>isOrdered</name><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jj</name><operator>==</operator><name>nTo</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&gt;=</operator><name>nTo</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* None of the existing best-so-far paths match the candidate. */</comment>
          <if_stmt><if>if<condition>( <expr><name>nTo</name><operator>&gt;=</operator><name>mxChoice</name>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>rCost</name><operator>&gt;</operator><name>mxCost</name> <operator>||</operator> <operator>(</operator><name>rCost</name><operator>==</operator><name>mxCost</name> <operator>&amp;&amp;</operator> <name>rUnsorted</name><operator>&gt;=</operator><name>mxUnsorted</name><operator>)</operator><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <comment type="block">/* The current candidate is no better than any of the mxChoice
            ** paths currently in the best-so-far buffer.  So discard
            ** this candidate as not viable. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
            <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"Skip   %s cost=%-3d,%3d,%3d order=%c\n"</literal></expr></argument>,
                  <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>rUnsorted</name></expr></argument>,
                  <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* If we reach this points it means that the new candidate path
          ** needs to be added to the set of best-so-far paths. */</comment>
          <if_stmt><if>if<condition>( <expr><name>nTo</name><operator>&lt;</operator><name>mxChoice</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Increase the size of the aTo set by one */</comment>
            <expr_stmt><expr><name>jj</name> <operator>=</operator> <name>nTo</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* New path replaces the prior worst to keep count below mxChoice */</comment>
            <expr_stmt><expr><name>jj</name> <operator>=</operator> <name>mxI</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>pTo</name> <operator>=</operator> <operator>&amp;</operator><name><name>aTo</name><index>[<expr><name>jj</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
          <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"New    %s cost=%-3d,%3d,%3d order=%c\n"</literal></expr></argument>,
                <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>rUnsorted</name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Control reaches here if best-so-far path pTo=aTo[jj] covers the
          ** same set of loops and has the same isOrdered setting as the
          ** candidate path.  Check to see if the candidate should replace
          ** pTo or if the candidate should be skipped.
          ** 
          ** The conditional is an expanded vector comparison equivalent to:
          **   (pTo-&gt;rCost,pTo-&gt;nRow,pTo-&gt;rUnsorted) &lt;= (rCost,nOut,rUnsorted)
          */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>&lt;</operator><name>rCost</name> 
           <operator>||</operator> <operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>rCost</name>
               <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name><operator>&lt;</operator><name>nOut</name>
                   <operator>||</operator> <operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name><operator>==</operator><name>nOut</name> <operator>&amp;&amp;</operator> <name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name><operator>&lt;=</operator><name>rUnsorted</name><operator>)</operator>
                  <operator>)</operator>
              <operator>)</operator></expr>
          )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
            <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
                  <argument><expr><literal type="string">"Skip   %s cost=%-3d,%3d,%3d order=%c"</literal></expr></argument>,
                  <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>rUnsorted</name></expr></argument>,
                  <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"   vs %s cost=%-3d,%3d,%3d order=%c\n"</literal></expr></argument>,
                  <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>iLoop</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>,
                  <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Discard the candidate path from further consideration */</comment>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>rCost</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>rCost</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Control reaches here if the candidate path is better than the
          ** pTo path.  Replace pTo with the candidate. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
          <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
                <argument><expr><literal type="string">"Update %s cost=%-3d,%3d,%3d order=%c"</literal></expr></argument>,
                <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>rUnsorted</name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  was %s cost=%-3d,%3d,%3d order=%c\n"</literal></expr></argument>,
                <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>iLoop</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>,
                <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* pWLoop is a winner.  Add it to the set of best so far */</comment>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>maskLoop</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name> <operator>|</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>revLoop</name></name> <operator>=</operator> <name>revMask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name> <operator>=</operator> <name>rUnsorted</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name> <operator>=</operator> <name>isOrdered</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLoop</name></name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>iLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>iLoop</name></expr>]</index></name> <operator>=</operator> <name>pWLoop</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nTo</name><operator>&gt;=</operator><name>mxChoice</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mxI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>mxCost</name> <operator>=</operator> <name><name>aTo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rCost</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>mxUnsorted</name> <operator>=</operator> <name><name>aTo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nRow</name></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>pTo</name><operator>=</operator><operator>&amp;</operator><name><name>aTo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>mxChoice</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTo</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>&gt;</operator><name>mxCost</name> 
             <operator>||</operator> <operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>mxCost</name> <operator>&amp;&amp;</operator> <name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name><operator>&gt;</operator><name>mxUnsorted</name><operator>)</operator></expr> 
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>mxCost</name> <operator>=</operator> <name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>mxUnsorted</name> <operator>=</operator> <name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>mxI</name> <operator>=</operator> <name>jj</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>  <comment type="block">/* &gt;=2 */</comment>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"---- after round %d ----\n"</literal></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTo</name><operator>=</operator><name>aTo</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTo</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTo</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" %s cost=%-3d nrow=%-3d order=%c"</literal></expr></argument>,
           <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>iLoop</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" rev=0x%llx\n"</literal></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>revLoop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Swap the roles of aFrom and aTo for the next generation */</comment>
    <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <name>aTo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aTo</name> <operator>=</operator> <name>aFrom</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aFrom</name> <operator>=</operator> <name>pFrom</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFrom</name> <operator>=</operator> <name>nTo</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>nFrom</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no query solution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StackFreeNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Find the lowest cost path.  pFrom will be left pointing to that path */</comment>
  <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <name>aFrom</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nFrom</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>rCost</name></name><operator>&gt;</operator><name><name>aFrom</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>rCost</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <operator>&amp;</operator><name><name>aFrom</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>==</operator><name>nLoop</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Load the lowest cost path into pWInfo */</comment>
  <for>for<control>(<init><expr><name>iLoop</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLoop</name><operator>&lt;</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>iLoop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name>iLoop</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name> <operator>=</operator> <name>pWLoop</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>iLoop</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name> <operator>=</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name><operator>==</operator><name>WHERE_DISTINCT_NOOP</name>
   <operator>&amp;&amp;</operator> <name>nRowEst</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>notUsed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>wherePathSatisfiesOrderBy</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name></name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>,
                 <argument><expr><name>WHERE_DISTINCTBY</name></expr></argument>, <argument><expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>notUsed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_ORDERED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>bOrderedInnerLoop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>isOrdered</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_ORDERED</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>revLoop</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u32</name></type> <name>wsFlags</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>wsFlags</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_ONEROW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
           <operator>&amp;&amp;</operator> <operator>(</operator><name>wsFlags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_COLUMN_IN</name><operator>)</operator><operator>)</operator><operator>!=</operator><operator>(</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_COLUMN_IN</name><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>wherePathSatisfiesOrderBy</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>,
                      <argument><expr><name>WHERE_ORDERBY_LIMIT</name></expr></argument>, <argument><expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_IPK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_COLUMN_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>bOrderedInnerLoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLoop</name>
            <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>==</operator><literal type="number">1</literal>
            <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_ORDERBY_MIN</name><operator>|</operator><name>WHERE_ORDERBY_MAX</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
            )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>bOrderedInnerLoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_SORTBYGROUP</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>&amp;&amp;</operator> <name>nLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>revMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nOrder</name> <init>= <expr><call><name>wherePathSatisfiesOrderBy</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, 
          <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revMask</name></expr></argument>
      )</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sorted</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nOrder</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name> <operator>=</operator> <name>revMask</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>


  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</expr_stmt>

  <comment type="block">/* Free temporary memory and return success */</comment>
  <expr_stmt><expr><call><name>sqlite3StackFreeNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Most queries use only a single table (they are not joins) and have
** simple == constraints against indexed fields.  This routine attempts
** to plan those simple cases using much less ceremony than the
** general-purpose query planner, and thereby yield faster sqlite3_prepare()
** times for the common case.
**
** Return non-zero on success, if this query can be handled by this
** no-frills query planner.  Return zero if this query needs the 
** general-purpose query planner.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereShortCut</name><parameter_list>(<parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereScan</name></type> <name>scan</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name> <operator>||</operator> <name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>WO_EQ</name><operator>|</operator><name>WO_IS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pTerm</name> <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>pTerm</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_COLUMN_EQ</name><operator>|</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_ONEROW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* TUNING: Cost of a rowid lookup is 10 */</comment>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <literal type="number">33</literal></expr>;</expr_stmt>  <comment type="block">/* 33==sqlite3LogEst(10) */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>opMask</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTermSpace</name></name><operator>==</operator><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call>
       <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>!=</operator><literal type="number">0</literal> 
       <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>&gt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>opMask</name> <operator>=</operator> <ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>uniqNotNull</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> </then><else>: <expr><name>WO_EQ</name></expr></else></ternary></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>opMask</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>pTerm</name> <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>!=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_COLUMN_EQ</name><operator>|</operator><name>WHERE_ONEROW</name><operator>|</operator><name>WHERE_INDEXED</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>isCovering</name></name> <operator>||</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>colNotIdxed</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_IDX_ONLY</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
      <comment type="block">/* TUNING: Cost of a unique index lookup is 15 */</comment>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>  <comment type="block">/* 39==sqlite3LogEst(15) */</comment>
      <break>break;</break>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pWLoop</name> <operator>=</operator> <name>pLoop</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iCur</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name><operator>.</operator><name>ix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* sqlite3WhereGetMask(&amp;pWInfo-&gt;sMaskSet, iCur); */</comment>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iTabCur</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator>  <name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNIQUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>scan</name><operator>.</operator><name>iEquiv</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_TRANSCONS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>cId</name></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"whereShortCut() used to compute solution\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Helper function for exprIsDeterministic().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprNodeIsDeterministic</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_ConstFunc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the expression contains no non-deterministic SQL 
** functions. Do not consider non-deterministic SQL functions that are 
** part of sub-select statements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprIsDeterministic</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprNodeIsDeterministic</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>sqlite3SelectWalkFail</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name></expr>;</return>
</block_content>}</block></function>

  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/*
** Display all WhereLoops in pWInfo
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>showAllWhereLoops</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>, <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name></expr> )</condition><block>{<block_content>    <comment type="block">/* Display all of the WhereLoop objects */</comment>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zLabel</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789abcdefghijklmnopqrstuvwyxz"</literal>
                                           <literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWYXZ"</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cId</name></name> <operator>=</operator> <name><name>zLabel</name><index>[<expr><name>i</name><operator>%</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zLabel</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WHERETRACE_ALL_LOOPS</name><parameter_list>(<parameter><type><name>W</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>showAllWhereLoops(W,C)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WHERETRACE_ALL_LOOPS</name><parameter_list>(<parameter><type><name>W</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Attempt to omit tables from a join that do not affect the result.
** For a table to not affect the result, the following must be true:
**
**   1) The query must not be an aggregate.
**   2) The table must be the RHS of a LEFT JOIN.
**   3) Either the query must be DISTINCT, or else the ON or USING clause
**      must contain a constraint that limits the scan of the table to 
**      at most a single row.
**   4) The table must not be referenced by any part of the query apart
**      from its own USING or ON clause.
**
** For example, given:
**
**     CREATE TABLE t1(ipk INTEGER PRIMARY KEY, v1);
**     CREATE TABLE t2(ipk INTEGER PRIMARY KEY, v2);
**     CREATE TABLE t3(ipk INTEGER PRIMARY KEY, v3);
**
** then table t2 can be omitted from the following:
**
**     SELECT v1, v3 FROM t1 
**       LEFT JOIN t2 ON (t1.ipk=t2.ipk)
**       LEFT JOIN t3 ON (t1.ipk=t3.ipk)
**
** or from:
**
**     SELECT DISTINCT v1, v3 FROM t1 
**       LEFT JOIN t2
**       LEFT JOIN t3 ON (t1.ipk=t3.ipk)
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>Bitmask</name></type> <name>whereOmitNoopJoin</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>tabUsed</name></decl>;</decl_stmt>

  <comment type="block">/* Preconditions checked by the caller */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_OmitNoopJoin</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* These two preconditions checked by the caller combine to guarantee
  ** condition (1) of the header comment */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_AGG_DISTINCT</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>tabUsed</name> <operator>=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>tabUsed</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pWLoop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><name>JT_LEFT</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEROW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>tabUsed</name> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name><operator>.</operator><name>nTerm</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name><operator>.</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call>
         <operator>||</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name><operator>!=</operator><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>
        )</condition><block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"-&gt; drop loop %c not used\n"</literal><operator>,</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>cId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>notReady</name> <operator>&amp;=</operator> <operator>~</operator><name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name><operator>.</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>i</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WhereLevel</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>notReady</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if there are any SEARCH loops that might benefit from
** using a Bloom filter.  Consider a Bloom filter if:
**
**   (1)  The SEARCH happens more than N times where N is the number
**        of rows in the table that is being considered for the Bloom
**        filter.
**   (2)  Some searches are expected to find zero rows.  (This is determined
**        by the WHERE_SELFCULL flag on the term.)
**   (3)  Bloom-filter processing is not disabled.  (Checked by the
**        caller.)
**   (4)  The size of the table being searched is known by ANALYZE.
**
** This block of code merely checks to see if a Bloom filter would be
** appropriate, and if so sets the WHERE_BLOOMFILTER flag on the
** WhereLoop.  The implementation of the Bloom filter comes further
** down where the code for each WhereLoop is generated.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>whereCheckIfBloomFilterIsUseful</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>nSearch</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_BloomFilter</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSearch</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pWLoop</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>reqFlags</name> <init>= <expr><operator>(</operator><name>WHERE_SELFCULL</name><operator>|</operator><name>WHERE_COLUMN_EQ</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>reqFlags</name><operator>)</operator><operator>==</operator><name>reqFlags</name>
     <comment type="block">/* vvvvvv--- Always the case if WHERE_COLUMN_EQ is defined */</comment>
     <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_INDEXED</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_StatsUsed</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSearch</name> <operator>&gt;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStat1</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_BLOOMFILTER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_IDX_ONLY</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><operator>(</operator>
           <literal type="string">"-&gt; use Bloom-filter on loop %c because there are ~%.1e "</literal>
           <literal type="string">"lookups into %s which has only ~%.1e rows\n"</literal><operator>,</operator>
           <name><name>pLoop</name><operator>-&gt;</operator><name>cId</name></name><operator>,</operator> <operator>(</operator><name>double</name><operator>)</operator><call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name>nSearch</name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator>
           <operator>(</operator><name>double</name><operator>)</operator><call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nSearch</name> <operator>+=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** This is an sqlite3ParserAddCleanup() callback that is invoked to
** free the Parse-&gt;pIdxEpr list when the Parse object is destroyed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereIndexedExprCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pObject</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><operator>(</operator><name>Parse</name><operator>*</operator><operator>)</operator><name>pObject</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IndexedExpr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pIENext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** The index pIdx is used by a query and contains one or more expressions.
** In other words pIdx is an index on an expression.  iIdxCur is the cursor
** number for the index and iDataCur is the cursor number for the corresponding
** table.
**
** This routine adds IndexedExpr entries to the Parse-&gt;pIdxEpr field for
** each of the expressions in the index so that the expression code generator
** will know to replace occurrences of the indexed expression with
** references to the corresponding column of the index.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>whereAddIndexedExpr</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Add IndexedExpr entries to pParse-&gt;pIdxEpr */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,       <comment type="block">/* The index-on-expression that contains the expressions */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>,       <comment type="block">/* Cursor number for pIdx */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name></decl></parameter>  <comment type="block">/* The FROM clause entry for the table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IndexedExpr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>bHasExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bMaybeNullRow</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bMaybeNullRow</name> <operator>=</operator> <operator>(</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bMaybeNullRow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexedExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pIENext</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iDataCur</name></name> <operator>=</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCol</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bMaybeNullRow</name></name> <operator>=</operator> <name>bMaybeNullRow</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zIdxName</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pIENext</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>whereIndexedExprCleanup</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Generate the beginning of the loop used for WHERE clause processing.
** The return value is a pointer to an opaque structure that contains
** information needed to terminate the loop.  Later, the calling routine
** should invoke sqlite3WhereEnd() with the return value of this function
** in order to complete the WHERE clause processing.
**
** If an error occurs, this routine returns NULL.
**
** The basic idea is to do a nested loop, one loop for each table in
** the FROM clause of a select.  (INSERT and UPDATE statements are the
** same as a SELECT with only a single table in the FROM clause.)  For
** example, if the SQL is this:
**
**       SELECT * FROM t1, t2, t3 WHERE ...;
**
** Then the code generated is conceptually like the following:
**
**      foreach row1 in t1 do       \    Code generated
**        foreach row2 in t2 do      |-- by sqlite3WhereBegin()
**          foreach row3 in t3 do   /
**            ...
**          end                     \    Code generated
**        end                        |-- by sqlite3WhereEnd()
**      end                         /
**
** Note that the loops might not be nested in the order in which they
** appear in the FROM clause if a different order is better able to make
** use of indices.  Note also that when the IN operator appears in
** the WHERE clause, it might result in additional nested loops for
** scanning through all values on the right-hand side of the IN.
**
** There are Btree cursors associated with each table.  t1 uses cursor
** number pTabList-&gt;a[0].iCursor.  t2 uses the cursor pTabList-&gt;a[1].iCursor.
** And so forth.  This routine generates code to open those VDBE cursors
** and sqlite3WhereEnd() generates the code to close them.
**
** The code that sqlite3WhereBegin() generates leaves the cursors named
** in pTabList pointing at their appropriate entries.  The [...] code
** can use OP_Column and OP_Rowid opcodes on these cursors to extract
** data from the various tables of the loop.
**
** If the WHERE clause is empty, the foreach loops must each scan their
** entire tables.  Thus a three-way join is an O(N^3) operation.  But if
** the tables have indices and there are terms in the WHERE clause that
** refer to those indices, a complete table scan can be avoided and the
** code will run much faster.  Most of the work of this routine is checking
** to see if there are indices that can be used to speed up the loop.
**
** Terms of the WHERE clause are also used to limit which rows actually
** make it to the "..." in the middle of the loop.  After each "foreach",
** terms of the WHERE clause that use only terms in that loop and outer
** loops are evaluated and if false a jump is made around all subsequent
** inner loops (or around the "..." if the test occurs within the inner-
** most loop)
**
** OUTER JOINS
**
** An outer join of tables t1 and t2 is conceptally coded as follows:
**
**    foreach row1 in t1 do
**      flag = 0
**      foreach row2 in t2 do
**        start:
**          ...
**          flag = 1
**      end
**      if flag==0 then
**        move the row2 cursor to a null row
**        goto start
**      fi
**    end
**
** ORDER BY CLAUSE PROCESSING
**
** pOrderBy is a pointer to the ORDER BY clause (or the GROUP BY clause
** if the WHERE_GROUPBY flag is set in wctrlFlags) of a SELECT statement
** if there is one.  If there is no ORDER BY clause or if this routine
** is called from an UPDATE or DELETE statement, then pOrderBy is NULL.
**
** The iIdxCur parameter is the cursor number of an index.  If 
** WHERE_OR_SUBCLAUSE is set, iIdxCur is the cursor number of an index
** to use for OR clause processing.  The WHERE clause should use this
** specific cursor.  If WHERE_ONEPASS_DESIRED is set, then iIdxCur is
** the first cursor in an array of cursors for all indices.  iIdxCur should
** be used to compute the appropriate cursor depending on which index is
** used.
*/</comment>
<function><type><name>WhereInfo</name> <modifier>*</modifier></type><name>sqlite3WhereBegin</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,      <comment type="block">/* FROM clause: A list of all tables to be scanned */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,           <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,     <comment type="block">/* An ORDER BY (or GROUP BY) clause, or NULL */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pResultSet</name></decl></parameter>,   <comment type="block">/* Query result set.  Req'd for DISTINCT */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,        <comment type="block">/* The entire SELECT statement */</comment>
  <parameter><decl><type><name>u16</name></type> <name>wctrlFlags</name></decl></parameter>,         <comment type="block">/* The WHERE_* flags defined in sqliteInt.h */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAuxArg</name></decl></parameter>             <comment type="block">/* If WHERE_OR_SUBCLAUSE is set, index cursor number
                          ** If WHERE_USE_LIMIT, then the limit amount */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByteWInfo</name></decl>;</decl_stmt>            <comment type="block">/* Num. bytes allocated for WhereInfo struct */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTabList</name></decl>;</decl_stmt>              <comment type="block">/* Number of elements in pTabList */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>         <comment type="block">/* Will become the return value of this function */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The virtual database engine */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>notReady</name></decl>;</decl_stmt>          <comment type="block">/* Cursors that are not yet positioned */</comment>
  <decl_stmt><decl><type><name>WhereLoopBuilder</name></type> <name>sWLB</name></decl>;</decl_stmt>     <comment type="block">/* The WhereLoop builder */</comment>
  <decl_stmt><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl>;</decl_stmt>    <comment type="block">/* The expression mask set */</comment>
  <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>        <comment type="block">/* A single level in pWInfo-&gt;a[] */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>          <comment type="block">/* Pointer to a single WhereLoop object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bFordelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* OPFLAG_FORDELETE or zero, as appropriate */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_MULTIROW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator>
        <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only one of WHERE_OR_SUBCLAUSE or WHERE_USE_LIMIT */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
            <operator>||</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_USE_LIMIT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Variable initialization */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWLB</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sWLB</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* An ORDER/GROUP BY clause of more than 63 terms cannot be optimized */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pOrderBy</name> <operator>&amp;&amp;</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name> <operator>&amp;&amp;</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;=</operator><name>BMS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* The number of tables in the FROM clause is limited by the number of
  ** bits in a Bitmask 
  */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><name>BMS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"at most %d tables in a join"</literal></expr></argument>, <argument><expr><name>BMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This function normally generates a nested loop for all tables in 
  ** pTabList.  But if the WHERE_OR_SUBCLAUSE flag is set, then we should
  ** only generate code for the first table in pTabList and assume that
  ** any cursors associated with subsequent tables are uninitialized.
  */</comment>
  <expr_stmt><expr><name>nTabList</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Allocate and initialize the WhereInfo structure that will become the
  ** return value. A single allocation is used to store the WhereInfo
  ** struct, the contents of WhereInfo.a[], the WhereClause structure
  ** and the WhereMaskSet structure. Since WhereClause contains an 8-byte
  ** field (type Bitmask) it must be aligned on an 8-byte boundary on
  ** some architectures. Hence the ROUND8() below.
  */</comment>
  <expr_stmt><expr><name>nByteWInfo</name> <operator>=</operator> <call><name>ROUND8P</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereInfo</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><name>nTabList</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByteWInfo</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <goto>goto <name>whereBeginError</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <name>pWhere</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <name>pResultSet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name> <operator>=</operator> <name>nTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>=</operator> <name>wctrlFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name>iAuxArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>savedNQueryLoop</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <name>pSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
         <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>WhereInfo</name></expr></argument>,<argument><expr><name>sWC</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>WhereInfo</name></expr></argument>,<argument><expr><name>nOBSat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nTabList</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ONEPASS defaults to OFF */</comment>
  <expr_stmt><expr><name>pMaskSet</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">99</literal></expr>;</expr_stmt> <comment type="block">/* Initialize ix[0] to a value that can never be
                         ** a valid cursor number, to avoid an initial
                         ** test for pMaskSet-&gt;n==0 in sqlite3WhereGetMask() */</comment>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pWInfo</name></name> <operator>=</operator> <name>pWInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name></name> <operator>=</operator> <operator>(</operator><name>WhereLoop</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pWInfo</name><operator>)</operator><operator>+</operator><name>nByteWInfo</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereLoopInit</name><argument_list>(<argument><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name><operator>-&gt;</operator><name>cId</name></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Split the WHERE clause into separate subexpressions where each
  ** subexpression is separated by an AND operator.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3WhereClauseInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereSplit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Special case: No FROM clause
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nTabList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DistinctOpt</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNIQUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ExplainQueryPlan</name><argument_list>(<argument><expr><operator>(</operator><name>pParse</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator> <literal type="string">"SCAN CONSTANT ROW"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Assign a bit from the bitmask to every term in the FROM clause.
    **
    ** The N-th term of the FROM clause is assigned a bitmask of 1&lt;&lt;N.
    **
    ** The rule of the previous sentence ensures thta if X is the bitmask for
    ** a table T, then X-1 is the bitmask for all other tables to the left of T.
    ** Knowing the bitmask for all tables to the left of a left join is
    ** important.  Ticket #3015.
    **
    ** Note that bitmasks are created for all pTabList-&gt;nSrc tables in
    ** pTabList, not just the first nTabList tables.  nTabList is normally
    ** equal to pTabList-&gt;nSrc but might be shortened to 1 if the
    ** WHERE_OR_SUBCLAUSE flag is set.
    */</comment>
    <expr_stmt><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><call><name>createMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereTabFuncArgs</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>++</operator><name>ii</name><operator>)</operator><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr> )</condition>;</do>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>mx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>m</name><operator>&gt;=</operator><name>mx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mx</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Analyze all of the subexpressions. */</comment>
  <expr_stmt><expr><call><name>sqlite3WhereExprAnalyze</name><argument_list>(<argument><expr><name>pTabList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSelect</name> <operator>&amp;&amp;</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WhereAddLimit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Special case: WHERE terms that do not refer to any tables in the join
  ** (constant expressions). Evaluate each such term, and jump over all the
  ** generated code if the result is not true.  
  **
  ** Do not do this if the expression contains non-deterministic functions
  ** that are not within a sub-select. This is not strictly required, but
  ** preserves SQLite's legacy behaviour in the following two cases:
  **
  **   FROM ... WHERE random()&gt;0;           -- eval random() once per row
  **   FROM ... WHERE (SELECT random())&gt;0;  -- eval random() once overall
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><operator>&amp;</operator><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pT</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pT</name><operator>-&gt;</operator><name>prereqAll</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>nTabList</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>exprIsDeterministic</name><argument_list>(<argument><expr><name><name>pT</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pT</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pT</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DistinctOpt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Disable the DISTINCT optimization if SQLITE_DistinctOpt is set via
      ** sqlite3_test_ctrl(SQLITE_TESTCTRL_OPTIMIZATIONS,...) */</comment>
      <expr_stmt><expr><name>wctrlFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_WANT_DISTINCT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_WANT_DISTINCT</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>isDistinctRedundant</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>pResultSet</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* The DISTINCT marking is pointless.  Ignore it. */</comment>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNIQUE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pOrderBy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Try to ORDER BY the result set to make distinct processing easier */</comment>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>|=</operator> <name>WHERE_DISTINCTBY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pResultSet</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Construct the WhereLoop objects */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WHERETRACE_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"*** Optimizer Start *** (wctrlFlags: 0x%x"</literal></expr></argument>,<argument><expr><name>wctrlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_USE_LIMIT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">", limit: %d"</literal></expr></argument>, <argument><expr><name>iAuxArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8000</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name></type> <name>sSelect</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sSelect</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSelect</name><operator>.</operator><name>selFlags</name></name> <operator>=</operator> <name>SF_WhereBegin</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSelect</name><operator>.</operator><name>pSrc</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSelect</name><operator>.</operator><name>pWhere</name></name> <operator>=</operator> <name>pWhere</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSelect</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSelect</name><operator>.</operator><name>pEList</name></name> <operator>=</operator> <name>pResultSet</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TreeViewSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4000</literal></expr> )</condition><block>{<block_content> <comment type="block">/* Display all WHERE clause terms */</comment>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"---- WHERE clause at start of analysis:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereClausePrint</name><argument_list>(<argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>nTabList</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <call><name>whereShortCut</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWLB</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWLB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
    <comment type="block">/* If one or more WhereTerm.truthProb values were used in estimating
    ** loop parameters, but then those truthProb values were subsequently
    ** changed based on STAT4 information while computing subsequent loops,
    ** then we need to rerun the whole loop building process so that all
    ** loops will be built using the revised truthProb values. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>sWLB</name><operator>.</operator><name>bldFlags2</name></name> <operator>&amp;</operator> <name>SQLITE_BLDF2_2NDPASS</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>WHERETRACE_ALL_LOOPS</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, 
           <argument><expr><operator>(</operator><literal type="string">"**** Redo all loop computations due to"</literal>
            <literal type="string">" TERM_HIGHTRUTH changes ****\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereLoopDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWLB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>WHERETRACE_ALL_LOOPS</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <expr_stmt><expr><call><name>wherePathSolver</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>wherePathSolver</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ReverseOrder</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name> <operator>=</operator> <name>ALLBITS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>whereBeginError</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"---- Solution nRow=%d"</literal></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" ORDERBY=%d,0x%llx"</literal></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>WHERE_DISTINCT_UNIQUE</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  DISTINCT=unique"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>WHERE_DISTINCT_ORDERED</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  DISTINCT=ordered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>WHERE_DISTINCT_UNORDERED</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  DISTINCT=unordered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereLoopPrint</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pWLoop</name></expr></argument>, <argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Attempt to omit tables from a join that do not affect the result.
  ** See the comment on whereOmitNoopJoin() for further information.
  **
  ** This query optimization is factored out into a separate "no-inline"
  ** procedure to keep the sqlite3WhereBegin() procedure from becoming
  ** too large.  If sqlite3WhereBegin() becomes too large, that prevents
  ** some C-compiler optimizers from in-lining the 
  ** sqlite3WhereCodeOneLoopStart() procedure, and it is important to
  ** in-line sqlite3WhereCodeOneLoopStart() for performance reasons.
  */</comment>
  <expr_stmt><expr><name>notReady</name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;=</operator><literal type="number">2</literal>
   <operator>&amp;&amp;</operator> <name>pResultSet</name><operator>!=</operator><literal type="number">0</literal>                         <comment type="block">/* these two combine to guarantee */</comment>
   <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_AGG_DISTINCT</name><operator>)</operator>  <comment type="block">/* condition (1) above */</comment>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OmitNoopJoin</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>notReady</name> <operator>=</operator> <call><name>whereOmitNoopJoin</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTabList</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTabList</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check to see if there are any SEARCH loops that might benefit from
  ** using a Bloom filter.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;=</operator><literal type="number">2</literal>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BloomFilter</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>whereCheckIfBloomFilterIsUseful</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WHERETRACE_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x4000</literal></expr> )</condition><block>{<block_content> <comment type="block">/* Display all terms of the WHERE clause */</comment>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"---- WHERE clause at end of analysis:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereClausePrint</name><argument_list>(<argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffffffff</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"*** Optimizer Finished ***\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>+=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name></expr>;</expr_stmt>

  <comment type="block">/* If the caller is an UPDATE or DELETE statement that is requesting
  ** to use a one-pass algorithm, determine if this is appropriate.
  **
  ** A one-pass approach can be used if the caller has requested one
  ** and either (a) the scan visits at most one row or (b) each
  ** of the following are true:
  **
  **   * the caller has indicated that a one-pass approach can be used
  **     with multiple rows (by setting WHERE_ONEPASS_MULTIROW), and
  **   * the table is not a virtual table, and
  **   * either the scan does not use the OR optimization or the caller
  **     is a DELETE operation (WHERE_DUPLICATES_OK is only specified
  **     for DELETE).
  **
  ** The last qualification is because an UPDATE statement uses
  ** WhereInfo.aiCurOnePass[1] to determine whether or not it really can
  ** use a one-pass approach, and this is not set accurately for scans
  ** that use the OR optimization.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>wsFlags</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bOnerow</name> <init>= <expr><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_ONEROW</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator> <operator>||</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bOnerow</name> <operator>||</operator> <operator>(</operator>
        <literal type="number">0</literal><operator>!=</operator><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_MULTIROW</name><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_DUPLICATES_OK</name><operator>)</operator><operator>)</operator>
    <operator>)</operator></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name> <operator>=</operator> <ternary><condition><expr><name>bOnerow</name></expr> ?</condition><then> <expr><name>ONEPASS_SINGLE</name></expr> </then><else>: <expr><name>ONEPASS_MULTI</name></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_MULTIROW</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bFordelete</name> <operator>=</operator> <name>OPFLAG_FORDELETE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <operator>~</operator><name>WHERE_IDX_ONLY</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open all tables in the pTabList and any indices selected for
  ** searching those tables.
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pLevel</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTabList</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>pLevel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>     <comment type="block">/* Table to open */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>         <comment type="block">/* Index of database containing table/index */</comment>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pTabItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Do nothing */</comment>
    </block_content>}</block></if><if type="elseif">else
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VOpen</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* noop */</comment>
    </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if<condition>( <expr><operator>(</operator><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LTORJ</name><operator>|</operator><name>JT_RIGHT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name>OP_OpenRead</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_OpenWrite</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>==</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> 
       <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;</operator><name>BMS</name>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TF_HasGenerated</name><operator>|</operator><name>TF_WithoutRowid</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_AUTO_INDEX</name><operator>|</operator><name>WHERE_BLOOMFILTER</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* If we know that only a prefix of the record will be used,
        ** it is advantageous to reduce the "column count" field in
        ** the P4 operand of the OP_OpenRead/Write opcode. */</comment>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>b</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>colUsed</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name><operator>=</operator><name>b</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_SEEKEQ</name><operator>|</operator><name>bFordelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bFordelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_USED_MASK</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ColumnsUsed</name></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>colUsed</name></name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIx</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iIndexCur</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name>OP_OpenRead</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* iAuxArg is always set to a positive value if ONEPASS is possible */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iAuxArg</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIx</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* This is one term of an OR-optimization using the PRIMARY KEY of a
        ** WITHOUT ROWID table.  No need for a separate index */</comment>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pJ</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name>iAuxArg</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pJ</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pJ</name><operator>!=</operator><name>pIx</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iIndexCur</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pJ</name> <operator>=</operator> <name><name>pJ</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_OpenWrite</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iIndexCur</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iAuxArg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name>iAuxArg</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_ReopenIdx</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIx</name><operator>-&gt;</operator><name>bHasExpr</name></name> <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_IndexedExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>whereAddIndexedExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIx</name></expr></argument>, <argument><expr><name>iIndexCur</name></expr></argument>, <argument><expr><name>pTabItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name>iIndexCur</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIx</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIndexCur</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIndexCur</name></expr></argument>, <argument><expr><name><name>pIx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_CONSTRAINT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_COLUMN_RANGE</name><operator>|</operator><name>WHERE_SKIPSCAN</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BIGNULL_SORT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_SEEKSCAN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name><operator>&amp;</operator><name>WHERE_ORDERBY_MIN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name><operator>!=</operator><name>WHERE_DISTINCT_ORDERED</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_SEEKEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pIx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_USED_MASK</name></cpp:ifdef>
        <block>{<block_content>
          <decl_stmt><decl><type><name>u64</name></type> <name>colUsed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name>jj</name> <operator>=</operator> <name><name>pIx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&gt;</operator><literal type="number">63</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>jj</name> <operator>=</operator> <literal type="number">63</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>jj</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>colUsed</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><ternary><condition><expr><name>ii</name><operator>&lt;</operator><literal type="number">63</literal></expr> ?</condition><then> <expr><name>ii</name></expr> </then><else>: <expr><literal type="number">63</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ColumnsUsed</name></expr></argument>, <argument><expr><name>iIndexCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>colUsed</name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_COLUMN_USED_MASK */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name> <operator>=</operator> <call><name>sqlite3WhereMalloc</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereRightJoin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereRightJoin</name> <modifier>*</modifier></type><name>pRJ</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRJ</name><operator>-&gt;</operator><name>iMatch</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regBloom</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr><literal type="number">65536</literal></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regBloom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regReturn</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>==</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>iMatch</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pInfo</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>iMatch</name></name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_IDX_ONLY</name></expr>;</expr_stmt>
      <comment type="block">/* The nature of RIGHT JOIN processing is such that it messes up
      ** the output order.  So omit any ORDER BY/GROUP BY elimination
      ** optimizations.  We need to do an actual sort for RIGHT JOIN. */</comment>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNORDERED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iTop</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Generate the code to do the search.  Each iteration of the for
  ** loop below generates code for a single nested loop of the VM
  ** program.
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTabList</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addrExplain</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wsFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pLevel</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>wsFlags</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isMaterialized</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iOnce</name> <init>= <expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_AUTO_INDEX</name><operator>|</operator><name>WHERE_BLOOMFILTER</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
        <expr_stmt><expr><call><name>constructAutomaticIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>,
                  <argument><expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ConstructBloomFilter</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>addrExplain</name> <operator>=</operator> <call><name>sqlite3WhereExplainOneScan</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>wctrlFlags</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBody</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>notReady</name> <operator>=</operator> <call><name>sqlite3WhereCodeOneLoopStart</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><name>pWInfo</name></expr></argument>,<argument><expr><name>ii</name></expr></argument>,<argument><expr><name>pLevel</name></expr></argument>,<argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wsFlags</name><operator>&amp;</operator><name>WHERE_MULTI_OR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name><operator>&amp;</operator><name>WHERE_OR_SUBCLAUSE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereAddScanStatus</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>addrExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Done. */</comment>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Begin WHERE-core"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iEndWhere</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pWInfo</name></expr>;</return>

  <comment type="block">/* Jump here if malloc fails */</comment>
<label><name>whereBeginError</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pWInfo</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>savedNQueryLoop</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereInfoFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Part of sqlite3WhereEnd() will rewrite opcodes to reference the
** index rather than the main table.  In SQLITE_DEBUG mode, we want
** to trace those changes if PRAGMA vdbe_addoptrace=on.  This routine
** does that.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>OpcodeRewriteTrace</name><parameter_list>(<parameter><type><name>D</name></type></parameter>,<parameter><type><name>K</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* no-op */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>OpcodeRewriteTrace</name><parameter_list>(<parameter><type><name>D</name></type></parameter>,<parameter><type><name>K</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3WhereOpcodeRewriteTrace(D,K,P)</cpp:value></cpp:define>
  <function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3WhereOpcodeRewriteTrace</name><parameter_list>(
    <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>,
    <parameter><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>
  )</parameter_list><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Return true if cursor iCur is opened by instruction k of the
** bytecode.  Used inside of assert() only.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cursorIsOpen</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>k</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>k</name><operator>--</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name>iCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Close</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenRead</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenWrite</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenDup</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenAutoindex</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenEphemeral</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block">/*
** Generate the end of the WHERE loop.  See comments on 
** sqlite3WhereBegin() for additional information.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereEnd</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRJ</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Generate loop termination code.
  */</comment>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"End WHERE-core"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pLevel</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Terminate the subroutine that forms the interior of the loop of
      ** the RIGHT JOIN table */</comment>
      <decl_stmt><decl><type><name>WhereRightJoin</name> <modifier>*</modifier></type><name>pRJ</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRJ</name><operator>-&gt;</operator><name>endSubrtn</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><name><name>pRJ</name><operator>-&gt;</operator><name>addrSubrtn</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRJ</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>OP_Noop</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_SKIPAHEAD_DISTINCT</name></cpp:ifndef>
      <decl_stmt><decl><type><name>int</name></type> <name>addrSeek</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name><operator>==</operator><name>WHERE_DISTINCT_ORDERED</name>
       <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal>  <comment type="block">/* Ticket [ef9318757b152e3] 2017-10-21 */</comment>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>)</operator><operator>-&gt;</operator><name>hasStat1</name>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nDistinctCol</name></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>n</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">36</literal></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>op</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>r1</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Prev</name></expr> ?</condition><then> <expr><name>OP_SeekLT</name></expr> </then><else>: <expr><name>OP_SeekGT</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>addrSeek</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DISABLE_SKIPAHEAD_DISTINCT */</comment>
      <comment type="block">/* The common case: Advance to the next row */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_VNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>regBignull</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBignull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DecrJumpZero</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>regBignull</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_SKIPAHEAD_DISTINCT</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name>addrSeek</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrSeek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_ABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>InLoop</name></name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name></expr><operator>,</operator> <expr><name>pIn</name><operator>=</operator><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>pIn</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_IsNull</name>
                 <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name><operator>!=</operator><name>OP_Noop</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>nPrefix</name></name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>bEarlyOut</name> <init>= 
                <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
                 <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_EARLYOUT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr> )</condition><block>{<block_content>
              <comment type="block">/* For LEFT JOIN queries, cursor pIn-&gt;iCur may not have been
              ** opened yet. This occurs for WHERE clauses such as
              ** "a = ? AND b IN (...)", where the index is on (a, b). If
              ** the RHS of the (a=?) is NULL, then the "b IN (...)" may
              ** never have been coded, but the body of the loop run to
              ** return the null-row. So, if the cursor is not open yet,
              ** jump over the OP_Next or OP_Prev instruction about to
              ** be coded.  */</comment>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNotOpen</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iCur</name></name></expr></argument>, 
                  <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>bEarlyOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>bEarlyOut</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNoHope</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>,
                  <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>,
                  <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iBase</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>nPrefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="block">/* Retarget the OP_IsNull against the left operand of IN so 
              ** it jumps past the OP_IfNoHope.  This is because the
              ** OP_IsNull also bypasses the OP_Affinity opcode that is
              ** required by OP_IfNoHope. */</comment>
              <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iCur</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name><operator>==</operator><name>OP_Prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name><operator>==</operator><name>OP_Next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name><operator>-&gt;</operator><name>regReturn</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"next skip-scan on %s"</literal><operator>,</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrLikeRep</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DecrJumpZero</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,
                        <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrLikeRep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ws</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>ws</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>ws</name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>ws</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name><operator>==</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>ws</name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator> 
       <operator>||</operator> <operator>(</operator><operator>(</operator><name>ws</name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCoveringIdx</name></name><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>ws</name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIx</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCoveringIdx</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pIx</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ReopenIdx</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name><name>pIx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Return</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"End WHERE-loop%d: %s"</literal><operator>,</operator> <name>i</name><operator>,</operator>
                     <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&lt;=</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pLevel</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pLevel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pLastOp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pTabItem</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>

    <comment type="block">/* Do RIGHT JOIN processing.  Generate code that will output the
    ** unmatched rows of the right operand of the RIGHT JOIN with
    ** all of the columns of the left operand set to NULL.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pRJ</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereRightJoinLoop</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* For a co-routine, change all OP_Column references to the table of
    ** the co-routine into OP_Copy of result contained in a register.
    ** OP_Rowid becomes OP_Null.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>translateColumnToCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBody</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>,
                            <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this scan uses an index, make VDBE code substitutions to read data
    ** from the index instead of from the table where possible.  In some cases
    ** this optimization prevents the table from ever being read, which can
    ** yield a significant performance boost.
    ** 
    ** Calls to the code generator in between sqlite3WhereBegin and
    ** sqlite3WhereEnd will have created code that references the table
    ** directly.  This loop scans all that code looking for opcodes
    ** that reference the table and converts them into opcodes that
    ** reference the index.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_INDEXED</name><operator>|</operator><name>WHERE_IDX_ONLY</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCoveringIdx</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIdx</name>
     <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr>
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>last</name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>iEndWhere</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>bHasExpr</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IndexedExpr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pIdxEpr</name></name></expr></init></decl>;</decl_stmt>
        <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCur</name></name><operator>==</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iDataCur</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pIENext</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrBody</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"TRANSLATE opcodes in range %d..%d\n"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>last</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Proof that the "+1" on the k value above is safe */</comment>
      <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_Column</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_Rowid</name>  <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_IfNullRow</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLastOp</name> <operator>=</operator> <name>pOp</name> <operator>+</operator> <operator>(</operator><name>last</name> <operator>-</operator> <name>k</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>&lt;=</operator><name>pLastOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* no-op */</comment>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Column</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:ifdef>
         <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Offset</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name><operator>==</operator><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:ifdef>
          <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Offset</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Do not need to translate the column number */</comment>
          </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>!=</operator><call><name>sqlite3StorageColumnToTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3StorageColumnToTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>OpcodeRewriteTrace</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* Unable to translate the table reference into an index
            ** reference.  Verify that this is harmless - that the
            ** table being referenced really is open.
            */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_OFFSET_SQL_FUNC</name></cpp:ifdef>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
                 <operator>||</operator> <call><name>cursorIsOpen</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call>
                 <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Offset</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
                 <operator>||</operator> <call><name>cursorIsOpen</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Rowid</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_IdxRowid</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>OpcodeRewriteTrace</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IfNullRow</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>OpcodeRewriteTrace</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>++</operator><name>pOp</name><operator>)</operator><operator>&lt;</operator><name>pLastOp</name></expr> )</condition>;</do>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"TRANSLATE complete\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* The "break" point is here, just past the end of the outer loop.
  ** Set it.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Final cleanup
  */</comment>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>savedNQueryLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereInfoFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>withinRJSubrtn</name></name> <operator>-=</operator> <name>nRJ</name></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
</unit>
