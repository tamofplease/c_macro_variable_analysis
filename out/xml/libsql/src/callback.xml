<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/callback.c"><comment type="block">/*
** 2005 May 23 
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains functions used to access the internal hash tables
** of user defined functions and collation sequences.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Invoke the 'collation needed' callback to request a collation sequence
** in the encoding enc of name zName, length nName.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callCollNeeded</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded</name></name> <operator>||</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded16</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExternal</name> <init>= <expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zExternal</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pCollNeededArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>zExternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zExternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded16</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zExternal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zExternal</name> <operator>=</operator> <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zExternal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded16</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pCollNeededArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zExternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called if the collation factory fails to deliver a
** collation function in the best encoding but there may be other versions
** of this collation function (for other text encodings) available. Use one
** of these instead if they exist. Avoid a UTF-8 &lt;-&gt; UTF-16 conversion if
** possible.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>synthCollSeq</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aEnc</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>SQLITE_UTF16BE</name></expr>, <expr><name>SQLITE_UTF16LE</name></expr>, <expr><name>SQLITE_UTF8</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pColl2</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aEnc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pColl2</name><operator>-&gt;</operator><name>xCmp</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pColl</name></expr></argument>, <argument><expr><name>pColl2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollSeq</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* Do not copy the destructor */</comment>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called on a collation sequence before it is used to
** check that it is defined. An undefined collation sequence exists when
** a database is loaded that contains references to collation sequences
** that have not been defined by sqlite3_create_collation() etc.
**
** If required, this routine calls the 'collation needed' callback to
** request a definition of the collating sequence. If this doesn't work, 
** an equivalent collating sequence that uses a text encoding different
** from the main database is substituted, if one is available.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CheckCollSeq</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pColl</name> <operator>&amp;&amp;</operator> <name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3GetCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pColl</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><name>pColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** Locate and return an entry from the db.aCollSeq hash table. If the entry
** specified by zName and nName is not found and parameter 'create' is
** true, then create a new entry. Otherwise return NULL.
**
** Each pointer stored in the sqlite3.aCollSeq hash table contains an
** array of three CollSeq structures. The first is the collation sequence
** preferred for UTF-8, the second UTF-16le, and the third UTF-16be.
**
** Stored immediately after the three collation sequences is a copy of
** the collation sequence name. A pointer to this string is stored in
** each collation sequence structure.
*/</comment>
<function><type><specifier>static</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>findCollSeqEntry</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,          <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,    <comment type="block">/* Name of the collating sequence */</comment>
  <parameter><decl><type><name>int</name></type> <name>create</name></decl></parameter>            <comment type="block">/* Create a new entry if true */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>pColl</name> <operator>&amp;&amp;</operator> <name>create</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pColl</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColl</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pColl</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pColl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pColl</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pColl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16LE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pColl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pColl</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pColl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16BE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDel</name> <operator>=</operator> <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>, <argument><expr><name><name>pColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If a malloc() failure occurred in sqlite3HashInsert(), it will 
      ** return the pColl pointer to be deleted (because it wasn't added
      ** to the hash table).
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDel</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pDel</name><operator>==</operator><name>pColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pDel</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pColl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parameter zName points to a UTF-8 encoded string nName bytes long.
** Return the CollSeq* pointer for the collation sequence named zName
** for the encoding 'enc' from the database 'db'.
**
** If the entry specified is not found and 'create' is true, then create a
** new entry.  Otherwise return NULL.
**
** A separate function sqlite3LocateCollSeq() is a wrapper around
** this routine.  sqlite3LocateCollSeq() invokes the collation factory
** if necessary and generates an error message if the collating sequence
** cannot be found.
**
** See also: sqlite3LocateCollSeq(), sqlite3GetCollSeq()
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3FindCollSeq</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,          <comment type="block">/* Database connection to search */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,               <comment type="block">/* Desired text encoding */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,    <comment type="block">/* Name of the collating sequence.  Might be NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>create</name></decl></parameter>            <comment type="block">/* True to create CollSeq if doesn't already exist */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_UTF8</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>SQLITE_UTF16LE</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>SQLITE_UTF16BE</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>&gt;=</operator><name>SQLITE_UTF8</name> <operator>&amp;&amp;</operator> <name>enc</name><operator>&lt;=</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>findCollSeqEntry</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>+=</operator> <name>enc</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pColl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the text encoding for a database connection. This means that
** the pDfltColl must change as well.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SetTextEncoding</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16LE</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-08308-17224 The default collating function for all
  ** strings is BINARY. 
  */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is responsible for invoking the collation factory callback
** or substituting a collation sequence of a different encoding when the
** requested collation sequence is not available in the desired encoding.
** 
** If it is not NULL, then pColl must point to the database native encoding 
** collation sequence with name zName, length nName.
**
** The return value is either the collation sequence to be used in database
** db for collation type name zName, length nName, or NULL, if no collation
** sequence can be found.  If no collation is found, leave an error message.
**
** See also: sqlite3LocateCollSeq(), sqlite3FindCollSeq()
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3GetCollSeq</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,               <comment type="block">/* The desired encoding for the collating sequence */</comment>
  <parameter><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl></parameter>,       <comment type="block">/* Collating sequence with native encoding, or NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>     <comment type="block">/* Collating sequence name */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pColl</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>xCmp</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* No collation sequence of this type for this encoding is registered.
    ** Call the collation factory to see if it can supply us with one.
    */</comment>
    <expr_stmt><expr><call><name>callCollNeeded</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>&amp;&amp;</operator> <call><name>synthCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>p</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such collation sequence: %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_ERROR_MISSING_COLLSEQ</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function returns the collation sequence for database native text
** encoding identified by the string zName.
**
** If the requested collation sequence is not available, or not available
** in the database native encoding, the collation factory is invoked to
** request it. If the collation factory does not supply such a sequence,
** and the sequence is available in another text encoding, then that is
** returned instead.
**
** If no versions of the requested collations sequence are available, or
** another error occurs, NULL is returned and an error message written into
** pParse.
**
** This routine is a wrapper around sqlite3FindCollSeq().  This routine
** invokes the collation factory if the named collation cannot be found
** and generates an error message.
**
** See also: sqlite3FindCollSeq(), sqlite3GetCollSeq()
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3LocateCollSeq</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>initbusy</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>initbusy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>initbusy</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>pColl</name> <operator>||</operator> <operator>!</operator><name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3GetCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pColl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* During the search for the best function definition, this procedure
** is called to test how well the function passed as the first argument
** matches the request for a function with nArg arguments in a system
** that uses encoding enc. The value returned indicates how well the
** request is matched. A higher value indicates a better match.
**
** If nArg is -1 that means to only return a match (non-zero) if p-&gt;nArg
** is also -1.  In other words, we are searching for a function that
** takes a variable number of arguments.
**
** If nArg is -2 that means that we are searching for any function 
** regardless of the number of arguments it uses, so return a positive
** match score for any
**
** The returned value is always between 0 and 6, as follows:
**
** 0: Not a match.
** 1: UTF8/16 conversion required and function takes any number of arguments.
** 2: UTF16 byte order change required and function takes any number of args.
** 3: encoding matches and function takes any number of arguments
** 4: UTF8/16 conversion required - argument count matches exactly
** 5: UTF16 byte order conversion required - argument count matches exactly
** 6: Perfect match:  encoding and argument count match exactly.
**
** If nArg==(-2) then any function with a non-null xSFunc is
** a perfect match and any function with xSFunc NULL is
** a non-match.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_PERFECT_MATCH</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>  <comment type="block">/* The score for a perfect match */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>matchQuality</name><parameter_list>(
  <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,     <comment type="block">/* The function we are evaluating for match quality */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,       <comment type="block">/* Desired number of arguments.  (-1)==any */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>          <comment type="block">/* Desired text encoding */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>match</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wrong number of arguments means "no match" */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>!=</operator><name>nArg</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>xSFunc</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>FUNC_PERFECT_MATCH</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Give a better score to a function with a specific number of arguments
  ** than to function that accepts any number of arguments. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>==</operator><name>nArg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Bonus points if the text encoding matches */</comment>
  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_ENCMASK</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>match</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* Exact encoding match */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>enc</name> <operator>&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>match</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Both are UTF16, but with different byte orders */</comment>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search a FuncDefHash for a function with the given name.  Return
** a pointer to the matching FuncDef if found, or 0 if there is no match.
*/</comment>
<function><type><name>FuncDef</name> <modifier>*</modifier></type><name>sqlite3FunctionSearch</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>,               <comment type="block">/* Hash of the name */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>    <comment type="block">/* Name of function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>sqlite3BuiltinFunctions</name><operator>.</operator><name>a</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pHash</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_BUILTIN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>p</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert a new FuncDef into a FuncDefHash hash table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3InsertBuiltinFuncs</name><parameter_list>(
  <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>aDef</name></decl></parameter>,      <comment type="block">/* List of global functions to be inserted */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDef</name></decl></parameter>            <comment type="block">/* Length of the apDef[] list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDef</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pOther</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><call><name>SQLITE_FUNC_HASH</name><argument_list>(<argument><expr><name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>funcFlags</name> <operator>&amp;</operator> <name>SQLITE_FUNC_BUILTIN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOther</name> <operator>=</operator> <call><name>sqlite3FunctionSearch</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOther</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOther</name><operator>!=</operator><operator>&amp;</operator><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pOther</name><operator>-&gt;</operator><name>pNext</name></name><operator>!=</operator><operator>&amp;</operator><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pNext</name> <operator>=</operator> <name><name>pOther</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOther</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>pHash</name></name> <operator>=</operator> <name><name>sqlite3BuiltinFunctions</name><operator>.</operator><name>a</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3BuiltinFunctions</name><operator>.</operator><name>a</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>aDef</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block">/*
** Locate a user function given a name, a number of arguments and a flag
** indicating whether the function prefers UTF-16 over UTF-8.  Return a
** pointer to the FuncDef structure that defines that function, or return
** NULL if the function does not exist.
**
** If the createFlag argument is true, then a new (blank) FuncDef
** structure is created and liked into the "db" structure if a
** no matching function previously existed.
**
** If nArg is -2, then the first valid function found is returned.  A
** function is valid if xSFunc is non-zero.  The nArg==(-2)
** case is used to see if zName is a valid function name for some number
** of arguments.  If nArg is -2, then createFlag must be 0.
**
** If createFlag is false, then a function with the required name and
** number of arguments may be returned even if the eTextRep flag does not
** match that requested.
*/</comment>
<function><type><name>FuncDef</name> <modifier>*</modifier></type><name>sqlite3FindFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,       <comment type="block">/* An open database */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <comment type="block">/* Name of the function.  zero-terminated */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,          <comment type="block">/* Number of arguments.  -1 means any number */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,            <comment type="block">/* Preferred text encoding */</comment>
  <parameter><decl><type><name>u8</name></type> <name>createFlag</name></decl></parameter>      <comment type="block">/* Create new entry if true and does not otherwise exist */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>         <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pBest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Best match found so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bestScore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Score of best match */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>              <comment type="block">/* Hash value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>          <comment type="block">/* Length of the name */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator> <name>createFlag</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* First search for a match amongst the application-defined functions.
  */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aFunc</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>score</name> <init>= <expr><call><name>matchQuality</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>score</name><operator>&gt;</operator><name>bestScore</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bestScore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* If no match is found, search the built-in functions.
  **
  ** If the DBFLAG_PreferBuiltin flag is set, then search the built-in
  ** functions even if a prior app-defined function was found.  And give
  ** priority to built-in functions.
  **
  ** Except, if createFlag is true, that means that we are trying to
  ** install a new function.  Whatever FuncDef structure is returned it will
  ** have fields overwritten with new information appropriate for the
  ** new function.  But the FuncDefs for built-in functions are read-only.
  ** So we must not search for built-ins when creating a new function.
  */</comment> 
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>createFlag</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pBest</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_PreferBuiltin</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bestScore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>SQLITE_FUNC_HASH</name><argument_list>(<argument><expr><name><name>sqlite3UpperToLower</name><index>[<expr><operator>(</operator><name>u8</name><operator>)</operator><name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FunctionSearch</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>score</name> <init>= <expr><call><name>matchQuality</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>score</name><operator>&gt;</operator><name>bestScore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bestScore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the createFlag parameter is true and the search did not reveal an
  ** exact match for the name, number of arguments and encoding, then add a
  ** new entry to the hash table and return it.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>createFlag</name> <operator>&amp;&amp;</operator> <name>bestScore</name><operator>&lt;</operator><name>FUNC_PERFECT_MATCH</name> <operator>&amp;&amp;</operator> 
      <operator>(</operator><name>pBest</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pBest</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pOther</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pBest</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pBest</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBest</name><operator>-&gt;</operator><name>nArg</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBest</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pBest</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>z</name><operator>=</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pBest</name><operator>-&gt;</operator><name>zName</name></name></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>z</name> <operator>=</operator> <name><name>sqlite3UpperToLower</name><index>[<expr><operator>*</operator><name>z</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>pOther</name> <operator>=</operator> <operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aFunc</name></name></expr></argument>, <argument><expr><name><name>pBest</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>pBest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>pOther</name> <operator>==</operator> <name>pBest</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pBest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pBest</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pOther</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pBest</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pBest</name><operator>-&gt;</operator><name>xSFunc</name></name> <operator>||</operator> <name>createFlag</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pBest</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources held by the schema structure. The void* argument points
** at a Schema struct. This function does not call sqlite3DbFree(db, ) on the 
** pointer itself, it just cleans up subsidiary resources (i.e. the contents
** of the schema hash tables).
**
** The Schema.cache_size variable is not cleared.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SchemaClear</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Hash</name></type> <name>temp1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name></type> <name>temp2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>pElem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><operator>(</operator><name>Schema</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name></type> <name>xdb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xdb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xdb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>temp1</name> <operator>=</operator> <name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>temp2</name> <operator>=</operator> <name><name>pSchema</name><operator>-&gt;</operator><name>trigHash</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>trigHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>idxHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pElem</name></expr>;</condition> <incr><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DeleteTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xdb</name></expr></argument>, <argument><expr><operator>(</operator><name>Trigger</name><operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pElem</name></expr>;</condition> <incr><expr><name>pElem</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xdb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>fkeyHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSchema</name><operator>-&gt;</operator><name>schemaFlags</name></name> <operator>&amp;</operator> <name>DB_SchemaLoaded</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>iGeneration</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>schemaFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DB_SchemaLoaded</name><operator>|</operator><name>DB_ResetWanted</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Find and return the schema associated with a BTree.  Create
** a new one if necessary.
*/</comment>
<function><type><name>Schema</name> <modifier>*</modifier></type><name>sqlite3SchemaGet</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Schema</name> <operator>*</operator><operator>)</operator><call><name>sqlite3BtreeSchema</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Schema</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sqlite3SchemaClear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Schema</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Schema</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if <condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>file_format</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>idxHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>trigHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fkeyHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
</unit>
