<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/alter.c"><comment type="block">/*
** 2005 February 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that used to generate VDBE code
** that implements the ALTER TABLE command.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** The code in this file only exists if we are not omitting the
** ALTER TABLE logic from the build.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>

<comment type="block">/*
** Parameter zName is the name of a table that is about to be altered
** (either with ALTER TABLE ... RENAME TO or ALTER TABLE ... ADD COLUMN).
** If the table is a system table, this function leaves an error message
** in pParse-&gt;zErr (system tables may not be altered) and returns non-zero.
**
** Or, if zName is not a system table, zero is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isAlterableTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
   <operator>||</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Eponymous</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>||</operator> <operator>(</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Shadow</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <call><name>sqlite3ReadOnlyShadowTables</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call>
   <operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %s may not be altered"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to verify that the schemas of database zDb and, if
** bTemp is not true, database "temp", can still be parsed. This is
** called at the end of the generation of an ALTER TABLE ... RENAME ...
** statement to ensure that the operation has not rendered any schema
** objects unusable.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameTestSchema</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of db to verify schema of */</comment>
  <parameter><decl><type><name>int</name></type> <name>bTemp</name></decl></parameter>,                      <comment type="block">/* True if this is the temp db */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWhen</name></decl></parameter>,              <comment type="block">/* "when" part of error message */</comment>
  <parameter><decl><type><name>int</name></type> <name>bNoDQS</name></decl></parameter>                      <comment type="block">/* Do not allow DQS in the schema */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>colNamesSet</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"SELECT 1 "</literal>
      <literal type="string">"FROM \"%w\"."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" "</literal>
      <literal type="string">"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"</literal>
      <literal type="string">" AND sql NOT LIKE 'create virtual%%'"</literal>
      <literal type="string">" AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL "</literal></expr></argument>,
      <argument><expr><name>zDb</name></expr></argument>,
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>bTemp</name></expr></argument>, <argument><expr><name>zWhen</name></expr></argument>, <argument><expr><name>bNoDQS</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>bTemp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"SELECT 1 "</literal>
        <literal type="string">"FROM temp."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" "</literal>
        <literal type="string">"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"</literal>
        <literal type="string">" AND sql NOT LIKE 'create virtual%%'"</literal>
        <literal type="string">" AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL "</literal></expr></argument>,
        <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zWhen</name></expr></argument>, <argument><expr><name>bNoDQS</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate VM code to replace any double-quoted strings (but not double-quoted
** identifiers) within the "sql" column of the sqlite_schema table in 
** database zDb with their single-quoted equivalents. If argument bTemp is
** not true, similarly update all SQL statements in the sqlite_schema table
** of the temp db.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameFixQuotes</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bTemp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"UPDATE \"%w\"."</literal> <name>LEGACY_SCHEMA_TABLE</name> 
      <literal type="string">" SET sql = sqlite_rename_quotefix(%Q, sql)"</literal>
      <literal type="string">"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"</literal>
      <literal type="string">" AND sql NOT LIKE 'create virtual%%'"</literal></expr></argument> , <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bTemp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"UPDATE temp."</literal> <name>LEGACY_SCHEMA_TABLE</name>
      <literal type="string">" SET sql = sqlite_rename_quotefix('temp', sql)"</literal>
      <literal type="string">"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"</literal>
      <literal type="string">" AND sql NOT LIKE 'create virtual%%'"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to reload the schema for database iDb. And, if iDb!=1, for
** the temp database as well.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameReloadSchema</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>p5</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddParseSchemaOp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddParseSchemaOp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to implement the "ALTER TABLE xxx RENAME TO yyy" 
** command. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterRenameTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,            <comment type="block">/* Parser context. */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,            <comment type="block">/* The table to rename. */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>              <comment type="block">/* The new table name. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database that contains the table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                <comment type="block">/* Name of database iDb */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>              <comment type="block">/* Table being renamed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* NULL-terminated version of pName */</comment> 
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTabName</name></decl>;</decl_stmt>             <comment type="block">/* Number of UTF-8 characters in zTabName */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTabName</name></decl>;</decl_stmt>     <comment type="block">/* Original name of the table */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Non-zero if this is a v-tab with an xRename() */</comment>

  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_table</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_table</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>

  <comment type="block">/* Get a NULL terminated version of the new table name. */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zName</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_table</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Check that a table or index named 'zName' does not already exist
  ** in database iDb. If so, this is an error.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call>
   <operator>||</operator> <call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call>
   <operator>||</operator> <call><name>sqlite3IsShadowTableOf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"there is already another table or index with this name: %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure it is not a system table being altered, or a reserved name
  ** that the table is being renamed to.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isAlterableTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"table"</literal></expr></argument>,<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"view %s may not be altered"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVTab</name> <operator>=</operator> <call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xRename</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pVTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Begin a transaction for database iDb. Then modify the schema cookie
  ** (since the ALTER TABLE modifies the schema). Call sqlite3MayAbort(),
  ** as the scalar functions (e.g. sqlite_rename_table()) invoked by the 
  ** nested SQL may raise an exception.  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* figure out how many UTF-8 characters are in zName */</comment>
  <expr_stmt><expr><name>zTabName</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTabName</name> <operator>=</operator> <call><name>sqlite3Utf8CharLen</name><argument_list>(<argument><expr><name>zTabName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Rewrite all CREATE TABLE, INDEX, TRIGGER or VIEW statements in
  ** the schema to use the new table name.  */</comment>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"UPDATE \"%w\"."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" SET "</literal>
      <literal type="string">"sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) "</literal>
      <literal type="string">"WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)"</literal>
      <literal type="string">"AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"</literal></expr></argument>
      , <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>(</operator><name>iDb</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the tbl_name and name columns of the sqlite_schema table
  ** as required.  */</comment>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr><literal type="string">"UPDATE %Q."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" SET "</literal>
          <literal type="string">"tbl_name = %Q, "</literal>
          <literal type="string">"name = CASE "</literal>
            <literal type="string">"WHEN type='table' THEN %Q "</literal>
            <literal type="string">"WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' "</literal>
            <literal type="string">"     AND type='index' THEN "</literal>
             <literal type="string">"'sqlite_autoindex_' || %Q || substr(name,%d+18) "</literal>
            <literal type="string">"ELSE name END "</literal>
      <literal type="string">"WHERE tbl_name=%Q COLLATE nocase AND "</literal>
          <literal type="string">"(type='table' OR type='index' OR type='trigger');"</literal></expr></argument>, 
      <argument><expr><name>zDb</name></expr></argument>,
      <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, 
      <argument><expr><name>nTabName</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
  <comment type="block">/* If the sqlite_sequence table exists in this database, then update 
  ** it with the new table name.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_sequence"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr><literal type="string">"UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q"</literal></expr></argument>,
        <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the table being renamed is not itself part of the temp database,
  ** edit view and trigger definitions within the temp database 
  ** as required.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"UPDATE sqlite_temp_schema SET "</literal>
            <literal type="string">"sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), "</literal>
            <literal type="string">"tbl_name = "</literal>
              <literal type="string">"CASE WHEN tbl_name=%Q COLLATE nocase AND "</literal>
              <literal type="string">"  sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) "</literal>
              <literal type="string">"THEN %Q ELSE tbl_name END "</literal>
            <literal type="string">"WHERE type IN ('view', 'trigger')"</literal></expr></argument>
        , <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is a virtual table, invoke the xRename() function if
  ** one is defined. The xRename() callback will modify the names
  ** of any resources used by the v-table implementation (including other
  ** SQLite tables) that are identified by the name of the virtual table.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>pVTab</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VRename</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>renameReloadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>INITFLAG_AlterRename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameTestSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iDb</name><operator>==</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"after rename"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit_rename_table</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write code that will raise an error if the table described by
** zDb and zTab is not empty.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3ErrorIfNotEmpty</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,      <comment type="block">/* Schema holding the table */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,     <comment type="block">/* Table to check for empty */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl></parameter>      <comment type="block">/* Error message text */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
     <argument><expr><literal type="string">"SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\""</literal></expr></argument>,
     <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after an "ALTER TABLE ... ADD" statement
** has been parsed. Argument pColDef contains the text of the new
** column definition.
**
** The Table structure pParse-&gt;pNewTable was extended to include
** the new column during parsing.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterFinishAddColumn</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pColDef</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>              <comment type="block">/* Copy of pParse-&gt;pNewTable */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>              <comment type="block">/* Table being altered */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database number */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>          <comment type="block">/* Database name */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>         <comment type="block">/* Table name */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>               <comment type="block">/* Null-terminated column definition */</comment>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>             <comment type="block">/* The new column */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDflt</name></decl>;</decl_stmt>              <comment type="block">/* Default value for the new column */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>              <comment type="block">/* The database connection; */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                  <comment type="block">/* The prepared statement under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>                   <comment type="block">/* Temporary registers */</comment>

  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTab</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zName</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Skip the "sqlite_altertab_" prefix on the name */</comment>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDflt</name> <operator>=</operator> <call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <comment type="block">/* Check that the new column is not specified as PRIMARY KEY or UNIQUE.
  ** If there is a NOT NULL constraint, then the default value for the
  ** column must not be NULL.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Cannot add a PRIMARY KEY column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>pIndex</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
         <argument><expr><literal type="string">"Cannot add a UNIQUE column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the default value for the new column was specified with a 
    ** literal NULL, then set pDflt to 0. This simplifies checking
    ** for an SQL NULL default below.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDflt</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDflt</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SPAN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pDflt</name> <operator>&amp;&amp;</operator> <name><name>pDflt</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pDflt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name> <operator>&amp;&amp;</operator> <name>pDflt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorIfNotEmpty</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>,
          <argument><expr><literal type="string">"Cannot add a REFERENCES column with non-NULL default value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pDflt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorIfNotEmpty</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>,
          <argument><expr><literal type="string">"Cannot add a NOT NULL column with default value NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* Ensure the default expression is something that sqlite3ValueFromExpr()
    ** can handle (i.e. not CURRENT_TIME etc.)
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pDflt</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDflt</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_AFF_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVal</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorIfNotEmpty</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>,
           <argument><expr><literal type="string">"Cannot add a column with non-constant default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorIfNotEmpty</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"cannot add a STORED column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* Modify the CREATE TABLE statement. */</comment>
  <expr_stmt><expr><name>zCol</name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pColDef</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pColDef</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCol</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zCol</name><index>[<expr><name><name>pColDef</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>zEnd</name><operator>&gt;</operator><name>zCol</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>zEnd</name><operator>==</operator><literal type="char">';'</literal> <operator>||</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zEnd</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>zEnd</name><operator>--</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* substr() operations on characters, but addColOffset is in bytes. So we
    ** have to use printf() to translate between these units: */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"UPDATE \"%w\"."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" SET "</literal>
          <literal type="string">"sql = printf('%%.%ds, ',sql) || %Q"</literal>
          <literal type="string">" || substr(sql,1+length(printf('%%.%ds',sql))) "</literal>
        <literal type="string">"WHERE type = 'table' AND name = %Q"</literal></expr></argument>, 
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>addColOffset</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>addColOffset</name></name></expr></argument>,
      <argument><expr><name>zTab</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Make sure the schema version is at least 3.  But do not upgrade
    ** from less than 3 to 4, as that will corrupt any preexisting DESC
    ** index.
    */</comment>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ReadCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>BTREE_FILE_FORMAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>BTREE_FILE_FORMAT</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reload the table definition */</comment>
    <expr_stmt><expr><call><name>renameReloadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>INITFLAG_AlterAdd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Verify that constraints are still satisfied */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>pCheck</name></name><operator>!=</operator><literal type="number">0</literal>
     <operator>||</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr><literal type="string">"SELECT CASE WHEN quick_check GLOB 'CHECK*'"</literal>
        <literal type="string">" THEN raise(ABORT,'CHECK constraint failed')"</literal>
        <literal type="string">" ELSE raise(ABORT,'NOT NULL constraint failed')"</literal>
        <literal type="string">" END"</literal>
        <literal type="string">"  FROM pragma_quick_check(%Q,%Q)"</literal>
        <literal type="string">" WHERE quick_check GLOB 'CHECK*' OR quick_check GLOB 'NULL*'"</literal></expr></argument>,
        <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the parser after the table-name in
** an "ALTER TABLE &lt;table-name&gt; ADD" statement is parsed. Argument 
** pSrc is the full-name of the table being altered.
**
** This routine makes a (partial) copy of the Table structure
** for the table being altered and sets Parse.pNewTable to point
** to it. Routines called by the parser as the column definition
** is parsed (i.e. sqlite3AddColumn()) add the new Column data to 
** the copy. The copy of the Table structure is deleted by tokenize.c 
** after parsing is finished.
**
** Routine sqlite3AlterFinishAddColumn() will be called to complete
** coding the "ALTER TABLE ... ADD" statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterBeginAddColumn</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Look up the table being altered. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_begin_add_column</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_begin_add_column</name>;</goto></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"virtual tables may not be altered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Make sure this is not an attempt to ALTER a view. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Cannot add a column to a view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isAlterableTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>addColOffset</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Put a copy of the Table struct in Parse.pNewTable for the
  ** sqlite3AddColumn() function and friends to modify.  But modify
  ** the name by adding an "sqlite_altertab_" prefix.  By adding this
  ** prefix, we insure that the name will not collide with an existing
  ** table because user table are not allowed to have the "sqlite_"
  ** prefix on their name.
  */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>Table</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_begin_add_column</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nTabRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal><operator>)</operator><operator>*</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="number">8</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nAlloc</name><operator>&gt;=</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <name>nAlloc</name><operator>%</operator><literal type="number">8</literal><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nAlloc</name><operator>-</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <operator>(</operator><name>Column</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Column</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_altertab_%s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>||</operator> <operator>!</operator><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Column</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>hName</name></name> <operator>=</operator> <call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pDfltList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>addColOffset</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>addColOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nTabRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<label><name>exit_begin_add_column</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parameter pTab is the subject of an ALTER TABLE ... RENAME COLUMN
** command. This function checks if the table is a view or virtual
** table (columns of views or virtual tables may not be renamed). If so,
** it loads an error message into pParse and returns non-zero.
**
** Or, if pTab is not a view or virtual table, zero is returned.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isRealTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bDrop</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"view"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"virtual table"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>zType</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot %s %s \"%s\""</literal></expr></argument>, 
        <argument><expr><operator>(</operator><ternary><condition><expr><name>bDrop</name></expr> ?</condition><then> <expr><literal type="string">"drop column from"</literal></expr> </then><else>: <expr><literal type="string">"rename columns of"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
        <argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isRealTable</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Handles the following parser reduction:
**
**  cmd ::= ALTER TABLE pSrc RENAME COLUMN pOld TO pNew
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterRenameColumn</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,                  <comment type="block">/* Table being altered.  pSrc-&gt;nSrc==1 */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>,                    <comment type="block">/* Name of column being changed */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>                     <comment type="block">/* New column name */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                    <comment type="block">/* Table being updated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Index of column being renamed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Old column name */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* New column name */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                <comment type="block">/* Name of schema containing the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSchema</name></decl>;</decl_stmt>                    <comment type="block">/* Index of the schema */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bQuote</name></decl>;</decl_stmt>                     <comment type="block">/* True to quote the new name */</comment>

  <comment type="block">/* Locate the table to be altered */</comment>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_column</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Cannot alter a system table */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isAlterableTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_column</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isRealTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_column</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Which schema holds the table to be altered */</comment>  
  <expr_stmt><expr><name>iSchema</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSchema</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iSchema</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Make sure the old name really is a column name in the table to be
  ** altered.  Set iCol to be the index of the column being renamed */</comment>
  <expr_stmt><expr><name>zOld</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zOld</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_column</name>;</goto></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such column: \"%T\""</literal></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_column</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Ensure the schema contains no double-quoted strings */</comment>
  <expr_stmt><expr><call><name>renameTestSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iSchema</name><operator>==</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameFixQuotes</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iSchema</name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do the rename operation using a recursive UPDATE statement that
  ** uses the sqlite_rename_column() SQL function to compute the new
  ** CREATE statement text for the sqlite_schema table.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zNew</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_column</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bQuote</name> <operator>=</operator> <call><name>sqlite3Isquote</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"UPDATE \"%w\"."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" SET "</literal>
      <literal type="string">"sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) "</literal>
      <literal type="string">"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' "</literal>
      <literal type="string">" AND (type != 'index' OR tbl_name = %Q)"</literal></expr></argument>,
      <argument><expr><name>zDb</name></expr></argument>,
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>bQuote</name></expr></argument>, <argument><expr><name>iSchema</name><operator>==</operator><literal type="number">1</literal></expr></argument>,
      <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"UPDATE temp."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" SET "</literal>
      <literal type="string">"sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) "</literal>
      <literal type="string">"WHERE type IN ('trigger', 'view')"</literal></expr></argument>,
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>bQuote</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Drop and reload the database schema. */</comment>
  <expr_stmt><expr><call><name>renameReloadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iSchema</name></expr></argument>, <argument><expr><name>INITFLAG_AlterRename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameTestSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iSchema</name><operator>==</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"after rename"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>exit_rename_column</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Each RenameToken object maps an element of the parse tree into
** the token that generated that element.  The parse tree element
** might be one of:
**
**     *  A pointer to an Expr that represents an ID
**     *  The name of a table column in Column.zName
**
** A list of RenameToken objects can be constructed during parsing.
** Each new object is created by sqlite3RenameTokenMap().
** As the parse tree is transformed, the sqlite3RenameTokenRemap()
** routine is used to keep the mapping current.
**
** After the parse finishes, renameTokenFind() routine can be used
** to look up the actual token value that created some element in
** the parse tree.
*/</comment>
<struct>struct <name>RenameToken</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>         <comment type="block">/* Parse tree element created by token t */</comment>
  <decl_stmt><decl><type><name>Token</name></type> <name>t</name></decl>;</decl_stmt>               <comment type="block">/* The token that created parse tree element p */</comment>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>    <comment type="block">/* Next is a list of all RenameToken objects */</comment>
}</block>;</struct>

<comment type="block">/*
** The context of an ALTER TABLE RENAME COLUMN operation that gets passed
** down into the Walker.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RenameCtx</name></name></type> <name>RenameCtx</name>;</typedef>
<struct>struct <name>RenameCtx</name> <block>{
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>             <comment type="block">/* List of tokens to overwrite */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nList</name></decl>;</decl_stmt>                      <comment type="block">/* Number of tokens in pList */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Index of column being renamed */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                    <comment type="block">/* Table being ALTERed */</comment> 
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOld</name></decl>;</decl_stmt>               <comment type="block">/* Old column name */</comment>
}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** This function is only for debugging. It performs two tasks:
**
**   1. Checks that pointer pPtr does not already appear in the 
**      rename-token list.
**
**   2. Dereferences each pointer in the rename-token list.
**
** The second is most effective when debugging under valgrind or
** address-sanitizer or similar. If any of these pointers no longer 
** point to valid objects, an exception is raised by the memory-checking 
** tool.
**
** The point of this is to prevent comparisons of invalid pointer values.
** Even though this always seems to work, it is undefined according to the
** C standard. Example of undefined comparison:
**
**     sqlite3_free(x);
**     if( x==y ) ...
**
** Technically, as x no longer points into a valid object or to the byte
** following a valid object, it may not be used in comparison operations.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameTokenCheckAll</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>==</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>RenameToken</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>pRename</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>p</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>p</name></name><operator>!=</operator><name>pPtr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>+=</operator> <operator>*</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>renameTokenCheckAll</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Remember that the parser tree element pPtr was created using
** the token pToken.
**
** In other words, construct a new RenameToken object and add it
** to the list of RenameToken objects currently being built up
** in pParse-&gt;pRename.
**
** The pPtr argument is returned so that this routine can be used
** with tail recursion in tokenExpr() routine, for a small performance
** improvement.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3RenameTokenMap</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPtr</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameTokenCheckAll</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name><operator>!=</operator><name>PARSE_MODE_UNMAP</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RenameToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>pPtr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <operator>*</operator><name>pToken</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pRename</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pRename</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** It is assumed that there is already a RenameToken object associated
** with parse tree element pFrom. This function remaps the associated token
** to parse tree element pTo.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RenameTokenRemap</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>renameTokenCheckAll</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>pRename</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>p</name></name><operator>==</operator><name>pFrom</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>pTo</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Walker callback used by sqlite3RenameExprUnmap().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameUnmapExprCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Iterate through the Select objects that are part of WITH clauses attached
** to select statement pSelect.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameWalkWith</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pWith</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWith</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pWith</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWith</name><operator>-&gt;</operator><name>nCte</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWith</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Expanded</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Push a copy of the With object onto the with-stack. We use a copy
      ** here as the original will be expanded and resolved (flags SF_Expanded
      ** and SF_Resolved) below. And the parser code that uses the with-stack
      ** fails if the Select objects on it have already been expanded and
      ** resolved.  */</comment>
      <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <call><name>sqlite3WithDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pWith</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <call><name>sqlite3WithPush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWith</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWith</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pCopy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sNC</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3RenameExprlistUnmap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pWith</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pCopy</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name><operator>==</operator><name>pCopy</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <name><name>pCopy</name><operator>-&gt;</operator><name>pOuter</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Unmap all tokens in the IdList object passed as the second argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unmapColumnIdlistNames</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>IdList</name> <modifier>*</modifier></type><name>pIdList</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIdList</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name><name>pIdList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Walker callback used by sqlite3RenameExprUnmap().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameUnmapSelectCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_View</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_CopyCte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_View</name><operator>|</operator><name>SF_CopyCte</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name> <operator>&amp;&amp;</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>  <comment type="block">/* Every Select as a SrcList, even if it is empty */</comment>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u3</name><operator>.</operator><name>pOn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>unmapColumnIdlistNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u3</name><operator>.</operator><name>pUsing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>renameWalkWith</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove all nodes that are part of expression pExpr from the rename list.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RenameExprUnmap</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>eMode</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Walker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>renameUnmapExprCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>renameUnmapSelectCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name> <operator>=</operator> <name>PARSE_MODE_UNMAP</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>eParseMode</name></name> <operator>=</operator> <name>eMode</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Remove all nodes that are part of expression-list pEList from the 
** rename list.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RenameExprlistUnmap</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pEList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Walker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>renameUnmapExprCb</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RenameTokenRemap</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free the list of RenameToken objects given in the second argument
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameTokenFree</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pToken</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Search the Parse object passed as the first argument for a RenameToken
** object associated with parse tree element pPtr. If found, return a pointer
** to it. Otherwise, return NULL.
**
** If the second argument passed to this function is not NULL and a matching
** RenameToken object is found, remove it from the Parse object and add it to
** the list maintained by the RenameCtx object.
*/</comment>
<function><type><specifier>static</specifier> <name>RenameToken</name> <modifier>*</modifier></type><name>renameTokenFind</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name><name>struct</name> <name>RenameCtx</name></name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pPtr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>pRename</name></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>p</name></name><operator>==</operator><name>pPtr</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pToken</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>pToken</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>nList</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>pToken</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a Walker select callback. It does nothing. It is only required
** because without a dummy callback, sqlite3WalkExpr() and similar do not
** descend into sub-select statements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameColumnSelectCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_View</name><operator>|</operator><name>SF_CopyCte</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_View</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_CopyCte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>renameWalkWith</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a Walker expression callback.
**
** For every TK_COLUMN node in the expression tree, search to see
** if the column being references is the column being renamed by an
** ALTER TABLE statement.  If it is, then attach its associated
** RenameToken object to the list of RenameToken objects being
** constructed in RenameCtx object at pWalker-&gt;u.pRename.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameColumnExprCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RenameCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRename</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_TRIGGER</name> 
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>iCol</name></name> 
   <operator>&amp;&amp;</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pTab</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> 
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>iCol</name></name>
   <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The RenameCtx contains a list of tokens that reference a column that
** is being renamed by an ALTER TABLE statement.  Return the "last"
** RenameToken in the RenameCtx and remove that RenameToken from the
** RenameContext.  "Last" means the last RenameToken encountered when
** the input SQL is parsed from left to right.  Repeated calls to this routine
** return all column name tokens in the order that they are encountered
** in the SQL statement.
*/</comment>
<function><type><specifier>static</specifier> <name>RenameToken</name> <modifier>*</modifier></type><name>renameColumnTokenNext</name><parameter_list>(<parameter><decl><type><name>RenameCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pBest</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pToken</name><operator>=</operator><name><name>pBest</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</init> <condition><expr><name>pToken</name></expr>;</condition> <incr><expr><name>pToken</name><operator>=</operator><name><name>pToken</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name><operator>&gt;</operator><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>pToken</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pBest</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pBest</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>

  <return>return <expr><name>pBest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An error occured while parsing or otherwise processing a database
** object (either pParse-&gt;pNewTable, pNewIndex or pNewTrigger) as part of an
** ALTER TABLE RENAME COLUMN program. The error message emitted by the
** sub-routine is currently stored in pParse-&gt;zErrMsg. This function
** adds context to the error message and then stores it in pCtx.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameColumnParseError</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWhen</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pType</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pObject</name></decl></parameter>,
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zT</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zN</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"error in %s %s%s%s: %s"</literal></expr></argument>, 
      <argument><expr><name>zT</name></expr></argument>, <argument><expr><name>zN</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>zWhen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>zWhen</name></expr></argument>,
      <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** For each name in the the expression-list pEList (i.e. each
** pEList-&gt;a[i].zName) that matches the string in zOld, extract the 
** corresponding rename-token from Parse object pParse and add it
** to the RenameCtx pCtx.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameColumnElistNames</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>RenameCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOld</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pEList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>eEName</name></name><operator>==</operator><name>ENAME_NAME</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>zName</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** For each name in the the id-list pIdList (i.e. each pIdList-&gt;a[i].zName) 
** that matches the string in zOld, extract the corresponding rename-token 
** from Parse object pParse and add it to the RenameCtx pCtx.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameColumnIdlistNames</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>RenameCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>IdList</name> <modifier>*</modifier></type><name>pIdList</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOld</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pIdList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdList</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pIdList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Parse the SQL statement zSql using Parse object (*p). The Parse object
** is initialized by this function before it is used.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameParseSql</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                       <comment type="block">/* Memory to use for Parse object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of schema SQL belongs to */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,               <comment type="block">/* SQL to parse */</comment>
  <parameter><decl><type><name>int</name></type> <name>bTemp</name></decl></parameter>                       <comment type="block">/* True if SQL is from temp schema */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3ParseObjectInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>,<argument><expr><literal type="string">"CREATE "</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name> <operator>=</operator> <ternary><condition><expr><name>bTemp</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eParseMode</name></name> <operator>=</operator> <name>PARSE_MODE_RENAME</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3RunParser</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> 
   <operator>&amp;&amp;</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pNewIndex</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pNewTrigger</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Ensure that all mappings in the Parse.pRename list really do map to
  ** a part of the input string.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSql</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pToken</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pRename</name></name></expr>;</init> <condition><expr><name>pToken</name></expr>;</condition> <incr><expr><name>pToken</name><operator>=</operator><name><name>pToken</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name><operator>&gt;=</operator><name>zSql</name> <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>pToken</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name><index>[<expr><name><name>pToken</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name></expr>]</index></name><operator>&lt;=</operator><operator>&amp;</operator><name><name>zSql</name><index>[<expr><name>nSql</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function edits SQL statement zSql, replacing each token identified
** by the linked list pRename with the text of zNew. If argument bQuote is
** true, then zNew is always quoted first. If no error occurs, the result
** is loaded into context object pCtx as the result.
**
** Or, if an error occurs (i.e. an OOM condition), an error is left in
** pCtx and an SQLite error code returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameEditSql</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* Return result here */</comment>
  <parameter><decl><type><name>RenameCtx</name> <modifier>*</modifier></type><name>pRename</name></decl></parameter>,             <comment type="block">/* Rename context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,               <comment type="block">/* SQL statement to edit */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNew</name></decl></parameter>,               <comment type="block">/* New token text */</comment>
  <parameter><decl><type><name>int</name></type> <name>bQuote</name></decl></parameter>                      <comment type="block">/* True to always quote token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nNew</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nSql</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQuot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nQuot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zNew</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Set zQuot to point to a buffer containing a quoted copy of the 
    ** identifier zNew. If the corresponding identifier in the original 
    ** ALTER TABLE statement was quoted (bQuote==1), then set zNew to
    ** point to zQuot so that all substitutions are made using the
    ** quoted version of the new column name.  */</comment>
    <expr_stmt><expr><name>zQuot</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"\"%w\" "</literal></expr></argument>, <argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zQuot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nQuot</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zQuot</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nQuot</name><operator>&gt;=</operator><name>nNew</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nSql</name> <operator>+</operator> <name><name>pRename</name><operator>-&gt;</operator><name>nList</name></name><operator>*</operator><name>nQuot</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zOut</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>nSql</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zBuf1</name> <operator>=</operator> <operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>nSql</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zBuf2</name> <operator>=</operator> <operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>nSql</name><operator>*</operator><literal type="number">4</literal><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* At this point pRename-&gt;pList contains a list of RenameToken objects
  ** corresponding to all tokens in the input SQL that must be replaced
  ** with the new column name, or with single-quoted versions of themselves. 
  ** All that remains is to construct and return the edited SQL string. */</comment>
  <if_stmt><if>if<condition>( <expr><name>zOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><name>nSql</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>nSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pRename</name><operator>-&gt;</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>                   <comment type="block">/* Offset of token to replace in zOut */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>nReplace</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zReplace</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pBest</name> <init>= <expr><call><name>renameColumnTokenNext</name><argument_list>(<argument><expr><name>pRename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>zNew</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>bQuote</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3IsIdChar</name><argument_list>(<argument><expr><operator>*</operator><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nReplace</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zReplace</name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>nReplace</name> <operator>=</operator> <name>nQuot</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zReplace</name> <operator>=</operator> <name>zQuot</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name><index>[<expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nReplace</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Dequote the double-quoted token. Then requote it again, this time
        ** using single quotes. If the character immediately following the
        ** original token within the input SQL was a single quote ('), then
        ** add another space after the new, single-quoted version of the
        ** token. This is so that (SELECT "string"'alias') maps to
        ** (SELECT 'string' 'alias'), and not (SELECT 'string''alias').  */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf1</name></expr></argument>, <argument><expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zBuf1</name><index>[<expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>zBuf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nSql</name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>zBuf2</name></expr></argument>, <argument><expr><literal type="string">"%Q%s"</literal></expr></argument>, <argument><expr><name>zBuf1</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name><index>[<expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zReplace</name> <operator>=</operator> <name>zBuf2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nReplace</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name> <operator>-</operator> <name>zSql</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name><operator>!=</operator><name>nReplace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOff</name> <operator>+</operator> <name>nReplace</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOff</name> <operator>+</operator> <name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>, 
            <argument><expr><name>nOut</name> <operator>-</operator> <operator>(</operator><name>iOff</name> <operator>+</operator> <name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name><operator>)</operator></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nOut</name> <operator>+=</operator> <name>nReplace</name> <operator>-</operator> <name><name>pBest</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>zReplace</name></expr></argument>, <argument><expr><name>nReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pBest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve all symbols in the trigger at pParse-&gt;pNewTrigger, assuming
** it was read from the schema of database zDb. Return SQLITE_OK if 
** successful. Otherwise, return an SQLite error code and leave an error
** message in the Parse object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameResolveTrigger</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTrigger</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TriggerStep</name> <modifier>*</modifier></type><name>pStep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pTabSchema</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, 
      <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pTabSchema</name></name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>eTriggerOp</name></name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <comment type="block">/* ALWAYS() because if the table of the trigger does not exist, the
  ** error would have been hit before this point */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Resolve symbols in WHEN clause */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>pWhen</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWhen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>pStep</name><operator>=</operator><name><name>pNew</name><operator>-&gt;</operator><name>step_list</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pStep</name></expr>;</condition> <incr><expr><name>pStep</name><operator>=</operator><name><name>pStep</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><call><name>sqlite3TriggerStepSrc</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pStep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSrc</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><call><name>sqlite3SelectNew</name><argument_list>(
            <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pSel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name><operator>==</operator><name><name>pSel</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name><operator>==</operator><name><name>pSel</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(  <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pStep</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pStep</name><operator>-&gt;</operator><name>pUpsert</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>pStep</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pUpsert</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name> <init>= <expr><name><name>pStep</name><operator>-&gt;</operator><name>pUpsert</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertSrc</name></name> <operator>=</operator> <name>pSrc</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>uNC</name><operator>.</operator><name>pUpsert</name></name> <operator>=</operator> <name>pUpsert</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>NC_UUpsert</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pUpsertSet</name> <init>= <expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertSet</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pUpsertSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke sqlite3WalkExpr() or sqlite3WalkSelect() on all Select or Expr
** objects that are part of the trigger passed as the second argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameWalkTrigger</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TriggerStep</name> <modifier>*</modifier></type><name>pStep</name></decl>;</decl_stmt>

  <comment type="block">/* Find tokens to edit in WHEN clause */</comment>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pTrigger</name><operator>-&gt;</operator><name>pWhen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find tokens to edit in trigger steps */</comment>
  <for>for<control>(<init><expr><name>pStep</name><operator>=</operator><name><name>pTrigger</name><operator>-&gt;</operator><name>step_list</name></name></expr>;</init> <condition><expr><name>pStep</name></expr>;</condition> <incr><expr><name>pStep</name><operator>=</operator><name><name>pStep</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pUpsert</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name> <init>= <expr><name><name>pStep</name><operator>-&gt;</operator><name>pUpsert</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTargetWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free the contents of Parse object (*pParse). Do not free the memory
** occupied by the Parse object itself.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameParseCleanup</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeFinalize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>pIdx</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewIndex</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewIndex</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3FreeIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3DeleteTrigger</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTrigger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameTokenFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pRename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ParseObjectReset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:
**
**     sqlite_rename_column(SQL,TYPE,OBJ,DB,TABLE,COL,NEWNAME,QUOTE,TEMP)
**
**   0. zSql:     SQL statement to rewrite
**   1. type:     Type of object ("table", "view" etc.)
**   2. object:   Name of object
**   3. Database: Database name (e.g. "main")
**   4. Table:    Table name
**   5. iCol:     Index of column to rename
**   6. zNew:     New column name
**   7. bQuote:   Non-zero if the new column name should be quoted.
**   8. bTemp:    True if zSql comes from temp schema
**
** Do a column rename operation on the CREATE statement given in zSql.
** The iCol-th column (left-most is 0) of table zTable is renamed from zCol
** into zNew.  The name should be quoted if bQuote is true.
**
** This function is used internally by the ALTER TABLE RENAME COLUMN command.
** It is only accessible to SQL created using sqlite3NestedParse().  It is
** not reachable from ordinary SQL passed into sqlite3_prepare() unless the
** SQLITE_TESTCTRL_INTERNAL_FUNCTIONS test setting is enabled.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameColumnFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RenameCtx</name></type> <name>sCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bQuote</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bTemp</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOld</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name></type> <name>sParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_xauth</name></type> <name>xAuth</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zOld</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>iCol</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>iCol</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameParseSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>bTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find tokens that need to be replaced. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Walker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <operator>&amp;</operator><name>sParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>renameColumnExprCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>renameColumnSelectCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pRename</name></name> <operator>=</operator> <operator>&amp;</operator><name>sCtx</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>renameColumnFunc_done</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_View</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> ?</condition><then> <expr><name>SQLITE_NOMEM</name></expr> </then><else>: <expr><name><name>sParse</name><operator>.</operator><name>rc</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>renameColumnFunc_done</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* A regular table */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>bFKOnly</name> <init>= <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bFKOnly</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(
              <argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>iCol</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>iPKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>sParse</name><operator>.</operator><name>pNewIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pFKey</name><operator>=</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name><operator>=</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr></incr>)</control><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>bFKOnly</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name><operator>==</operator><name>iCol</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call>
           <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCol</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pFKey</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name><operator>-&gt;</operator><name>aColExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* A trigger */</comment>
    <decl_stmt><decl><type><name>TriggerStep</name> <modifier>*</modifier></type><name>pStep</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameResolveTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>renameColumnFunc_done</name>;</goto></block_content></block></if></if_stmt>

    <for>for<control>(<init><expr><name>pStep</name><operator>=</operator><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name><operator>-&gt;</operator><name>step_list</name></name></expr>;</init> <condition><expr><name>pStep</name></expr>;</condition> <incr><expr><name>pStep</name><operator>=</operator><name><name>pStep</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name></expr> )</condition><block>{<block_content> 
        <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTarget</name> <init>= <expr><call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pTarget</name><operator>==</operator><name>pTab</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pUpsert</name></name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pUpsertSet</name> <init>= <expr><name><name>pStep</name><operator>-&gt;</operator><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertSet</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>renameColumnElistNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name>pUpsertSet</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>renameColumnIdlistNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pIdList</name></name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>renameColumnElistNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>pExprList</name></name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>


    <comment type="block">/* Find tokens to edit in UPDATE OF clause */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pTriggerTab</name></name><operator>==</operator><name>pTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>renameColumnIdlistNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>,<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name><operator>-&gt;</operator><name>pColumns</name></name></expr></argument>,<argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find tokens to edit in various expressions and selects */</comment>
    <expr_stmt><expr><call><name>renameWalkTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameEditSql</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>bQuote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>renameColumnFunc_done</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name> <operator>&amp;&amp;</operator> <call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>renameColumnParseError</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>renameParseCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameTokenFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <name>xAuth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Walker expression callback used by "RENAME TABLE". 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameTableExprCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RenameCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRename</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
   <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walker select callback used by "RENAME TABLE". 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>renameTableSelectCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RenameCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRename</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_View</name><operator>|</operator><name>SF_CopyCte</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_View</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_CopyCte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pSrc</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pTab</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>renameWalkWith</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This C function implements an SQL user function that is used by SQL code
** generated by the ALTER TABLE ... RENAME command to modify the definition
** of any foreign key constraints that use the table being renamed as the 
** parent table. It is passed three arguments:
**
**   0: The database containing the table being renamed.
**   1. type:     Type of object ("table", "view" etc.)
**   2. object:   Name of object
**   3: The complete text of the schema statement being modified,
**   4: The old name of the table being renamed, and
**   5: The new name of the table being renamed.
**   6: True if the schema statement comes from the temp db.
**
** It returns the new schema statement. For example:
**
** sqlite_rename_table('main', 'CREATE TABLE t1(a REFERENCES t2)','t2','t3',0)
**       -&gt; 'CREATE TABLE t1(a REFERENCES t3)'
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameTableFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOld</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bTemp</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zInput</name> <operator>&amp;&amp;</operator> <name>zOld</name> <operator>&amp;&amp;</operator> <name>zNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Parse</name></type> <name>sParse</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bQuote</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RenameCtx</name></type> <name>sCtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <decl_stmt><decl><type><name>sqlite3_xauth</name></type> <name>xAuth</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RenameCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Walker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <operator>&amp;</operator><name>sParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>renameTableExprCb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>renameTableSelectCb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pRename</name></name> <operator>=</operator> <operator>&amp;</operator><name>sCtx</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameParseSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>bTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isLegacy</name> <init>= <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_LegacyAlter</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>isLegacy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <operator>&amp;</operator><name>sParse</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_View</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_View</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>sParse</name><operator>.</operator><name>rc</name></name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Modify any FK definitions to point to the new table. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>isLegacy</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ForeignKeys</name><operator>)</operator><operator>)</operator>
           <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>
          )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>pFKey</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>pFKey</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name><operator>=</operator><name><name>pFKey</name><operator>-&gt;</operator><name>pNextFrom</name></name></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pFKey</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

          <comment type="block">/* If this is the table being altered, fix any table refs in CHECK
          ** expressions. Also update the name that appears right after the
          ** "CREATE [VIRTUAL] TABLE" bit. */</comment>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zOld</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>isLegacy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>

      <if type="elseif">else if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>isLegacy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
      <else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name> <init>= <expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TriggerStep</name> <modifier>*</modifier></type><name>pStep</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call> 
            <operator>&amp;&amp;</operator> <name><name>sCtx</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTrigger</name><operator>-&gt;</operator><name>pTabSchema</name></name></expr>
          )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>isLegacy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameResolveTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>renameWalkTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>pStep</name><operator>=</operator><name><name>pTrigger</name><operator>-&gt;</operator><name>step_list</name></name></expr>;</init> <condition><expr><name>pStep</name></expr>;</condition> <incr><expr><name>pStep</name><operator>=</operator><name><name>pStep</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name><name>pStep</name><operator>-&gt;</operator><name>zTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name></name></expr> )</condition><block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pStep</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
                    <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameEditSql</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>bQuote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name> <operator>&amp;&amp;</operator> <call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>renameColumnParseError</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>renameParseCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>renameTokenFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <name>xAuth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>renameQuotefixExprCb</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_STRING</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_DblQuoted</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>renameTokenFind</name><argument_list>(<argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRename</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* SQL function: sqlite_rename_quotefix(DB,SQL)
**
** Rewrite the DDL statement "SQL" so that any string literals that use
** double-quotes use single quotes instead.
**
** Two arguments must be passed:
**
**   0: Database name ("main", "temp" etc.).
**   1: SQL statement to edit.
**
** The returned value is the modified SQL statement. For example, given
** the database schema:
**
**   CREATE TABLE t1(a, b, c);
**
**   SELECT sqlite_rename_quotefix('main', 
**       'CREATE VIEW v1 AS SELECT "a", "string" FROM t1'
**   );
**
** returns the string:
** 
**   CREATE VIEW v1 AS SELECT "a", 'string' FROM t1
**
** If there is a error in the input SQL, then raise an error, except
** if PRAGMA writable_schema=ON, then just return the input string
** unmodified following an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameQuotefixFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zInput</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_xauth</name></type> <name>xAuth</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <name>zInput</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Parse</name></type> <name>sParse</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameParseSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>RenameCtx</name></type> <name>sCtx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>

      <comment type="block">/* Walker to find tokens that need to be replaced. */</comment>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RenameCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Walker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <operator>&amp;</operator><name>sParse</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>renameQuotefixExprCb</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>renameColumnSelectCb</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pRename</name></name> <operator>=</operator> <operator>&amp;</operator><name>sCtx</name></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_View</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> ?</condition><then> <expr><name>SQLITE_NOMEM</name></expr> </then><else>: <expr><name><name>sParse</name><operator>.</operator><name>rc</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, 
               <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></argument>, 
                                         <argument><expr><operator>&amp;</operator><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_GENERATED_COLUMNS */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name><operator>-&gt;</operator><name>aColExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewIndex</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameResolveTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>renameWalkTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRIGGER */</comment>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content> 
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameEditSql</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>renameTokenFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>renameParseCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <name>xAuth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Function:  sqlite_rename_test(DB,SQL,TYPE,NAME,ISTEMP,WHEN,DQS)
**
** An SQL user function that checks that there are no parse or symbol
** resolution problems in a CREATE TRIGGER|TABLE|VIEW|INDEX statement.
** After an ALTER TABLE .. RENAME operation is performed and the schema
** reloaded, this function is called on each SQL statement in the schema
** to ensure that it is still usable.
**
**   0: Database name ("main", "temp" etc.).
**   1: SQL statement.
**   2: Object type ("view", "table", "trigger" or "index").
**   3: Object name.
**   4: True if object is from temp schema.
**   5: "when" part of error message.
**   6: True to disable the DQS quirk when parsing SQL.
**
** The return value is computed as follows:
**
**   A. If an error is seen and not in PRAGMA writable_schema=ON mode,
**      then raise the error.
**   B. Else if a trigger is created and the the table that the trigger is
**      attached to is in database zDb, then return 1.
**   C. Otherwise return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameTableTest</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zInput</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bTemp</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isLegacy</name> <init>= <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_LegacyAlter</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zWhen</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bNoDQS</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_xauth</name></type> <name>xAuth</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <name>zInput</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Parse</name></type> <name>sParse</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>bNoDQS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>SQLITE_DqsDML</name><operator>|</operator><name>SQLITE_DqsDDL</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameParseSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>bTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_DqsDML</name><operator>|</operator><name>SQLITE_DqsDDL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>isLegacy</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sParse</name><operator>.</operator><name>pNewTable</name></name> <operator>&amp;&amp;</operator> <call><name>IsView</name><argument_list>(<argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <operator>&amp;</operator><name>sParse</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTable</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>view</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>sParse</name><operator>.</operator><name>rc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>

      <if type="elseif">else if<condition>( <expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>isLegacy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameResolveTrigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i1</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>sParse</name><operator>.</operator><name>pNewTrigger</name><operator>-&gt;</operator><name>pTabSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>i1</name><operator>==</operator><name>i2</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Handle output case B */</comment>
            <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zWhen</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Output case A */</comment>
      <expr_stmt><expr><call><name>renameColumnParseError</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zWhen</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>renameParseCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <name>xAuth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** The implementation of internal UDF sqlite_drop_column().
** 
** Arguments:
**
**  argv[0]: An integer - the index of the schema containing the table
**  argv[1]: CREATE TABLE statement to modify.
**  argv[2]: An integer - the index of the column to remove.
**
** The value returned is a string containing the CREATE TABLE statement
** with column argv[2] removed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dropColumnFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSchema</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iSchema</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name></type> <name>sParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_xauth</name></type> <name>xAuth</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>renameParseSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>iSchema</name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>drop_column_done</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>sParse</name><operator>.</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iCol</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content> 
    <comment type="block">/* This can happen if the sqlite_schema table is corrupt */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>drop_column_done</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>RenameToken</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <call><name>renameTokenFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pEnd</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zSql</name><index>[<expr><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>addColOffset</name></name></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">','</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%.*s%s"</literal></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>z</name></name><operator>-</operator><name>zSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>drop_column_done</name>:</label>
  <expr_stmt><expr><call><name>renameParseCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAuth</name></name> <operator>=</operator> <name>xAuth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the parser upon parsing an 
**
**     ALTER TABLE pSrc DROP COLUMN pName
**
** statement. Argument pSrc contains the possibly qualified name of the
** table being edited, and token pName the name of the column to drop.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterDropColumn</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                    <comment type="block">/* Table to modify */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                        <comment type="block">/* Index of db containing pTab in aDb[] */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                <comment type="block">/* Database containing pTab ("main" etc.) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Name of column to drop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Index of column zCol in pTab-&gt;aCol[] */</comment>

  <comment type="block">/* Look up the table being altered. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_drop_column</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_drop_column</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Make sure this is not an attempt to ALTER a view, virtual table or 
  ** system table. */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isAlterableTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_drop_column</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isRealTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_drop_column</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Find the index of the column being dropped. */</comment>
  <expr_stmt><expr><name>zCol</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>sqlite3ColumnIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such column: \"%T\""</literal></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_column</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do not allow the user to drop a PRIMARY KEY column or a column 
  ** constrained by a UNIQUE constraint.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <operator>(</operator><name>COLFLAG_PRIMKEY</name><operator>|</operator><name>COLFLAG_UNIQUE</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot drop %s column: \"%s\""</literal></expr></argument>, 
        <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>colFlags</name><operator>&amp;</operator><name>COLFLAG_PRIMKEY</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"PRIMARY KEY"</literal></expr> </then><else>: <expr><literal type="string">"UNIQUE"</literal></expr></else></ternary></expr></argument>,
        <argument><expr><name>zCol</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_column</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do not allow the number of columns to go to zero */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot drop column \"%s\": no other columns exist"</literal></expr></argument>,<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_column</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Edit the sqlite_schema table */</comment>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_drop_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>renameTestSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iDb</name><operator>==</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameFixQuotes</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iDb</name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr><literal type="string">"UPDATE \"%w\"."</literal> <name>LEGACY_SCHEMA_TABLE</name> <literal type="string">" SET "</literal>
      <literal type="string">"sql = sqlite_drop_column(%d, sql, %d) "</literal>
      <literal type="string">"WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)"</literal></expr></argument>
      , <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Drop and reload the database schema. */</comment>
  <expr_stmt><expr><call><name>renameReloadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>INITFLAG_AlterDrop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>renameTestSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>iDb</name><operator>==</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"after drop column"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Edit rows of table on disk */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>reg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regRec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of non-virtual columns after drop */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>regRec</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>iCol</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>regOut</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iPos</name> <init>= <expr><call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iColPos</name> <init>= <expr><call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>iPos</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>regOut</name> <operator>=</operator> <name>reg</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>iPos</name><operator>-</operator><operator>(</operator><name>iPos</name><operator>&gt;</operator><name>iColPos</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>regOut</name> <operator>=</operator> <name>reg</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>nField</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>nField</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nField</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* dbsqlfuzz 5f09e7bcc78b4954d06bf9f2400d7715f48d1fef */</comment>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nField</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nField</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_SAVEPOSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>exit_drop_column</name>:</label>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Register built-in functions used to help implement ALTER TABLE
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterFunctions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>FuncDef</name></type> <name><name>aAlterTableFuncs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>INTERNAL_FUNCTION</name><argument_list>(<argument><expr><name>sqlite_rename_column</name></expr></argument>,  <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>renameColumnFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>INTERNAL_FUNCTION</name><argument_list>(<argument><expr><name>sqlite_rename_table</name></expr></argument>,   <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>renameTableFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>INTERNAL_FUNCTION</name><argument_list>(<argument><expr><name>sqlite_rename_test</name></expr></argument>,    <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>renameTableTest</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>INTERNAL_FUNCTION</name><argument_list>(<argument><expr><name>sqlite_drop_column</name></expr></argument>,    <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>dropColumnFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>INTERNAL_FUNCTION</name><argument_list>(<argument><expr><name>sqlite_rename_quotefix</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>renameQuotefixFunc</name></expr></argument>)</argument_list></call></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3InsertBuiltinFuncs</name><argument_list>(<argument><expr><name>aAlterTableFuncs</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aAlterTableFuncs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_ALTER_TABLE */</comment>
</unit>
