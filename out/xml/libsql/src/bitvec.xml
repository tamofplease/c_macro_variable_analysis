<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/src/bitvec.c"><comment type="block">/*
** 2008 February 16
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file implements an object that represents a fixed-length
** bitmap.  Bits are numbered starting with 1.
**
** A bitmap is used to record which pages of a database file have been
** journalled during a transaction, or which pages have the "dont-write"
** property.  Usually only a few pages are meet either condition.
** So the bitmap is usually sparse and has low cardinality.
** But sometimes (for example when during a DROP of a large table) most
** or all of the pages in a database can get journalled.  In those cases, 
** the bitmap becomes dense with high cardinality.  The algorithm needs 
** to handle both cases well.
**
** The size of the bitmap is fixed when the object is created.
**
** All bits are clear when the bitmap is created.  Individual bits
** may be set or cleared one at a time.
**
** Test operations are about 100 times more common that set operations.
** Clear operations are exceedingly rare.  There are usually between
** 5 and 500 set operations per Bitvec object, though the number of sets can
** sometimes grow into tens of thousands or larger.  The size of the
** Bitvec object is the number of pages in the database file at the
** start of a transaction, and is thus usually less than a few thousand,
** but can be as large as 2 billion for a really big database.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/* Size of the Bitvec structure in bytes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_SZ</name></cpp:macro>        <cpp:value>512</cpp:value></cpp:define>

<comment type="block">/* Round the union size down to the nearest pointer boundary, since that's how 
** it will be aligned within the Bitvec struct. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_USIZE</name></cpp:macro> \
    <cpp:value>(((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))</cpp:value></cpp:define>

<comment type="block">/* Type of the array "element" for the bitmap representation. 
** Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE. 
** Setting this to the "natural word" size of your CPU may improve
** performance. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_TELEM</name></cpp:macro>     <cpp:value>u8</cpp:value></cpp:define>
<comment type="block">/* Size, in bits, of the bitmap element. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_SZELEM</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>
<comment type="block">/* Number of elements in a bitmap array. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_NELEM</name></cpp:macro>     <cpp:value>(BITVEC_USIZE/sizeof(BITVEC_TELEM))</cpp:value></cpp:define>
<comment type="block">/* Number of bits in the bitmap array. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_NBIT</name></cpp:macro>      <cpp:value>(BITVEC_NELEM*BITVEC_SZELEM)</cpp:value></cpp:define>

<comment type="block">/* Number of u32 values in hash table. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_NINT</name></cpp:macro>      <cpp:value>(BITVEC_USIZE/sizeof(u32))</cpp:value></cpp:define>
<comment type="block">/* Maximum number of entries in hash table before 
** sub-dividing and re-hashing. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_MXHASH</name></cpp:macro>    <cpp:value>(BITVEC_NINT/2)</cpp:value></cpp:define>
<comment type="block">/* Hashing function for the aHash representation.
** Empirical testing showed that the *37 multiplier 
** (an arbitrary prime)in the hash function provided 
** no fewer collisions than the no-op *1. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_HASH</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(((X)*1)%BITVEC_NINT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITVEC_NPTR</name></cpp:macro>      <cpp:value>(BITVEC_USIZE/sizeof(Bitvec *))</cpp:value></cpp:define>


<comment type="block">/*
** A bitmap is an instance of the following structure.
**
** This bitmap records the existence of zero or more bits
** with values between 1 and iSize, inclusive.
**
** There are three possible representations of the bitmap.
** If iSize&lt;=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straight
** bitmap.  The least significant bit is bit 1.
**
** If iSize&gt;BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] is
** a hash table that will hold up to BITVEC_MXHASH distinct values.
**
** Otherwise, the value i is redirected into one of BITVEC_NPTR
** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmap
** handles up to iDivisor separate values of i.  apSub[0] holds
** values between 1 and iDivisor.  apSub[1] holds values between
** iDivisor+1 and 2*iDivisor.  apSub[N] holds values between
** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalized
** to hold deal with values between 1 and iDivisor.
*/</comment>
<struct>struct <name>Bitvec</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>iSize</name></decl>;</decl_stmt>      <comment type="block">/* Maximum bit index.  Max iSize is 4,294,967,296. */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nSet</name></decl>;</decl_stmt>       <comment type="block">/* Number of bits that are set - only valid for aHash
                  ** element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,
                  ** this would be 125. */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iDivisor</name></decl>;</decl_stmt>   <comment type="block">/* Number of bits handled by each apSub[] entry. */</comment>
                  <comment type="block">/* Should &gt;=0 for apSub element. */</comment>
                  <comment type="block">/* Max iDivisor is max(u32) / BITVEC_NPTR + 1.  */</comment>
                  <comment type="block">/* For a BITVEC_SZ of 512, this would be 34,359,739. */</comment>
  <union>union <block>{
    <decl_stmt><decl><type><name>BITVEC_TELEM</name></type> <name><name>aBitmap</name><index>[<expr><name>BITVEC_NELEM</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Bitmap representation */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name><name>aHash</name><index>[<expr><name>BITVEC_NINT</name></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* Hash table representation */</comment>
    <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name><name>apSub</name><index>[<expr><name>BITVEC_NPTR</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Recursive representation */</comment>
  }</block> <decl><name>u</name></decl>;</union>
}</block>;</struct>

<comment type="block">/*
** Create a new bitmap object able to handle bits between 0 and iSize,
** inclusive.  Return a pointer to the new object.  Return NULL if 
** malloc fails.
*/</comment>
<function><type><name>Bitvec</name> <modifier>*</modifier></type><name>sqlite3BitvecCreate</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>iSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof><operator>==</operator><name>BITVEC_SZ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>iSize</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the i-th bit is set.  Return true or false.
** If p is NULL (if the bitmap has not been created) or if
** i is out of range, then return false.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BitvecTestNotNull</name><parameter_list>(<parameter><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>bin</name> <init>= <expr><name>i</name><operator>/</operator><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name><operator>%</operator><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name><operator>&lt;=</operator><name>BITVEC_NBIT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aBitmap</name><index>[<expr><name>i</name><operator>/</operator><name>BITVEC_SZELEM</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>i</name><operator>&amp;</operator><operator>(</operator><name>BITVEC_SZELEM</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else<block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>h</name> <init>= <expr><call><name>BITVEC_HASH</name><argument_list>(<argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name><operator>==</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BITVEC_NINT</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3BitvecTest</name><parameter_list>(<parameter><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>p</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3BitvecTestNotNull</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the i-th bit.  Return 0 on success and an error code if
** anything goes wrong.
**
** This routine might cause sub-bitmaps to be allocated.  Failing
** to get the memory needed to hold the sub-bitmap is the only
** that can go wrong with an insert, assuming p and i are valid.
**
** The calling function must ensure that p is a valid Bitvec object
** and that the value for "i" is within range of the Bitvec object.
** Otherwise the behavior is undefined.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BitvecSet</name><parameter_list>(<parameter><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>h</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
  <while>while<condition>(<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name> <operator>&gt;</operator> <name>BITVEC_NBIT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>bin</name> <init>= <expr><name>i</name><operator>/</operator><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name><operator>%</operator><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name><index>[<expr><name>bin</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name><index>[<expr><name>bin</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3BitvecCreate</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name><index>[<expr><name>bin</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name><operator>&lt;=</operator><name>BITVEC_NBIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aBitmap</name><index>[<expr><name>i</name><operator>/</operator><name>BITVEC_SZELEM</name></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><operator>(</operator><name>BITVEC_SZELEM</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>BITVEC_HASH</name><argument_list>(<argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* if there wasn't a hash collision, and this doesn't */</comment>
  <comment type="block">/* completely fill the hash, then just add it without */</comment>
  <comment type="block">/* worring about sub-dividing and re-hashing. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>nSet</name></name><operator>&lt;</operator><operator>(</operator><name>BITVEC_NINT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <goto>goto <name>bitvec_set_end</name>;</goto>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <goto>goto <name>bitvec_set_rehash</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* there was a collision, check to see if it's already */</comment>
  <comment type="block">/* in hash, if not, try to find a spot for it */</comment>
  <do>do <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name><operator>==</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>h</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>h</name><operator>&gt;=</operator><name>BITVEC_NINT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block> while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition>;</do>
  <comment type="block">/* we didn't find it in the hash.  h points to the first */</comment>
  <comment type="block">/* available free spot. check to see if this is going to */</comment>
  <comment type="block">/* make our hash too "full".  */</comment>
<label><name>bitvec_set_rehash</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nSet</name></name><operator>&gt;=</operator><name>BITVEC_MXHASH</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aiValues</name> <init>= <expr><call><name>sqlite3StackAllocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>aiValues</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aiValues</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+</operator> <name>BITVEC_NPTR</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>BITVEC_NPTR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>BITVEC_NINT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aiValues</name><index>[<expr><name>j</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>|=</operator> <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>aiValues</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3StackFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aiValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>bitvec_set_end</name>:</label>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSet</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clear the i-th bit.
**
** pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storage
** that BitvecClear can use to rebuilt its hash table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BitvecClear</name><parameter_list>(<parameter><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>bin</name> <init>= <expr><name>i</name><operator>/</operator><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name><operator>%</operator><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name><operator>&lt;=</operator><name>BITVEC_NBIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aBitmap</name><index>[<expr><name>i</name><operator>/</operator><name>BITVEC_SZELEM</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><operator>(</operator><name>BITVEC_SZELEM</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aiValues</name> <init>= <expr><name>pBuf</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aiValues</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>BITVEC_NINT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aiValues</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>aiValues</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>h</name> <init>= <expr><call><name>BITVEC_HASH</name><argument_list>(<argument><expr><name><name>aiValues</name><index>[<expr><name>j</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSet</name></name><operator>++</operator></expr>;</expr_stmt>
        <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>h</name><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>h</name><operator>&gt;=</operator><name>BITVEC_NINT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aHash</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name><name>aiValues</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Destroy a bitmap object.  Reclaim all memory used.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BitvecDestroy</name><parameter_list>(<parameter><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDivisor</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>BITVEC_NPTR</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>apSub</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the value of the iSize parameter specified when Bitvec *p
** was created.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3BitvecSize</name><parameter_list>(<parameter><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_UNTESTABLE</name></cpp:ifndef>
<comment type="block">/*
** Let V[] be an array of unsigned characters sufficient to hold
** up to N bits.  Let I be an integer between 0 and N.  0&lt;=I&lt;N.
** Then the following macros can be used to set, clear, or test
** individual bits within V.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETBIT</name><parameter_list>(<parameter><type><name>V</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>V[I&gt;&gt;3] |= (1&lt;&lt;(I&amp;7))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEARBIT</name><parameter_list>(<parameter><type><name>V</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>V[I&gt;&gt;3] &amp;= ~(1&lt;&lt;(I&amp;7))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TESTBIT</name><parameter_list>(<parameter><type><name>V</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>(V[I&gt;&gt;3]&amp;(1&lt;&lt;(I&amp;7)))!=0</cpp:value></cpp:define>

<comment type="block">/*
** This routine runs an extensive test of the Bitvec code.
**
** The input is an array of integers that acts as a program
** to test the Bitvec.  The integers are opcodes followed
** by 0, 1, or 3 operands, depending on the opcode.  Another
** opcode follows immediately after the last operand.
**
** There are 6 opcodes numbered from 0 through 5.  0 is the
** "halt" opcode and causes the test to end.
**
**    0          Halt and return the number of errors
**    1 N S X    Set N bits beginning with S and incrementing by X
**    2 N S X    Clear N bits beginning with S and incrementing by X
**    3 N        Set N randomly chosen bits
**    4 N        Clear N randomly chosen bits
**    5 N S X    Set N bits from S increment X in array only, not in bitvec
**
** The opcodes 1 through 4 perform set and clear operations are performed
** on both a Bitvec object and on a linear array of bits obtained from malloc.
** Opcode 5 works on the linear array only, not on the Bitvec.
** Opcode 5 is used to deliberately induce a fault in order to
** confirm that error detection works.
**
** At the conclusion of the test the linear array is compared
** against the Bitvec object.  If there are any differences,
** an error is returned.  If they are the same, zero is returned.
**
** If a memory allocation error occurs, return -1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BitvecBuiltinTest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>pBitvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pV</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nx</name></decl>, <decl><type ref="prev"/><name>pc</name></decl>, <decl><type ref="prev"/><name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pTmpSpace</name></decl>;</decl_stmt>

  <comment type="block">/* Allocate the Bitvec to be tested and a linear array of
  ** bits to act as the reference */</comment>
  <expr_stmt><expr><name>pBitvec</name> <operator>=</operator> <call><name>sqlite3BitvecCreate</name><argument_list>( <argument><expr><name>sz</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pV</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><operator>(</operator><name>sz</name><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTmpSpace</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>BITVEC_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBitvec</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pV</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pTmpSpace</name><operator>==</operator><literal type="number">0</literal></expr>  )</condition><block type="pseudo"><block_content> <goto>goto <name>bitvec_end</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* NULL pBitvec tests */</comment>
  <expr_stmt><expr><call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BitvecClear</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTmpSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Run the program */</comment>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>op</name> <operator>=</operator> <name><name>aOp</name><index>[<expr><name>pc</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">1</literal></expr>:</case>
      <case>case <expr><literal type="number">2</literal></expr>:</case>
      <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>nx</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>aOp</name><index>[<expr><name>pc</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aOp</name><index>[<expr><name>pc</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name><name>aOp</name><index>[<expr><name>pc</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="number">3</literal></expr>:</case>
      <case>case <expr><literal type="number">4</literal></expr>:</case> 
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>nx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>--</operator><name><name>aOp</name><index>[<expr><name>pc</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pc</name> <operator>+=</operator> <name>nx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator><operator>%</operator><name>sz</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SETBIT</name><argument_list>(<argument><expr><name>pV</name></expr></argument>, <argument><expr><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>pBitvec</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>bitvec_end</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>CLEARBIT</name><argument_list>(<argument><expr><name>pV</name></expr></argument>, <argument><expr><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BitvecClear</name><argument_list>(<argument><expr><name>pBitvec</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTmpSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Test to make sure the linear array exactly matches the
  ** Bitvec object.  Start with the assumption that they do
  ** match (rc==0).  Change rc to non-zero if a discrepancy
  ** is found.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pBitvec</name></expr></argument>, <argument><expr><name>sz</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call>
          <operator>+</operator> <call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pBitvec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
          <operator>+</operator> <operator>(</operator><call><name>sqlite3BitvecSize</name><argument_list>(<argument><expr><name>pBitvec</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>sz</name><operator>)</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>(  <expr><operator>(</operator><call><name>TESTBIT</name><argument_list>(<argument><expr><name>pV</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pBitvec</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Free allocated structure */</comment>
<label><name>bitvec_end</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pTmpSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pBitvec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_UNTESTABLE */</comment>
</unit>
